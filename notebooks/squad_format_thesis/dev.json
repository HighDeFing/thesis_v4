{"data": [{"paragraphs": [{"qas": [{"question": "que es el desarollo agil", "id": 320664, "answers": [{"answer_id": 331154, "document_id": 539584, "question_id": 320664, "text": "Desarrollo \u00c1gil Explicar el concepto de Desarrollo \u00c1gil no es sencillo, ya que existe una definici\u00f3n clara, pero seg\u00fan [Agile Alliance (2001)] se plantea como un t\u00e9rmino que comprende distintas metodolog\u00edas de desarrollo de software, cuyas premisas buscan satisfacer los requerimientos cambiantes de los clientes,", "answer_start": 31628, "answer_end": 31941, "answer_category": null}], "is_impossible": false}, {"question": "que es Asterisk", "id": 320666, "answers": [{"answer_id": 331156, "document_id": 539584, "question_id": 320666, "text": "Seg\u00fan [MJS (2005)], Asterisk es una aplicaci\u00f3n, multiplataforma, distribuida y desarrollada libremente, de una central telef\u00f3nica PBX (Private Branch Exchange), liberada bajo la Licencia GPL de GNU (General Public License).", "answer_start": 48128, "answer_end": 48351, "answer_category": null}], "is_impossible": false}, {"question": "que es ruby on rails", "id": 320667, "answers": [{"answer_id": 331157, "document_id": 539584, "question_id": 320667, "text": "Ruby on Rails Ruby on Rails, conocido tambi\u00e9n como RoR o Rails, es un framework de aplicaciones Web escrito en el lenguaje de programaci\u00f3n Ruby, que como se afirma en la p\u00e1gina Web Wikipedia (2007), se apega al paradigma de la arquitectura Modelo Vista Controlador (MVC).", "answer_start": 82654, "answer_end": 82925, "answer_category": null}], "is_impossible": false}, {"question": "que es una gema", "id": 320668, "answers": [{"answer_id": 331158, "document_id": 539584, "question_id": 320668, "text": "Gemas Seg\u00fan el sitio Web [RubyGems Manual (2007)], una gema es una aplicaci\u00f3n Ruby empaquetada, o biblioteca de Ruby, que tiene un nombre y una versi\u00f3n definida. RubyGems es el nombre del proyecto que fue responsable del desarrollo de esta herramienta, su proceso de instalaci\u00f3n es muy sencillo y se resume simplemente en descargar el paquete de un sitio Web en Internet y ejecutar el comando Ruby setup.rb cuando se est\u00e1 parado en el directorio de la descarga.", "answer_start": 100545, "answer_end": 101006, "answer_category": null}], "is_impossible": false}, {"question": "que es la programacion extrema", "id": 320665, "answers": [{"answer_id": 331155, "document_id": 539584, "question_id": 320665, "text": "Programaci\u00f3n Extrema La Programaci\u00f3n Extrema, mejor conocida por su nombre en ingl\u00e9s eXtreme Programming, de all\u00ed sus siglas (XP), es una de las llamadas Metodolog\u00edas \u00c1giles de desarrollo. [Beck (1999-b)] explica que en este tipo programaci\u00f3n el t\u00e9rmino \u201cextrema\u201d viene de tomar los principios y pr\u00e1cticas a niveles extremos. Se\u00f1ala que esta metodolog\u00eda ha evolucionado de los distintos problemas causados por los largos ciclos de desarrollo de los modelos tradicionales.", "answer_start": 35494, "answer_end": 35965, "answer_category": null}], "is_impossible": false}], "context": "Microsoft Word - tesis_v5.doc Universidad Central de Venezuela Facultad de Ciencias Escuela de Computaci\u00f3n Aplicaciones con Tecnolog\u00eda Internet DISE\u00d1O Y DESARROLLO DE UN M\u00d3DULO DE COMUNICACI\u00d3N ENTRE EL FRAMEWORK RUBY ON RAILS Y LA CENTRAL TELEF\u00d3NICA POR SOFTWARE ASTERISK, PARA EL MERCADEO DE PRODUCTOS Y SERVICIOS EMPRESARIALES Trabajo Especial de Grado presentado ante la Ilustre Universidad Central de Venezuela Por el Bachiller Carlos Augusto Garc\u00eda Mujica CI: 17.400.329 para optar al t\u00edtulo de Licenciado en Computaci\u00f3n Tutor Prof. Edgar Gonz\u00e1lez Caracas, mayo / 2008 i ACTA Quienes suscriben miembros del Jurado, designado por el Consejo de Escuela de Computaci\u00f3n, para examinar el Trabajo Especial de Grado presentado por el Bachiller Carlos Augusto Garc\u00eda Mujica, C.I. 17.400.329, con el t\u00edtulo: \u201dDise\u00f1o y Desarrollo de un M\u00f3dulo de Comunicaci\u00f3n entre el Framework Ruby on Rails y la Central Telef\u00f3nica por Software Asterisk, para el Mercadeo de Productos y Servicios Empresariales\u201d, a los fines de optar al t\u00edtulo de Licenciado en Computaci\u00f3n, dejan constancia lo siguiente: Le\u00eddo como fue, dicho trabajo por cada uno de los miembros del Jurado, se fij\u00f3 el 03 de Junio de 2008 a las 11:30 a.m, para que su autor lo defendiera en forma p\u00fablica, se hizo en la sala del Centro de Computaci\u00f3n, mediante una presentaci\u00f3n oral de su contenido. Finalizada la defensa p\u00fablica del Trabajo Especial de Grado, el Jurado decidi\u00f3 aprobarlo con una nota de _______ puntos, en fe de lo cual se levanta la presente Acta, en Caracas a los tres d\u00edas del mes de Junio del a\u00f1o dos mil ocho, dej\u00e1ndose tambi\u00e9n constancia de que act\u00fao como Coordinador del Jurado el profesor Edgar Gonz\u00e1lez. _____________________________ Prof. Edgar Gonz\u00e1lez (Tutor) _____________________________ _____________________________ Prof. Sergio Rivas Prof. Andr\u00e9s Sanoja (Jurado Principal) (Jurado principal) ii DEDICATORIA Y AGRADECIMIENTOS A mi n\u00facleo familiar por haber apostado a mi \u00e9xito desde el comienzo de mi carrera y seguirlo haciendo. En especial a mi madre por el soporte moral, mi hermana porque es un ser especial con el que se que cuento de principio a fin sin importar el asunto y mi padre que me apoy\u00f3 durante todos mis estudios. A Mi Esperanza por el apoyo incondicional en todos los aspectos de mi vida y en especial por la ayuda brindada en el desarrollo de este proyecto. A mis tios, abuelos y primos que me han demostrado ser unas excelentes personas consecuentes, por lo que siempre contar\u00e9 con ellos. A mi tutor y profesores de la carrera, por haber brindado sus conocimientos en un tiempo oportuno de mi formaci\u00f3n. A mis compa\u00f1eros de la universidad, con los que compart\u00ed momentos inolvidables, especialmente al legendario \u201ccirculo\u201d, que espero continuemos en contacto a trav\u00e9s de los a\u00f1os cultivando las amistades permanentemente. iii \u00cdNDICE DE CONTENIDOS ACTA ............................................................................................................................. i DEDICATORIA Y AGRADECIMIENTOS ................................................................ii \u00cdNDICE DE CONTENIDOS........................................................................................iii \u00cdNDICE DE GR\u00c1FICOS .............................................................................................vi \u00cdNDICE DE TABLAS.................................................................................................vii RESUMEN................................................................................................................... ix INTRODUCCI\u00d3N......................................................................................................... 2 CAP\u00cdTULO I................................................................................................................. 4 Planteamiento del Problema y justificaci\u00f3n del proyecto ............................................ 4 Objetivos ............................................................................................................... 6 Objetivo general .................................................................................................... 6 Objetivos espec\u00edficos............................................................................................. 6 CAP\u00cdTULO II................................................................................................................ 8 Marco Te\u00f3rico ............................................................................................................... 8 Desarrollo \u00c1gil ...................................................................................................... 8 Manifiesto \u00c1gil...................................................................................................... 8 Caracter\u00edsticas del Desarrollo \u00c1gil...................................................................... 10 Programaci\u00f3n Extrema ........................................................................................ 11 Caracter\u00edsticas ..................................................................................................... 12 Pr\u00e1cticas de XP.................................................................................................... 14 Asterisk................................................................................................................ 19 \u00bfQu\u00e9 es? .............................................................................................................. 21 Historia ................................................................................................................ 22 Caracter\u00edsticas y Ventajas ................................................................................... 24 Asterisk como un PBX ........................................................................................ 27 Flexibilidad Vs. Configuraci\u00f3n ........................................................................... 31 Configuraci\u00f3n Gr\u00e1fica vs Configuraci\u00f3n de Texto ............................................. 32 Dialplans: Contextos, Extensiones, Prioridades y Aplicaciones ......................... 33 Contextos............................................................................................................. 33 Canales ................................................................................................................ 35 Extensiones.......................................................................................................... 35 Prioridades........................................................................................................... 37 Aplicaciones ........................................................................................................ 38 Dialplans.............................................................................................................. 38 Interfaces Asterisk Manager Interface y Asterisk Gateway Interface................. 39 iv Asterisk Gateway Interface ................................................................................. 40 Asterisk Manager Interface ................................................................................. 42 Ruby on Rails ...................................................................................................... 48 Filosof\u00edas ............................................................................................................. 50 Arquitectura......................................................................................................... 51 Componentes b\u00e1sicos .......................................................................................... 54 Active Record...................................................................................................... 54 Action Pack ......................................................................................................... 59 Gemas.................................................................................................................. 61 Caracter\u00edsticas ..................................................................................................... 62 Comandos B\u00e1sicos .............................................................................................. 62 Plugins ................................................................................................................. 64 Comandos B\u00e1sicos .............................................................................................. 65 Pruebas ................................................................................................................ 67 Conectividad Rails - Asterisk.............................................................................. 74 Adhearsion........................................................................................................... 74 Instalaci\u00f3n y Uso ................................................................................................. 77 Dialplans.............................................................................................................. 80 Telegraph............................................................................................................. 82 Instalaci\u00f3n y Uso ................................................................................................. 83 Comparaci\u00f3n Adhearsion - Telegraph ................................................................ 94 CAP\u00cdTULO III ............................................................................................................ 97 Marco Aplicativo......................................................................................................... 97 Requerimientos Generales................................................................................... 97 Adaptaci\u00f3n del Proceso de Desarrollo XP .......................................................... 99 Planificaci\u00f3n........................................................................................................ 99 Dise\u00f1o................................................................................................................ 100 Codificaci\u00f3n ...................................................................................................... 100 Pruebas .............................................................................................................. 100 Feedback............................................................................................................ 101 Desarrollo de la Aplicaci\u00f3n............................................................................... 101 Met\u00e1fora del Sistema......................................................................................... 101 Iteraci\u00f3n 0.......................................................................................................... 104 Planificaci\u00f3n...................................................................................................... 104 Iteraci\u00f3n 1.......................................................................................................... 104 Planificaci\u00f3n...................................................................................................... 105 Dise\u00f1o................................................................................................................ 106 Codificaci\u00f3n ...................................................................................................... 106 Pruebas .............................................................................................................. 109 Feedback............................................................................................................ 110 Iteraci\u00f3n 2.......................................................................................................... 110 Planificaci\u00f3n...................................................................................................... 111 v Dise\u00f1o................................................................................................................ 111 Codificaci\u00f3n ...................................................................................................... 112 Pruebas .............................................................................................................. 116 Feedback............................................................................................................ 119 Iteraci\u00f3n 3.......................................................................................................... 120 Planificaci\u00f3n...................................................................................................... 120 Dise\u00f1o................................................................................................................ 121 Codificaci\u00f3n ...................................................................................................... 122 Pruebas .............................................................................................................. 124 Feedback............................................................................................................ 128 Iteraci\u00f3n 4.......................................................................................................... 129 Planificaci\u00f3n...................................................................................................... 129 Dise\u00f1o................................................................................................................ 129 Codificaci\u00f3n ...................................................................................................... 130 Pruebas .............................................................................................................. 131 Feedback............................................................................................................ 134 CAP\u00cdTULO IV .......................................................................................................... 135 Conclusiones y Recomendaciones ............................................................................ 135 REFERENCIAS ........................................................................................................ 139 CONTACTOS........................................................................................................... 146 ANEXOS................................................................................................................... 147 Glosario de t\u00e9rminos ......................................................................................... 147 Anexo 1: Valores del Manifiesto \u00c1gil .............................................................. 151 Anexo2: Principios del Manifiesto \u00c1gil............................................................ 153 Anexo3: Proceso de la Programaci\u00f3n Extrema................................................. 155 Anexo4: Pr\u00e1cticas de la Programaci\u00f3n Extrema ............................................... 156 vi \u00cdNDICE DE GR\u00c1FICOS Gr\u00e1fico 1: Diagrama de la soluci\u00f3n propuesta. ............................................................. 5 Gr\u00e1fico 2: Esquema de interconexi\u00f3n de Asterisk con dispositivos internos y externos. ...................................................................................................................... 29 Gr\u00e1fico 3: Esquema de interconexi\u00f3n entre varios PBX`s con dispositivos asociados. ..................................................................................................................................... 30 Gr\u00e1fico 4: Modelo MVC ............................................................................................. 53 Gr\u00e1fico 5: Modelo MVC en Rails ............................................................................... 54 Gr\u00e1fico 6: Met\u00e1fora del Sistema. .............................................................................. 103 Gr\u00e1fico 7: Especificaci\u00f3n Clase AMIManager. ........................................................ 106 Gr\u00e1fico 8: Diagrama de Clases, Iteraci\u00f3n 2. ............................................................. 112 Gr\u00e1fico 9: Prueba Aceptaci\u00f3n, Pantalla Operador. ................................................... 118 Gr\u00e1fico 10: Prueba Aceptaci\u00f3n, Pantalla Supervisor (Estado Asterisk). .................. 118 Gr\u00e1fico 11: Prueba Aceptaci\u00f3n, Pantalla Supervisor (Detalle Llamada). ................. 119 Gr\u00e1fico 12: Diagrama de Clases, Iteraci\u00f3n 3. ........................................................... 121 Gr\u00e1fico 13: Prueba Aceptaci\u00f3n, Pantalla Administrador (Modo Mantenimiento). .. 128 Gr\u00e1fico 14: Prueba Aceptaci\u00f3n, Pantalla Validador (Cargar Archivo)..................... 128 Gr\u00e1fico 15: Diagrama de Clases, Iteraci\u00f3n 4. ........................................................... 129 Gr\u00e1fico 16: Anexo 3, Proceso de la programaci\u00f3n Extrema..................................... 155 Gr\u00e1fico 17: Anexo 4, Pr\u00e1cticas de la programaci\u00f3n Extrema. .................................. 156 vii \u00cdNDICE DE TABLAS Tabla 1:Extensi\u00f3n Asterisk. ........................................................................................ 36 Tabla 2: Componentes Extensiones Asterisk. ............................................................. 37 Tabla 3: Orden de Ejecuci\u00f3n de Extensiones. ............................................................. 37 Tabla 4: Ejemplo de Dialplan de Asterisk................................................................... 38 Tabla 5: Paquete Ejemplo de Comunicaci\u00f3n AMI...................................................... 42 Tabla 6: Ejemplo de Paquete de Autenticaci\u00f3n AMI.................................................. 43 Tabla 7: Ejemplo Evento Dial. .................................................................................... 47 Tabla 8: Ejemplo Evento ExtensionStatus. ................................................................. 47 Tabla 9: Ejemplo ORM, b\u00fasqueda en base de datos por id. ....................................... 57 Tabla 10: Ejemplo ORM, guardar objeto en base de datos......................................... 57 Tabla 11: Ejemplo Listar Gemas................................................................................. 62 Tabla 12: Ejemplo Buscar Gema................................................................................. 63 Tabla 13: Ejemplo Instalar Gema................................................................................ 63 Tabla 14: Ejemplo Desinstalar Gema.......................................................................... 64 Tabla 15: Ejemplo para buscar un repositorio (Plugin). ............................................. 65 Tabla 16: Ejemplo para buscar un repositorio (Plugin/Windows). ............................. 65 Tabla 17: Ejemplo para agregar un repositorio (Plugins). .......................................... 65 Tabla 18: Ejemplo para quitar un repositorio (Plugins). ............................................. 66 Tabla 19 Ejemplo para Instalar un Plugin en el Proyecto. .......................................... 66 Tabla 20: Ejemplo de C\u00f3digo RSPEC. ....................................................................... 72 Tabla 21: Ejemplo 2 de C\u00f3digo RSPEC. .................................................................... 73 Tabla 22: Instalaci\u00f3n Adhearsion................................................................................ 77 Tabla 23: Comunicaci\u00f3n Adhearsion/Asterisk............................................................ 78 Tabla 24: Nuevo Proyecto Adhearsion. ...................................................................... 79 Tabla 25: Arrancar Adhearsion. .................................................................................. 80 Tabla 26: Ejemplo Dialplan de Adhearsion. ............................................................... 81 Tabla 27: Instalaci\u00f3n Telegraph. ................................................................................. 83 Tabla 28: Comunicaci\u00f3n Telegraph/Asterisk, AGI..................................................... 85 Tabla 29: Ejemplo Dialplan Telegraph AGI ............................................................... 85 Tabla 30: Empezando Telegraph/AMI........................................................................ 87 Tabla 31: Conexi\u00f3n Telegraph/Rails AMI. ................................................................. 87 Tabla 32: Iniciar Servidor AMI/Telegraph. ................................................................ 88 Tabla 33: Ejemplo Comandos Telegraph AMI. .......................................................... 88 Tabla 34: Ejemplo Funciones AMI Telegraph............................................................ 89 Tabla 35: M\u00e9todos Telegraph para consultas.............................................................. 90 Tabla 36: M\u00e9todos Telegraph para actualizaciones. ................................................... 90 Tabla 37: M\u00e9todos Telegraph para crear..................................................................... 90 Tabla 38: M\u00e9todos Telegraph para borrar. .................................................................. 91 viii Tabla 39: Empezando Telegraph Eventos AMI. ......................................................... 92 Tabla 40: Iniciar Servidor Eventos AMI Telegraph................................................... 92 Tabla 41: Funciones Eventos AMI.............................................................................. 93 Tabla 42: Cuadro comparativo Adhearsion - Telegraph. ............................................ 96 Tabla 43: Comunicaci\u00f3n Adhearsion/Asterisk.......................................................... 107 Tabla 44: Script Adhearsion de Prueba. .................................................................... 107 Tabla 45: Comunicaci\u00f3n Telegraph/Asterisk............................................................ 108 Tabla 46: Correcciones en Telegraph........................................................................ 109 Tabla 47: Pruebas Telegraph Iteraci\u00f3n 1................................................................... 110 Tabla 48: Clase Central / C\u00f3digo Fuente Iteraci\u00f3n 2. ............................................... 114 Tabla 49: Clase Extension / C\u00f3digo Fuente Iteraci\u00f3n 2. ........................................... 115 Tabla 50: Clase Producto / C\u00f3digo Fuente Iteraci\u00f3n 2. ............................................ 116 Tabla 51: Pruebas Clase Central Iteraci\u00f3n 2. ............................................................ 117 Tabla 52: Pruebas Clase Producto Iteraci\u00f3n 2........................................................... 117 Tabla 53: Clase Carga / C\u00f3digo Fuente Iteraci\u00f3n 3. ................................................. 123 Tabla 54: Clase Mantenimiento / C\u00f3digo Fuente Iteraci\u00f3n 3. .................................. 124 Tabla 55: Pruebas Clase Carga, Iteraci\u00f3n 3. ............................................................. 125 Tabla 56: Pruebas Clase Mantenimiento, Iteraci\u00f3n 3................................................ 126 Tabla 57: Clase AmiLogic Iteraci\u00f3n 4. ..................................................................... 131 Tabla 58: Pruebas Clase Central y AmiLogic Iteraci\u00f3n 4......................................... 133 ix RESUMEN En el presente Trabajo Especial de Grado se dise\u00f1\u00f3 e implement\u00f3 un m\u00f3dulo de conexi\u00f3n entre el framework Web Ruby on Rails y una central telef\u00f3nica por software llamada Asterisk, como parte de una aplicaci\u00f3n Web que integr\u00f3 elementos de la tecnolog\u00eda voz sobre IP (VoIP). Dicho m\u00f3dulo se implement\u00f3 con el apoyo una herramienta que facilita el intercambio de informaci\u00f3n a bajo nivel entre dichas tecnolog\u00edas, llamada Telegraph. La aplicaci\u00f3n automatiz\u00f3 el proceso de oferta de productos y servicios empresariales, agilizando el proceso de contacto v\u00eda telef\u00f3nica a los potenciales clientes. Durante el desarrollo se utiliz\u00f3 una interfaz de Asterisk llamada AMI, sobre la cual se env\u00edan y reciben comandos desde la aplicaci\u00f3n para lograr los objetivos principales del proyecto, los cuales se listan a continuaci\u00f3n: 1. Realizaci\u00f3n de llamadas desde la aplicaci\u00f3n, es decir que el Software marque autom\u00e1ticamente un n\u00famero recuperado de un repositorio de datos. 2. Monitoreo de llamadas, consiste en supervisar las llamadas realizadas. 3. Transferencia de llamadas, se transfiere una llamada en curso de una extensi\u00f3n a otra. 4. Estatus de Asterisk, es decir conocer el estatus de las extensiones y llamadas realizadas en Asterisk. Palabras Claves: Aplicaciones con tecnolog\u00eda Internet, Ruby on Rails (RoR), Programaci\u00f3n Extrema (XP), Asterisk, Telegraph, Voz sobre IP (VoIP) 2 INTRODUCCI\u00d3N En la actualidad, la utilizaci\u00f3n del mercadeo personalizado para ofrecer productos y servicios es la constante de las grandes corporaciones. Las Tecnolog\u00edas de Informaci\u00f3n y Comunicaci\u00f3n (TIC`s) aplicadas al mercadeo, facilitan el contacto directo, eficiente y r\u00e1pido con los potenciales clientes, creando ventajas competitivas en el mundo de los negocios, reemplazando o complementando el uso de formas tradicionales de comunicaci\u00f3n con el cliente. Productividad, eficiencia, eficacia y precisi\u00f3n, son los anhelos perseguidos por las organizaciones a la hora de realizar sus tareas, por lo que la automatizaci\u00f3n pasa a ser el pilar de los procesos cotidianos. La tecnolog\u00eda facilita las actividades corporativas, dotando a las organizaciones de mayores y mejores medios, que ampl\u00edan su campo de aplicaciones e incrementan su rendimiento. Con estos planteamientos como premisas, y dada la creciente competitividad de los mercados, surge en las organizaciones la necesidad de contar con sistemas inform\u00e1ticos que mejoren la productividad o eficiencia en los procesos del negocio que se llevan a cabo diariamente. En el \u00e1rea de mercadeo \u00e9sto se traduce en el r\u00e1pido y oportuno contacto con los potenciales clientes, elevando la cantidad de posibles ventas. Debido a la gran competencia en el \u00e1rea de mercadeo personalizado, las organizaciones requieren estar a la vanguardia tecnol\u00f3gica, automatizando la mayor\u00eda de los procesos que se puedan. Con el gran auge de la gran autopista cibern\u00e9tica como 3 se considera a Internet, y el crecimiento sostenido de las telecomunicaciones se considera la utilizaci\u00f3n de una aplicaci\u00f3n que, vali\u00e9ndose de herramientas Web y tecnolog\u00edas telef\u00f3nicas por software, facilite la oferta de productos y servicios mediante la realizaci\u00f3n de llamadas. En el presente proyecto se dise\u00f1\u00f3 y desarroll\u00f3 un m\u00f3dulo de una aplicaci\u00f3n Web, utilizada para automatizar el proceso de mercadeo de productos y servicios empresariales a trav\u00e9s de la central telef\u00f3nica por software Asterisk. A nivel metodol\u00f3gico se seleccion\u00f3 una t\u00e9cnica de desarrollo \u00e1gil, espec\u00edficamente Programaci\u00f3n Extrema que permite la elaboraci\u00f3n de aplicaciones adaptables a las necesidades del cliente, lo cual favoreci\u00f3 para aplicar una t\u00e9cnica de programaci\u00f3n orientada a pruebas. Precisamente, por su flexibilidad, sencillez y velocidad a la hora de dise\u00f1ar y desarrollar aplicaciones, Ruby on Railes fue escogido como framework Web para la ejecuci\u00f3n de este proyecto. Por su parte, Asterisk, una central telef\u00f3nica por software de c\u00f3digo abierto, fue utilizada por sus facilidades de interacci\u00f3n con sistemas externos. Este estudio se presenta en cuatro cap\u00edtulos, siendo el primero el referido al planteamiento del problema, as\u00ed como los objetivos y alcances del proyecto. En un segundo cap\u00edtulo se introduce el marco te\u00f3rico que sustenta a esta investigaci\u00f3n, mientras que la metodolog\u00eda ser\u00e1 abordada en un tercer cap\u00edtulo. Por \u00faltimo se tendr\u00e1n las conclusiones y recomendaciones de la investigaci\u00f3n. 4 CAP\u00cdTULO I PLANTEAMIENTO DEL PROBLEMA Y JUSTIFICACI\u00d3N DEL PROYECTO Las Tecnolog\u00edas de Informaci\u00f3n y Comunicaci\u00f3n (TIC`s) al servicio del mercadeo personalizado optimizan los procesos de oferta de productos y servicios, garantizando una mejor atenci\u00f3n a los posibles clientes. El uso de herramientas inform\u00e1ticas representa una soluci\u00f3n pr\u00e1ctica en mercados que son cada d\u00eda m\u00e1s competitivos, pues ahorra costos de comercializaci\u00f3n y supone mayor efectividad en la venta de los productos. Sustent\u00e1ndose en las ventajas que suponen las tecnolog\u00edas inform\u00e1ticas para optimizar las tareas que componen el proceso de mercadeo telef\u00f3nico, se plantea el desarrollo de una soluci\u00f3n tecnol\u00f3gica que explote las potencialidades que proveen las herramientas orientadas a Web y las innovaciones de los sistemas de telefon\u00eda por software. Para dicha soluci\u00f3n es conveniente el uso de un framework Web, ya que permite acelerar los tiempos de desarrollo a trav\u00e9s de la reutilizaci\u00f3n de componentes, sin perder calidad en el producto. En este proyecto se utiliz\u00f3 Ruby on Rails por ser un framework Web de c\u00f3digo abierto, para el desarrollo de aplicaciones Web, que combina simplicidad y precisi\u00f3n, codificando y configurando menos que con otros frameworks. A nivel de 5 telecomunicaciones se utiliz\u00f3 la central telef\u00f3nica o PBX por software, Asterisk, que permite desarrollar una amplia variedad de aplicaciones telef\u00f3nicas. La escogencia de estas tecnolog\u00edas result\u00f3 estrat\u00e9gica ya que existen herramientas para implementar la comunicaci\u00f3n e interacci\u00f3n entre ellas, como por ejemplo el plugin para Ruby on Rails (RoR), Telegraph, que provee una capa de abstracci\u00f3n para que los complejos comandos de Asterisk sean usados con facilidad en una aplicaci\u00f3n que sea desarrollada con RoR. Entonces este proyecto comprende el desarrollo de una aplicaci\u00f3n Web compuesta por un framework Web (RoR), un PBX (Asterisk) y una herramienta para la interconexi\u00f3n entre ambos (Telegraph), para automatizar los procesos que comprenden la realizaci\u00f3n de la llamadas telef\u00f3nicas, supervisi\u00f3n de las llamadas, transferencia de llamadas y actualizaci\u00f3n constante del estado de la central telef\u00f3nica. Tal como se muestra en el siguiente gr\u00e1fico: Aplicaci\u00f3n Web Modulo de Interconexi\u00f3n Central Telef\u00f3nica (PBX) Gr\u00e1fico 1: Diagrama de la soluci\u00f3n propuesta. Fuente: Autor 6 La existencia de centrales telef\u00f3nicas en sitios geogr\u00e1ficos distantes que puedan conectarse con el mismo servidor, represent\u00f3 un punto a favor a la hora de escoger el modelo Web para la realizaci\u00f3n del m\u00f3dulo que se plante\u00f3 este estudio. Adem\u00e1s, la posibilidad de tener la aplicaci\u00f3n en l\u00ednea le brinda escalabilidad al Software, facilitando la labor de acceso a los usuarios ya que permite acceder a \u00e9l de forma remota, consideraci\u00f3n a tomar en cuenta a la hora de desarrollar la aplicaci\u00f3n con tecnolog\u00eda Web. Objetivos Objetivo general 1. Dise\u00f1ar y desarollar un m\u00f3dulo de comunicaci\u00f3n entre el framework Web Ruby on Rails y la central telef\u00f3nica por software, Asterisk, para el mercadeo de productos y servicios empresariales. Objetivos espec\u00edficos 1.1. Dise\u00f1ar e implementar un m\u00f3dulo que se comunique con la central telef\u00f3nica Asterisk para el procesamiento de llamadas utilizando el plugin Telegraph como puente entre el framework Ruby on Rails y dicha central telef\u00f3nica, que permita: 1.1.1. Realizar llamadas: se requiere automatizar la realizaci\u00f3n de 7 llamadas, es decir que el Software marque autom\u00e1ticamente un n\u00famero recuperado de un repositorio de datos. 1.1.2. Monitorear llamadas: se necesita supervisar la llamada realizada por los operadores. 1.1.3. Transferir llamadas: se desea que un supervisor tenga la capacidad de transferir la llamada en curso a su extensi\u00f3n en un momento determinado. 1.1.4. Revisar el estatus de Asterisk: posibilidad de conocer el estatus de las extensiones y llamadas de Asterisk. 1.2. Automatizar el proceso de carga de n\u00fameros en el sistema. 8 CAP\u00cdTULO II MARCO TE\u00d3RICO Desarrollo \u00c1gil Explicar el concepto de Desarrollo \u00c1gil no es sencillo, ya que existe una definici\u00f3n clara, pero seg\u00fan [Agile Alliance (2001)] se plantea como un t\u00e9rmino que comprende distintas metodolog\u00edas de desarrollo de software, cuyas premisas buscan satisfacer los requerimientos cambiantes de los clientes, haciendo \u00e9nfasis en: \u2022 Amplia colaboraci\u00f3n entre los programadores y los expertos en el dominio del problema. \u2022 Comunicaci\u00f3n cara a cara por encima de la documentaci\u00f3n escrita, es decir que promueve las reuniones personales. \u2022 Frecuentes entregas del producto, que generen un valor agregado desde el punto de vista de negocio. \u2022 Equipos de desarrollo peque\u00f1os y organizados. \u2022 Eficiente estructuraci\u00f3n del c\u00f3digo y del grupo de trabajo. Manifiesto \u00c1gil Para comprender el contexto en que nacieron las conocidas metodolog\u00edas de Desarrollo \u00c1gil, es interesante remontarse al febrero de 2001 fecha en la que fueron convocados por Kent Beck (autor del libro Extreme Programming Explained), 9 numerosos cr\u00edticos del modelaje de software en Snowbird, Utah para tratar sobre las crecientes vertientes de lo que hasta ese entonces le llamaban m\u00e9todos \u201cligeros\u201d de desarrollo de software. Tal como rese\u00f1a [Folwer (2006)], s\u00f3lo diecisiete de los expertos citados por Beck pudieron asistir, incluyendo al anfitri\u00f3n, a la reuni\u00f3n donde empez\u00f3 a utilizarse el t\u00e9rmino de \u201cM\u00e9todos \u00c1giles\u201d para describir estas nuevas castas. En la cita se resumieron los principios sobre los que se basan los m\u00e9todos alternativos en cuatro postulados, conocidos como Manifiesto \u00c1gil. El Manifiesto \u00c1gil, firmado por Kent Beck, Mike Beedle, Arie van Bennekum, Alistair Cockburn, Ward Cunningham, Martin Fowler, James Grenning, Jim Highsmith, Andrew Hunt, Ron Jeffries, Jon Kern, Brian Marick, Robert C. Martin, Steve Mellor, Ken Schwaber, Jeff Sutherland y Dave Thomas, expone que: \u201cEstamos poniendo al descubierto mejores m\u00e9todos para desarrollar software, haci\u00e9ndolo y ayudando a otros a que lo hagan. Con este trabajo hemos llegado a valorar: \ufffd A los individuos y su interacci\u00f3n, por encima de los procesos y las herramientas. \ufffd El software que funciona, por encima de la documentaci\u00f3n exhaustiva. \ufffd La colaboraci\u00f3n con el cliente, por encima de la negociaci\u00f3n contractual. \ufffd La respuesta al cambio, por encima del seguimiento de un plan. Aunque hay valor en los elementos de la derecha, valoramos m\u00e1s los de la izquierda.\u201d Entre los miembros m\u00e1s resaltados de este grupo se tienen: \u2022 Martin Fowler, investigador reconocido mundialmente en el campo del An\u00e1lisis y Dise\u00f1o Orientado a Objetos, UML y Patrones. \u2022 Alistair Cockburn, quien defini\u00f3 y document\u00f3 los Casos de Uso. 10 \u2022 Jim Highsmith, creador de la metodolog\u00eda ligera \u201cDesarrollo de Software Adaptativo\u201d. \u2022 Dave Thomas y Andrew Hunt, conocidos como \u201cthe pragmatic programmers\u201d por su serie de libros \u201cPragmatic Programmer\u201d. \u2022 Ken Beck, autor intelectual de la \u201cProgramaci\u00f3n Extrema\u201d, junto a Erich Gamma desarrollaron Junit (framework de prueba para Java), entre otros. \u2022 Ward Cunningham, creador del Wiki, y del cl\u00e1sico Repositorio de Patrones de Portland. Caracter\u00edsticas del Desarrollo \u00c1gil Seg\u00fan [Miller (2001)] las caracter\u00edsticas del proceso \u00e1gil de desarrollo de software, tomado desde el punto de vista del tiempo de entrega, son: \u2022 Modularidad en el proceso de desarrollo. \u2022 Iterativo, con cortos ciclos, permitiendo r\u00e1pidas correcciones y actualizaciones. \u2022 Ciclos en un per\u00edodo de tiempo de una (1) a seis (6) semanas. \u2022 Sencillez en el proceso de desarrollo, evitando tareas innecesarias. \u2022 Adaptativo, con la posibilidad de aparici\u00f3n de nuevos riesgos. \u2022 Proceso incremental que permite segmentar la construcci\u00f3n de las aplicaciones. \u2022 Orientado a las personas: se prefiere el proceso \u00e1gil enfocado a las personas que a los procesos y la tecnolog\u00eda. \u2022 Un ambiente de trabajo comunicativo y de colaboraci\u00f3n. 11 Programaci\u00f3n Extrema La Programaci\u00f3n Extrema, mejor conocida por su nombre en ingl\u00e9s eXtreme Programming, de all\u00ed sus siglas (XP), es una de las llamadas Metodolog\u00edas \u00c1giles de desarrollo. [Beck (1999-b)] explica que en este tipo programaci\u00f3n el t\u00e9rmino \u201cextrema\u201d viene de tomar los principios y pr\u00e1cticas a niveles extremos. Se\u00f1ala que esta metodolog\u00eda ha evolucionado de los distintos problemas causados por los largos ciclos de desarrollo de los modelos tradicionales. El mismo autor explica que, en sus or\u00edgenes, la Programaci\u00f3n Extrema comenz\u00f3 como \u201cuna simple oportunidad de realizar el trabajo\u201d, en combinaci\u00f3n con otras pr\u00e1cticas de desarrollo de software que hab\u00edan sido efectivas en d\u00e9cadas recientes. Sin embargo, [AAB (1998)] refieren que despu\u00e9s de un n\u00famero de pruebas exitosas, la metodolog\u00eda XP fue documentada en los principios y pr\u00e1cticas usadas. Seg\u00fan [Beck (1999-b)] XP es un proceso de desarrollo ligero, que propone el trabajo orientado directamente al objetivo, basado en las relaciones interpersonales y la velocidad de reacci\u00f3n. Por su parte, en el sitio Web Wikipedia se afirma que esta metodolog\u00eda es muy utilizada por sus fundamentos de adaptabilidad en vez de la previsibilidad. [Beck (1999-b)] propone que XP define Historias de Usuario como base del software a desarrollar. Dichas historias las escribe el cliente y describen escenarios 12 sobre el funcionamiento del software donde generalmente se describe el modelo, dominio, entre otros. [JRA (2001)] Jeffries R, Anderson A y Hendrickson C (2001) afirman que la Programaci\u00f3n Extrema es una disciplina de desarrollo de software, basada en los valores de la simplicidad, comunicaci\u00f3n y retroalimentaci\u00f3n, que trabaja en un ambiente de integraci\u00f3n del equipo de desarrollo, en presencia de pr\u00e1cticas sencillas, donde el cliente trabaja d\u00eda a d\u00eda con el grupo de desarrollo. Caracter\u00edsticas En 1999, Beck refiere una serie de caracter\u00edsticas de la llamada Programaci\u00f3n Extrema, entre las cuales podemos destacar las siguientes: \u2022 Minimizar el riesgo de fallo del proceso por medio de la disposici\u00f3n permanente de un representante competente del cliente en el ambiente del equipo de desarrollo, que permite una retroalimentaci\u00f3n veloz y eficaz, logrando una buena comunicaci\u00f3n y coordinaci\u00f3n entre los miembros del equipo y el cliente. \u2022 Trabaja bajo el esquema de entregas de funcionalidades o releases e iteraciones, por lo que se programar\u00e1 solo lo necesario para la entrega de ese release. En caso de que \u00e9ste no se encuentre satisfecho, se adaptar\u00e1 el plan de releases e iteraciones hasta obtener su aprobaci\u00f3n. Cabe destacar que, para cada entrega se discuten los objetivos con el cliente y se definen iteraciones, de corto tiempo, para cumplir con los objetivos de la entrega. Esta caracter\u00edstica implica la integraci\u00f3n continua del c\u00f3digo, es decir que 13 cada funcionalidad que se desarrolla se integrar\u00e1 al sistema de inmediato. \u2022 Propone realizar cont\u00ednuas pruebas unitarias por cada funcionalidad, de modo que se pueda corregir cualquier fallo antes de la entrega. Dichas pruebas deber\u00edan ser automatizadas y es recomendable que se escriban antes de la codificaci\u00f3n del requerimiento. \u2022 La codificaci\u00f3n del software en XP se produce siempre en parejas (dos programadores por ordenador), rot\u00e1ndolas a lo largo del proyecto, lo cual supone una mayor calidad del c\u00f3digo. \u2022 Definir cortas iteraciones con r\u00e1pidas y cortas entregas, que permiten escribir un c\u00f3digo incremental al ir a\u00f1adiendo peque\u00f1as mejoras. \u2022 Implementar funcionalidades de la forma m\u00e1s sencilla posible, lo que lleva a una de sus premisas: simplicidad a la hora de escribir el c\u00f3digo. \u2022 Refactorizar el c\u00f3digo, lo que implica la reescritura de ciertos trozos con el fin de incrementar la legibilidad, mantenimiento y eficiencia del c\u00f3digo. \u2022 El c\u00f3digo es colectivo, ya que cualquier integrante del grupo puede realizar modificaciones sobre cualquier parte del c\u00f3digo. \u2022 Documentaci\u00f3n Limitada, es decir que no se basa en una documentaci\u00f3n 14 exhaustiva sino s\u00f3lo la necesaria para el proyecto, la cual generalmente se lleva a cabo en las \u00faltimas etapas del mismo. Pr\u00e1cticas de XP [Beck (1999-a)] explica que XP es una colecci\u00f3n de ideas y pr\u00e1cticas tomadas de metodolog\u00edas existentes. A continuaci\u00f3n se explican las pr\u00e1cticas de XP seg\u00fan este autor: \ufffd El Juego de Planificaci\u00f3n El programador debe estimar el esfuerzo que requiere la implementaci\u00f3n de las historias de usuarios, luego el cliente decide el alcance y los tiempos del release en cuesti\u00f3n. Esta pr\u00e1ctica se puede ilustrar como un juego, donde existen dos jugadores: Cliente y Programador, cada uno con su respectivo rol. Este juego se realiza durante la planificaci\u00f3n de las entregas y las iteraciones. \ufffd Peque\u00f1os y Cortos Releases Se desea producir fragmentos sencillos del sistema, pero velozmente, sin importar que esto signifique que no cuenten con todas las funcionalidades pretendidas, pero que s\u00ed constituyan un valor adicional para el negocio. Nuevos releases son lanzados hasta diariamente, pero al menos una vez al mes. 15 \ufffd Met\u00e1fora [Fowler (2004)] dice que la arquitectura de XP es evolutiva y los posibles inconvenientes que se pueden generar por no contar con ella desde el comienzo del proyecto, se solventan con la existencia de la pr\u00e1ctica conocida como la met\u00e1fora. El autor se\u00f1ala que \u201cla met\u00e1fora es una pr\u00e1ctica que consiste en formar un conjunto de nombres que act\u00faen como vocabulario para hablar sobre el dominio del problema\u201d. Seg\u00fan Fowler, el sistema es definido por una met\u00e1fora o un conjunto de met\u00e1foras compartidas entre el cliente y los programadores, lo cual gu\u00eda el desarrollo describiendo el funcionamiento del sistema. \ufffd Dise\u00f1o Simple XP hace \u00e9nfasis en dise\u00f1ar el sistema lo m\u00e1s simple como sea posible, tomando una soluci\u00f3n sencilla que pueda ser implementada en el momento. Cualquier complejidad innecesaria y c\u00f3digo extra deben ser eliminados. Al respecto, [Beck (1999-b)], explica que \u201cen cualquier momento el dise\u00f1o adecuado para el software es aquel que: supera con \u00e9xito todas las pruebas, no tiene l\u00f3gica duplicada, refleja claramente la intenci\u00f3n de implementaci\u00f3n de los programadores y tiene el menor n\u00famero posible de clases y m\u00e9todos\u201d. \ufffd Pruebas La escritura de c\u00f3digo est\u00e1 dirigida por las pruebas unitarias. Las pruebas unitarias son implementadas antes de codificar el requerimiento y son ejecutadas 16 cont\u00ednuamente ante cada modificaci\u00f3n del sistema. El cliente es encargado de escribir las pruebas funcionales y vela por la validez de cada historia de usuario. En este contexto de desarrollo evolutivo y de pruebas, se hace indispensable la automatizaci\u00f3n de esta actividad. \ufffd Refactorizaci\u00f3n La refactorizaci\u00f3n es una pr\u00e1ctica que comprende la reestructuraci\u00f3n del c\u00f3digo, eliminando la duplicaci\u00f3n, simplific\u00e1ndolo y a\u00f1adi\u00e9ndole flexibilidad para permitir la escalabilidad. La refactorizaci\u00f3n refuerza la estructura interna del sistema sin cambiar su comportamiento externo. Sobre este aspecto, [Martin, R (2002)] se\u00f1ala que \"el dise\u00f1o del sistema de software es una cosa viviente. No se puede imponer todo en un inicio, pero en el transcurso del tiempo este dise\u00f1o evoluciona conforme cambia las funcionalidades del sistema\u201d \ufffd Programaci\u00f3n en Parejas Dos personas deben codificar en un solo ordenador, este estilo de programaci\u00f3n brinda numerosas ventajas, entre las que tenemos: \u2022 Una baja tasa de errores, ya que se detectan muchos errores tempranamente entre los compa\u00f1eros. \u2022 Mayor calidad del c\u00f3digo en menos l\u00edneas de c\u00f3digo (se hacen mejoras inmediatas). \u2022 Los problemas se resuelven con mayor rapidez. 17 \u2022 M\u00e1s de una persona conoce el c\u00f3digo, lo que brinda velocidad a la hora del soporte. \u2022 Los programadores disfrutan m\u00e1s la labor de la codificaci\u00f3n. \ufffd C\u00f3digo Colectivo Cualquier persona puede cambiar el c\u00f3digo, a\u00fan si no lo haya hecho esa persona, ya que el c\u00f3digo es de todos no pertenece a ning\u00fan integrante en particular. Esto incentiva a cada individuo del grupo a aportar con nuevas ideas y evita que alg\u00fan programador sea imprescindible a la hora de cambios en el c\u00f3digo. \ufffd Integraci\u00f3n Cont\u00ednua Cada pieza de c\u00f3digo nuevo es integrada al sistema inmediatamente despu\u00e9s de haberlo culminado. Las pruebas son ejecutadas antes y despu\u00e9s del proceso de integraci\u00f3n. La integraci\u00f3n continua reduce el doble esfuerzo del grupo de trabajo, ya que existe m\u00e1s comunicaci\u00f3n entre los integrantes que implica mayor reutilizaci\u00f3n de componentes. \ufffd 40 Horas a la Semana de Programaci\u00f3n Se debe trabajar 40 horas a la semana como m\u00e1ximo. No se permite sobre tiempo en 2 semanas seguidas, si esto llegara a suceder se considera como un 18 problema. El trabajo extra trae una fuerte desventaja al desmotivar al grupo de trabajo. Proyectos que requieren sobre tiempo para intentar cumplir con los tiempos suelen ser entregados con retraso, debido a un fallo en la etapa de planificaci\u00f3n. \ufffd Cliente en el Sitio El cliente debe estar presente y disponible para el equipo tiempo completo, si esto no es posible, se recomienda que tenga un representante siempre disponible que actu\u00e9 como su vocero. Una parte del \u00e9xito en un proyecto XP se debe a que el cliente conduce constantemente el trabajo para darle un mayor valor de negocio y los programadores pueden realizar cambios de manera r\u00e1pida. Se considera que la comunicaci\u00f3n oral es m\u00e1s efectiva que la escrita, ya que aminora el tiempo de comunicaci\u00f3n y disminuye el riesgo de ser mal interpretada. \ufffd Est\u00e1ndares de Codificaci\u00f3n Es indispensable que los programadores sigan ciertos est\u00e1ndares y/o reglas de codificaci\u00f3n establecidos para el desarrollo del proyecto. Esto trae ventajas como mejoras en la comunicaci\u00f3n de los programadores a trav\u00e9s del c\u00f3digo, producci\u00f3n de c\u00f3digo m\u00e1s legible y mantenible, facilitando la realizaci\u00f3n de modificaciones. \ufffd Espacio de Trabajo Se prefiere tener una zona espaciosa con cub\u00edculos peque\u00f1os. 19 \ufffd Reglas El equipo tiene sus propias reglas a seguir, pero pueden cambiar en cualquier momento. Dichos cambios deben realizarse por acuerdos y son implementados seg\u00fan el impacto determinado del cambio. Asterisk El \u00e1rea de las telecomunicaciones es quiz\u00e1 una de las \u00faltimas grandes industrias que hasta el momento no hab\u00eda sido afectada por la revoluci\u00f3n del \u201cSoftware Libre\u201d. La mayor\u00eda de las grandes empresas de telecomunicaciones siguen fabricando costosos, incompatibles, complicados y obsoletos sistemas de telefon\u00eda. [MJS (2005)] refiere como ejemplo de lo anterior que Nortel y su \u201cBusiness Communications Manager\u201d que corre bajo el servidor Windows NT 4.0, un switch o interruptor telef\u00f3nico de aproximadamente 15 a\u00f1os y un PC de 700 Mhz, puede costar entre 5 y 15 mil d\u00f3lares, sin incluir dispositivos extra de telefon\u00eda. Aparte se debe instalar el software de las funcionalidades \u201climitadas\u201d para el funcionamiento de este dispositivo. La mayor\u00eda de los sistemas propietarios no brindan flexibilidad, no permiten incluir nuevas funcionalidades ni ofrecen escalabilidad, sino m\u00e1s bien pretenden implantar sistemas r\u00edgidos que obliguen al consumidor a cambiar todo el sistema en vez de re-potenciar el existente. 20 Asterisk cambia este paradigma, brindando flexibilidad y escalabilidad al cliente, tiene muy pocas limitaciones en este aspecto, siendo la mayor, la configuraci\u00f3n del sistema. Asterisk permite implantar un sistema telef\u00f3nico fabricado especialmente seg\u00fan las necesidades de cada consumidor. Una de las ventajas m\u00e1s notorias la comprende el ser distribuido bajo Software Libre. Seg\u00fan la [GNU (2007)], el Software Libre representa un software que respeta ciertas libertades a los usuarios, entonces una vez que se dispone, el mismo puede ser usado, estudiado, copiado, modificado y redistribuido libremente. El t\u00e9rmino puede ser confundido como software gratuito por su traducci\u00f3n del ingl\u00e9s, pero se refieren al t\u00e9rmino free, al garantizar libertades m\u00e1s no por ser gratis. Espec\u00edficamente se refieren a 4 libertades necesarias para los usuarios del software: \u2022 Libertad de ejecutar el programa con cualquier prop\u00f3sito (privado, educativo, p\u00fablico, comercial, militar, entre otros). \u2022 Libertad de estudiar y modificar el programa. \u2022 Libertad de copiar o redistribuir el programa, de esta manera se puede ayudar al \u201cvecino\u201d o a cualquier otra persona. \u2022 Libertad de hacer mejoras en el programa y capacidad de publicar las mejoras, de modo que toda la comunidad se vea beneficiada de esta correcci\u00f3n. \u2022 Para cumplir el segundo y el cuarto punto, se tiene como precondici\u00f3n tener la posibilidad de acceder al c\u00f3digo fuente, es decir que es necesario brindar al usuario acceso al c\u00f3digo fuente para que se considere como Software Libre. 21 \u00bfQu\u00e9 es? Seg\u00fan [MJS (2005)], Asterisk es una aplicaci\u00f3n, multiplataforma, distribuida y desarrollada libremente, de una central telef\u00f3nica PBX (Private Branch Exchange), liberada bajo la Licencia GPL de GNU (General Public License). Un PBX puede ser imaginado como una red privada de conmutaci\u00f3n, conectada en un extremo a una cantidad de extensiones privadas y del otro lado, una red telef\u00f3nica, usando el PBX como un conmutador de llamadas. El sistema incluye las funcionalidades asociadas a cualquier PBX propietarios, como conectar un n\u00famero determinado de tel\u00e9fonos para hacer llamadas entre s\u00ed o conectar con un proveedor de VoIP (Voice over Internet Protocol) o una ISDN (Integrated Services Digital Network). La central telef\u00f3nica Asterisk tambi\u00e9n incluye caracter\u00edsticas especiales que s\u00f3lo poseen algunos PBX como: buz\u00f3n de voz, distribuci\u00f3n autom\u00e1tica e interactiva de llamadas (Interactive Voice Response, IVR), conferencias, entre otras funcionalidades que se mencionar\u00e1n m\u00e1s adelante. Por sus caracter\u00edsticas, su flexibilidad y sus bondades para la construcci\u00f3n de soluciones en las telecomunicaciones, Asterisk comprende una de las herramientas telef\u00f3nicas de c\u00f3digo abierto m\u00e1s usada en la actualidad. Tambi\u00e9n es considerado un marco de trabajo o framework que permite seleccionar y/o quitar ciertos m\u00f3dulos, lo que realza su flexibilidad y versatilidad, 22 facilitando dise\u00f1ar un sistema telef\u00f3nico hecho a la medida, lo que comprende una gran ventaja al compararlo contra los PBX propietarios, que como se coment\u00f3, son muy r\u00edgidos en este aspecto. Historia [MJS (2005)] refieren que en sus or\u00edgenes, Asterisk fue desarrollada por Mark Spencer en el a\u00f1o 1999, qui\u00e9n para ese entonces era estudiante de Ingenier\u00eda Inform\u00e1tica en la Universidad de Auburn, Alabama. Entonces, Spencer decidi\u00f3 crear la empresa \"Linux Support Services\" con el objetivo de dar soporte a usuarios de Linux. Para lograr su misi\u00f3n, Spencer necesitaba una central telef\u00f3nica, pero ante la imposibilidad de adquirirla dados sus elevados precios, decidi\u00f3 construir un software que le brindara los mismos beneficios, con s\u00f3lo un PC bajo Linux y utilizando el lenguaje de programaci\u00f3n \u201cC\u201d. De all\u00ed nace la idea del proyecto que dio origen a Asterisk, llamado de esta manera por el s\u00edmbolo Asterisco (*), que en ambientes tales como Linux, Unix y DOS representa cualquier combinaci\u00f3n de caracteres o un \u201ccomod\u00edn\u201d, utilizado de igual manera en muchos otros sistemas y lenguajes de programaci\u00f3n. El proyecto de Asterisk fue creciendo a trav\u00e9s de los a\u00f1os bajo el paradigma del c\u00f3digo abierto, por lo que programadores de diversas partes del mundo fueron 23 realizando contribuciones importantes al c\u00f3digo de Asterisk, adicionando funcionalidades, realizando correcciones a ciertos errores y pruebas de la aplicaci\u00f3n, entre muchas otras actividades. En el a\u00f1o 2002, \"Linux Support Services\", la empresa creada por Spencer, se convertir\u00eda en \"Digium\", redirigiendo sus objetivos al desarrollo y soporte de Asterisk. Spencer ampli\u00f3 el modelo de negocio tanto con la venta de hardware espec\u00edfico, fundamentalmente tarjetas de comunicaci\u00f3n para la utilizaci\u00f3n de Asterisk, como con la venta de software propietario, entre el que destaca el \"Asterisk Business Edition\", aplicaci\u00f3n basada en Asterisk a la que se le incorporan ciertas funcionalidades con derecho de autor (copyright). Uno de los grandes colaboradores para posicionar a Asterisk al sitio donde se encuentra en la actualidad, es Jim Dixon y su proyecto \u201cZapata Telephony\u201d, nacido de la motivaci\u00f3n de este ingeniero al que le interesaba mucho la interconexi\u00f3n entre los ordenadores y la telefon\u00eda. Y es que en primera instancia se cre\u00eda que si existiera una tarjeta que pasara la informaci\u00f3n de la telefon\u00eda anal\u00f3gica al computador representar\u00eda un gran avance, ya que el procesamiento que se realizaba hasta el momento era a trav\u00e9s de costosos sistemas con DSP (Digital Signal Processing) y ahora se podr\u00eda llevar a cabo en el procesador del computador. Este fen\u00f3meno bajar\u00eda considerablemente los costos de los sistemas telef\u00f3nicos, ya que se podr\u00eda procesar la informaci\u00f3n en un computador en vez de en un costoso hardware. 24 Al pasar los a\u00f1os y observar que nadie hab\u00eda fabricado, ni planificaba la creaci\u00f3n de dichas tarjetas, se propuso a fabricarlas \u00e9l mismo y fue entonces cuando naci\u00f3 el proyecto conocido como \u201cZapata Telephony Project\u201d. Al finalizar su construcci\u00f3n, comparti\u00f3 sus resultados con la comunidad de Software Libre, y gracias a su contribuci\u00f3n naci\u00f3 la PSTN (Public Switched Telephone Network) de Asterisk, es decir la \u201cLa Red Telef\u00f3nica P\u00fablica de Asterisk\u201d. Caracter\u00edsticas y Ventajas [MJS (2005)] mencionan las caracter\u00edsticas telef\u00f3nicas m\u00e1s importantes que tiene Asterisk: \u2022 Permite realizar llamadas entre extensiones conectadas a \u00e9l y al exterior. \u2022 Transferencias de llamadas entre las extensiones. \u2022 Monitoreo de llamada. \u2022 Permite la conexi\u00f3n con un proveedor de telefon\u00eda de VoIP o RDSI. \u2022 Buz\u00f3n de voz. \u2022 Grabaci\u00f3n de la llamada. 25 \u2022 Identificador de n\u00fameros. \u2022 Bloqueo de n\u00fameros. \u2022 Distribuci\u00f3n autom\u00e1tica e interactiva de llamadas (\u201cInteractive Voice Response\u201d, IVR). \u2022 Llamadas en conferencia. Los mismos autores, en su obra Asterisk: The Future of Telephony, explican que las ventajas m\u00e1s notables que presenta este PBX son: \u2022 Posee soporte para voz sobre IP en numerosos protocolos tales como SIP, H.323, IAX, MGCP. \u2022 Puede establecer comunicaci\u00f3n con casi todos los equipos est\u00e1ndares de telefon\u00eda. Por ejemplo, para conectar tel\u00e9fonos anal\u00f3gicos se necesita instalar al menos una tarjeta telef\u00f3nica FXS o FXO, fabricadas casi en su totalidad por la compa\u00f1\u00eda de Mark Spencer, \u201cDigium\u201d. \u2022 Es una aplicaci\u00f3n de c\u00f3digo abierto con licencia GPL de GNU. Esto trae una gran ventaja porque permite que miles de desarrolladores a nivel mundial trabajen sobre este software, mejor\u00e1ndolo, agreg\u00e1ndole nuevas funcionalidades, y colaborando al realizar correcciones sobre los errores. 26 \u2022 Una gran parte de la flexibilidad que brinda la aplicaci\u00f3n se debe a la disponibilidad de modificar el c\u00f3digo fuente, permitiendo que los desarrolladores puedan modificar el comportamiento de la aplicaci\u00f3n y adaptarlo al problema. \u2022 Este software tambi\u00e9n presenta dentro de sus ventajas el ahorro de coste al consumidor, este aspecto es uno de los m\u00e1s trascendentales, y a su vez inspir\u00f3 al desarrollo del sistema. Mientras que un PBX propietario puede generar gastos de varios miles de d\u00f3lares, teniendo un ordenador disponible, este sistema se puede implantar con s\u00f3lo cientos de d\u00f3lares, lo que representa el costo de las tarjetas fabricadas por Digium. \u2022 Escalabilidad de aplicaci\u00f3n: cualquier usuario puede agregar nuevas funcionalidades, llamadas dialplans, a trav\u00e9s del lenguaje de script de Asterisk. Un dialplan, o plan de marcado en espa\u00f1ol, se considera el coraz\u00f3n de Asterisk y son los entes que definen como se va a procesar el tr\u00e1fico del sistema, tanto de llamadas como de aplicaciones. Simplemente consisten de una lista de instrucciones o pasos que seguir\u00e1 Asterisk durante la ejecuci\u00f3n y comprenden la base de su configuraci\u00f3n. Contrariamente a los sistemas PBX propietarios, los dialplans de Asterisk son hechos y modificados seg\u00fan la necesidad del consumidor. \u2022 Interfaces para la comunicaci\u00f3n con otros lenguajes de programaci\u00f3n, permitiendo a\u00f1adir nuevos dialplans y/o nuevos m\u00f3dulos programados en el lenguaje C, escribiendo scripts en los lenguajes de programaci\u00f3n Perl, Ruby, Phyton o cualquier otro lenguaje soportado por Linux a trav\u00e9s del Asterisk Gateway Interface (AGI) y/o Asterisk Manager Interface (AMI). 27 \u2022 Asterisk es capaz de inter-operar con terminales IP actuando como un registrador y como puerta de enlace (gateway) entre ambos. \u2022 Multiplataforma, este software se puede ejecutar en diversos sistemas operativos, tales como Linux, Mac OS X, OpenBSD, FreeBSD, Solaris y Microsoft Windows, en referencia a este \u00faltimo es un caso especial ya que s\u00f3lo hubo una versi\u00f3n de demostraci\u00f3n, pero en realidad se dice que Asterisk no corre sobre la plataforma Microsoft. Originalmente Asterisk fue dise\u00f1ado \u00fanicamente para trabajar sobre una plataforma Linux, siendo \u00e9sta la mejor soportada. Asterisk como un PBX En la historia de las telecomunicaciones, nunca se ha desarrollado un sistema que satisfaga las necesidades de cada negocio, a ning\u00fan precio. El consumidor siempre hab\u00eda tenido que adaptarse a las posibilidades del sistema, pero Asterisk es un sistema telef\u00f3nico de PBX que revoluciona este aspecto, ya que ahora el cliente no tiene que adaptarse al sistema sino que \u00e9ste se ajusta a las necesidades del cliente. Por esta raz\u00f3n, existen problemas en el \u00e1rea de la telefon\u00eda donde por los momentos s\u00f3lo Asterisk puede ayudar. El \u00e9xito y la aceptaci\u00f3n de este software ha sido muy buena y mucho m\u00e1s r\u00e1pida que la que ocurri\u00f3 con Linux. Esto se debe a varias razones: \u2022 Linux progresivamente encendi\u00f3 la primera llamarada hacia la aceptaci\u00f3n 28 del Software Libre, as\u00ed que para Asterisk es m\u00e1s sencillo seguir estos pasos. \u2022 La industria de telefon\u00eda carece de liderazgo. Es ah\u00ed donde aparece Asterisk, que tiene una visi\u00f3n realista, comprometida y futurista. \u2022 A lo largo del tiempo, los usuarios han sido v\u00edctimas de sistemas costosos, incompatibles, con muchas limitaciones y sin mucho soporte. Asterisk ha resuelto los primeros, por su compatibilidad, bajo costo y flexibilidad, y ha demostrado bastante pasi\u00f3n por resolver el \u00faltimo. \u2022 Asterisk es un PBX que puede ser orientado hacia la telefon\u00eda IP o la telefon\u00eda tradicional, pero generalmente es utilizado como un h\u00edbrido, conmutando llamadas, resolviendo las rutas y conectando los usuarios con el exterior a trav\u00e9s del Internet, la telefon\u00eda anal\u00f3gica y con conexiones digitales (T1/E1). Entre sus caracter\u00edsticas m\u00e1s notables tenemos las llamadas entre las estaciones, que como un PBX cualquiera ofrece. Esto significa que los usuarios pueden discar desde un tel\u00e9fono a otro. Quiz\u00e1 parece una funcionalidad implicita, pero existen sistemas muy elementales (generalmente llamados Key) que tienen soporte para m\u00faltiples dispositivos y m\u00faltiples l\u00edneas telef\u00f3nicas. Ellos permiten a los dispositivos usar cualquier l\u00ednea, pero como \u00e9stos no poseen extensiones individuales, no existe manera de iniciar una llamada de una extensi\u00f3n a otra. Asterisk permite tanto comunicaciones directas entre extensiones internas como establecer contacto a dispositivos externos si se encuentra conectado a un proveedor de servicio, como se muestra en el siguiente gr\u00e1fico: 29 Gr\u00e1fico 2: Esquema de interconexi\u00f3n de Asterisk con dispositivos internos y externos. Fuente: Meggelen (et al. 2005) En este diagrama cada extensi\u00f3n que se encuentra a la izquierda del PBX puede conectarse a otra extensi\u00f3n disc\u00e1ndola directamente. Esto significa que si el m\u00f3dem va a enviar un fax a la m\u00e1quina local, los dispositivos se comunicar\u00e1n directamente, a trav\u00e9s del PBX. Para dar un ejemplo m\u00e1s ilustrativo, se puede imaginar dos oficinas separadas f\u00edsicamente, que bien pudieran tener dos l\u00edneas telef\u00f3nicas separadas, pero si ambas tienen Asterisk y una conexi\u00f3n a Internet, se puede realizar una configuraci\u00f3n tal que se puedan comunicar las extensiones de cada uno de las oficinas a trav\u00e9s de Internet, representando un ahorro de costos notable, especialmente si las oficinas est\u00e1n en pa\u00edses distintos. Inclusive se pudiera dar el caso que se reciba una llamada a la oficina A preguntando por cualquier protocolo. Si esa llamada la debe manejar el personal de la oficina B, se puede transferir la llamada a \u00e9sta oficina, pas\u00e1ndola a trav\u00e9s de Internet, tal cual como se presenta en la siguiente imagen: 30 Gr\u00e1fico 3: Esquema de interconexi\u00f3n entre varios PBX`s con dispositivos asociados. Fuente: Meggelen (et al. 2005) En el gr\u00e1fico se aprecia el escenario con mayor claridad cuando entra una llamada a trav\u00e9s de la PSTN (Public Switched Telephone Network) conectada al PBX de la oficina A, es atendida por una extensi\u00f3n de la oficina A y transferida a una extensi\u00f3n en la oficina B a trav\u00e9s de Internet. Tambi\u00e9n se puede dar el escenario donde la oficina B no tenga conexi\u00f3n a un proveedor de telefon\u00eda y realice sus llamadas a tel\u00e9fonos externos a trav\u00e9s de la oficina A. Estos son unos pocos ejemplos de la potencialidad que posee Asterisk con s\u00f3lo una configuraci\u00f3n adecuada usando telefon\u00eda con voz sobre IP. Tal como sostiene [GDD (2005)], con Asterisk tambi\u00e9n es posible implantar un sistema de comunicaci\u00f3n com\u00fan como el planteado en el primer escenario donde Asterisk s\u00f3lo 31 se encuentre conectado a trav\u00e9s de la telefon\u00eda tradicional, permitiendo con un poco de configuraci\u00f3n nuevas funcionalidades utilizando VoIP. La mayor\u00eda de las compa\u00f1\u00edas manejan dos redes, una para la telefon\u00eda y otra para los ordenadores. Si unimos estas dos redes en una sola comprender\u00eda un beneficio a nivel de costos, tanto en equipo como en personal. Adem\u00e1s que a trav\u00e9s del tiempo el hardware para los computadores y redes de ordenadores parece bajar progresivamente de precio, mientras que los sistemas propietarios de telefon\u00eda permanecen iguales. Voz sobre IP permite tener una extensi\u00f3n conectada siempre y cuando se disponga de una conexi\u00f3n veloz a Internet. Entonces una persona pudiera tener la misma extensi\u00f3n en su oficina y en su casa o hasta en su tel\u00e9fono celular. Por \u00e9stas y otras caracter\u00edsticas Asterisk est\u00e1 siendo implantado en muchos centros de llamadas a nivel mundial. Flexibilidad Vs. Configuraci\u00f3n Naturalmente las ventajas y caracter\u00edsticas vienen asociadas a un precio, ya que Asterisk no es un sistema simple a la hora de configuraci\u00f3n, que quiz\u00e1 comprende su principal desventaja. A pesar que el software es claro y l\u00f3gico, pudiendo implementar casi cualquier escenario a nivel de telefon\u00eda, cada una de las funcionalidades lleva un esfuerzo asociado, que para un principiante pudiera significar un tiempo considerable de dedicaci\u00f3n. 32 Existe una curva de aprendizaje, pero puede ser sobrellevada con facilidad. Muchos desarrolladores se han convertido en expertos en telefon\u00eda. [GDD (2005)] explican que Asterisk no fue concebido para todos los perfiles de usuario, ya que para personas que no se quieren encargar en lo m\u00e1s m\u00ednimo de configuraci\u00f3n ni instalaci\u00f3n, esta no es la mejor opci\u00f3n. Es importante reflejar que aunque Asterisk tiene esta cantidad de ventajas, no es la soluci\u00f3n adecuada para cada negocio, depende de las necesidades de cada uno, es por eso que se deben estudiar las posibilidades antes de escoger la tecnolog\u00eda a ser usada. Configuraci\u00f3n Gr\u00e1fica vs Configuraci\u00f3n de Texto Actualmente la mayor\u00eda de las opciones de Asterisk se configuran a trav\u00e9s de archivos de texto plano. Esta es una forma sencilla de crear, respaldar y modificar configuraciones para aquellos usuarios o desarrolladores que se sientan a gusto con este tipo de archivos. Existen algunos PBX que ofrecen interfaces gr\u00e1ficas, mejor conocidas como Graphical User Interface en ingl\u00e9s (GUI), para manipular su configuraci\u00f3n. Otros PBX se configuran a trav\u00e9s de los dispositivos conectadas a \u00e9l como, por ejemplo, un tel\u00e9fono, y algunos otros simplemente no pueden ser configuradas, excepto con personal certificado, que requieren de dispositivos especiales fabricados por la misma compa\u00f1\u00eda de telecomunicaciones del sistema, para realizar dicha configuraci\u00f3n. 33 Ya existen varias herramientas para instalar y configurar a Asterisk f\u00e1cilmente a trav\u00e9s de una interfaz gr\u00e1fica, pero para tener la posibilidad de configurar todas las funcionalidades a\u00fan se requiere de una configuraci\u00f3n de texto, aunque reducida. Pudiendo afirmar que la configuraci\u00f3n de Asterisk se ha facilitado, reduciendo un poco el punto cr\u00edtico que lo desvirt\u00faa. Dialplans: Contextos, Extensiones, Prioridades y Aplicaciones Los dialplans (planes de marcado en espa\u00f1ol) est\u00e1n compuestos por cuatro partes principales, los contextos, las extensiones, las prioridades y las aplicaciones. Se explicar\u00e1n sus componentes para luego dar una visi\u00f3n general de los dialplans. Contextos En Asterisk un contexto no es m\u00e1s que una colecci\u00f3n de extensiones definidas por un nombre l\u00f3gico. Por lo cual una misma extensi\u00f3n puede estar definida m\u00e1s de una vez, siempre y cuando se encuentre en dos contextos distintos, funcionando cada extensi\u00f3n de manera aislada. Estas extensiones no pueden establecer conexi\u00f3n a menos que se especifiqu\u00e9 lo contrario en Asterisk, es decir que dos contextos no se comunican al menos que se indique a nivel de configuraci\u00f3n. Supongamos que 2 compa\u00f1\u00edas comparten un mismo servidor de Asterisk, pero en las 2 compa\u00f1\u00edas quieren definir sus extensiones del 1 al 10, en este momento se utilizan los contextos para separar cada lote de extensiones. Por ejemplo si en cada una de las compa\u00f1\u00edas la extensi\u00f3n 1 es la de recepci\u00f3n, cuando una extensi\u00f3n de la compa\u00f1\u00eda A marque 1, con la diferenciaci\u00f3n de contextos, se asegura que se est\u00e9 34 comunicando con la recepcionista de la compa\u00f1\u00eda A y no se confunda con las extensiones de la compa\u00f1\u00eda B. Los contextos son denotados por un nombre de caracteres dentro de corchetes ([]). Nombre que puede estar compuesto por combinaciones de letras desde a \u201cA\u201d hasta la \u201cZ\u201d, may\u00fasculas o min\u00fasculas, d\u00edgitos del 0 al 9 y ciertos caracteres especiales. En la p\u00e1gina Web Asterisk Dialplan Introduction (2003), se explica que un contexto podr\u00eda estar compuesto de cualquier cantidad de extensiones, un ejemplo sencillo podr\u00eda ser (no como se configura en Asterisk): Context [prueba]: Extension Description 101 Edgar 102 Omar 103 Andr\u00e9s 104 Chequear Contestadora 105 Sal\u00f3n de Conferencias 0 Recepci\u00f3n En el ejemplo se define un contexto llamado \u201cprueba\u201d, donde las primeras 3 extensiones, de la 101 a la 103, est\u00e1n asociadas a distintos empleados, la extensi\u00f3n 104 para solicitar consulta sobre el contestador autom\u00e1tico, la quinta extensi\u00f3n con su n\u00famero 105 pertenecer\u00eda al sal\u00f3n de conferencias, finalmente la \u00faltima definida con el n\u00famero 0 asociada a la recepci\u00f3n. El sitio Web [Asterisk Dialplan Introduction (2003)], se\u00f1ala que los contextos pueden ser \u00fatiles al implementar ciertas configuraciones, tales como: \u2022 Seguridad: Con restricci\u00f3n sobre las llamadas salientes, dependiendo de la 35 extensi\u00f3n. \u2022 Enrutando: Seg\u00fan la extensi\u00f3n se pueden enrutar las llamdas. \u2022 Respuesta autom\u00e1tica: Dar un mensaje autom\u00e1tico, donde el usuario indique la extensi\u00f3n a comunicar. \u2022 Men\u00fas multinivel: Men\u00fas para ventas, soportes, entre otros, en una instituci\u00f3n. \u2022 Autenticaci\u00f3n: Preguntar por contrase\u00f1as para ciertas extensiones. Asterisk al recibir una llamada desde afuera o desde una extensi\u00f3n interna, las asocia a un contexto, el cual depende del canal en el que la llamada se recibi\u00f3. Esto es posible ya que al configurar los canales en Asterisk, se define el contexto asociado a cada uno de ellos. Canales Seg\u00fan [Asterisk channels (2003)], un canal en Asterisk es una conexi\u00f3n que se asocia a una llamada cuando esta entra a Asterisk. Dicha conexi\u00f3n pudiera estar asociada a un tel\u00e9fono, l\u00ednea de tel\u00e9fono, o a una llamada l\u00f3gica (como una llamada a trav\u00e9s de Internet). Se debe tomar en cuenta que cada llamada es colocada o recibida en un canal distinto, lo cual conforma un identificador \u00fanico para esa llamada. Extensiones En cada contexto se definen una o m\u00e1s extensiones. A pesar que las extensiones generalmente son usadas para especificar cada de las extensiones 36 telef\u00f3nicas, al igual que en los PBX tradicionales, en Asterisk pueden ser usadas para m\u00e1s que un simple identificador. Seg\u00fan [MJS (2005)], una extensi\u00f3n puede ser una instrucci\u00f3n que Asterisk va a seguir y es disparada por una llamada entrante o por una serie de d\u00edgitos marcados en un canal. Las extensiones especifican que sucede con una llamada cuando se manejan en el dialplan. La sintaxis para una extensi\u00f3n es la palabra \u201cexten\u201d, seguida de una flecha, de la siguiente manera: Instrucci\u00f3n de Asterisk: exten => Tabla 1:Extensi\u00f3n Asterisk. Coloc\u00e1ndose luego el identificador de la extensi\u00f3n. A pesar que tradicionalmente se piensa en una extensi\u00f3n como un n\u00famero, en Asterisk podemos definir identificadores como combinaci\u00f3n de n\u00fameros y letras. Una extensi\u00f3n est\u00e1 compuesta por 3 componentes: \u2022 El identificador de la extensi\u00f3n \u2022 La prioridad \u2022 La aplicaci\u00f3n o comando que es llamado Cada uno de los componentes separados por comas, por ejemplo: 37 Componentes de la extensi\u00f3n: exten => 123,1,Answer() Tabla 2: Componentes Extensiones Asterisk. En el ejemplo el identificador de la extensi\u00f3n es \u201c123\u201d, la prioridad es \u201c1\u201d y la aplicaci\u00f3n es \u201cAnswer()\u201d. Existe una extensi\u00f3n especial para Asterisk llamada \u201cs\u201d. Cuando una llamada entra a un contexto sin una extensi\u00f3n espec\u00edfica destino, son manejadas autom\u00e1ticamente por la extensi\u00f3n \u201cs\u201d. La \u201cs\u201d viene del t\u00e9rmino en ingl\u00e9s \u201cstart\u201d (comienzo), ya que la mayor\u00eda de las llamadas empiezan su curso en la extensi\u00f3n \u201cs\u201d. Prioridades [MJS (2005)], comenta que cada extensi\u00f3n puede tener varios pasos, llamados prioridades. Cada prioridad es numerada secuencialmente, empezando desde el n\u00famero uno (1). Cada prioridad se ejecuta en una aplicaci\u00f3n espec\u00edfica. Por ejemplo: Prioridades de extensiones: exten => 123,1,Answer( ) exten => 123,2,Hangup( ) Tabla 3: Orden de Ejecuci\u00f3n de Extensiones. En el ejemplo la extensi\u00f3n con la prioridad uno ejecuta su aplicaci\u00f3n 38 (Contestar el tel\u00e9fono) y luego se cuelga con la ejecuci\u00f3n de la aplicaci\u00f3n (Hangup()) que tiene asignada la prioridad dos. Aplicaciones [MJS (2005)], explica que una aplicaci\u00f3n es el c\u00f3digo que se ejecuta o la acci\u00f3n a tomar en el canal actual, tal como reproducir un sonido, leer una opci\u00f3n de usuario, responder o colgar la llamada, entre otras. Algunas aplicaciones como las expuestas en el punto anterior llamadas Answer() y Hangup(), que significan responder y colgar una llamada respectivamente, son algunas de las m\u00e1s usadas en el PBX. A estas aplicaciones no se les pasa ning\u00fan par\u00e1metro, m\u00e1s existen aplicaciones que llevan par\u00e1metros y tal cual como las funciones en la mayor\u00eda de los lenguajes de programaci\u00f3n, son colocados dentro de par\u00e9ntesis y separados por comas. Dialplans Finalmente la uni\u00f3n de las piezas (prioridades, aplicaciones, extensiones y contextos) se arman para formar lo que se llama en Asterisk, un dialplan. Un ejemplo sencillo puede ser: Dialplan ejemplo: [entrante] exten => s,1,Answer( ) exten => s,2,Playback(bienvenido) exten => s,3,Hangup( ) exten => 123,1,Answer() Tabla 4: Ejemplo de Dialplan de Asterisk. 39 En el ejemplo tenemos tres extensiones con el identificador \u201cs\u201d, cuyo funcionamiento fue comentado anteriormente y una extensi\u00f3n con el identificador \u201c123\u201d. Tomando como premisa que las llamadas se asocian al contexto \u201centrante\u201d, cualquier llamada con un destino distinto a la extensi\u00f3n \u201c123\u201d pasar\u00e1 por la secuencia de aplicaciones Answer(), que contestar\u00e1 la llamada, Playback(hello-world), aplicaci\u00f3n encargada de reproducir un archivo de sonido llamado hello-world y finalmente ejecutando Hangup(), aplicaci\u00f3n que colgar\u00e1 la llamada. Pero si la llamada va dirigida hacia la extensi\u00f3n \u201c123\u201d, se ejecutar\u00e1 \u00fanicamente la aplicaci\u00f3n Answer(). Interfaces Asterisk Manager Interface y Asterisk Gateway Interface Una de las facilidades de las que provee Asterisk son las interfaces de comunicaci\u00f3n con ese framework, que permiten flexibilidad y escalabilidad. Esas interfaces son: Asterisk Gateway Interface (AGI) y Asterisk Manager Interface (AMI). AGI es una interfaz que permite establecer un intercambio de datos entre Asterisk y c\u00f3digo escrito en un lenguaje de programaci\u00f3n que tenga la capacidad de escribir al STDOUT (salida est\u00e1ndar) y leer del STDIN (entrada est\u00e1ndar), para tomar decisiones de enrutamiento y ejecuci\u00f3n de aplicaciones y/o llamadas que se encuentren activas en Asterisk. AMI por su parte, da un control sobre el funcionamiento del sistema de 40 Asterisk; permitiendo conectarnos al framework por medio de un socket TCP desde cualquier lenguaje con soporte para sockets. Al recibir notificaciones sobre eventos que ocurren en Asterisk tales como informaci\u00f3n sobre las llamadas activas, sobre las extensiones, entre otros; as\u00ed como emitiendo acciones que se ejecuten en Asterisk, como por ejemplo, realizar, colgar o transferir una llamada. Asterisk Gateway Interface Seg\u00fan [MJS (2005)], la interfaz Asterisk Gateway Interface (AGI), provee un est\u00e1ndar de conexi\u00f3n desde programas externos hacia el funcionamiento de Asterisk. Los scripts o conjunto de instrucciones son usados para agregarle una l\u00f3gica avanzada al sistema de Asterisk, como lograr comunicaci\u00f3n con bases de datos (tales como PostgreSQL o MySQL), o utilizar otros recursos externos. Dichos c\u00f3digos pueden ser escritos en distintos lenguajes de programaci\u00f3n tales como Perl, PHP, C, Pascal, Ruby, entre otros, dependiendo de la elecci\u00f3n del desarrollador. Tambi\u00e9n plantea que el sistema pasa el control desde el dialplan de Asterisk a un lenguaje externo a trav\u00e9s de AGI, permitiendo la realizaci\u00f3n de tareas que ser\u00edan muy dif\u00edciles o casi imposibles de implementar con Asterisk. Los scripts AGI se comunican con Asterisk a trav\u00e9s de canales (apuntadores a archivos) conocidos como STDIN, STDOUT, y STDERR que pueden ser interpretados en Unix como la entrada est\u00e1ndar, la salida est\u00e1ndar y la salida de error est\u00e1ndar, respectivamente. As\u00ed, un c\u00f3digo AGI lee del STDIN para tomar informaci\u00f3n de Asterisk, 41 escribe datos en el STDOUT para enviar informaci\u00f3n a Asterisk y puede escribir en el STDERR para enviar informaci\u00f3n de traza a la consola de Asterisk. Desde luego que se necesita una porci\u00f3n de configuraci\u00f3n en Asterisk para lograr la comunicaci\u00f3n efectiva a trav\u00e9s de esta interfaz. Esta interfaz fue desarrollada para permitir que una aplicaci\u00f3n externa a Asterisk tome el control sobre el flujo de la llamada, permitiendo desv\u00edos, respuestas autom\u00e1ticas y otras modificaciones sobre la llamada. Esto pensando en los avances de los lenguajes de script y los beneficios que esto podr\u00eda significar para el \u00e1rea de las centrales telef\u00f3nicas, por ejemplo, la implementaci\u00f3n sencilla de un centro de llamada o un IVR de manera programada. Vali\u00e9ndose de la ventaja que significa la manipulaci\u00f3n del flujo desde alg\u00fan lenguaje externo, ya que proveen soportes para conexiones a bases de datos, rutinas externas, pase de informaci\u00f3n, entre otros aspectos que salen del alcance de Asterisk. En el sitio Web [Asterisk AGI (2003)], explican que la interfaz fue concebida para la distribuci\u00f3n de llamadas recibidas a la central telef\u00f3nica, mas no para la realizaci\u00f3n de llamadas as\u00edncronas. Pero Asterisk brinda soporte para la realizaci\u00f3n de llamadas as\u00edncronas por otros m\u00e9todos que estudiaremos a continuaci\u00f3n. Si se desea iniciar una llamada as\u00edncrona con Asterisk, se tienen dos posibilidades: \u2022 Escribiendo un archivo de texto (.call) que iniciar\u00e1 una llamada autom\u00e1tica a trav\u00e9s de Asterisk, acci\u00f3n llamada auto-dial out. \u2022 Usando un comando llamado originate, que pudiera ser ejecutado a trav\u00e9s el Asterisk Manager Interface, o AMI. 42 Asterisk Manager Interface La Web [AMAPI (2003)] explica que Asterisk Manager Interface (AMI), permite que una aplicaci\u00f3n cliente, establezca comunicaci\u00f3n con una instancia de Asterisk, y le env\u00ede comandos o lea eventos del PBX a trav\u00e9s de un flujo sobre TCP/IP. Esto resulta \u00fatil a la hora de realizar consultas sobre el estado de Asterisk o dar ciertas reglas que pudieran implicar la ejecuci\u00f3n de un comando, aplicaci\u00f3n, entre otras. Por su parte, en la p\u00e1gina Web [UsingAMI (2007)], se afirma que \u00e9sta es una forma de conectarse a Asterisk desde una aplicaci\u00f3n externa que permite consultar y manipular la informaci\u00f3n del PBX en un tiempo determinado. En el sitio Web [AMAPI (2003)] enfatizan que la interfaz utiliza un protocolo de comunicaci\u00f3n para el intercambio de informaci\u00f3n entre la aplicaci\u00f3n y el PBX, con previa autenticaci\u00f3n. Para un conjunto de l\u00edneas se usar\u00e1 el t\u00e9rmino \u201cpaquete\u201d, el cual es terminado con una l\u00ednea en blanco, es decir con 2 saltos de l\u00ednea seguidos. Dichos paquetes vienen dados de la siguiente forma: Paquete ejemplo de AMI: Action: <tipo de acci\u00f3n> <CRLF> <Key 1>: <valor 1> <CRLF> <Key 2>: <valor 2> <CRLF> ... <Variable>: <valor> <CRLF> <Variable>: <valor> <CRLF> ... <CRLF> Tabla 5: Paquete Ejemplo de Comunicaci\u00f3n AMI. 43 Por ejemplo, para autenticarse con el sistema, se enviar\u00eda un paquete con este formato: Paquete ejemplo de autenticaci\u00f3n AMI: Action: login <CRLF> Username: carlos <CRLF> Secret: good <CRLF> <CRLF> Tabla 6: Ejemplo de Paquete de Autenticaci\u00f3n AMI. En este paquete el campo login es la acci\u00f3n a realizar, seguido del nombre de usuario y la contrase\u00f1a de la cuenta a autenticar. En el sitio Web [AMAPI (2003)] mencionan algunas caracter\u00edsticas del protocolo, entre las cuales encontramos: \u2022 Antes de empezar a enviar comandos a Asterisk, se debe establecer una sesi\u00f3n, es decir autenticarse contra el sistema. \u2022 Luego se pueden enviar paquetes en cualquier instante, sin importar la direcci\u00f3n, es decir si van a viajar del cliente al servidor Asterisk o viceversa. \u2022 La primera l\u00ednea del paquete debe tener la acci\u00f3n cuando es enviado desde la aplicaci\u00f3n, pero cuando lo env\u00eda Asterisk debe ser un evento o una respuesta a la aplicaci\u00f3n cliente. \u2022 El orden de las l\u00edneas dentro del paquete es insignificante. \u2022 Los caracteres CR y LF son usados para delimitar cada l\u00ednea. \u2022 Una l\u00ednea en blanco indica el fin de un paquete. 44 En el mismo sitio de Internet, se se\u00f1alan tres tipos de paquetes, entre los cuales se encuentran los paquetes de acci\u00f3n, de respuesta y de evento, a continuaci\u00f3n se dar\u00e1 una breve descripci\u00f3n de cada uno: \u2022 Acci\u00f3n: un paquete enviado por un cliente de Asterisk conectado, pidiendo que una acci\u00f3n en particular sea ejecutada. Hay un conjunto finito pero extensible de acciones disponibles para los clientes, determinadas por los m\u00f3dulos cargados en Asterisk para ese momento. Solo se puede ejecutar una acci\u00f3n a la vez. Los paquetes de acci\u00f3n contienen tanto el nombre como los par\u00e1metros de la operaci\u00f3n a ser ejecutada. \u2022 Respuesta: paquete de respuesta enviado por Asterisk, devolviendo el resultado al \u00faltimo paquete de acci\u00f3n entregado por el cliente. \u2022 Evento: paquete de data pertinente de un evento o cambio generado en Asterisk, como por ejemplo el cambio de estado de una extensi\u00f3n de Asterisk, cambio de estado de un canal, entre otros. [MJS (2005)] se\u00f1ala que para alcanzar la comunicaci\u00f3n entre Asterisk y la aplicaci\u00f3n externa a trav\u00e9s de AMI, es necesario poseer una cuenta en Asterisk sobre la cual se autenticar\u00e1 la informaci\u00f3n. Dicha cuenta es una simple entrada en el archivo de configuraci\u00f3n de Asterisk, manager.conf. Tambi\u00e9n explica [MJS (2005)] que la aplicaci\u00f3n cliente env\u00eda paquetes de acci\u00f3n al servidor de Asterisk, quien los recibe, procesa, realiza las operaciones adecuadas y le env\u00eda de vuelta a la aplicaci\u00f3n cliente el resultado (error o \u00e9xito), en un 45 paquete de respuesta. Los paquetes incluyen un identificador para poder realizar la correspondencia sobre las acciones y respuestas. Por su parte, en la p\u00e1gina de Internet [AMAPI (2003)] se explica que los paquetes de evento son usados bajo dos escenarios: \u2022 En primer lugar cuando Asterisk cambia de estado, es decir que hay un cambio en el sistema (una extensi\u00f3n es colgada o alguien es autenticado en el sistema, entre otras), Asterisk env\u00eda un paquete de evento informando el cambio. \u2022 El segundo escenario se da cuando la aplicaci\u00f3n le env\u00eda un paquete a Asterisk solicitando informaci\u00f3n sobre el sistema y Asterisk le contesta con un paquete de respuesta que contiene: \u201cResponse: Follows\u201d indicando \u00e9xito. Luego son enviados cero o m\u00e1s paquetes de evento con la informaci\u00f3n del sistema que solicit\u00f3 el cliente seguido de una respuesta del cliente en una acci\u00f3n, indicando que toda la data fue enviada correctamente. A continuaci\u00f3n se presentan las acciones m\u00e1s resaltantes tomadas del sitio de Internet [AMAPI (2003)]: \u2022 Command: Acci\u00f3n para ejecutar un comando espec\u00edfico de la consola de Asterisk. \u2022 ExtensionState: Devuelve el estado en que se encuentra una extensi\u00f3n espec\u00edfica. \u2022 Hangup: Cuelga un canal \u2022 Logoff: Termina la sesi\u00f3n iniciada con el sistema 46 \u2022 Monitor: Grabar la conversaci\u00f3n de un canal. \u2022 Originate: Realiza una nueva llamada. \u2022 Redirect: Transfiere una llamada a otra extensi\u00f3n. \u2022 Status: Muestra el estado del sistema. Como se coment\u00f3 anteriormente, existen dos escenarios para el env\u00edo de paquetes de eventos, desde Asterisk hacia la aplicaci\u00f3n externa. Una posibilidad comprenden los paquetes as\u00edncronos informativos sobre cambios, conocidos como eventos AMI. En este caso lo que sucede es simplemente un proceso de difusi\u00f3n de la informaci\u00f3n. En el sitio Web de [AME (2003)], se explica que dado un cambio dentro de Asterisk, se genera un evento que el PBX difundir\u00e1 a trav\u00e9s de su interfaz AMI en un formato espec\u00edfico. De esta manera las aplicaciones externas a Asterisk son capaces de conocer cualquier evento que sucede dentro del PBX casi al instante del mismo, ya que reciben un mensaje as\u00edncrono desde Asterisk. Los paquetes de eventos llegan a distintos m\u00e9todos de la aplicaci\u00f3n. Seg\u00fan el m\u00e9todo, la aplicaci\u00f3n pudiera tomar una acci\u00f3n u otra dependiendo de lo que quiera lograr al momento del evento. A continuaci\u00f3n se explican algunos eventos: \u2022 Dial --- Evento de marcado [derivado o disparado desde app_dial.c] 47 Ejemplo del mensaje: Ejemplo de evento cuando se marca un n\u00famero en Asterisk: Event: Dial Evento Privilege: call,all Privilegio Source: Local/900@default,2 Fuente Destination: SIP/900-4c21 Destino CallerID: <unknown> Identificador de llamada CallerIDName: default Identificador de llamada SrcUniqueID: 1149161705.2 Identificador de la fuente DestUniqueID: 1149161705.4 Identificador del destino Tabla 7: Ejemplo Evento Dial. \u2022 ExtensionStatus --- Evento del estatus de la extensi\u00f3n [derivado o disparado desde manager.c] Ejemplo del mensaje: Ejemplo de evento de cambio de estatus de extensi\u00f3n en Asterisk: Event: ExtensionStatus Evento Exten: <ext> Extensi\u00f3n Context: <context> Contexto Status: <state> Estatus Tabla 8: Ejemplo Evento ExtensionStatus. En todos los mensajes viaja al principio del paquete el tipo del evento, luego viajan una serie de par\u00e1metros distintos dependiendo del evento que se genere. En este \u00faltimo caso tenemos que el tipo de evento es \u201cExtensionStatus\u201d, que tiene tres par\u00e1metros, el primero \u201cExten\u201d que tiene la informaci\u00f3n de la extensi\u00f3n que sufri\u00f3 el cambio de estado, \u201cContext\u201d que tiene el contexto en el que se encuentra y \u201cStatus\u201d, variable que contiene el estatus en el cual qued\u00f3 la extensi\u00f3n que sufri\u00f3 el cambio. 48 Ruby on Rails Ruby on Rails, conocido tambi\u00e9n como RoR o Rails, es un framework de aplicaciones Web escrito en el lenguaje de programaci\u00f3n Ruby, que como se afirma en la p\u00e1gina Web Wikipedia (2007), se apega al paradigma de la arquitectura Modelo Vista Controlador (MVC). Seg\u00fan [TDH (2006)] Ruby on Rails es un framework cuyo lema es facilitar el desarrollo, despliego y mantenimiento de aplicaciones Web. Persigue combinar simplicidad con la posibilidad de desarrollar escribiendo menos l\u00edneas de c\u00f3digo que utilizando otros frameworks. Aproximadamente al a\u00f1o de ser lanzado al p\u00fablico (en 2004), Rails pas\u00f3 de ser un framework desconocido a un fen\u00f3meno a nivel mundial, convirti\u00e9ndose en una de las mejores opciones a la hora de implementar aplicaciones Web. Para dar una perspectiva de esta evoluci\u00f3n, se puede mencionar que pas\u00f3 de ser usado por s\u00f3lo hackers, a utilizarse como framework de desarrollo en compa\u00f1\u00edas transnacionales a nivel mundial, seg\u00fan rese\u00f1a [TDH (2006)]. Las aplicaciones implementadas con esta tecnolog\u00eda siguen una arquitectura MVC, igual que las desarrolladas usando frameworks como Tapestry y Struts basados en Java. [TDH (2006)] destaca como otro de los puntos claves de Rails el referido a las pruebas. Los programadores escriben pruebas para desarrollar una aplicaci\u00f3n de calidad y Rails facilita la implementaci\u00f3n de este tipo de pruebas, por lo que cualquier 49 aplicaci\u00f3n Rails provee soporte para pruebas dentro del mismo framework. Por cada funcionalidad, RoR crea de manera autom\u00e1tica con su herramienta de generaci\u00f3n de c\u00f3digo, un esqueleto de las pruebas del requerimiento, trozos que pudieran considerarse como una plantilla para desarrollar las pruebas. La facilidad de escribir y ejecutar las pruebas, trae como resultado que las aplicaciones desarrolladas tiendan a ser probadas. Los desarrollos en RoR son escritos en el lenguaje de programaci\u00f3n Ruby. Tal como se se\u00f1ala en el sitio Web [Acerca de Ruby (2007)], Ruby es un lenguaje de scripting orientado a objetos, caracterizado por ser claro y conciso, donde el desarrollador puede expresar las ideas de forma limpia y natural. La sencillez a la hora de programar facilita retomar un c\u00f3digo que fue escrito en tiempo pasado, dando legibilidad y claridad. El lenguaje fue creado en el a\u00f1o 1993 por Yukihiro Matsumoto, programador japon\u00e9s conocido en el gremio inform\u00e1tico como \u201cMatz\u201d. Su creador alega que tom\u00f3 partes de sus lenguajes favoritos (Perl, Smalltalk, Eiffel, Ada y Lisp) que permitieran el dise\u00f1o de un nuevo lenguaje que equilibra la programaci\u00f3n funcional con la imperativa. El el sitio Web [Acerca de Ruby (2007)], se\u00f1ala que el lenguaje Ruby permite la metaprogramaci\u00f3n, que consiste en generar o manipular programas a partir de otro programa, es decir que un c\u00f3digo tenga la capacidad de modificar o generar un programa. Esto permite al programador ahorrar tiempo en la producci\u00f3n de c\u00f3digo, de la cual Rails hace uso, lo que resulta en una sintaxis que muchos de sus usuarios 50 encuentran legible. El lenguaje combina una sintaxis inspirada en Perl, orientado a objetos similar a Smalltalk que comparte funcionalidades con algunos lenguajes de programaci\u00f3n como Python, Lisp, Dylan y CLU. Ruby se vale de su caracter\u00edstica orientada a objetos, teniendo hasta los n\u00fameros y los literales como objetos. Es un lenguaje de programaci\u00f3n interpretado y su implementaci\u00f3n es distribuida bajo la licencia de software libre GNU GPL. Filosof\u00edas Rails tiene vertientes claras de como una aplicaci\u00f3n Web deber\u00eda estar compuesta y organizada, adem\u00e1s de la forma en que los subsistemas deber\u00edan configurarse e integrarse. Distinto a los frameworks Java que existen actualmente que basan su integraci\u00f3n en archivos de configuraci\u00f3n XML, una de las filosof\u00edas m\u00e1s acentuadas de Rails es la Convenci\u00f3n sobre configuraci\u00f3n. Ruby on Rails reemplaza la configuraci\u00f3n masiva de archivos XML por una convenci\u00f3n de nombres consistentes y rutas est\u00e1ndares para los distintos tipos de archivos usados en una aplicaci\u00f3n Rails. Un ejemplo de esta pr\u00e1ctica es la presente en la conexi\u00f3n con la base de datos, y es que seg\u00fan las convenciones de Rails, las tablas de las bases de datos deber\u00edan ser nombradas en plural y las clases en singular, entonces las clases User y Call tendr\u00edan por tablas a users y calls respectivamente, y su clave primaria en cada tabla conocido por el nombre id. Tal y como se presenta la convenci\u00f3n en este caso, tambi\u00e9n sucede en muchos otros casos en las que se necesita la integraci\u00f3n de los distintos elementos de la aplicaci\u00f3n. 51 Cuando se dise\u00f1a una aplicaci\u00f3n partiendo de cero sin una base de datos preexistente, el seguir las convenciones de Rails significa usar menos c\u00f3digo (aunque el comportamiento puede ser configurado si el sistema debe ser compatible con un sistema heredado). Otro de los principios fundamentales en Ruby on Rails es expresado com\u00fanmente como DRY, por sus siglas en ingl\u00e9s Don't Repeat Yourself, en espa\u00f1ol significa no te repitas, cuya idea es minimizar la duplicaci\u00f3n de c\u00f3digo. Este principio plantea que las definiciones deber\u00edan hacerse una sola vez, ya que cuando se tiene c\u00f3digo duplicado en la aplicaci\u00f3n y es descubierto un error en \u00e9l, habr\u00eda que cambiar el defecto en numerosos lugares. Al reutilizar el c\u00f3digo se minimiza el impacto de estos cambios a un s\u00f3lo punto. [TDH (2006)] destaca que la combinaci\u00f3n de las filosof\u00edas Rails en conjunto: la meta-programaci\u00f3n, los plugins, las bondades y caracter\u00edsticas del lenguaje Ruby, hacen de Rails un poderoso framework para el desarrollo de aplicaciones Web. Rails saca provecho de Ruby, facilit\u00e1ndole al programador el desarrollo de aplicaciones, permitiendo que la codificaci\u00f3n sea considerablemente m\u00e1s corta y legible. Arquitectura En 1979 el Licenciado en Computaci\u00f3n noruego, Trygve Mikkjel Heyerdahl Reenskaug, de 49 a\u00f1os de edad, propuso el Modelo Vista Controlador (MVC), un 52 nuevo dise\u00f1o para el desarrollo de aplicaciones interactivas dividido en tres tipos de componentes: \u2022 Modelos. Comprenden los entes responsables del estado de la aplicaci\u00f3n, en ocasiones estados transitorios durando s\u00f3lo el tiempo de interactividad del usuario. En otros casos el estado es permanente, persistiendo generalmente en repositorios de datos. Un modelo es m\u00e1s que simplemente datos, comprende toda la l\u00f3gica de negocio que es aplicada a esa data. Como se coment\u00f3, en Rails cada tabla es representada por un modelo asociado a ella, siendo el rol principal del modelo la implementaci\u00f3n de m\u00e9todos de consulta a la base de datos, com\u00fanmente llamados querys, validaciones y actualizaciones a la base de datos. \u2022 Vistas. Son los componentes encargados de generar una interfaz de usuario, generalmente presentando los datos obtenidos de los modelos. Por ejemplo en una aplicaci\u00f3n de una tienda se tiene una lista de productos disponibles. Dicha lista ser\u00eda construida en un modelo de la aplicaci\u00f3n, pero la vista estar\u00eda encargada de acceder la colecci\u00f3n y definir un formato para su presentaci\u00f3n al usuario final. \u2022 Controladores. Este componente es quien organiza y dirige la aplicaci\u00f3n. Los controladores reciben eventos desde el exterior del sistema, interact\u00faan con el modelo y le devuelve la vista apropiada al usuario. Tal como explica [TDH (2006)], estos tres componentes forman la arquitectura conocida como MVC, en el gr\u00e1fico 3 se muestra el funcionamiento en t\u00e9rminos abstractos. MVC es s\u00f3lo un patr\u00f3n que involucra separaci\u00f3n del c\u00f3digo de un modo espec\u00edfico para facilitarle ciertos aspectos al programador. 53 Gr\u00e1fico 4: Modelo MVC Fuente: [TDH (2006)] En sus or\u00edgenes la plantilla MVC fue concebida \u00fanicamente para aplicaciones convencionales (Stand-alone) con interfaces de usuario, donde se descubri\u00f3 que la separaci\u00f3n de roles implicaba menor acoplamiento, un c\u00f3digo m\u00e1s sencillo y mantenible con cada acci\u00f3n en el lugar correcto. Esta estructura provee una base o esqueleto de la aplicaci\u00f3n, sobre la cual es m\u00e1s sencillo trabajar. Con el auge de las aplicaciones Web, los programadores retrocedieron, usando el obsoleto modelo monol\u00edtico donde se mezclaban la l\u00f3gica de negocio, la presentaci\u00f3n, el manejo de eventos y el acceso a repositorio de datos en un solo lugar. Luego, se empez\u00f3 a experimentar y desarrollar aplicaciones Web con arquitecturas que intentaban separar el c\u00f3digo, tal como lo propone el patr\u00f3n MVC. El resultado fueron frameworks como WebObjects, Struts y Java Server Faces, todos basados en el modelo MVC. Rails provee una estructura para las aplicaciones donde se desarrollan modelos, vistas y controladores por separado, y los va integrando mientras se va Controlador Base de datos Modelo Vista 54 ejecutando el c\u00f3digo. En la figura 4 se muestra el funcionamiento de Rails cuando recibe una petici\u00f3n. Seg\u00fan [Dave Astels (2007)], en una aplicaci\u00f3n Rails los eventos de entrada son enviados primero a un enrutador (1), encargado de decidir qui\u00e9n ser\u00e1 el componente que va a manejar dicha petici\u00f3n. Luego se identifica qu\u00e9 m\u00e9todo se va a ejecutar en el controlador (2), la acci\u00f3n pudiera capturar la data de la petici\u00f3n e interactuar con el modelo (3). Eventualmente una acci\u00f3n preparar\u00e1 la data para la vista (4) que va a mostrarle al usuario. Gr\u00e1fico 5: Modelo MVC en Rails Fuente: [TDH (2006)] Componentes b\u00e1sicos Active Record En la actualidad la mayor\u00eda de las aplicaciones desean persistir informaci\u00f3n en una base de datos relacional, hasta los sistemas poco estructurados como blogs y p\u00e1ginas de noticias usan este tipo de repositorios para guardar su informaci\u00f3n. Enrutador Controlador Modelo Vista Base de datos 1 2 3 4 5 55 Con el auge de los lenguajes de programaci\u00f3n orientados a objeto, se ha presentado una dificultad al asociarlos con una base de datos relacional. Las base de datos a diferencia de los objetos se basa en conjuntos de valores agrupados, mientras que los objetos tienen sentido usando datos y operaciones. Existen dos tendencias al organizar la data en un sistema conciliando el paradigma orientado a objetos y el relacional, la primera consiste en organizar el programa alrededor de la base de datos (Programaci\u00f3n centrada en la base de datos), el segundo al contrario organiza la base de datos alrededor del programa (ORM - Object/Relational Mapping). \ufffd Programaci\u00f3n centrada en la base de datos En sus or\u00edgenes, la programaci\u00f3n contra bases de datos relacionales se ven\u00eda haciendo en lenguajes procedimentales tales como C y Cobol, y se realizaba escribiendo trozos de lenguaje SQL embebidos/empotrados dentro del c\u00f3digo fuente, lo que produc\u00eda una integraci\u00f3n entre la l\u00f3gica del c\u00f3digo y la interacci\u00f3n con la base de datos. Este tipo de programaci\u00f3n es com\u00fan entre lenguajes de scripting como PHP, Perl y en Ruby tambi\u00e9n es usado. Es considerado la concepci\u00f3n ideal para peque\u00f1as aplicaciones. Pero existe un problema: al mezclar la l\u00f3gica de negocio junto con los accesos a la base de datos se pueden causar problemas de mantenimiento del c\u00f3digo que pudieran traer graves repercusiones a la hora de agregar nuevos requerimientos o 56 modificar los ya existentes en el programa, teniendo duplicaci\u00f3n de c\u00f3digo no deseable en el mismo. El paradigma orientado a objetos nos ha ense\u00f1ado que la encapsulaci\u00f3n de los datos resuelve este problema. Al seguirlo, tendr\u00edamos un c\u00f3digo m\u00e1s mantenible, que a la hora de un cambio se realizar\u00eda la modificaci\u00f3n en un solo lugar del c\u00f3digo. Luego se llevo el principio a la programaci\u00f3n centrada en base de datos, encapsulando el acceso a la base de datos en clases. La aplicaci\u00f3n se comunicar\u00eda a la base de datos a trav\u00e9s de las clases. Pr\u00e1ctica que fue bautizada con el acr\u00f3nimo: ORM, del ingl\u00e9s Object/Relational Mapping o Asociaci\u00f3n Objeto/Relacional. \ufffd Asociaci\u00f3n Objeto/Relacional Las bibliotecas ORM se encuentran encargadas de asociar las tablas de las bases de datos a clases. Por ejemplo, si una base de datos tiene una tabla llamada productos, el programa va a tener una clase llamada Producto. Las filas en la tabla corresponder\u00edan a distintos objetos de la clase y los atributos ser\u00edan usados para obtener e introducir los valores de las columnas. Las clases de Rails proveen m\u00e9todos de operaciones sobre las tablas, por ejemplo, si se quiere buscar un producto espec\u00edfico en una tabla de productos. Simplemente se debe llamar a un m\u00e9todo propio de la clase que devuelve el objeto seg\u00fan su identificador o alg\u00fan atributo en especial. Si se busca por el atributo id, el c\u00f3digo ser\u00eda algo como: 57 C\u00f3digo ejemplo para buscar en la base de datos con id=1: producto = Producto.find(1) Objeto Clase funci\u00f3n identificador Tabla 9: Ejemplo ORM, b\u00fasqueda en base de datos por id. Tambi\u00e9n se tienen otras funciones que actualizan la base de datos (save, update). Probablemente la m\u00e1s usada es la funci\u00f3n save, que guarda un objeto en la base de datos, en el caso que sea un objeto previamente recuperado y no sea nuevo, simplemente actualiza su estado en la base de datos. El c\u00f3digo podr\u00eda ser algo como: C\u00f3digo ejemplo para guardar en la base de datos un producto: producto.descuento = 0.5 producto.save Objeto M\u00e9todo Tabla 10: Ejemplo ORM, guardar objeto en base de datos. ORM relaciona tablas con clases, filas con objetos y columnas con atributos de esos objetos. Generalmente en la biblioteca de ORM se especifica la configuraci\u00f3n para establecer la conexi\u00f3n entre la base de datos y las clases del programa. Active Record es la capa ORM (Object/Relational Mapping) que provee el framework Rails. Sigue al pie de la letra el est\u00e1ndar del modelo ORM: asociando 58 tablas con clases, filas con objetos y columnas con los atributos de los objetos como se reflej\u00f3 anteriormente. La diferencia con respecto a las otras bibliotecas de ORM es en la forma que es configurado. Active Record se basa en el principio de convenci\u00f3n sobre configuraci\u00f3n para lograr esta conexi\u00f3n para minimizar la cantidad de configuraci\u00f3n para los desarrolladores. En este caso la clase se asocia con la tabla teniendo el mismo nombre en plural como en el caso que se mencion\u00f3 de la tabla users y la clase User. Entonces la labor de Active Record es de conectar los objetos del negocio y las tablas de la base de datos. Lograr la persistencia del dominio donde la l\u00f3gica y la data sean envueltas en un solo sitio. Active Record es una implementaci\u00f3n del patr\u00f3n ORM y fue descrito por Fowler, tal como se rese\u00f1a en el sitio Web [Active Record (2006)]: \u201cUn objeto que envuelve una fila en una base de dato o una vista, encapsula el acceso a la base de datos y a\u00f1ade la l\u00f3gica del dominio en esa data\u201d. Este componente tambi\u00e9n brinda soporte de validaciones sofisticadas, inclusive, en una sola l\u00ednea de c\u00f3digo se puede extraer y aplicar el formato de errores o validar. En fin, tal como se plantea en [TDH (2006)], Active Record es la parte que describe el modelo en Rails de la arquitectura MVC. Active Record implementa lo que es llamado CRUD, siglas de (Create, Read/Retrieve, Update, Delete) en ingl\u00e9s, en espa\u00f1ol Crear, Obtener, Actualizar y Borrar. Acr\u00f3nimo usado para referirse a las funciones b\u00e1sicas de bases de datos o de la capa de persistencia en un sistema. En algunos textos, se utilizan las siglas ABM para lo mismo (Alta Baja Modificaci\u00f3n), obviando la operaci\u00f3n de Obtener.. 59 Action Pack La vista y el controlador son partes del MVC que se encuentran estrechamente unidas. El controlador provee data a la vista, y el controlador recibe eventos desde la p\u00e1gina generada por las vistas. Por esta causa el manejo de vistas y controladores en Rails dependen de un solo componente, Action Pack. A pesar que en Rails estas piezas (vista, controlador) se encuentran fusionados en un solo componente, se respeta la separaci\u00f3n que propone el patr\u00f3n Modelo Vista Controlador. \ufffd Vista En Rails la vista es responsable de generar la p\u00e1gina que ser\u00e1 mostrada en el navegador, es decir el c\u00f3digo HTML que usualmente va a ser desplegado. Usualmente se quiere incluir contenido din\u00e1mico creado por alguna acci\u00f3n del controlador. En Rails el contenido din\u00e1mico es generado por plantillas que vienen dadas por tres grandes vertientes. La m\u00e1s usada es llamada RHTML que consiste de un c\u00f3digo HTML con c\u00f3digo Ruby embebido. De est\u00e1 vertiente se han desarrollado diversas mejoras como HAML que simplifica el largo y enredado c\u00f3digo de la plantilla RHTML. Seg\u00fan la p\u00e1gina en Internet de [HAML (2007)], HAML es un plugin -los 60 cuales ser\u00e1n discutidos m\u00e1s adelante- para la generaci\u00f3n de vistas en las aplicaciones Rails y est\u00e1 basado en el principio \u201cEl Marcado debe ser bonito\u201d del ingl\u00e9s Markup should be beautiful. M\u00e1s no es simplemente por la belleza del c\u00f3digo, sino para ser usado en ambientes altamente productivos (\u201cLa belleza lo hace m\u00e1s r\u00e1pido\u201d). HAML brinda una soluci\u00f3n al problema del lento y repetitivo c\u00f3digo de las plantillas. La segunda plantilla es llamada RXML, que permite la construcci\u00f3n de documentos XML usando c\u00f3digo Ruby, siendo RJS la tercera plantilla permitiendo crear fragmentos JavaScript en el servidor para luego ser ejecutados en el navegador, est\u00e1 \u00faltima es muy usada para crear vistas din\u00e1micas con Ajax. Este soporte es muy flexible, pero en ocasiones puede violentar el patr\u00f3n MVC. Embebiendo c\u00f3digo en la vista se corre el riesgo de colocar c\u00f3digo que deber\u00eda estar en el modelo o el controlador, por lo que es labor del desarrollador prestar especial cuidado separando las labores de cada componente de la aplicaci\u00f3n. \ufffd Controlador El controlador es quien orquesta la l\u00f3gica de la aplicaci\u00f3n, coordinando la interacci\u00f3n entre los usuarios, las vistas y el modelo. No obstante, Rails maneja internamente la mayor\u00eda de esta interacci\u00f3n facilitando el desarrollo y el mantenimiento de los controladores. Los controladores presentan un conjunto de servicios importantes, dentro de los cuales conseguimos: 61 \u2022 Enrutar peticiones externas hacia acciones internas, manejando URL`s sencillos. \u2022 Acelerar el proceso de respuesta manejando cache. \u2022 Manejar las sesiones. Gemas Seg\u00fan el sitio Web [RubyGems Manual (2007)], una gema es una aplicaci\u00f3n Ruby empaquetada, o biblioteca de Ruby, que tiene un nombre y una versi\u00f3n definida. RubyGems es el nombre del proyecto que fue responsable del desarrollo de esta herramienta, su proceso de instalaci\u00f3n es muy sencillo y se resume simplemente en descargar el paquete de un sitio Web en Internet y ejecutar el comando Ruby setup.rb cuando se est\u00e1 parado en el directorio de la descarga. Las gemas son manejadas en el ordenador usando el comando gem, permitiendo instalar, desinstalar y hacer b\u00fasquedas de paquetes o bibliotecas local o remotamente. Dicha herramienta funciona como un gestor de paquetes para Ruby, proporcionando un formato est\u00e1ndar y auto-contenido (gem) para distribuir programas o bibliotecas en Ruby, dando facilidades para manejar la instalaci\u00f3n de los paquetes y su distribuci\u00f3n. Es, por tanto, equivalente al papel que juegan CPAN y PEAR en los lenguajes Perl y PHP, respectivamente. 62 Caracter\u00edsticas \u2022 Sencilla instalaci\u00f3n y desinstalaci\u00f3n de los paquetes y sus dependencias. \u2022 Manejo y control de paquetes locales. \u2022 Manejo de dependencias entre paquetes. \u2022 Buscar y listar paquetes locales y remotos. \u2022 Soporte para m\u00faltiples versiones de los paquetes instalados. \u2022 Interfaz Web para consultar la documentaci\u00f3n de las gemas instaladas. \u2022 Interfaz sencilla para la construcci\u00f3n de paquetes. \u2022 Servidor sencillo para la distribuci\u00f3n de paquetes. Comandos B\u00e1sicos En esta secci\u00f3n se mencionar\u00e1n los comandos m\u00e1s usados de la herramienta gem, dando una breve explicaci\u00f3n de su funcionamiento. 1. Cuando se quiere buscar o listar simplemente basta con ejecutar: Ejemplo para listar Gemas: Gem query --remote #Atajo: gem q \u2013R Tabla 11: Ejemplo Listar Gemas. Lo cual retornar\u00e1 una lista detallada de todas las gemas que se encuentran en el servidor remoto. Si se quiere depurar la lista y buscar una 63 gema espec\u00edfica basta simplemente con agregar la opci\u00f3n --name-matches y el nombre, ejemplo si queremos buscar un paquete llamado activerecord simplemente ejecutar\u00edamos: Ejemplo para buscar Gema: gem query --remote --name-matches activerecord #Atajo: gem q -R -n activerecord Tabla 12: Ejemplo Buscar Gema. Esto retornar\u00e1 una lista de las gemas que coinciden con el nombre que fue especificado. 2. Si se desea instalar una nueva gema, simplemente se debe ejecutar el comando install seguido del nombre de la gema, por ejemplo si deseamos instalar un paquete llamado progressbar se debe ejecutar: Ejemplo para instalar una Gema: gem install --remote progressbar #Atajo: gem i -R progressbar Tabla 13: Ejemplo Instalar Gema. Finalmente para desinstalar una gema simplemente se ejecuta uninstall y el nombre de la gema, por ejemplo si se quisiera desinstalar la gema instalada en el comando anterior se ejecutar\u00eda: 64 Ejemplo para desinstalar una Gema: gem uninstall progressbar Tabla 14: Ejemplo Desinstalar Gema. Plugins Seg\u00fan [Wikipedia (2007)], un plugin (del ingl\u00e9s plug-in: \u201cenchufar\u201d, tambi\u00e9n conocido como addin o addon) es una aplicaci\u00f3n inform\u00e1tica que le aporta una funci\u00f3n o utilidad espec\u00edfica a otra aplicaci\u00f3n. Se utilizan como una forma de expandir programas de manera modular, permitiendo la inclusi\u00f3n de nuevas funcionalidades sin afectar a las ya existentes ni complicar el desarrollo del programa principal. Seg\u00fan [TDH (2006)], en Rails un plugin es una extensi\u00f3n o modificaci\u00f3n del n\u00facleo del framework y proveen: \u2022 Una forma de compartir ideas entre los desarrolladores, sin afectar el c\u00f3digo base de cada proyecto. \u2022 Una arquitectura segmentada de manera que cada bloque de c\u00f3digo pueda ser arreglado o modificado en el momento m\u00e1s conveniente. \u2022 Una ayuda para el n\u00facleo de los desarrolladores, de modo que no est\u00e9n obligados a incluir cada una de las nuevas caracter\u00edsticas que d\u00eda a d\u00eda se van agregando en Rails, es decir, que al instalar Rails no se instalen todas las mejoras que existen sino que quede a potestad del programador si la necesita o no. 65 Comandos B\u00e1sicos 1. Para buscar los repositorios (donde residen plugins) basta con ejecutar en la ruta de un proyecto: Buscar un repositorio de plugins: Rails script/plugin discover Tabla 15: Ejemplo para buscar un repositorio (Plugin). Mientras que para Windows (en todos los casos) se invierte la barra y se agrega el prefijo Ruby, es decir: Buscar un repositorio de plugins en Windows: Ruby script\\plugin discover Tabla 16: Ejemplo para buscar un repositorio (Plugin/Windows). 2. Para agregar un repositorio de plugins, simplemente se ejecuta el comando source seguida de la URL donde se encuentra el repositorio, de esta forma: Agregar un repositorio de plugins: script/plugin source svn://Rubyforge.org/var/svn/expressica/plugins/ Tabla 17: Ejemplo para agregar un repositorio (Plugins). 66 3. Para quitar un repositorio: Quitar un repositorio de plugins: script/plugin unsource svn://Rubyforge.org/var/svn/expressica/plugins/ Tabla 18: Ejemplo para quitar un repositorio (Plugins). 4. Para instalar un plugin espec\u00edfico en un proyecto Rails, debemos navegar hasta la ruta del proyecto y ejecutar el comando install seguido del nombre del plugin (si se encuentra en un repositorio conocido) o del URL donde se aloja, ejemplo: Instalar un plugin en el proyecto: script/plugin install haml (si se tiene un repositorio con ese plugin incluido) \u00f3 script/plugin install svn://Rubyforge.org/var/svn/Telegraph/trunk (especificando el URL del plugin) Tabla 19 Ejemplo para Instalar un Plugin en el Proyecto. Se debe tener instalado subversion (SVN) y se debe cuidar el nombre del proyecto ya que si contiene espacios el proceso fallar\u00e1. Se puede encontrar una diversidad de plugins para Rails disponibles para instalar en un proyecto, de los m\u00e1s utilizados en la actualidad tenemos: 67 \ufffd acts_as_rateable, plugin utilizado para asociarle un ranking a los modelos de ActiveRecord, indicador que puede usarse para realizar b\u00fasquedas, ordenamientos, entre otros. Este plugin se encuentra disponible en la siguiente URL: http://rateableplugin.Rubyforge.org \ufffd Acts as Authenticated, plugin utilizado para agregar restricciones de acceso a la aplicaci\u00f3n de una manera sencilla. El plugin se encuentra disponible en la siguiente URL: http://technoweenie.stikipad.com/plugins/show/Acts+as+Authentic ated \ufffd RSpec on Rails, plugin que incluye las permite realizarle pruebas Spec al c\u00f3digo de la aplicaci\u00f3n. El plugin se encuentra disponible en la siguiente URL: http://rspec.Rubyforge.org Pruebas Seg\u00fan [Wikipedia (2007)], las pruebas de software son procesos que permiten verificar y revelar la calidad de una aplicaci\u00f3n, de modo de identificar fallas o errores de implementaci\u00f3n. Dichas Pruebas se integran dentro de las diferentes fases del ciclo de desarrollo del software. La calidad de un sistema es algo subjetivo que depende del contexto y del objeto que se pretenda conseguir. Para determinar dicho nivel de calidad se deben efectuar unas medidas o pruebas que permitan comprobar el grado de cumplimiento respecto a las especificaciones del sistema. 68 En el [RubyGems Manual (2007)] se plantea que las pruebas de software son colecciones de preguntas y escenarios que si devuelven un resultado consistente, se considera una aplicaci\u00f3n que se responde seg\u00fan lo esperado. Informalmente hablando, las pruebas se escriben para interrogar y tantear una aplicaci\u00f3n seg\u00fan un comportamiento esperado. Por ejemplo se podr\u00edan tener pruebas como: \u2022 Asegurar que un nombre tenga al menos 4 caracteres \u2022 Asegurar que el impuesto es del 9 % \u2022 Asegurar que al hacer una petici\u00f3n, el servidor despliegue la p\u00e1gina correcta La idea de codificar las pruebas comprende agilizar y automatizar el proceso de desarrollo, ya que cada vez que crece una aplicaci\u00f3n, probablemente se modifican clases existentes. Clases que funcionaban correctamente y quiz\u00e1 dejen de hacerlo. Anteriormente con las pruebas manuales se perder\u00eda mucho tiempo aplic\u00e1ndolas cada vez que haya una modificaci\u00f3n, pero con las pruebas automatizadas, simplemente se vuelven a ejecutar despu\u00e9s del cambio y verificar si se \u201crompi\u00f3\u201d algo en el camino. Existen diversos tipos de prueba, entre los cuales encontramos: \u2022 Pruebas unitarias \u2022 Pruebas funcionales \u2022 Pruebas de integraci\u00f3n 69 \u2022 Pruebas de validaci\u00f3n \u2022 Pruebas de sistema \u2022 Pruebas de caja blanca \u2022 Pruebas de caja negra \u2022 Pruebas de aceptaci\u00f3n En el sitio Web [A Guide to Testing the Rails (2007)] se explica que al probar un c\u00f3digo se tiene un porcentaje m\u00e1s elevado de certeza que se ha hecho un buen trabajo, brind\u00e1ndonos robustez, confiabilidad, minimizando los riesgos de fallos. \u00c9sta \u00faltima se considera una de las principales razones para aplicar pruebas al c\u00f3digo. Adem\u00e1s si se han codificado correctamente las pruebas, en cualquier iteraci\u00f3n del desarrollo podemos saber: \u2022 Qu\u00e9 procesos funcionan correctamente. \u2022 Qu\u00e9 procesos presentan errores. \u2022 Qu\u00e9 efecto tiene la agregaci\u00f3n de un nuevo m\u00f3dulo en la aplicaci\u00f3n. Otra ventaja que nos brinda la codificaci\u00f3n de pruebas es que a partir de all\u00ed se puede obtener la documentaci\u00f3n del funcionamiento b\u00e1sico de la aplicaci\u00f3n. Con estudiar los archivos de pruebas, se puede tener una idea del la labor que lleva un objeto en especial. Rails facilita la implementaci\u00f3n de ciertos tipos de pruebas como las pruebas unitarias, pruebas funcionales y de integraci\u00f3n. 70 La labor de las pruebas unitarias consiste en verificar el comportamiento de una clase a la vez, es decir que se encarga de probar cada m\u00e9todo que se encuentra dentro de la clase que se est\u00e1 probando. En Rails Test::Unit es el m\u00f3dulo m\u00e1s conocido encargado de realizar las pruebas unitarias. Una prueba funcional es una prueba basada en la ejecuci\u00f3n, revisi\u00f3n y retroalimentaci\u00f3n de las funcionalidades, de all\u00ed su nombre, previamente dise\u00f1adas para el software. Las pruebas funcionales se hacen mediante el dise\u00f1o de modelos de prueba que buscan evaluar cada una de las opciones con las que cuenta el paquete inform\u00e1tico. En Rails las pruebas funcionales son utilizadas para realizar pruebas de controladores, verificar las interacciones de estos con las clases del Modelo. Test::Unit provee soporte para este tipo de pruebas. Finalmente, est\u00e1n las pruebas integrales o pruebas de integraci\u00f3n, son aquellas que se realizan en el \u00e1mbito del desarrollo de software una vez que se han aprobado todas las pruebas unitarias de un m\u00f3dulo. \u00danicamente se refieren a la prueba o pruebas de todos los elementos unitarios que componen un proceso, hecha en conjunto, de una sola vez. En Rails las pruebas de integraci\u00f3n fueron incluidas en la versi\u00f3n 1.1, pues su prop\u00f3sito recae en la verificaci\u00f3n de las interacciones entre distintas acciones de la aplicaci\u00f3n, a trav\u00e9s de todos los controladores del sistema. Existe una t\u00e9cnica de programaci\u00f3n orientada a pruebas llamada Test-Driven Development (TDD por sus siglas en ingl\u00e9s), que tiene su fundamento en la realizaci\u00f3n de los casos de pruebas que cubrir\u00e1n las nuevas funcionalidades. Dichas 71 pruebas son codificadas al principio, escribiendo el c\u00f3digo del requerimiento posterior a las pruebas. Esto garantiza que al finalizar la codificaci\u00f3n el requerimiento, estos pasen las pruebas propuestas, tal como se se\u00f1ala en el sitio [Web Wikipedia (2007)]. En la actualidad se encuentra en auge una t\u00e9cnica que se considera una evoluci\u00f3n sobre el TDD, llamada Behavior Driven Development (BDD por sus siglas en ingl\u00e9s). Seg\u00fan la p\u00e1gina en Internet [Behaviour Driven Development (2007)], BDD consiste en el desarrollo de software realizando preguntas sobre el comportamiento de una aplicaci\u00f3n antes y durante el proceso de desarrollo. El BDD direcciona los requerimientos y las especificaciones en un modo m\u00e1s textual, realizando preguntas como: \u201c\u00bfQu\u00e9 deber\u00eda llevar a cabo esta aplicaci\u00f3n?\u201d o \u201c\u00bfQu\u00e9 labor deber\u00eda realizar este modulo?\u201d los desarrolladores son capaces de identificar fallos en su entendimiento del dominio del problema. Gracias a la t\u00e9cnica antes descrita, al enfocarnos en el comportamiento de las aplicaciones, se intenta crear un vocabulario com\u00fan entre los integrantes de las distintas disciplinas en el proyecto. Entonces, busca minimizar los malos entendidos entre los expertos del dominio del problema y los expertos en tecnolog\u00eda tratando de resolver los requerimientos con una terminolog\u00eda clara y consistente. En el sitio Web [Behaviour Driven Development (2007)] se enfatiza que para verificar el comportamiento de una aplicaci\u00f3n durante y despu\u00e9s del proceso de desarrollo el c\u00f3digo es sometido a pruebas de comportamiento. Dichas pruebas deber\u00edan responder e ilustrar el funcionamiento de la aplicaci\u00f3n. 72 Por su parte, [Astels (2007)] destaca que la t\u00e9cnica contempla la codificaci\u00f3n de especificaciones que describen el comportamiento en una forma clara, concisa, ejecutable y sin ambig\u00fcedades. Entonces en vez de escribir pruebas se plasman especificaciones sobre como el c\u00f3digo deber\u00eda comportarse. El sitio Web [RSpec Doc (2007)], refiere que en Ruby se puede implementar la t\u00e9cnica de la cual se viene hablando (BDD) de una forma sencilla, utilizando el framework Rspec, herramienta que le provee al programador un lenguaje espec\u00edfico de dominio para describir el comportamiento de un c\u00f3digo Ruby a trav\u00e9s de ejemplos ejecutables que sirven de gu\u00eda en el proceso de desarrollo, documentaci\u00f3n y pruebas de la aplicaci\u00f3n. Esta herramienta tambi\u00e9n se puede incluir como un plugin en Rails para facilitar el uso a los programadores que quieren empezar a utilizarla. Un ejemplo de lo antes descrito es suponer que se est\u00e1 en conversaci\u00f3n con un cliente sobre un desarrollo para un banco, donde un trozo de conversaci\u00f3n podr\u00eda ser: \u2022 Desarrollador: Describir una cuenta cuando es creada por primera vez. \u2022 Cliente: Deber\u00eda tener saldo de 0 BsF. Traducido en Rspec podr\u00eda ser algo como: Ejemplo de prueba RSPEC: describe Cuenta, \" cuando es creada por primera vez\" do it \"deber\u00eda tener saldo de 0 BsF\" do ... end end Tabla 20: Ejemplo de C\u00f3digo RSPEC. Con este trozo de c\u00f3digo se busca describir como se comporta una cuenta cuando se crea por primera vez en el sistema. El m\u00e9todo devuelve un objeto de tipo 73 examplegroup, el cual no es m\u00e1s que un conjunto de ejemplos para simular un comportamiento particular de un sistema. En un ejemplo m\u00e1s completo se podr\u00eda tener: Ejemplo completo de prueba RSPEC: describe Cuenta, \" cuando es creada por primera vez\" do before do @cuenta = Cuenta.new end it \"deber\u00eda tener saldo de 0 BsF\" do @cuenta.saldo.should eql(0) end after do @cuenta = nil end end Tabla 21: Ejemplo 2 de C\u00f3digo RSPEC. En el ejemplo el m\u00e9todo \u201cit\u201d devuelve un objeto de tipo ejemplo que representa un ejemplo del comportamiento que se desea describir. Mientras que los m\u00e9todos \u201cbefore\u201d y \u201cafter\u201d son utilizados para inicializar el estado de ciertos objetos antes que cada ejemplo sea ejecutado y liberar cualquier recurso despu\u00e9s que cada ejemplo sea ejecutado, respectivamente. Cuando se ejecuta la especificaci\u00f3n, se define el m\u00e9todo should, el cual es encargado de la comparaci\u00f3n de los objetos del sistema y le da sentido a la herramienta. \u00c9ste m\u00e9todo junto a su opuesto (should_not), pueden tomar como par\u00e1metro una expresi\u00f3n a evaluar, llamada Expression Matcher. Durante la ejecuci\u00f3n de esta funci\u00f3n se realiza un llamado al m\u00e9todo \u201cmatches?\u201d, que es qui\u00e9n realiza la comparaci\u00f3n a bajo nivel. Si este \u00faltimo devuelve verdadero, el ejemplo pasa y la ejecuci\u00f3n contin\u00faa, pero si devuelve falso, el ejemplo falla, especificando un 74 mensaje de error retornado por matcher.failure_message. En el sitio Web [Rspec (2007)] se explica que Rspec tambi\u00e9n brinda soporte para la creaci\u00f3n de Mocks y/o Stubs, objetos que son utilizados para simular el comportamiento de cualquier objeto real que pudiera interactuar en un momento dado con la aplicaci\u00f3n. Estos objetos son muy utilizados por los desarrolladores cuando la aplicaci\u00f3n interact\u00faa con un sistema externo que no se tiene a disposici\u00f3n, pero su comportamiento es conocido. Los Mocks y los Stubs son similares, pero hay una diferencia sem\u00e1ntica a la hora de su creaci\u00f3n. Conectividad Rails - Asterisk Adhearsion Adhearsion es un framework que fue escrito en Ruby, de c\u00f3digo abierto, cuyo prop\u00f3sito reside en facilitar la uni\u00f3n o conexi\u00f3n entre distintas tecnolog\u00edas. Dicho framework integra uno de los principales PBXs de la actualidad como lo es Asterisk, con Ruby a trav\u00e9s de las interfaces AMI y AGI como se explic\u00f3 en el segundo cap\u00edtulo, especialmente orientado a la escritura de aplicaciones con la interfaz AGI. Este framework fue dise\u00f1ado para entender de manera sencilla los elementos de VoIP, mejor\u00e1ndolos e integr\u00e1ndolos en una soluci\u00f3n coherente. Alguna de las tareas que son mejoradas con el uso del framework son: \u2022 Escribir instrucciones que procesan llamadas \u2022 Funcionalidades VoIP 75 \u2022 Colaboraci\u00f3n con tecnolog\u00edas m\u00e1s all\u00e1 de VoIP \u2022 Integraci\u00f3n de bases de datos para aplicaciones de VoIP \u2022 Integraci\u00f3n con funcionalidades internas de Asterisk Adhearsion facilita a los programadores el dise\u00f1o e implementaci\u00f3n de aplicaciones a\u00fan sin haber tenido experiencia trabajando con tecnolog\u00edas de VoIP, con un uso intuitivo y permitiendo descargar alguna soluci\u00f3n pre-hecha e implantarla. Con la arquitectura extendida del framework, las funcionalidades de VoIP se pueden masificar con facilidad por su sencillez en la implementaci\u00f3n. Adhearsion posee una cantidad de extensiones que pueden ser usadas de manera sencilla, brindando funcionalidades adicionales como integraci\u00f3n con mensajer\u00eda instant\u00e1nea (Jabber/XMPP), en servidor para controlar el PBX de forma remota, entre otras. Todo esto en cualquier parte del framework, ya que Adhearsion \u201cadhiere\u201d estas tecnolog\u00edas entre s\u00ed, que comprende una de las funcionalidades fundamentales de Adhearsion, inclusive es sencillo integrar extensiones propias del programador. Adem\u00e1s el framework incluye un amplio conjunto de caracter\u00edsticas, funcionalidades m\u00e1s implementadas por cada una de las aplicaciones de esta \u00e1rea. Una de las grandes ventajas de Adhearsion, es su integraci\u00f3n y asociaci\u00f3n con las bases de datos relacionales, ya que se basa en la relaci\u00f3n de objetos y base de datos que fue desarrollado para Ruby on Rails. Vali\u00e9ndose de esto, es muy sencillo integrar VoIP con una base de datos, donde una tabla en la base de datos llamada \u201cusuarios\u201d, se asocia con el objeto \u201cUsuario\u201d y cada columna de la tabla es una propiedad representativa del objeto, tal como se coment\u00f3 en el cap\u00edtulo anterior. 76 Tambi\u00e9n se basa en el mismo principio que Rails al aplicar DRY (Don't Repeat Yourself), mencionado en el cap\u00edtulo anterior. Adhearsion emplea un lenguaje de dominio espec\u00edfico orientado hacia VoIP, sin dejar de ser c\u00f3digo Ruby completamente v\u00e1lido. Por ejemplo en un plan de llamado se tiene acceso a variables preestablecidas tales como \u201cextension\u201d o \u201ccallerid\u201d (correspondientes a la extensi\u00f3n e identificador de llamada respectivamente) para cada llamada. Para acceder a las variables de bajo nivel propias de Asterisk, se tiene el objeto \u201cPBX\u201d, que envuelve la idea f\u00edsica del PBX. Entonces por ejemplo se puede hacer llamados a variables propias de Asterisk como lo es sip_users de esta forma: PBX.sip_users, que retorna informaci\u00f3n desde Asterisk. Esta comprende una de las grandes virtudes de este framework, ya que en el ejemplo ni siquiera se necesitaba informaci\u00f3n del uso apropiado de la interfaz con Asterisk (AMI), explicada en cap\u00edtulos anteriores, sino que lo hace transparentemente para el programador, de forma de facilitarle la labor que se lleva a cabo a bajo nivel. Al igual que Ruby, Adhearsion buscan mejorar la productividad de los programadores permiti\u00e9ndole realizar aplicaciones de manera r\u00e1pida y sencilla. Actualmente Adhearsion es un software en versi\u00f3n beta, lo que en parte constituye una de sus desventajas, puesto que para llevar una aplicaci\u00f3n a producci\u00f3n con Adhearsion, se deben hacer un conjunto adecuado de pruebas, pero el proyecto tiene su sistema de reporte de errores, lo que promueve que cada d\u00eda sea m\u00e1s robusto y eficaz, incentivando al usuario a reportar y ayudar con errores que pudiera tener el framework. 77 Instalaci\u00f3n y Uso Al igual que la mayor\u00eda de los otros proyectos de Ruby, Adhearsion usa el manejador de paquetes RubyGems, esto reduce el proceso de instalaci\u00f3n del framework a la ejecuci\u00f3n de un simple comando gem install, simplificando el tradicional des-empaquetamiento, posibilidad que se puede usar si no se instala RubyGems. Entonces se ejecutar\u00eda: Instalaci\u00f3n Adhearsion: gem install Adhearsion --include-dependencies Tabla 22: Instalaci\u00f3n Adhearsion. Con este comando adem\u00e1s de la instalaci\u00f3n del framework , RubyGems crea el comando ahn, comando de Adhearsion que permite crear nuevos proyectos para Adhearsion. Tambi\u00e9n da la oportunidad de ejecutar el framework, instalar extensiones para Adhearsion, leer la documentaci\u00f3n, entre otros. Para entender un poco m\u00e1s el funcionamiento de la integraci\u00f3n Asterisk- Adhearsion, cuando llega a una llamada al servidor Asterisk, \u00e9ste act\u00faa como una especie de n\u00facleo a bajo nivel para la llamada que transfiere el flujo a Adhearsion que se encarga de la l\u00f3gica que se le va a aplicar a la llamada, entre las acciones que se pueden tomas tenemos: transferir la llamada, reproducir un mensaje, persistir informaci\u00f3n, entre otra gama de posibilidades. Esto lo logra estableciendo desde Asterisk una conexi\u00f3n TCP (por la cual se comunican) a un proceso de Adhearsion que ejecuta comandos y devuelve una respuesta con la acci\u00f3n. 78 Para establecer la comunicaci\u00f3n entre Asterisk y Adhearsion solo hace falta un m\u00ednimo de configuraci\u00f3n en Asterisk, una entrada en el archivo de configuraci\u00f3n de las extensiones de usuarios, llamado extensions.conf. Por ejemplos si los usuarios se encuentran asociados con el contexto por defecto llamado \u201cinternal\u201d, se modificar\u00eda de la siguiente forma: Para la comunicaci\u00f3n Adhearsion y Asterisk: [internal] exten => _X.,1,AGI(agi://192.168.1.1) Tabla 23: Comunicaci\u00f3n Adhearsion/Asterisk. \u2022 La primera l\u00ednea indica el contexto, en este caso llamado \u201cinternal\u201d. \u2022 En la l\u00ednea siguiente encontramos la instrucci\u00f3n \u201cexten=>\u201d, comando requerido como prefijo a cada instrucci\u00f3n de llamada en enxtensions.conf. \u2022 Los caracteres \u201c_X.\u201d comprenden la expresi\u00f3n que denota la secuencia de n\u00fameros a ser capturados. Donde el car\u00e1cter \u201c_\u201d indica que es un patr\u00f3n en vez de ser un conjunto est\u00e1tico y la \u201cX\u201d representa cualquier n\u00famero (0-9) mientras que el punto (\u201c.\u201d) indica que cualquier cantidad de repeticiones. Lo que en conjunto representa \u201cel patr\u00f3n de cualquier n\u00famero con cualquier cantidad de repeticiones\u201d. Entonces en este contexto cualquier n\u00famero que sea procesado es redireccionado a Adhearsion. \u2022 Despu\u00e9s de la coma aparece un n\u00famero que indica la prioridad de la instrucci\u00f3n. \u2022 Finalmente, despu\u00e9s de la segunda coma, tenemos la instrucci\u00f3n que se va a ejecutar que en este caso tenemos el comando AGI con un par\u00e1metro 79 \u201cagi://192.168.1.1\u201d indicando que otra aplicaci\u00f3n va a procesar la llamada, y el par\u00e1metro es el URI que le indica a Asterisk que busque la IP especificada para ejecutar la aplicaci\u00f3n, por lo que se debe colocar la IP donde se encuentra Adhearsion en ejecuci\u00f3n (No es recomendado usar nombres de m\u00e1quinas sino su IP). El siguiente paso es crear un nuevo proyecto de Adhearsion, por ejemplo: Nuevo Proyecto de Adhearsion: ahn create prueba Tabla 24: Nuevo Proyecto Adhearsion. Esto crear\u00e1 un nuevo proyecto que tendr\u00e1 una estructura como: config/ extensions.rb helpers/ LICENSE logs/ Rakefile \u2022 La carpeta config es donde reside la configuraci\u00f3n de la aplicaci\u00f3n Adhearsion, incluyendo cualquier extensi\u00f3n del framework que se haya instalado. \u2022 El archivo extensions.rb es donde residen los planes de marcado (\u201cdialplans\u201d), m\u00e1s adelante se ver\u00e1 un ejemplo. \u2022 La carpeta helpers contiene todas las extensiones instaladas para la aplicaci\u00f3n espec\u00edfica en la que se haya instalado. Dichas extensiones agregan funcionalidades \u00fatiles a la aplicaci\u00f3n, pueden ser instaladas y/o desintaladas. El c\u00f3digo fuente se encuentra en esta ruta en caso que se 80 necesiten modificar. \u2022 El archivo LICENSE contiene una copia de la licencia (GPL v2) por la cual se rige Adhearsion. \u2022 La carpeta logs contiene la bit\u00e1cora de la aplicaci\u00f3n. \u2022 Finalmente el Rakefile es el archivo del \u201crake\u201d. Rake es un comando Ruby que automatiza ciertas tareas. Para arrancar la aplicaci\u00f3n Adhearsion solo se debe ejecutar el comando ahn start con la ruta donde se encuenta el proyecto, por ejemplo: Nuevo Proyecto de Adhearsion: ahn start /prueba Tabla 25: Arrancar Adhearsion. Dialplans Finalmente se va a discutir sobre el c\u00f3digo en si que se ejecuta cuando la aplicaci\u00f3n es puesta en marcha y es pasado el procesamiento a Adhearsion. Como se coment\u00f3, el c\u00f3digo va ubicado en el archivo extensions.rb que se encuentra en la ruta config en el proyecto de Adhearsion. Tradicionalmente los programadores pod\u00edan enrutar llamadas en Asterisk de dos formas, la primera modificando directamente el archivo de configuraci\u00f3n de Asterisk extensions.conf o escribiendo una aplicaci\u00f3n aparte en un lenguaje de 81 scripting y usar el AGI para la comunicaci\u00f3n. Un ejemplo sencillo de un plan de marcado o dialplan en Adhearsion podr\u00eda verse algo como: Ejemplo de dialplan de Adhearsion: # File extensions.rb internal { case extension when 101...200 employee = User.find_by_extension extension dial employee voicemail when 888 play weather_report(\"Dallas Texas\") end } Tabla 26: Ejemplo Dialplan de Adhearsion. El c\u00f3digo esta escrito en lenguaje Ruby. Los fundamentos de Ruby permiten la modificaci\u00f3n en el funcionamiento del lenguaje, convirti\u00e9ndose en un lenguaje particular seg\u00fan la necesidad, sin perder los beneficios del lenguaje Base (Ruby). En el ejemplo mostrado anteriormente Adhearsion relaciona directamente por convenci\u00f3n el flujo del contexto llamado \u201cinternal\u201d que como se explic\u00f3 debe haber sido configurado en el archivo extensions.conf de Asterisk. Estudiando el c\u00f3digo notamos la flexibilidad de Ruby con respecto a los rangos ya que se tiene un case con una condici\u00f3n de un rango entre 101 y 200 sin complicaciones. En la pr\u00f3xima l\u00ednea se nota la convenci\u00f3n con respecto a los objetos de la base de datos, ejecutando una consulta normal. Infiriendo que hay una colecci\u00f3n de usuarios y extensiones. 82 Tambi\u00e9n se observa la sencillez, que es uno de los factores de la creaci\u00f3n de este framework. Finalmente tenemos una gama de funcionalidades de Adhearsion que nos simplifica el trabajo, como lo son la funci\u00f3n dial para realizar una llamada a una extensi\u00f3n, voicemail para activar el contestador autom\u00e1tico y play para reproducir sonidos. Existen otros m\u00e9todos que se pueden usar a la hora de codificar un dialplan. Telegraph Telegraph es un plugin de Rails de c\u00f3digo abierto, escrito en Ruby que permite la utilizaci\u00f3n de forma sencilla de las interfaces AGI y AMI de Asterisk. Funciona como un puente entre Rails y Asterisk, aprovechando la sencillez de Rails combin\u00e1ndolo con voz sobre IP (VoIP). Telegraph extiende el API de Asterisk, permitiendo el desarrollo de aplicaciones Web basadas VoIP de una forma r\u00e1pida y sencilla al estilo de Rails usando el patr\u00f3n MVC. Entre sus caracter\u00edsticas m\u00e1s importantes tenemos: \u2022 La integraci\u00f3n de funciones de la interfaz AGI en un controlador cualquiera de Rails. \u2022 Un modelo para el acceso a la interfaz AMI de Asterisk con funciones sencillas. \u2022 Soporte para recibir los eventos AMI. \u2022 Servidor proxy AMI que se comunica directamente con Asterisk. 83 Las aplicaciones hechas en Telegraph son sencillas de desarrollar, producir y mantener adem\u00e1s de ser hechas en una forma robusta y escalable, ya que son realizadas bajo la filosof\u00eda de Rails. Telegraph maneja los comandos AMI de la aplicaci\u00f3n a trav\u00e9s de un proceso independiente (Drb), biblioteca Ruby utilizada para invocar objetos remotos, tal como se ejecutan en Java RMI y/o CORBA. Telegraph fue inspirado en centros de llamados distribuidos complejos, que existen realmente y su c\u00f3digo es basado en un proyecto llamado RAGI y otros proyectos Ruby-AMI. Instalaci\u00f3n y Uso La instalaci\u00f3n es muy simple, ya que por ser un plugin lo \u00fanico que se necesita es instalarlo en un proyecto Rails. Tal como se explic\u00f3 en el cap\u00edtulo anterior, basta con ejecutar un comando en la ruta del proyecto al que se quiere agregar, por ejemplo: Instalaci\u00f3n de Telegraph: script/plugin install svn://Rubyforge.org/var/svn/Telegraph/trunk Tabla 27: Instalaci\u00f3n Telegraph. Luego se debe definir que funcionalidad de Telegraph se va a implantar, como ya se coment\u00f3 Telegraph soporta las dos grandes vertientes de comunicaci\u00f3n de Asterisk con aplicaciones externas, que son las interfaces AGI y AMI, adem\u00e1s brinda 84 soporte para los AMI Eventos o eventos AMI generados por Asterisk. \ufffd AGI Al igual que Adhearsion brinda soporte para la integraci\u00f3n con Asterisk a trav\u00e9s de la interfaz AGI de manera sencilla, de modo de crear una aplicaci\u00f3n donde se quiere controlar el flujo de llamadas entrantes (IVR). Pero en vez de escribir largos dialplans, la meta es desarrollar aplicaciones similares a las aplicaciones Web basadas en MVC, de modo que al momento de redireccionar el flujo de una llamada, con Telegraph direccionamos de un controlador a una \u201cvoz\u201d, que es la analog\u00eda de una \u201cvista\u201d en el MVC tal como lo hacemos en una aplicaci\u00f3n Web. De esta forma se puede integrar en el mismo c\u00f3digo la l\u00f3gica de la aplicaci\u00f3n Web y la l\u00f3gica de la aplicaci\u00f3n basada en voz. La petici\u00f3n AGI se comporta igual que las peticiones est\u00e1ndares de Rails, se diferencian cuando se va a mostrar la \u201cvista\u201d, ya que se debe capturar un objeto especial de voz (tipo MIME) que usa el API de Telegraph para mostrar la data aprovechando las ventajas de Rails durante el camino. Para lograr la comunicaci\u00f3n entre Asterisk y la aplicaci\u00f3n, se realiza un m\u00ednimo de configuraci\u00f3n en Asterisk de modo que env\u00ede la petici\u00f3n a trav\u00e9s de la interfaz. De modo que se agrega una entrada en el archivo de configuraci\u00f3n extensions.conf de Asterisk seg\u00fan el contexto, al igual que en el ejemplo con Adhearsion, supongamos que existe un contexto llamado \u201cinternal\u201d, debemos colocar algo como: 85 Comunicaci\u00f3n de Telegraph y Asterisk a trav\u00e9s de AGI: [internal] exten => _X.,1,AGI(agi://192.168.1.1/controlador/index) Tabla 28: Comunicaci\u00f3n Telegraph/Asterisk, AGI. El significado de las entradas son exactamente los mismos explicados en la secci\u00f3n anterior, por lo que se pasar\u00e1 directamente a un ejemplo pr\u00e1ctico de la manipulaci\u00f3n del flujo de una llamada, supongamos que queremos redireccionar una llamada a un archivo de sonido llamado \u201catender\u201d, simplemente se debe tener un controlador parecido al siguiente c\u00f3digo Rails: Ejemplo dialplan de Telegraph AGI: class ControladorController < ApplicationController def index respond_to do |ayuda| ayuda.html { render } ayuda.voice { render_voice do |voice| voice.play_sound \"atender\" end } end end end ) Tabla 29: Ejemplo Dialplan Telegraph AGI En principio se instancia el bloque respond_to para capturar el objeto de voz (tipo MIME), luego a\u00f1adimos un \u201chelper\u201d para la voz (ayuda.voz). Seguidamente se llama al la funci\u00f3n render_voice propia de Telegraph, junto a un bloque. Dentro de ese bloque insertamos el c\u00f3digo de la \u201cvista\u201d o la \u201cvoz\u201d, usando el lenguaje espec\u00edfico de dominio de Telegraph, en este caso el bloque simplemente llama a la 86 funci\u00f3n \u201cplay\u201d, para reproducir un archivo. \ufffd AMI Esta interfaz se debe usar cuando se quiere entablar una comunicaci\u00f3n as\u00edncrona con Asterisk, envi\u00e1ndole peticiones de acciones a realizar en Asterisk, por ejemplo iniciar una llamada saliente, conocer el estado de las llamadas en curso y otra gama de peticiones que se pueden realizar. AMI (Asterisk Manager Interface) como se mencion\u00f3 en cap\u00edtulos anteriores es una de las formas que tiene Asterisk de interacci\u00f3n con aplicaciones externas. Interfaz que permite realizar distinto tipo de consultas y comandos, tales como: \u2022 Consultar el estatus de alg\u00fan dispositivo. \u2022 Modificaci\u00f3n de par\u00e1metros en una llamada saliente. \u2022 Eventos de estatus hacia las aplicaciones, soportado en Telegraph por los eventos AMI. El API que provee el plugin es robusto, escondiendo la complejidad de bajo nivel de enviar, recibir y \u201cparsear\u201d m\u00e9todos AMI tras un modelo de uso sencillo escrito en Ruby. Los m\u00e9todos AMI realizan cuatro trabajos fundamentales: obtener informaci\u00f3n, crear objetos, actualizar objetos y borrar o destruir objetos. Como se mencion\u00f3 en el cap\u00edtulo anterior estas son las cuatro acciones b\u00e1sicas de los registros (CRUD). El modelo es accesible en cualquier parte de la aplicaci\u00f3n Web. 87 Para empezar a usar la interfaz primero se debe crear el modelo del que se ha venido hablando, para eso se deber\u00eda ejecutar en la ruta del proyecto el siguiente comando: Empezando con Telegraph AMI: script/generate ami_model MiModelo Tabla 30: Empezando Telegraph/AMI. En el ejemplo script/generate es un comando para la generaci\u00f3n autom\u00e1tica de c\u00f3digo en Rails, con ami_model se especifica que se quiere generar el modelo AMI y finalmente \u201cMiModelo\u201d que es el nombre del modelo a generar. Luego se le debe indicar al proyecto de Rails que se debe conectar con Asterisk en el archivo de configuraci\u00f3n del proyecto confit/enviroment.rb, se debe colocar una entrada como: Conexi\u00f3n de Telegraph y Rails AMI: Telegraph::AMIManager.establish_connection!(:host=> '192.168.1.1', :username=>'usuario', :secret=>'contrase\u00f1a') Tabla 31: Conexi\u00f3n Telegraph/Rails AMI. Para llevar a cabo la acci\u00f3n explicada se debe tener configurado en Asterisk un nombre de usuario y una contrase\u00f1a en el archivo manager.conf tal como se ilustr\u00f3 en el cap\u00edtulo de Asterisk. En este ejemplo Telegraph::AMIManager.establish_connection! es la funci\u00f3n de Telegraph encargada de realizar la conexi\u00f3n, seguida de una lista de par\u00e1metros. El primero es host, que indica el nombre o IP de la m\u00e1quina a la que se quiere conectar, 88 luego se especifica el nombre de usuario y la contrase\u00f1a (username y secret respectivamente) que corresponden a las entradas que se deben tener en el manager.conf de Asterisk. Finalmente se debe ejecutar el comando que inicia el servidor que funciona como puente entre la aplicaci\u00f3n Rails y Asterisk: Iniciar servidor AMI en Telegraph: script/ami_server Tabla 32: Iniciar Servidor AMI/Telegraph. En este momento ya se tiene conectado Rails y Asterisk a trav\u00e9s de la interfaz AMI. Como se coment\u00f3 anteriormente, las funciones AMI de Telegraph se basan en el concepto CRUD al igual que Rails, entonces la invocaci\u00f3n de m\u00e9todos es similar a los de Rails, usando el modelo AMI. Luego se especifica una lista de par\u00e1metros, siendo el primero la operaci\u00f3n que se quiere realizar en Asterisk, por ejemplo: Ejemplo comandos de Telegraph AMI: estatus = MiModelo.find(:sip_peer, :peer=>'SIP/usuario_prueba') Lista_estatus = MiModelo.find(:all_sip_peers) MiModelo.create(:call,:channel=>'SIP/usuario_prueba', :context=>'internal', :exten => 'xxxx', :priority=>1) Tabla 33: Ejemplo Comandos Telegraph AMI. En estos ejemplos se puede ver que comprende un modelo est\u00e1tico con el mismo nombre con el que fue generado, seguido de un m\u00e9todo de la clase con su lista de par\u00e1metros. En el primero se llama a la funci\u00f3n find (obtener), especificando como operaci\u00f3n sip_show_peer de AMI y como \u00faltimo par\u00e1metro sobre quien se desea 89 hacer la consulta. El segundo ejemplo solo tiene 1 par\u00e1metro que indica que se va a llamar a una operaci\u00f3n de AMI sin par\u00e1metros (all_sip_peers), esta operaci\u00f3n devuelve una lista de todas las extensiones existentes en Asterisk. En el \u00faltimo ejemplo se llama a la funci\u00f3n create (crear) y como primer par\u00e1metro call especificando un canal (channel), contexto (context), extensi\u00f3n (exten) y prioridad (priority), esta funci\u00f3n de Asterisk inicia una llamada nueva por el canal dado usando el contexto y la prioridad especificados hacia un n\u00famero que recibe en el par\u00e1metro exten. Las funciones AMI dependiendo del tipo retornan propiedades o eventos, las propiedades se pueden acceder directamente, mientas que los eventos vienen en un arreglo llamado events. En base a los ejemplos anteriores es v\u00e1lido: Ejemplo par\u00e1metros de funciones AMI en Telegraph: estatus.sip_user_agent Lista_estatus.events.each[:status] Tabla 34: Ejemplo Funciones AMI Telegraph. A continuaci\u00f3n se va a presentar una lista de las funciones AMI m\u00e1s usadas en Telegraph junto con sus par\u00e1metros y la funci\u00f3n que es activada en Asterisk Find: Operaci\u00f3n Telegraph Par\u00e1metros Funci\u00f3n AMI :extension_state :context, :exten extension_state 90 :variable :channel, :variable get_variable :all_iax_peers - iax_peers :queue - queue_status :sip_peer :peer sip_show_peer :all_sip_peers - sip_peers :status :channel status Tabla 35: M\u00e9todos Telegraph para consultas. Update: Operaci\u00f3n Telegraph Par\u00e1metros Funci\u00f3n AMI :redirect :channel, :context, :exten, :priority redirect :variable :channel, :variable, :value setvar Tabla 36: M\u00e9todos Telegraph para actualizaciones. Create: Operaci\u00f3n Telegraph Par\u00e1metros Funci\u00f3n AMI :monitor :channel, :file, :format, :mix monitor :call :channel, :context, :exten, :priority, :async (Entre otros opcionales) orginiate Tabla 37: M\u00e9todos Telegraph para crear. Destroy: 91 Operaci\u00f3n Telegraph Par\u00e1metros Funci\u00f3n AMI :monitor :channel stopmonitor :call :channel Hangup Tabla 38: M\u00e9todos Telegraph para borrar. \ufffd Eventos AMI Los eventos AMI son los distintos cambios de estado que se env\u00edan a trav\u00e9s de la interfaz AMI. En Telegraph se puede configurar un proceso Rails espec\u00edfico que escucha dichos eventos para realizar distintas acciones. En el plugin, la interfaz para eventos AMI es usada cuando se quiere ejecutar una l\u00f3gica espec\u00edfica cuando se produce un cambio por el PBX, eventos tales como el ingreso de un nuevo dispositivo al sistema, una nueva llamada exitosa, entre otros. Los eventos AMI no son recibidos directamente en la propia aplicaci\u00f3n Web. Al ejecutar el comando de generaci\u00f3n autom\u00e1tica de c\u00f3digo para los eventos AMI en Telegraph, se crea una carpeta dentro de la ruta del proyecto con un archivo llamado ami_logic.rb. Dicho comando se debe ejecutar en la ruta del proyecto Rails, tal como: 92 Empezando con Telegraph Eventos AMI: script/generate ami_logic Tabla 39: Empezando Telegraph Eventos AMI. Despu\u00e9s de la ejecuci\u00f3n se crear\u00e1 la carpeta \u201capp/ami_logic\u201d. Entonces al momento que Asterisk env\u00ede un evento, Telegraph escuchar\u00e1 y ejecutar\u00e1 un m\u00e9todo con el mismo nombre que se encuentre dentro del archivo app/ami_logic.rb junto con cualquier par\u00e1metro que acarree de Asterisk. Estos \u00faltimos son colocados en una lista de par\u00e1metros que pueden ser accedidos en dichos m\u00e9todos. Para iniciar el proceso encargado de escuchar los eventos enviados por Asterisk y asociarlo con el m\u00e9todo correspondiente en el ami_logic, se debe ejecutar: Iniciar servidor de Eventos AMI en Telegraph: script/ami_events Tabla 40: Iniciar Servidor Eventos AMI Telegraph. En el siguiente ejemplo del archivo ami_logic.rb podemos encontrar los eventos de mayor utilidad: Funciones que capturan Eventos AMI en Telegraph: class AmiLogic < Telegraph::AMIHandler def peer_status # M\u00e9todo llamado cuando el estatus de un dispositivo # registrado en el sistema cambia # Los par\u00e1metros son :peer, :peer_status # El par\u00e1metro peer_status puede tener uno de los # siguientes valores: # (Registered, Unregistered, Reachable, Unreachable) estado = params[:peer_status] quien = params[:peer] p \u201cStatus de #{quien} : #{estado}\u201d 93 end def link # Funci\u00f3n llamada cuando 2 canales son conectados con # \u00e9xito. # Los par\u00e1metros son :channel1, :channel2 canal1 = params[:channel1] canal2 = params[:channel2] p \u201cLlamada activa!\u201d end def extension_status # Funcion que se dispara cuando existe un cambio de estado # en alguna extension de Asterisk # Tiene un par\u00e1metro que indica la extensi\u00f3n que cambia de # estado :exten y otro que indica el estatus :status #STATUS POSIBLES # 0: Disponible / inactiva # 1: Disponible / activa o llamando # 4: No Disponible # 8: Disponible / sonando extension = params[:exten] estado = params[:status] p \u201cLa extensi\u00f3n: #{extension} tiene el estado : #{estado}\u201d end end Tabla 41: Funciones Eventos AMI. Dentro de cada m\u00e9todo se puede tener una l\u00f3gica tan simple como la mostrada o tan compleja que llame a otro m\u00e9todo AMI, cambio en la base de datos, entre otras acciones que se pudieran realizarse a nivel de programaci\u00f3n. 94 Comparaci\u00f3n Adhearsion - Telegraph En las secciones anteriores se ha venido hablando sobre dos herramientas cuyo objetivo es facilitar la comunicaci\u00f3n entre el PBX por software Asterisk y aplicaciones externas utilizando las interfaces AGI y AMI. En esta secci\u00f3n se va a realizar una breve comparaci\u00f3n entre las herramientas. En primer lugar se observa que el n\u00facleo de las herramientas es similar, ya que ambas se encuentran desarrolladas en el lenguaje de programaci\u00f3n Ruby y distribuidas bajo el paradigma de c\u00f3digo abierto de la GNU, pero una de las grandes diferencias es que por concepci\u00f3n son distintos, siendo Adhearsi\u00f3n un framework y Telegraph un plugin. Esto no hace a Adhearsion mejor que Telegraph ni viceversa, pero influye a la hora de decidir cual de las herramientas se va a usar en el proyecto, ya que dependiendo de la orientaci\u00f3n de la aplicaci\u00f3n VoIP que se desea desarrollar, conviene m\u00e1s una herramienta sobre la otra. A pesar de que la madurez de Adhearsion es escasa, inclusive los creadores recomiendan probarlo exhaustivamente antes de llevar un sistema a producci\u00f3n con el framework; Telegraph no tiene m\u00e1s tiempo en distribuci\u00f3n que Adhearsion, por lo que no es un indicador de mucho peso. Aunque sobre este aspecto se puede afirmar que Adhearsion ya es un framework con un poco de uso mientras que Telegraph es un plugin que est\u00e1 empezando a crecer por lo que hay mas probabilidades de fallo con este \u00faltimo. 95 Un plugin es f\u00e1cil de manejar en un proyecto que un framework que te crea un proyecto propio. Una de las razones de \u00e9sta afirmaci\u00f3n comprenden los cambios que se deseen hacer sobre el c\u00f3digo fuente bien sea por adaptaci\u00f3n o correcci\u00f3n de errores, ya que es m\u00e1s sencillo realizarlo a un plugin que a un framework. Esto es considerado importante, m\u00e1s a\u00fan tomando en cuenta lo comentado anteriormente sobre la madurez de las herramientas, ya que las primeras versiones de cualquier software tiene a presentar m\u00e1s fallos que las que tienen tiempo distribuy\u00e9ndose. Por otro lado con los plugins no se puede empezar una aplicaci\u00f3n desde cero, sino que tiene que estar asociados a un proyecto, esto dependiendo de la aplicaci\u00f3n a desarrollar puede ser beneficioso o no. Las tecnolog\u00edas difieren en la forma como se integran. Con Adhearsion se debe realizar un proyecto nuevo propio de la herramienta, mientras que Telegraph se adapta a un proyecto Rails, lo cual requiere pensar si el objetivo es integrar VoIP con Web o si solo se quiere una aplicaci\u00f3n VoIP. Uno de los aspectos m\u00e1s importantes es el uso para el cual se encuentra orientada la herramienta depende mucho de la interfaz por la cual se comunica con Asterisk (AGI/AMI). A pesar que ambas herramientas brindan soporte para ambas interfaces, Telegraph brindando un valor agregado con el soporte para los eventos AMI, en base a lo expuesto en este cap\u00edtulo de Adhearsion, podemos afirmar que es una herramienta orientada hacia el uso de la interfaz AGI. Dise\u00f1ado para la facilitaci\u00f3n de la implementaci\u00f3n de IVR's, que manipulan el flujo de llamadas que se reciben, procesando informaci\u00f3n de una llamada recibida. De Telegraph no se puede afirmar lo mismo, ya que no tiene una tendencia tan marcada como Adhearsion, lo que si se puede afirmar es el amplio soporte para la interfaz AMI, manej\u00e1ndose de 96 manera sencilla, incluyendo los eventos que se disparan en Asterisk. En la siguiente tabla se aprecian algunas diferencias y semejanzas entre las dos herramientas en aspectos que se deben tomar en cuenta a la hora de elegir cu\u00e1l usar para un proyecto espec\u00edfico: Propiedad Adhearsion Telegraph Lenguaje C\u00f3digo Fuente Ruby Ruby Licencia C\u00f3digo abierto (GPL) C\u00f3digo abierto (GPL) Distribuido como Framework Plugin Instalaci\u00f3n RubyGems Svn \u2013 Plugin Install Interfaz Soporte AGI \u2013 AMI AGI - AMI - AMI Events Orientado a Interfaz AGI AMI Soporte para desarrolladores Reporte de errores / Foros Lista de correo / Foros Conectividad Ruby - Asterisk Rails \u2013 Asterisk Tabla 42: Cuadro comparativo Adhearsion - Telegraph. 97 CAP\u00cdTULO III MARCO APLICATIVO En este cap\u00edtulo se describir\u00e1 el \u00e1mbito aplicativo de la presente investigaci\u00f3n, plasmando los requerimientos generales del cliente y el proceso de desarrollo de los componentes de la aplicaci\u00f3n y su adaptaci\u00f3n a la metodolog\u00eda aplicada, en este caso Programaci\u00f3n Extrema (XP, por sus siglas en ingl\u00e9s). Luego se mostrar\u00e1 la visi\u00f3n general de los componentes de software que fueron desarrollados para el proyecto, explicando detalladamente la utilizaci\u00f3n de las herramientas, lenguajes y frameworks que se utilizaron. Finalmente se explica la adaptaci\u00f3n del proceso de desarrollo (XP) y sus pr\u00e1cticas, llevadas al desarrollo del proyecto, en cada una de sus iteraciones o fases. Requerimientos Generales A gran escala, el proyecto busca automatizar el proceso de mercadeo de productos y servicios empresariales v\u00eda telef\u00f3nica. El proceso de llamado, consisti\u00f3 primordialmente en la recuperaci\u00f3n de un 98 n\u00famero telef\u00f3nico de un repositorio de datos, junto con cierta informaci\u00f3n personal del posible cliente, donde dicho n\u00famero sea discado desde el PBX y pasado a la extensi\u00f3n desde donde se realiza la petici\u00f3n. Adem\u00e1s de ese proceso, se requiere realizar manipulaciones adicionales a dicha llamada, que ser\u00edan: \u2022 Supervisi\u00f3n: proceso en el que una extensi\u00f3n del PBX tiene la posibilidad de escuchar el di\u00e1logo de una llamada en curso, realizada desde otra extensi\u00f3n de la central telef\u00f3nica. \u2022 Transferencia: proceso en el que el se transfiere una llamada en curso desde una extensi\u00f3n a otra de la central telef\u00f3nica. Cabe destacar que se desea conocer en todo momento el estatus de las llamadas y extensiones de la central telef\u00f3nica, desde la aplicaci\u00f3n. Se requieren distintos perfiles en la aplicaci\u00f3n, entre los cuales tenemos: \u2022 Operador: usuario encargado \u00fanicamente de la realizaci\u00f3n de llamadas a los potenciales clientes. \u2022 Supervisor: usuario encargado de monitorear el estatus de las llamadas hechas por operadores, capaz de supervisar llamadas en curso, con la posibilidad de transferirlas a su extensi\u00f3n. \u2022 Validador: usuario capaz de introducir y validar un nuevo n\u00famero telef\u00f3nico y los datos de un potencial cliente. \u2022 Administrador: usuario encargado de la gesti\u00f3n y supervisi\u00f3n de todo el sistema. Pudiendo ver las estad\u00edsticas de ventas, ingresar nuevos usuarios al sistema y capaz de realizar labores de los perfiles del validador y supervisor, entre otras funciones. 99 Se requiere automatizar el proceso de carga de posibles clientes en el sistema. Adaptaci\u00f3n del Proceso de Desarrollo XP Como se mencion\u00f3 en el segundo cap\u00edtulo de la investigaci\u00f3n, el proceso de desarrollo XP es ligero y capaz de manejar los requerimientos cambiantes del cliente, teni\u00e9ndolo bastante involucrado con el desarrollo. En esta secci\u00f3n se ilustrar\u00e1 la adaptaci\u00f3n del proceso de desarrollo de la programaci\u00f3n extrema en la presente investigaci\u00f3n. El proceso de desarrollo de software XP est\u00e1 basado en entregas e iteraciones. Se dividi\u00f3 el proyecto en 4 iteraciones, con un tiempo aproximado de 4 a 5 semanas por iteraci\u00f3n. En cada iteraci\u00f3n se aplicar\u00e1n las siguientes pr\u00e1cticas: Planificaci\u00f3n Dado que en esta investigaci\u00f3n el producto se desarroll\u00f3 a trav\u00e9s de un tercero y no del usuario final de la aplicaci\u00f3n, no se realizaron historias de usuario como define la metodolog\u00eda XP en sus pr\u00e1cticas. Sin embargo, se definieron requerimientos a ser desarrollados en cada iteraci\u00f3n. 100 Dise\u00f1o En el dise\u00f1o se realizar\u00e1 la definici\u00f3n de clases involucradas en la implementaci\u00f3n de los requerimientos de la iteraci\u00f3n. Vali\u00e9ndose de la modelaci\u00f3n \u00e1gil, se anexar\u00e1n diagramas, utilizando la notaci\u00f3n de UML, que permitan visualizar con mayor claridad la interacci\u00f3n entre dichas clases. Codificaci\u00f3n En cada iteraci\u00f3n se realiz\u00f3 el c\u00f3digo fuente que di\u00f3 soluci\u00f3n a los requerimientos establecidos por el cliente en cada etapa del proceso de desarrollo. Dado que este proyecto fue realizado por una sola persona, no fue posible la aplicaci\u00f3n de la pr\u00e1ctica de programaci\u00f3n en pareja. Pruebas El desarrollo del proyecto se bas\u00f3 en la t\u00e9cnica BDD (Behavior Driven Development), que propone la escritura de pruebas de comportamiento para el desarrollo de una aplicaci\u00f3n, inclusive hace hincapi\u00e9 que dichas pruebas deber\u00edan ser definidas antes de implementar los requerimientos. Adem\u00e1s explica que el uso de la t\u00e9cnica, implica la automatizaci\u00f3n de las pruebas. Al final de cada iteraci\u00f3n se realizaron pruebas de aceptaci\u00f3n de parte del cliente. En cada iteraci\u00f3n se anexar\u00e1 el c\u00f3digo fuente de las pruebas codificadas. Para la adaptaci\u00f3n de las pruebas de comportamientos en Rails se utiliz\u00f3 un plugin llamado rspec que facilita la escritura de las mismas, seg\u00fan se\u00f1ala RSpec Doc (2007). 101 Para las pruebas que involucraban interacci\u00f3n con entes externos se utilizaron herramientas como Mocks y Stubs, destacadas en la Web RSpec Doc (2007), ya que simulan o imitan el comportamiento de esos entes, permitiendo la realizaci\u00f3n de las pruebas sin la necesidad de interactuar con los sistemas externos. Feedback Esta fase no pertenece a la metodolog\u00eda XP, m\u00e1s se cree conveniente presentar los resultados obtenidos de cada iteraci\u00f3n, reflejando los aspectos que requieran de una refactorizaci\u00f3n en iteraciones posteriores. Desarrollo de la Aplicaci\u00f3n Met\u00e1fora del Sistema El sistema est\u00e1 compuesto por dos piezas principales y dos entes externos que interact\u00faan con \u00e9l, brindandole servicios para lograr el objetivo final que implica el desarrollo de una aplicaci\u00f3n Web/VoIP. Las piezas de la aplicaci\u00f3n comprenden en principio un m\u00f3dulo que maneja la conexi\u00f3n hacia la central telef\u00f3nica usando el plugin de Rails: Telegraph y el resto de la l\u00f3gica de la aplicaci\u00f3n comprende la segunda pieza, esta \u00faltima desarrollada con el framework Web Ruby on Rails. 102 Con respecto a los entes externos, tenemos al manejador de base de datos MySQL, que fue utilizado para la persistencia de los datos en la aplicaci\u00f3n y Asterisk es la otra herramienta en cuesti\u00f3n que desempe\u00f1\u00f3 un papel fundamental en la investigaci\u00f3n, ya que suministr\u00f3 la capa de servicios en el \u00e1mbito telef\u00f3nico (VoIP), siendo el PBX que estuvo en constante comunicaci\u00f3n con la aplicaci\u00f3n Web. Siendo el fin \u00faltimo del proyecto la automatizaci\u00f3n del proceso de mercadeo de productos y servicios empresariales v\u00eda telef\u00f3nica, result\u00f3 de gran utilidad la interconexi\u00f3n entre Rails y Asterisk, ya que la idea era automatizar el proceso de llamado, realizandose directamente desde un browser al accionar un bot\u00f3n. Un softphone es un software que hace una simulaci\u00f3n de tel\u00e9fono convencional a trav\u00e9s de la computadora, es decir, que permite utilizarla para hacer llamadas a otros dispositivos telef\u00f3nicos. De tal modo, que la aplicaci\u00f3n se encargue de solicitarle la realizaci\u00f3n de una nueva llamada al PBX Asterisk hacia el destinatario correspondiente. Llamada que luego es transferida al softphone que tiene asignada la extensi\u00f3n del usuario que ejecut\u00f3 la orden, m\u00e1s no es necesario que conteste la llamada ni conozca la existencia del softphone, ya que el software est\u00e1 configurado para que la llamada se contesta autom\u00e1ticamente. Por su parte, para lograr la comunicaci\u00f3n entre la aplicaci\u00f3n Web y Asterisk, utilizando la herramienta Telegraph, fue necesaria la ejecuci\u00f3n de procesos Ruby (drb) responsables de recibir y/o enviar los datos al PBX. Espec\u00edficamente, a trav\u00e9s de Telegraph se inician dos procesos, el primero de ellos para comunicar la aplicaci\u00f3n 103 Web con la interfaz AMI de Asterisk; mientras que el segundo se encarga de recibir los eventos AMI as\u00edncronos que difunde el PBX y ejecutar el m\u00e9todo espec\u00edfico para el evento generado. A continuaci\u00f3n se mostrar\u00e1 gr\u00e1ficamente el funcionamiento general de la aplicaci\u00f3n: Aplicac i\u00f3n Web - VoIP M\u00f3dulo de Inte rcone xi\u00f3n Central Telef\u00f3nica (PBX) Repos itorio de Datos Consultas Utiliza Comandos Aplica ci\u00f3n We b Operador AMI AMI Events AMI drb`s Eventos as\u00edncronos Validador Administrador Supervisor Browser S oftphone S oftphone Browser Browser Browser Red p\u00fablica Llamada Clie nte Gr\u00e1fico 6: Met\u00e1fora del Sistema. Fuente: Autor 104 Iteraci\u00f3n 0 En la iteraci\u00f3n 0 se defini\u00f3 la planificaci\u00f3n general de todo el proceso de desarrollo de los componentes de software que se realizaron en la investigaci\u00f3n. Planificaci\u00f3n A continuaci\u00f3n se muestran la lista de requerimientos generales que guiaron el desarrollo de los componentes de software: 1. Establecer comunicaci\u00f3n efectiva entre el PBX Asterisk y el framework Rails. 2. Implementaci\u00f3n de un m\u00f3dulo encargado de manejar el proceso de llamadas e intercambio de informaci\u00f3n con el PBX. 3. Implementaci\u00f3n de funcionalidades en la aplicaci\u00f3n Web. Iteraci\u00f3n 1 Fecha de inicio: 19-06-2007 Al comienzo de esta iteraci\u00f3n se instal\u00f3 en el sistema un softphone (X-Lite) para lograr la comunicaci\u00f3n b\u00e1sica entre el computador y Asterisk, dicho intercambio lo cual fue realizado sobre el protocolo SIP. Durante la primera iteraci\u00f3n se realiz\u00f3 la comunicaci\u00f3n entre el framework Ruby on Rails y el PBX Asterisk, a trav\u00e9s de una herramienta que sirvi\u00f3 de puente entre ambas tecnolog\u00edas. 105 En primera instancia se instal\u00f3 el framework Adhearsion, y se logr\u00f3 la comunicaci\u00f3n entre Asterisk y un script de Adhearsion escrito en lenguaje Ruby. Luego de lograr la conexi\u00f3n, se detect\u00f3 que dicho framework no era el m\u00e1s adecuado para resolver el problema, ya que se encuentra orientado para la realizaci\u00f3n de IVR's vali\u00e9ndose de la interfaz AGI de Asterisk. Seguidamente se procedi\u00f3 a buscar una herramienta m\u00e1s adaptada para satisfacer las necesidades del cliente, y se lleg\u00f3 a una herramienta m\u00e1s adecuada que comprend\u00eda un plugin de Rails llamado Telegraph, lo que lo hac\u00eda m\u00e1s atractivo para la adaptaci\u00f3n a la aplicaci\u00f3n. Finalmente, en esta iteraci\u00f3n se realiz\u00f3 la instalaci\u00f3n/inclusi\u00f3n del plugin en el proyecto logrando la conexi\u00f3n efectiva entre Rails y Asterisk con la herramienta adecuada, ya que soportaba el env\u00edo de comandos AMI e inclusive la captura de eventos AMI. Planificaci\u00f3n Lista de requerimientos que fueron desarrollados en la primera iteraci\u00f3n: 1. Instalaci\u00f3n y prueba del framework Adhearsion para la comunicaci\u00f3n Rails- Asterisk. 2. Instalaci\u00f3n del plugin Telegraph para la comunicaci\u00f3n Rails-Asterisk. 106 Dise\u00f1o Se incluyeron nuevas clases en el proyecto con la instalaci\u00f3n de Telegraph, m\u00e1s no se crearon nuevas clases propias. En el siguiente diagrama se refleja la clase principal de Telegraph sobre la cual se realizaron algunas correcciones de errores que presentaba el plugin, las cuales ser\u00e1n presentadas m\u00e1s adelante. Gr\u00e1fico 7: Especificaci\u00f3n Clase AMIManager. Codificaci\u00f3n \ufffd Adhearsion Despu\u00e9s de instalar el framework Adhearsion, se procedi\u00f3 a establecer la comunicaci\u00f3n entre el mismo y Asterisk para lo que se necesitaba una entrada en Asterisk que transfiriera las llamadas desde Asterisk a Adhearsion. En el archivo 107 extention.conf de Asterisk, se agregaron las siguientes instrucciones: Comunicaci\u00f3n entre Adhearsion y Asterisk: [internal] exten => _X.,1,AGI(agi://200.200.200.10) Tabla 43: Comunicaci\u00f3n Adhearsion/Asterisk. C\u00f3digo que enviaba las llamadas que llegaron al contexto \u201cinternal\u201d de la aplicaci\u00f3n que se ejecuta en la direcci\u00f3n IP 200.200.200.10. En este caso se hizo s\u00f3lo una prueba de comunicaci\u00f3n exitosa antes de cambiar de herramienta. El script Adhearsion que se corri\u00f3 fue muy sencillo imprimiendo la extensi\u00f3n destino de la llamada, como se ilustra a continuaci\u00f3n: Script Adhearsion de prueba: internal { puts extension } Tabla 44: Script Adhearsion de Prueba. \ufffd Telegraph Se instal\u00f3 el plugin Telegraph en el proyecto y se logr\u00f3 la conexi\u00f3n con Asterisk a trav\u00e9s de la interfaz AMI. Para ello se gener\u00f3 el modelo que usa dicha interfaz y se le indic\u00f3 al proyecto que se conectara a Asterisk, coloc\u00e1ndole el host, usuario y contrase\u00f1a de Asterisk en un archivo de configuraci\u00f3n de Rails, de forma de cargar esa configuraci\u00f3n y establecer la conexi\u00f3n al momento de iniciar el servidor AMI. Para eso se coloc\u00f3 en el script que inicia el servidor AMI (ami_server) la siguiente instrucci\u00f3n: 108 Comunicaci\u00f3n entre Telegraph y Asterisk: ami_server = Telegraph::AMIServer.new(:host => @config['host'], :username => @config['username'], :secret => @config['secret']) Tabla 45: Comunicaci\u00f3n Telegraph/Asterisk. Donde en la variable @config se carg\u00f3 el archivo de configuraci\u00f3n de Rails \u201cami.yml\u201d, quien tiene la informaci\u00f3n de Asterisk. Finalmente en Asterisk se tiene que ingresar el usuario y contrase\u00f1a en el archivo managers.conf para que realice la autenticaci\u00f3n y permita establecer la conexi\u00f3n TCP. Luego de la instalaci\u00f3n y conexi\u00f3n se corrigieron algunos errores que presentaba el plugin en su clase AMIManager, espec\u00edficamente en la definici\u00f3n de los arreglos que se usan para llamar a las funciones de Telegraph, a continuaci\u00f3n se muestra el c\u00f3digo fuente de los arreglos que fueron modificados, las modificaciones se encuentr\u00e1n marcadas en el color rojo: Correcciones del c\u00f3digo fuente en Telegraph: FIND = { :agents => [:agents, []], :db => [:db_get,[:family, :key]], :extension_state => [:extension_state, [:context, :exten]], :variable => [:getvar, [:channel, :variable]], :all_iax_peers => [:iax_peers, []], :mailbox => [:mailbox_status, [:mailbox]], :parked_calls => [:parked_calls, []], :queue => [:queue_status, []], 109 :mailbox_count=> [:mailbox_count, []], :sip_peer=> [:sip_show_peer, [:peer]], :all_sip_peers=> [:sip_peers, []], :status=> [:status, [:channel]] } UPDATE = {:absolute_timeout => [:absolute_timeout, [:channel, :timeout]], :monitor => [:change_monitor, [:channel, :file]], :db => [:db_put, [:family, :key, :value]], :redirect => [:redirect, [:channel, :context, :exten, :priority]], :variable => [:setvar, [:channel, :variable, :value]] } CREATE = {:monitor => [:monitor, [:channel, :file, :format, :mix]], :call => [:originate, []] #Call/Originate has many optional parameters } DESTROY = { :call => [:hangup, [:channel]], :monitor => [:stopmonitor, [:channel]] } Tabla 46: Correcciones en Telegraph. Pruebas Se realizaron un pool de pruebas de conexi\u00f3n, usando el modelo AMI. Dichas pruebas involucraban acciones b\u00e1sicas de llamadas, tales como realizaci\u00f3n y transferencia de llamadas. A continuaci\u00f3n se muestran los comandos ejecutados, probados desde la c\u00f3nsola Ruby del proyecto Rails: 110 Pruebas de Telegraph en la primera iteraci\u00f3n: AMIModel.create(:call, :channel=>'SIP/12', :context=>'from internal', exten=>'12', priority=>1); AMIModel.update(:redirect, :channel=>'SIP/11-09ec47c8', :context=>'from-internal', :extension=>'13', :priority=>1); AMIModel.find(:status, :channel=>'SIP/12'); Tabla 47: Pruebas Telegraph Iteraci\u00f3n 1. En cada caso se invoca al modelo generado din\u00e1micamente por Telegraph y se llaman a las distintas funciones estilo CRUD, indicando la funci\u00f3n espec\u00edfica a activar de AMI y los par\u00e1metros que recibe la misma. Feedback El prof. Edgar Gonz\u00e1lez revis\u00f3 la instalaci\u00f3n del plugin, colabor\u00f3 en la realizaci\u00f3n de las pruebas de conexi\u00f3n con el servidor de Telegraph y brind\u00f3 apoyo permanente para la correcci\u00f3n de errores en el plugin. Cada uno de los requerimientos fue desarrollado y probado con \u00e9xito, presentando el funcionamiento esperado. Iteraci\u00f3n 2 Fecha de inicio: 11-07-2007 En la segunda iteraci\u00f3n se procedi\u00f3 a implementar lo que era el m\u00f3dulo de conexi\u00f3n como tal, entre la aplicaci\u00f3n y Asterisk utilizando los beneficios que aporta el plugin Telegraph. 111 Planificaci\u00f3n Requerimientos que fueron desarrolladas en la segunda iteraci\u00f3n: 1. Implementar una funci\u00f3n que permita a un operador iniciar una llamada telef\u00f3nica a trav\u00e9s del PBX Asterisk, hacia un n\u00famero de un potencial cliente recuperado del repositorio de datos elegidos seg\u00fan ciertos par\u00e1metros de prioridad, registrando la llamada en el sistema. 2. Implementar una funci\u00f3n que permita colgar una llamada. 3. Implementar una funci\u00f3n que permita a un supervisor transferir una llamada telef\u00f3nica en curso a su extensi\u00f3n. 4. Implementar una funci\u00f3n que permita a un supervisor monitorear una llamada en curso, es decir que permita escuchar la conversaci\u00f3n de la llamada y persista esta informaci\u00f3n en el sistema. 5. Implementar una funci\u00f3n que consulte el estado de una extensi\u00f3n de Asterisk en un momento dado, y actualic\u00e9 la informaci\u00f3n del sistema. Dise\u00f1o En el siguiente diagrama se visualizan las clases involucradas para la soluci\u00f3n 112 de las tareas concebidas en esta iteraci\u00f3n. Gr\u00e1fico 8: Diagrama de Clases, Iteraci\u00f3n 2. Fuente: Autor Codificaci\u00f3n Se muestra a continuaci\u00f3n el c\u00f3digo fuente de las funciones m\u00e1s importantes dentro de la clase Central, la funci\u00f3n de actualizaci\u00f3n de estatus de la clase Extension y el algoritmo de b\u00fasqueda de n\u00fameros en el repositorio de datos de la clase Producto: Parte del c\u00f3digo desarrollado en la segunda iteraci\u00f3n, espec\u00edficamente la clase Central, 113 donde se definen las funciones que presentan la l\u00f3gica con todo lo pertinente a la llamada: class Central < Telegraph::AMIManager def self.llamar(producto, operador, ip) extension = self.extension_from_ip(ip) return nil, :extension_no_ociosa unless Extension.find_by_numero(extension).state == Extension::OCIOSA llamada = nil Numero.transaction do numero = producto.siguiente_numero_a_llamar(operador) return nil, :no_hay_numeros_disponibles unless numero extension = self.extension_from_ip(ip) self.establecer_llamada(numero.numero, extension) llamada = Llamada.create!(:producto => producto, :operador => operador, :numero => numero, :extension => extension, :centro => operador.centro) end return llamada, nil end def self.colgar(llamada) finalizar_llamada(llamada.extension) end def self.establecer_llamada(number, extension) # Hace una llamada al numero suministrado, pero primero # espera por que la extension sea levantada number_to_call = add_dial_prefix(strip_local_area_code(number)) create(:call, :context => ::ApplConfig[:context], :priority => ::ApplConfig[:priority], :async => ::ApplConfig[:async], :channel => \"SIP/#{extension}\", :exten => number_to_call) end def self.espiar_llamada(extension_a_espiar, extension_que_espia) create(:call, :channel => \"local/#{extension_que_espia}\", :context => ::ApplConfig[:context], :application => 'ChanSpy', :priority => ::ApplConfig[:priority], 114 :data => \"sip/#{extension_a_espiar} |q\", :async => true, :variable => \"espiando= #{extension_a_espiar\") end def self.extension_espiada(extension) res = find(:variable, :channel => channel_from_extension(extension), :variable => 'espiando') return res.value unless res.value.blank? nil end def self.transferir_llamada(extension_origen, extension_destino) channel = channel_linked_to_extension(extension_origen) return unless channel Central.update(:redirect, :channel => channel, :context => ::ApplConfig[:context], :exten => extension_destino, :priority => ::ApplConfig[:priority]) end def self.finalizar_llamada(extension) channel = channel_from_extension(extension) return unless channel destroy(:call, :channel => channel) end def self.extension_from_ip(ip) dot_index = ip.rindex('.') ip[dot_index-1,1]+ip[dot_index+1, ip.length] end end Tabla 48: Clase Central / C\u00f3digo Fuente Iteraci\u00f3n 2. Parte del c\u00f3digo desarrollado en la segunda iteraci\u00f3n, Clase Extensi\u00f3n, donde se presenta el estatus de la extensi\u00f3n: class Extension < ActiveRecord::Base def state(reload = false) if @state.nil? or reload 115 res = Central.find(:extension_state, :exten => numero, :context => ::ApplConfig[:context]) @state = res.status if res end @state end end Tabla 49: Clase Extension / C\u00f3digo Fuente Iteraci\u00f3n 2. Parte del c\u00f3digo desarrollado en la segunda iteraci\u00f3n, Clase Producto, donde se presenta el algoritmo encargado de b\u00fascar el siguiente n\u00famero a ser llamado: class Producto < ActiveRecord::Base def siguiente_numero_a_llamar(operador, options = {}) raise ArgumentError.new(\"Operador esperado\") unless operador.is_a?(Operador) num = numeros_llamar.find(:first, :conditions => [\"volver_llamar_at < ? and operador = ?\",Time.now, operador.login], :order => \"volver_llamar_at\") return num if num num = numeros_llamar.find(:first, :conditions => [\"volver_llamar_at < ? and (operador is null or operador = '')\",Time.now], :order => \"volver_llamar_at\") return num if num num = numeros_llamar.find(:first, :conditions => [\"volver_llamar_at is null and operador = ?\", operador.login], :order => \"prioritario desc, ultima_llamada_at, created_at\") return num if num num = numeros_llamar.find(:first, :conditions => \"volver_llamar_at is null and (operador is null or operador = '')\", :order => \"prioritario desc, ultima_llamada_at, created_at\") 116 return num if num return nil end end Tabla 50: Clase Producto / C\u00f3digo Fuente Iteraci\u00f3n 2. Pruebas Se codificaron una serie de pruebas de comportamiento con el plugin rspec, que fueron aplicadas a las clases del modelo, al igual que se realizaron pruebas de aceptaci\u00f3n del producto. A continuaci\u00f3n se muestran ciertas pruebas realizadas sobre la clase Central: Pruebas SPEC de la clase Central en la segunda iteraci\u00f3n: describe Central do fixtures :productos, :centros, :usuarios, :extensiones, :mantenimientos, :numeros before(:each) do end it \"deberia llamar si el sistema no esta en mantenimiento y los parametros son correctos\" do Central.llamar(productos(:aba_1024_venta), usuarios(:operador_caracas), \"200.200.201.112\") end it \"no deberia llamar si la extension no esta ociosa\" do Central.llamar(productos(:aba_1024_venta), usuarios(:operador_maracay), \"200.200.202.112\").should be_eql([nil, :extension_no_ociosa]) end it \"deberia recuperar la extension desde una ip valida\" do Central.extension_from_ip(\"200.200.200.34\").should == 117 \"034\" end it \"deberia arrojar una exception al intentar recuperar la extension desde una ip que es nil\" do lambda{ Central.extension_from_ip(nil) }.should raise_error end end Tabla 51: Pruebas Clase Central Iteraci\u00f3n 2. Seguidamente se anexa una de las varias pruebas que se le aplicaron al algoritmo de b\u00fasqueda de llamadas: Pruebas SPEC de la clase Producto en la segunda iteraci\u00f3n: describe Producto, \"Primera Prueba, numero a llamar con 5 entradas una fecha de volver_a_llamar. La primera 30 minutos antes de la hora actual (fuera del rango), la segunda a 10 minutos de la hora actual (dentro del rango) y la tercera 5 minutos despues de la hora actual (dentro del rango) y otras 2 con volver a llamar en nil\" do fixtures :numeros, :usuarios, :productos before(:each) do @producto = productos(:aba_1024_instalacion) end it \"deberia devolver el numero de Anibal\" do num=@producto.siguiente_numero_a_llamar(usuarios(:operado r_caracas)) num.should be_eql(numeros(:anibal_rojas)) end end Tabla 52: Pruebas Clase Producto Iteraci\u00f3n 2. Se realizaron pruebas de aceptaci\u00f3n sobre el producto, donde el cliente se familiariz\u00f3 las funcionalidades b\u00e1sicas tales como iniciar una nueva llamada, transferir o espiar una llamada, como se muestra en las siguientes pantallas: 118 \u2022 Pantalla de la aplicaci\u00f3n con perfil de operador, donde es posible realizar una llamada. Gr\u00e1fico 9: Prueba Aceptaci\u00f3n, Pantalla Operador. Fuente: Autor \u2022 Pantalla de la aplicaci\u00f3n con perfil de supervisor, donde se muestra toda la informaci\u00f3n de llamadas y extensiones del centro al que pertenece Gr\u00e1fico 10: Prueba Aceptaci\u00f3n, Pantalla Supervisor (Estado Asterisk). Fuente: Autor 119 \u2022 Pantalla que muestra el detalle de una llamada a un supervisor, donde puede monitorearla o transferirla a su extensi\u00f3n. Gr\u00e1fico 11: Prueba Aceptaci\u00f3n, Pantalla Supervisor (Detalle Llamada). Fuente: Autor Feedback El cliente estuvo satisfecho con las funcionalidades agregadas. Los algoritmos codificados fueron revisados y aprobados. El cliente pidi\u00f3 una refactorizaci\u00f3n del algoritmo de actualizaci\u00f3n de estatus, ya que las constantes llamadas a Asterisk congestionaron el canal produciendo un cierto colapso de la aplicaci\u00f3n. Dicha refactorizaci\u00f3n se realizar\u00e1 en iteraciones posteriores. Se determin\u00f3 que se requer\u00eda un softphone con la capacidad de contestar autom\u00e1ticamente una llamada entrante de modo que el usuario no se vea en la necesidad de interactuar con dicho software, sino solo con la aplicaci\u00f3n en cuesti\u00f3n, por lo que se instal\u00f3 un softphone llamado \u201cTwinkle\u201d. 120 Iteraci\u00f3n 3 Fecha de inicio: 21-08-2007 En la tercera iteraci\u00f3n se procedi\u00f3 a desarrollar requerimientos adicionales del cliente. Funcionalidades, tales como la carga de un archivo excel a la base de datos con la informaci\u00f3n de los clientes, entre otras. Planificaci\u00f3n Lista de requerimientos a desarrollar de la tercera iteraci\u00f3n: \u2022 Implementar una funcionalidad en el sistema que permita al usuario (perfil Validador), tomar un archivo excel e ingresar la data del archivo (contiene datos del cliente) en el repositorio de datos de la aplicaci\u00f3n. Permitiendole validar el n\u00famero telef\u00f3nico posteriormente. \u2022 Implementar una funcionalidad que permita al Administrador del sistema colocarlo a la aplicaci\u00f3n en un modo \u201cMantenimiento\u201d, en el cual ning\u00fan operador pueda iniciar una llamada nueva. 121 Dise\u00f1o En el siguiente diagrama se visualizan las clases involucradas para la soluci\u00f3n realizada en esta iteraci\u00f3n. Gr\u00e1fico 12: Diagrama de Clases, Iteraci\u00f3n 3. Fuente: Autor. 122 Codificaci\u00f3n Se muestra a continuaci\u00f3n el c\u00f3digo fuente de las funciones m\u00e1s importantes dentro de la clase Carga y Mantenimiento que comprenden el modelo en la implementaci\u00f3n de las tareas. C\u00f3digo fuente de la tercera iteraci\u00f3n, la clase Carga, encargada de tomar el archivo Excel, parsearlo e ingresar la informaci\u00f3n en la base de datos: class Carga < ActiveRecord::Base def self.parsear inicializa_logger carga = Carga.find ARGV[2] # Se recupera el n\u00famero de la # corrida a procesar de la # linea de comando carga.iniciada_at = Time.new carga.save! logger.info \"Iniciando proceso de la carga del archivo de excel llamado #{carga.filename} de la Corrida ID: #{ARGV[2]}\" begin workbook = Spreadsheet::ParseExcel.parse(carga.full_filename) worksheet = workbook.worksheet(0) carga.recuperar_filas_excel(worksheet) carga.finalizada_at = Time.new carga.save! rescue Exception => e CargaLog.create(:carga_id => carga.id,:descripcion => \"Error cargando el archivo: (#{carga.filename}) Detalle: #{e.to_s}\") logger.debug \"Se presento un error cargando el archivo (#{carga.filename}), en la carga: (#{carga.id})\" end end def recuperar_filas_excel (worksheet) contadorError = 0 contadorExito = 0 skip = 1 worksheet.each(skip) do |row| sleep(Carga.sleep_time) if Carga.sleep? begin n = Numero.new 123 n.central = row.at(0).to_texto.to_s rescue nil n.numero = row.at(1).to_texto.to_s rescue nil n.numero = \"0#{n.numero}\" unless n.numero[0,1] == '0' n.nombre = row.at(2).to_texto rescue nil n.producto_id = producto_id n.carga_id = id n.created_by = created_by n.updated_by = updated_by unless row.at(3).blank? prioritario = row.at(3).to_entero rescue nil n.prioritario = (prioritario == 1) else n.prioritario = false end unless row.at(4).blank? n.operador = row.at(4).to_texto.strip rescue nil n.operador = nil if n.operador.blank? end unless n.save! contadorError = contadorError+1 else contadorExito = contadorExito+1 logger.info \"Se agrego el numero: (#{n.numero}) al sistema con exito.\" end rescue Exception => e CargaLog.create( :carga_id => id, :descripcion => \"Detalle: #{e.to_s}, Error cargando el numero: (#{n.numero})\" ) logger.info \"Error al agregar el numero: (#{n.numero}). Detalle: #{e.to_s}\" end logger.info \"Se procesaron #{contadorExito+contadorError} registros, #{contadorExito} se agregaron con Exito a la Base de Datos y #{contadorError} presentaron Errores.\" end end def en_proceso?(reload=false) if @en_proceso.nil? or reload @en_proceso = if finalizada_at false else res = `ps -ef | grep ruby` res[\"Carga.parsear #{id}\"] end end Tabla 53: Clase Carga / C\u00f3digo Fuente Iteraci\u00f3n 3. 124 C\u00f3digo fuente de la tercera iteraci\u00f3n, clase Mantenimiento, donde se restringe la salida de llamadas de un operador: class Mantenimiento < ActiveRecord::Base def self.empezar_mantenimiento mant = Mantenimiento.find(1) mant.en_mantenimiento = true mant.save end def self.terminar_mantenimiento mant = Mantenimiento.find(1) mant.en_mantenimiento = false mant.save end def self.en_mantenimiento? mant = Mantenimiento.find(1) return mant.en_mantenimiento if mant nil end End Tabla 54: Clase Mantenimiento / C\u00f3digo Fuente Iteraci\u00f3n 3. Pruebas Se codificaron una serie de pruebas de comportamiento con el plugin rspec, que fueron aplicadas a las clases Carga y Mantenimiento, al igual que se realizaron pruebas de aceptaci\u00f3n del producto. A continuaci\u00f3n se muestran ciertas pruebas realizadas sobre la clase Carga: 125 Pruebas SPEC clase Carga en la tercera iteraci\u00f3n: describe Carga, \"with enough text\" do before(:each) do producto = Producto.new @carga = Carga.new(:descripcion => 'x' * 255, :content_type => 'x', :filename => 'amiMODEL', :size => 100.kilobytes, :producto_id => producto) end it \"should be saved\" do lambda { @carga.save }.should change(Carga, :count) end it \"should't have errors in the attribute descripcion, content_type and filename\" do @carga.should have(:no).error_on(:descripcion) @carga.should have(:no).error_on(:content_type) @carga.should have(:no).error_on(:filename) @carga.should have(:no).error_on(:size) end end describe Carga, \"with too much text\" do before(:each) do producto = Producto.new @carga = Carga.new(:descripcion => 'x' * 256, :producto_id => producto) end it \"should not be saved\" do lambda { @carga.save }.should_not change(Carga, :count) end it \"should have a length error in the attribute descripcion\" do @carga.should have(1).error_on(:descripcion) @carga.errors.on(:descripcion).should == \"es demasiado largo (el m\u00e1ximo es de 255 caracteres)\" end end Tabla 55: Pruebas Clase Carga, Iteraci\u00f3n 3. 126 A continuaci\u00f3n se incluyen pruebas realizadas sobre la clase Central que involucra la opci\u00f3n de Mantenimiento: Pruebas SPEC clase Mantenimiento en la tercera iteraci\u00f3n: describe Central do fixtures :productos, :centros, :usuarios, :extensiones, :mantenimientos, :numeros before(:each) do end it \"no deberia llamar si el sistema entra mantenimiento\" do Mantenimiento.empezar_mantenimiento Central.llamar(productos(:aba_1024_venta), usuarios(:operador_caracas), \"200.200.201.112\").should be_eql([nil, :sistema_en_mantenimineto]) end it \"deberia llamar si el sistema termina el mantenimiento\" do Mantenimiento.terminar_mantenimiento Central.llamar(productos(:aba_1024_venta), usuarios(:operador_caracas), \"200.200.201.112\").nil?.should be_false end end Tabla 56: Pruebas Clase Mantenimiento, Iteraci\u00f3n 3. El cliente prob\u00f3 las nuevas funcionalidades agregadas. En el caso de la funcionalidad de mantenimiento, se cambi\u00f3 de estado, mientras hab\u00edan varias llamadas en curso, las cuales continuaron y a la hora de volver a llamar les lanz\u00f3 un mensaje de error, lo que califica como aprobada la prueba del cliente. Para la carga de data en el sistema, se realizaron varias pruebas con distintos archivos, probando archivos con datos desde 15 a 4500 filas, comportandose bien 127 ante los casos borde, tales como n\u00fameros repetidos, error en la data, entre otros. Dichos datos vienen en un archivo de la siguiente manera: Tabla 6: Ejemplo de Archivo de datos. A continuaci\u00f3n se muestran las pantallas que fueron \u00fatilizadas durante las distintas pruebas del usuario de esta iteraci\u00f3n. \u2022 A continuaci\u00f3n se muestra la pantalla de la aplicaci\u00f3n donde al usuario Administrador se le permite activar el modo \u201cMantenimiento\u201d en la aplicaci\u00f3n: 128 Gr\u00e1fico 13: Prueba Aceptaci\u00f3n, Pantalla Administrador (Modo Mantenimiento). Fuente: Autor \u2022 El siguiente gr\u00e1fico muestra la pantalla que utiliza el usuario Validador, que le permite cargar un archivo de nueva data para la base de datos de clientes: Gr\u00e1fico 14: Prueba Aceptaci\u00f3n, Pantalla Validador (Cargar Archivo). Fuente: Autor Feedback Luego de la aplicaci\u00f3n de pruebas el cliente certific\u00f3 las funcionalidades agregadas y pidi\u00f3 que el algoritmo de carga en el sistema se realizar\u00e1 en segundo plano previendo que los archivos de datos fueran muy grandes. 129 Iteraci\u00f3n 4 Fecha de inicio: 01-10-2007 \u2022 En la cuarta iteraci\u00f3n se refactoriz\u00f3 la funcionalidad incluida en la segunda iteraci\u00f3n de consulta de estado de una extensi\u00f3n de Asterisk. Planificaci\u00f3n Requerimientos que fueron desarrollados en la cuarta iteraci\u00f3n: \u2022 Refactorizar el c\u00f3digo de la actualizaci\u00f3n de estatus de la aplicaci\u00f3n. Reemplazando las peticiones AMI a la recepci\u00f3n y manipulaci\u00f3n de los eventos AMI generados por Asterisk. Dise\u00f1o En el siguiente diagrama se muestra la clase que fue desarrollada para la soluci\u00f3n de la tarea en cuesti\u00f3n. Gr\u00e1fico 15: Diagrama de Clases, Iteraci\u00f3n 4. Fuente: Autor 130 Codificaci\u00f3n Se muestra a continuaci\u00f3n el c\u00f3digo fuente de la funci\u00f3n extension_status de la clase AmiLogic, encargada de toda la l\u00f3gica de la actualizaci\u00f3n del estatus de una extensi\u00f3n, tanto del estado de uso (inactiva, activa, sonando, no disponible), como del estado de monitoreo (espiada, espiando, no espiada). C\u00f3digo fuente de la clase AmiLogic, es la clase donde llegan los eventos generados por Asterisk: class AmiLogic < Telegraph::AMIHandler # Funcion que se dispara cuando existe un cambio de estado en # alguna extension de asterisk def extension_status #STATUS POSIBLES # 0: Arriba / inactiva | Idle # 1: Arriba / activa o llamando | In Use # 4: Abajo | Unavailable # 8: Arriba / sonando | Ringing unless ((exten = Extension.find_by_numero(params[:exten])).nil?) begin exten.state = Extension.find_human_state(params[:status]) if (exten.state == 'Ociosa') if exten.espiada? exten1 = Extension.find_by_numero(exten.espiada_por) exten1.espiando_a = nil exten1.save! Central.finalizar_llamada(exten1.numero) exten.espiada_por = nil elsif exten.espiando? exten1 = Extension.find_by_numero(exten.espiando_a) exten1.espiada_por = nil exten1.save! exten.espiando_a = nil end end 131 exten.save! rescue Exception => e logger.error(\"Cambio de Status de Extension: Error al cambiar de status a la extensi\u00f3n (#{params[:exten]}).\") logger.error(\"Detalle del error: (#{e.to_s}).\") end else logger.warn(\"Cambio de Status de Extension: No se encontr\u00f3 la extensi\u00f3n (#{params[:exten]}) registrada en el sistema.\") end end end Tabla 57: Clase AmiLogic Iteraci\u00f3n 4. Pruebas Se codificaron una serie de pruebas de comportamiento con el plugin rspec, que fueron aplicadas a las clase AmiLogic, al igual que se realizaron pruebas de aceptaci\u00f3n del requerimiento. Se simul\u00f3 el sistema PBX Asterisk a trav\u00e9s de un stub para las pruebas de cambio de estado de monitoreo. Pruebas SPEC sobre la clase AmiLogic y Central, donde se simul\u00f3 el comportamiento de Asterisk a trav\u00e9s de objetos STUB: describe Central do it \"deberia quedar igual el status de las extensiones (0- espiada y 0-espiando) (dado que la respuesta es de unos canales vacios, ninguna extension deberia ser espiada ni espiando)\" do exten1 = extensiones(:exten_operador_caracas_2) exten2 = extensiones(:exten_supervisor_caracas_1) exten1.espiada?.should be(false) exten2.espiando?.should be(false) 132 a = Telegraph::AsteriskResponse.new a.results = \"Channel Location State Application(Data) \\n0 active channels\\n0 active calls\\n\" Central.stub!(:cli_command).and_return(a) Central.actualizar_espio_extension_channels(exten1.numero) exten1.reload exten1.espiada?.should be(false) Central.actualizar_espio_extension_channels(exten2.numero) exten2.reload exten2.espiando?.should be(false) end it \"deberia actualizar el status de las extensiones (dado que la respuesta es de una extension espiada, una extension debera ser espiada y la otra espiando)\" do exten1 = extensiones(:exten_operador_caracas_2) exten2 = extensiones(:exten_supervisor_caracas_1) exten1.espiada?.should be(false) exten2.espiando?.should be(false) a = Telegraph::AsteriskResponse.new a.results = \"Channel Location State Application(Data) \\nSIP/0112-08b54440 (None) Up Bridged Call(Local/0112@defaul\\nLocal/0112@default-5 s@macro-dial:10 Up Dial(SIP/0112||tr) \\nLocal/1121@default-5 s@default:1 Up ChanSpy(sip/1115|q) \\nZap/1-1 s@from-zaptel:1 Up Bridged Call(SIP/0133-08b7aae0\\nSIP/0133-08b7aae0 s@macro-dialout-trun Up Dial(ZAP/1/2424379|300|) \\n5 active channels\\n2 active calls\\n\" Central.stub!(:cli_command).and_return(a) Central.actualizar_espio_extension_channels(exten1.numero) exten1.reload exten1.espiada?.should be(true) Central.actualizar_espio_extension_channels(exten2.numero) exten2.reload exten2.espiando?.should be(true) end end describe AmiLogic, \"Events that change extensions states\" do fixtures :extensiones it \"should change the extension 1112 state from Ociosa to En uso\" do @ami_event_handler = AmiLogic.new({:exten => '1112', :status => '1'}) @extension = extensiones(:exten_operador_caracas) @extension.state.should be_eql(\"Ociosa\") @ami_event_handler.extension_status @extension.reload 133 @extension.state.should be_eql(\"En uso\") end it \"should change the extension 2112 state from No disponible to Ociosa\" do @ami_event_handler = AmiLogic.new({:exten => '2112', :status => '0'}) @extension = extensiones(:exten_operador_maracay) @extension.state.should be_eql(\"No disponible\") @ami_event_handler.extension_status @extension.reload @extension.state.should be_eql(\"Ociosa\") end it \"should change the extension 2112 state from No disponible to En uso\" do @ami_event_handler = AmiLogic.new({:exten => '2112', :status => '1'}) @extension = extensiones(:exten_operador_maracay) @extension.state.should be_eql(\"No disponible\") @ami_event_handler.extension_status @extension.reload @extension.state.should be_eql(\"En uso\") end it \"should change the extension 2112 state from No disponible to Repicando\" do @ami_event_handler = AmiLogic.new({:exten => '2112', :status => '8'}) @extension = extensiones(:exten_operador_maracay) @extension.state.should be_eql(\"No disponible\") @ami_event_handler.extension_status @extension.reload @extension.state.should be_eql(\"Repicando\") end end Tabla 58: Pruebas Clase Central y AmiLogic Iteraci\u00f3n 4. El cliente prob\u00f3 el requerimiento cambiando de estatus una extensi\u00f3n y verificando en la aplicaci\u00f3n el estatus de la misma. Se realizaron varias pruebas con la aplicaci\u00f3n funcionando establemente con el cambio. 134 Feedback Al llevar el cambio a producci\u00f3n, el cliente inform\u00f3 que tanto el performance como la estabilidad de la aplicaci\u00f3n mejoraron notablemente, reduciendo sustancialmente el n\u00famero de peticiones desde la aplicaci\u00f3n hacia Asterisk. 135 CAP\u00cdTULO IV CONCLUSIONES Y RECOMENDACIONES El proyecto culmin\u00f3 con la puesta en producci\u00f3n de una aplicaci\u00f3n que combina el \u00e1mbito Web y la tecnolog\u00eda de voz sobre IP (VoIP), conectandolos a trav\u00e9s de un m\u00f3dulo desarrollado seg\u00fan los principios de las metodolog\u00edas \u00e1giles. Con esto se cumpli\u00f3 el objetivo principal del estudio dando como fruto una herramienta que automatiz\u00f3 el proceso de mercadeo de productos y servicios empresariales. Actualmente, la aplicaci\u00f3n desarrollada se est\u00e1 utilizando para implementar centros de llamadas telef\u00f3nicas automatizados, donde se tienen operadores que contactan a los potenciales clientes v\u00eda telef\u00f3nica. Supervisores que monitorean el tr\u00e1fico de las llamadas y usuarios validadores que ingresan nuevos datos al sistema, ampliando as\u00ed la base de datos de posibles clientes. En el proyecto se utiliz\u00f3 la central telef\u00f3nica Asterisk, que es un PBX orientado hacia el desarrollo de sistemas automatizados de voz. \u00c9ste a pesar de manejar su lenguaje de scripting interno, brinda la posibilidad de intercambio de datos con entes externos que pudieran intervenir en el flujo de los procesos del PBX, bien sea modificando el curso de una llamada, activando funciones propias o recolectando informaci\u00f3n que manda el PBX para procesarla y/o almacenarla. En este estudio la aplicaci\u00f3n desarrollada es un ente externo de Asterisk que se comunica por una interfaz llamada Asterisk Manager Interface (AMI), bien sea 136 activando funciones de Asterisk o interpretando mensajes enviados por dicha central telef\u00f3nica. Cabe destacar que el papel de la herramienta conectora entre la tecnolog\u00eda VoIP del PBX Asterisk y framework Ruby on Rails, llamada Telegraph, fue fundamental en el desarrollo de la aplicaci\u00f3n ya que facilit\u00f3 el uso de las interfaces que provee Asterisk para la comunicaci\u00f3n. Esto redujo los tiempos de desarrollo considerablemente ya que gran parte de la comunicaci\u00f3n a bajo nivel se encontraba implementado en la herramienta conectora. Por su parte, el uso de Ruby on Rails permiti\u00f3 el desarrollo de una aplicaci\u00f3n de calidad de manera \u00e1gil, vali\u00e9ndose de su sencilla organizaci\u00f3n de las piezas y componentes, tales como Action Pack, Active Record y Plugins, estos \u00faltimos muy \u00fatiles ya que existe una gran gama de ellos en la Web brindando soluci\u00f3n a problemas cuyo desarrollo pudiera llevar gran cantidad de horas de dise\u00f1o e implementaci\u00f3n. En el \u00e1mbito tecnol\u00f3gico de la investigaci\u00f3n realizada se puede concluir que al pasar el tiempo las t\u00e9cnicas de desarrollo son cada vez m\u00e1s refinadas permitiendo as\u00ed el desarrollo \u00e1gil de aplicaciones manteniendo la calidad, enfoc\u00e1ndose cada vez m\u00e1s en los requerimientos del cliente, por lo cual se pudiera inferir que en el futuro las aplicaciones ser\u00e1n orientadas a satisfacer las demandas del cliente de la mejor manera posible. Al aplicar programaci\u00f3n extrema como proceso de desarrollo, se observ\u00f3 el ahorro de tiempo de las etapas de la implementaci\u00f3n con respecto a experiencias pasadas. Este proceso de desarrollo se debe usar cuando el cliente necesita obtener 137 resultados r\u00e1pidamente, mas para lograr esta acometida es necesario aplicar y adaptar correctamente las pr\u00e1cticas que propone la especificaci\u00f3n del proceso de desarrollo. Otro aspecto fundamental en la aplicaci\u00f3n de la metodolog\u00eda XP es tener al cliente lo m\u00e1s involucrado posible con el desarrollo y validar cada una de las soluciones implementadas a las tareas descritas a trav\u00e9s de pruebas de aceptaci\u00f3n, lo cual es muy importante ya que es una medida confiable del avance del proyecto. La utilizaci\u00f3n del proceso de desarrollo XP en este estudio brindo muchos beneficios, entre los cuales tenemos la entrega oportuna al cliente de requerimientos establecidos, la prueba de cada algoritmo implementado, el enfoque en el desarrollo de los requerimientos, entre otros. Es prudente mencionar que el desarrollo del proyecto fue basado en la filosof\u00eda de desarrollo orientado a pruebas. Un porcentaje importante de las soluciones fueron implementadas luego de haber codificado las pruebas, tal como lo describe la t\u00e9cnica BDD, lo que garantiza robustez en el producto realizado. Los algoritmos codificados fueron sometidos a pruebas antes, durante y despu\u00e9s de finalizada la realizaci\u00f3n y/o modificaci\u00f3n en la implementaci\u00f3n de los mismos. Con respecto al \u00e1rea de las telecomunicaciones e inform\u00e1tica, se puede afirmar que pareciera estrecharse la l\u00ednea de separaci\u00f3n entre \u00e9stas. En la actualidad es complicado hablar de un desarrollo completamente telef\u00f3nico, porque las telecomunicaciones se encuentran ligadas con la inform\u00e1tica a tal punto que en la mayor\u00eda de los casos se utilizan algoritmos para llevar a cabo ciertas tareas. Los desarrolladores est\u00e1n empezando a incursionar en el \u00e1rea de telecomunicaciones y 138 viceversa, lo que pudiera resultar en un extenso desarrollo de las aplicaciones VoIP a nivel mundial. Para futuros desarrollos donde se aplicar\u00e1 la metodolog\u00eda XP, es recomendable definir claramente el alcance del proyecto y de cada requerimiento, sustent\u00e1ndolos contra los requerimientos, tareas o historias de usuarios seg\u00fan sea hecha la adaptaci\u00f3n de XP. Esto sin perder la flexibilidad y adaptabilidad que brinda el proceso de desarrollo ante posibles cambios. Se recomienda estudiar a fondo el funcionamiento de las herramientas que se vean involucradas en el proyecto, ya que ese tiempo de an\u00e1lisis puede resultar en ahorro de tiempo y costos. Este punto se ve reflejado en este estudio cuando se tom\u00f3 la decisi\u00f3n de cambiar de herramienta conectora de Adhearsion a Telegraph debido a la adaptaci\u00f3n de la herramienta en la soluci\u00f3n realizada. En este caso Telegraph prevaleci\u00f3 ya que es un plugin para Ruby on Rails, framework en el que se desarroll\u00f3 la aplicaci\u00f3n. Tambi\u00e9n se debe tomar en cuenta, sobre el tiempo de entrega del producto, la curva de aprendizaje que pudiera tener cada programador en caso de que los mismos no posean total dominio de las tecnolog\u00edas a ser usadas durante el proceso de desarrollo. 139 REFERENCIAS \u2022 [About \"A Guide to Testing the Rails\" (2007)].[P\u00e1gina Web en l\u00ednea]. Disponible: http://manuals.rubyonrails.com/read/book/5 [Consulta: 2007, diciembre 20] \u2022 [Acerca de Ruby (2007)]. [P\u00e1gina Web en l\u00ednea]. Disponible: http://www.ruby-lang.org/es/about [Consulta: 2008, enero 10] \u2022 [Active Record (2006)]. [Documento en l\u00ednea]. Disponible: http://www.martinfowler.com/eaaCatalog/activeRecord.html [Consulta: 2007, noviembre 2] \u2022 [Active Record (2007)]. [P\u00e1gina Web en l\u00ednea]. Disponible: http://wiki.rubyonrails.org/rails/pages/ActiveRecord [Consulta: 2007, noviembre 5] \u2022 [Adhearsion (2007)]. [P\u00e1gina Web en l\u00ednea]. Disponible: http://adhearsion.com/ [Consulta: 2007, diciembre 29] \u2022 [Agile Alliance (2001)]. [P\u00e1gina Web en l\u00ednea]. Disponible : http://www.agilealliance.org/ [Consulta: 2007, septiembre 17] \u2022 [AAB (1998)]. Anderson A, Beattie R, Beck K, Bryant D, DeArment M, Fowler M, Fronczak M, Garzaniti R, Gore D, Hacker B, Handrickson C, Jeffries R, Joppie D, Kim D, Kowalsky P, Mueller D, Murasky T, Nutter R, Pantea A y Thomas D (1998).Chrysler Goes to \"Extremes\". Case Study. En Agile software development methods [Libro en l\u00ednea] Disponible: http://www.inf.vtt.fi/pdf/publications/2002/P478.pdf. [Consulta: 2007, septiembre 17] 140 \u2022 [Asterisk AGI (2003)]. [P\u00e1gina Web en l\u00ednea]. Disponible: http://www.voip-info.org/wiki-Asterisk+AGI [Consulta: 2007, noviembre 20] \u2022 [Asterisk channels (2003)]. [P\u00e1gina Web en l\u00ednea]. Disponible: http://www.voip-info.org/wiki/view/Asterisk+channels [Consulta: 2008, enero 10] \u2022 [Asterisk Dialplan Introduction (2003)]. [P\u00e1gina Web en l\u00ednea]. Disponible: http://www.voip-info.org/wiki-Asterisk+Dialplan+Introduction [Consulta: 2008, enero 10] \u2022 [AMAPI (2003)] Asterisk manager API (2003). [P\u00e1gina Web en l\u00ednea]. Disponible: http://www.voip-info.org/wiki/view/Asterisk+manager+API [Consulta: 2007, noviembre 22] \u2022 [AME (2003)] Asterisk manager events (2003). [P\u00e1gina Web en l\u00ednea]. Disponible: http://www.voip-info.org/wiki/view/asterisk+manager+events [Consulta: 2008, enero 05] \u2022 [Barrios M. (2005)]. Manual de Trabajos de Grado de Especializaci\u00f3n y Maestr\u00eda y Tesis Doctorales. Universidad Pedag\u00f3gica Experimental Libertador, Caracas, Venezuela. \u2022 [Beck, K. (1999-a)]. Embracing Change With Extreme Programming. IEEE Computer 32, Estados Unidos. \u2022 [Beck, K. (1999-b)]. Extreme programming explained: Embrace change. Addisson-Wesley, Estados Unidos. 141 \u2022 [Behaviour Driven Development (2007, diciembre 23)]. [P\u00e1gina Web en l\u00ednea]. Disponible: http://behaviour-driven.org/ [Consulta: 2007, diciembre 28] \u2022 [Dave Astels (2007)]. A New Look at Test Driven Development [Documento en l\u00ednea]. Disponible: http://blog.daveastels.com/2005/07/05/a-new-look-at-test-driven- development [Consulta: 2007, diciembre 28] \u2022 [Fowler, Martin. (2004, mayo)]. Is Design Dead? [Art\u00edculo en l\u00ednea]. Disponible: http://martinfowler.com/articles/designDead.html [Consulta: 2007, diciembre 01] \u2022 [Fowler, Martin. (2006, julio)]. Writing The Agile Manifesto. [Art\u00edculo en l\u00ednea]. Disponible: http://martinfowler.com/articles/agileStory.html [Consulta: 2007, septiembre 01] \u2022 [GNU (2007, noviembre 01)]. The Free Software Definition. [P\u00e1gina Web en l\u00ednea]. Disponible: http://www.gnu.org/philosophy/free-sw.html [Consulta: 2007, noviembre 05] \u2022 [GDD (2005)] Gomillion D y Dempster B (2005). Building Telephony Systems with Asterisk. Packt Publishing Ltd. 32 Lincoln Road Olton Birmingham, B27 6PA, UK. \u2022 [HAML (2007)]. [P\u00e1gina Web en l\u00ednea]. Disponible: http://haml.hamptoncatlin.com/ [Consulta: 2007, diciembre 20] \u2022 [Introducing Test/Unit (2007)]. [P\u00e1gina Web en l\u00ednea]. Disponible: http://manuals.rubyonrails.com/read/chapter/21 [Consulta: 2007, diciembre 27] 142 \u2022 [JRA (2001)]. Jeffries R, Anderson A y Hendrickson C (2001). Extreme Programming Installed. En Agile software development methods [Libro en l\u00ednea] Disponible: http://www.inf.vtt.fi/pdf/publications/2002/P478.pdf. [Consulta: 2007, septiembre 17] \u2022 [MAS (2001)]. Manifesto for Agile Software Development (2001) [Documento en l\u00ednea]. Disponible: http://www.agilemanifesto.org/ [Consulta: 2007, septiembre 17] \u2022 [Martin, R (2002)]. Continuos Care vs. Initial Design [Art\u00edculo en l\u00ednea]. Disponible: http://www.agilealliance.org/system/article/file/833/file.pdf. [Consulta: 2007, septiembre 01] \u2022 [MJS (2005)]. Meggelen J, Smith J y Madsen L (2005). Asterisk: The Future of Telephony O\u2019Reilly Media, Inc., Estados Unidos. \u2022 [Miller, M. (2001)]. Writing The Agile Manifesto. [Libro en l\u00ednea]. Disponible: http://martinfowler.com/articles/agileStory.html [Consulta: 2007, noviembre 01] \u2022 [Models (2006)]. [P\u00e1gina Web en l\u00ednea]. Disponible: http://wiki.rubyonrails.org/Rails/pages/Models [Consulta: 2007, noviembre 10] \u2022 [Plugins (2006)]. [P\u00e1gina Web en l\u00ednea]. Disponible: http://wiki.rubyonrails.org/rails/pages/Plugins [Consulta: 2007, diciembre 20] \u2022 [Rspec (2008)]. [P\u00e1gina Web en l\u00ednea]. Disponible: http://rspec.info/rdoc/index.html [Consulta: 2007, diciembre 27] 143 \u2022 [RSpec Doc (2007)]. [P\u00e1gina Web en l\u00ednea]. Disponible: http://rspec.info/documentation/ [Consulta: 2007, diciembre 28] \u2022 [RubyGems Manual (2007)]. [P\u00e1gina Web en l\u00ednea]. Disponible: http://rubygems.org/read/book/1 [Consulta: 2007, diciembre 20] \u2022 [Telegraph (2007)]. [P\u00e1gina Web en l\u00ednea]. Disponible: http://telegraph.rubyforge.org/Home.html [Consulta: 2007, enero 6] \u2022 [Telegraph Documentation (2007)]. [P\u00e1gina Web en l\u00ednea]. Disponible: http://telegraph.rubyforge.org/wiki/wiki.pl [Consulta: 2008, enero 2] \u2022 [TDH (2006)]. Thomas D., Heinemeier D, Breedt L., Clark M., Duncan J., Gehtland J., y Andreas Schwarz (2006). Agile Web Development with Rails: Second Edition, 2nd Edition. The Pragmatic Bookshelf, Estados Unidos. \u2022 [UsingAMI (2007)]. [P\u00e1gina Web en l\u00ednea]. Disponible: http://telegraph.rubyforge.org/wiki/wiki.pl?UsingAMI [Consulta: 2007, noviembre 12] \u2022 [Wikipedia (2007, diciembre 17)]. Behavior Driven Development [P\u00e1gina Web en l\u00ednea]. Disponible: http://en.wikipedia.org/wiki/Behavior_driven_development [Consulta: 2007, noviembre 15] \u2022 [Wikipedia (2007, julio 8)]. Manifiesto \u00c1gil [P\u00e1gina Web en l\u00ednea]. Disponible: http://es.wikipedia.org/wiki/Manifiesto_%C3%A1gil. [Consulta: 2007, octubre 05] \u2022 [Wikipedia (2007, octubre 6)]. Modelo Vista Controlador [P\u00e1gina Web en 144 l\u00ednea]. Disponible: http://es.wikipedia.org/wiki/Modelo_Vista_Controlador [Consulta: 2007, noviembre 10] \u2022 [Wikipedia (2007, diciembre 31)]. Plugin [P\u00e1gina Web en l\u00ednea]. Disponible: http://es.wikipedia.org/wiki/Plugin [Consulta: 2007, diciembre 20] \u2022 [Wikipedia (2007, julio 7)]. Programaci\u00f3n Extrema [P\u00e1gina Web en l\u00ednea]. Disponible: http://es.wikipedia.org/wiki/Programaci%C3%B3n_Extrema. [Consulta: 2007, agosto 21] \u2022 [Wikipedia (2007, diciembre 20)]. Pruebas de Software [P\u00e1gina Web en l\u00ednea]. Disponible: http://es.wikipedia.org/wiki/Pruebas_de_software [Consulta: 2007, diciembre 15] \u2022 [Wikipedia (2008, enero 2)]. Ruby [P\u00e1gina Web en l\u00ednea]. Disponible: http://es.wikipedia.org/wiki/Ruby [Consulta: 2008, enero 10] \u2022 [Wikipedia (2007, diciembre 7)]. Ruby on Rails [P\u00e1gina Web en l\u00ednea]. Disponible: http://es.wikipedia.org/wiki/Ruby_on_Rails [Consulta: 2007, diciembre 18] \u2022 [Wikipedia (2007, marzo 30)]. RubyGems [P\u00e1gina Web en l\u00ednea]. Disponible: http://es.wikipedia.org/wiki/RubyGems [Consulta: 2007, diciembre 20] \u2022 [Wikipedia (2008, mayo 7)]. Softphone [P\u00e1gina Web en l\u00ednea]. Disponible: http://es.wikipedia.org/wiki/Softphone. [Consulta: 2008, mayo 7] \u2022 [Wikipedia (2008, enero 5)]. Software Libre [P\u00e1gina Web en l\u00ednea]. 145 Disponible: http://es.wikipedia.org/wiki/Software_libre. [Consulta: 2008, enero 10] \u2022 [Wikipedia (2008, enero 17)]. Test-driven development [P\u00e1gina Web en l\u00ednea]. Disponible: http://en.wikipedia.org/wiki/Test-driven_development. [Consulta: 2008, enero 10] 146 CONTACTOS A continuaci\u00f3n se plasman los datos de contacto del presente Trabajo Especial de Grado: Nombres: Carlos Augusto Apellidos: Garc\u00eda Mujica Direcci\u00f3n de Correo: carlosve.ucv@gmail.com Nombre: Edgar Apellido: Gonz\u00e1lez Cargo: Profesor de la Escuela de Computaci\u00f3n de la Facultad de Ciencias UCV. Direcci\u00f3n de Correo: edgargonzalez@gmail.com. 147 ANEXOS Glosario de t\u00e9rminos \u2022 AJAX: acr\u00f3nimo de Asynchronous JavaScript And XML, es una t\u00e9cnica de desarrollo Web para crear aplicaciones interactivas o RIA (Rich Internet Applications). \u00c9stas se ejecutan en el cliente, es decir, en el navegador de los usuarios y mantiene comunicaci\u00f3n as\u00edncrona con el servidor en segundo plano. De esta forma es posible realizar cambios sobre la misma p\u00e1gina sin necesidad de recargarla. \u2022 API: del ingl\u00e9s Application Programming Interface - Interfaz de Programaci\u00f3n de Aplicaciones, es el conjunto de funciones y procedimientos (o m\u00e9todos si se refiere a programaci\u00f3n orientada a objetos) que ofrece cierta librer\u00eda para ser utilizado por otro software como una capa de abstracci\u00f3n. \u2022 Blog: en espa\u00f1ol tambi\u00e9n una bit\u00e1cora, es un sitio Web peri\u00f3dicamente actualizado que recopila cronol\u00f3gicamente textos o art\u00edculos de uno o varios autores, apareciendo primero el m\u00e1s reciente, donde el autor conserva siempre la libertad de dejar publicado lo que crea pertinente. \u2022 Digital Signal Processing (DSP): Es un dispositivo capaz de interpretar, procesar y modificar se\u00f1ales provenientes de distintas fuentes. \u2022 Framework: En el desarrollo de software, un framework es una estructura de soporte definida en la cual otro proyecto de software puede ser organizado y desarrollado. T\u00edpicamente, un framework puede incluir soporte de programas, bibliotecas y un lenguaje interpretado entre otros 148 softwares para ayudar a desarrollar y unir los diferentes componentes de un proyecto. \u2022 Gateway: en inform\u00e1tica corresponde a un dispositivo cap\u00e1z de conectar redes de distinto protocolo o protocolos incompatibles, funcionando como intermediario permitiendo la comunicaci\u00f3n. \u2022 GNU: proyecto iniciado por Richard Stallman con el objetivo de crear un sistema operativo completamente libre: el sistema GNU . \u2022 GPL: (Licencia P\u00fablica General) es una licencia creada por la Free Software Foundation, y est\u00e1 orientada principalmente a proteger la libre distribuci\u00f3n, modificaci\u00f3n y uso de software. \u2022 Hacker: es el neologismo utilizado para referirse a un experto en varias o alguna rama t\u00e9cnica relacionada con la inform\u00e1tica: programaci\u00f3n, redes de computadoras, sistemas operativos, hardware de red/voz, entre otros. \u2022 IAX: AX (Inter-Asterisk eXchange protocol) es uno de los protocolos utilizado por Asterisk. Es utilizado para manejar conexiones VoIP entre servidores Asterisk, y entre servidores y clientes que tambi\u00e9n utilizan protocolo IAX. \u2022 Java: es un lenguaje de programaci\u00f3n orientado a objetos desarrollado por Sun Microsystems a principios de los a\u00f1os 1990. El lenguaje en s\u00ed mismo toma mucha de su sintaxis de C y C++, pero tiene un modelo de objetos m\u00e1s simple y elimina herramientas de bajo nivel como punteros. \u2022 JavaScript: es un lenguaje de programaci\u00f3n interpretado, es decir, que no requiere compilaci\u00f3n, utilizado principalmente en p\u00e1ginas Web, con una sintaxis semejante a la del lenguaje Java y el lenguaje C. 149 \u2022 Lenguajes de Script: es un lenguaje de programaci\u00f3n que fue dise\u00f1ado para ser ejecutado por medio de un int\u00e9rprete, en contraste con los lenguajes compilados. \u2022 Productividad: Tambi\u00e9n conocido como eficiencia es gen\u00e9ricamente entendida como la relaci\u00f3n entre la producci\u00f3n obtenida por un sistema de producci\u00f3n o servicios y los recursos utilizados para obtenerla. Tambi\u00e9n puede ser definida como la relaci\u00f3n entre los resultados y el tiempo utilizado para obtenerlos: cuanto menor sea el tiempo que lleve obtener el resultado deseado, m\u00e1s productivo es el sistema. \u2022 PSTN: La Red Telef\u00f3nica Conmutada (PSTN en ingl\u00e9s) es una red de comunicaci\u00f3n dise\u00f1ada primordialmente para la transmisi\u00f3n de voz, aunque pueda tambi\u00e9n transportar datos, por ejemplo en el caso del fax o de la conexi\u00f3n a Internet a trav\u00e9s de un m\u00f3dem ac\u00fastico. \u2022 RSDI: Seg\u00fan la UIT-T podemos definir Red Digital de Servicios Integrados (RDSI o ISDN en ingl\u00e9s) como: una red que procede por evoluci\u00f3n de la Red Digital Integrada (RDI) y que facilita conexiones digitales extremo a extremo para proporcionar una amplia gama de servicios, tanto de voz como de otros tipos, y a la que los usuarios acceden a trav\u00e9s de un conjunto de interfaces normalizados. \u2022 SIP: Session Initiation Protocol (SIP o Protocolo de Inicio de Sesiones) es un protocolo desarrollado por el IETF MMUSIC Working Group con la intenci\u00f3n de ser el est\u00e1ndar para la iniciaci\u00f3n, modificaci\u00f3n y finalizaci\u00f3n de sesiones interactivas de usuario donde intervienen elementos multimedia como el video, voz, mensajer\u00eda instant\u00e1nea, juegos online y realidad virtual. 150 \u2022 Softphone: es un software que hace una simulaci\u00f3n de tel\u00e9fono convencional por computadora. Es decir, permite usar la computadora para hacer llamadas a otros softphones o a otros tel\u00e9fonos convencionales. \u2022 TCP/IP: La familia de protocolos de Internet es un conjunto de protocolos de red en la que se basa Internet y que permiten la transmisi\u00f3n de datos entre redes de computadoras. En ocasiones se la denomina conjunto de protocolos TCP/IP, en referencia a los dos protocolos m\u00e1s importantes que la componen: Protocolo de Control de Transmisi\u00f3n (TCP) y Protocolo de Internet (IP), que fueron los dos primeros en definirse, y que son los m\u00e1s utilizados de la familia. \u2022 URI: es una cadena corta de caracteres que identifica inequ\u00edvocamente un recurso (servicio, p\u00e1gina, documento, direcci\u00f3n de correo electr\u00f3nico, enciclopedia, etc). Normalmente estos recursos son accesibles en una red o sistema. \u2022 URL: significa Uniform Resource Locator, es decir, localizador uniforme de recurso. Es una secuencia de caracteres, de acuerdo a un formato est\u00e1ndar, que se usa para nombrar recursos, como documentos e im\u00e1genes en Internet, por su localizaci\u00f3n. \u2022 VoIP: Voz sobre Protocolo de Internet, tambi\u00e9n llamado Voz sobre IP, VozIP, VoIP (por sus siglas en ingl\u00e9s), o Telefon\u00eda IP, es un grupo de recursos que hacen posible que la se\u00f1al de voz viaje a trav\u00e9s de Internet empleando un protocolo IP (Internet Protocol). Esto significa que se env\u00eda la se\u00f1al de voz en forma digital en paquetes en lugar de enviarla (en forma digital o anal\u00f3gica) a trav\u00e9s de circuitos utilizables solo para telefon\u00eda como una compa\u00f1\u00eda telef\u00f3nica convencional o PSTN. 151 \u2022 XMPP: siglas inglesas de eXtensible Messaging and Presence Protocol (Protocolo ampliable de mensajer\u00eda y [comunicaci\u00f3n de] presencia), es un protocolo abierto y ampliable basado en XML, originalmente ideado para mensajer\u00eda instant\u00e1nea. Anexo 1: Valores del Manifiesto \u00c1gil \u2022 Valorar m\u00e1s a los individuos y su interacci\u00f3n que a los procesos y las herramientas \u2022 Este principio es muy importante y no se puede malinterpretar su planteamiento. No plantea que los procesos no son importantes, es m\u00e1s generalmente comprenden una gu\u00eda de operaci\u00f3n, pero sin personas con el conocimiento t\u00e9cnico e incentivo adecuado, no producen resultados por m\u00e1s que los procesos se encuentren eficientes. \u2022 Se plantea que los procesos deber\u00edan adaptarse a la organizaci\u00f3n, a las personas y a los grupos de trabajo; no al rev\u00e9s. \u2022 Valorar m\u00e1s el software que funciona que la documentaci\u00f3n exhaustiva \u2022 Se deber\u00eda tener en cuenta el valor del trabajo por prototipos o por partes, ya que las entregas de funcionalidades ya elaboradas ofrece una retroalimentaci\u00f3n enriquecedora y estimulante, generando nuevas ideas y posibilidades que ser\u00edan muy complicadas concebir en un documento de requisitos hecho antes de comenzar a elaborar el proyecto. \u2022 Los documentos son soporte del an\u00e1lisis y dise\u00f1o y permiten la transferencia del conocimiento, registrando informaci\u00f3n hist\u00f3rica. El manifiesto no afirma que no hagan falta, sino plantea que son menos importantes que los productos que funcionan. \u2022 Entonces se afirma que los documentos no pueden sustituir, ni pueden 152 ofrecer la riqueza y generaci\u00f3n de valor que se logra con la comunicaci\u00f3n directa entre las personas y a trav\u00e9s de la interacci\u00f3n con los prototipos. \u2022 Valorar m\u00e1s la colaboraci\u00f3n con el cliente que la negociaci\u00f3n contractual \u2022 Como se observo en valores expuestos anteriormente, el manifiesto \u00e1gil plantea que el valor del resultado no es consecuencia de haber controlado una ejecuci\u00f3n conforme a procesos, sino de haber sido implementado directamente sobre el producto. Un contrato tampoco aporta mucho valor al producto, simplemente comprende una formalidad que establece l\u00edneas divisorias entre responsabilidades, que fija los referentes para posibles disputas contractuales entre cliente y proveedor. \u2022 En el desarrollo \u00e1gil se intenta incluir al cliente como un miembro m\u00e1s del equipo, integr\u00e1ndolo y aportando colaboraci\u00f3n en el grupo de trabajo, es por eso que los modelos por contrato no encajan es este tipo de m\u00e9todos. \u2022 Valorar m\u00e1s la respuesta al cambio que el seguimiento de un plan \u2022 Las pr\u00e1cticas \u00e1giles est\u00e1n especialmente indicadas para productos dif\u00edciles de definir con detalle en el principio, en entornos inestables, que tienen como factor inherente al cambio, que presentan una evoluci\u00f3n r\u00e1pida y continua, es por eso que la capacidad de respuesta a los cambios resulta un aporte de mayor valor que la elaboraci\u00f3n y cumplimiento una rigurosa planificaci\u00f3n. \u2022 Uno de los principales valores de la gesti\u00f3n \u00e1gil es la adaptaci\u00f3n y facilidad de respuesta al cambio; diferentes a los de la antigua gesti\u00f3n de proyectos que comprenden control y planificaci\u00f3n para evitar desviaciones sobre el plan. 153 Anexo2: Principios del Manifiesto \u00c1gil Tras los cuatro valores descritos anteriormente, los firmantes redactaron los siguientes lineamientos como principios del Manifiesto \u00c1gil: \u2022 Nuestra principal prioridad es satisfacer al cliente a trav\u00e9s de la entrega temprana y continua de software de valor. \u2022 Los requisitos cambiantes son bienvenidos, aunque lleguen tarde al desarrollo. Los procesos \u00e1giles explotan el cambio como ventaja competitiva para el cliente. \u2022 Entregar con frecuencia software que funcione, los periodos pueden variar de un par de semanas hasta un par de meses, prefiriendo los periodos breves. \u2022 Los clientes o expertos del negocio y los desarrolladores deben trabajar juntos de forma cotidiana a lo largo del proyecto. \u2022 Construir los proyectos en torno a individuos motivados, brind\u00e1ndoles la oportunidad y el respaldo que necesitan y d\u00e1ndoles confianza para que lleven a cabo la tarea. \u2022 La forma m\u00e1s eficiente y efectiva de hacer fluir la informaci\u00f3n de ida y vuelta dentro de un grupo de desarrollo es mediante la conversaci\u00f3n personalizada. \u2022 Software en funcionamiento es la principal medida del progreso. \u2022 Los procesos \u00e1giles promueven el desarrollo sostenible. Los patrocinadores, desarrolladores y usuarios deben mantener un ritmo constante en forma indefinida. \u2022 La atenci\u00f3n continua a la excelencia t\u00e9cnica y buen dise\u00f1o enaltece la agilidad. 154 \u2022 Simplicidad, arte de maximizar la cantidad de trabajo que no se hace, es esencial. \u2022 Las mejores arquitecturas, requisitos y dise\u00f1os emergen de equipos auto- organizados. \u2022 En intervalos regulares, el equipo reflexiona la forma de ser m\u00e1s efectivo para ajustar acordemente su conducta. 155 Anexo3: Proceso de la Programaci\u00f3n Extrema El ciclo de XP comprende cinco fases: Exploraci\u00f3n, Planeamiento, Iteraciones de Entregas, Producci\u00f3n, Mantenimiento y Muerte, como se muestran en la siguiente figura: Gr\u00e1fico 16: Anexo 3, Proceso de la programaci\u00f3n Extrema. Fuente: Beck, K. (1999-b) 156 Anexo4: Pr\u00e1cticas de la Programaci\u00f3n Extrema Las pr\u00e1cticas de la programaci\u00f3n extrema se pueden apreciar gr\u00e1ficamente en el siguiente gr\u00e1fico: Gr\u00e1fico 17: Anexo 4, Pr\u00e1cticas de la programaci\u00f3n Extrema. Fuente: Beck, K. (1999-b)", "document_id": 539584}]}, {"paragraphs": [{"qas": [{"question": "que es debian", "id": 320675, "answers": [{"answer_id": 331165, "document_id": 539585, "question_id": 320675, "text": "Debian GNU/Linux: Debian [16] es una distribuci\u00f3n del sistema operativo Linux y est\u00e1 compuesto de varios paquetes de software siguiendo la filosof\u00eda de software libre bajo la licencia GNU GPL.", "answer_start": 48839, "answer_end": 49031, "answer_category": null}], "is_impossible": false}, {"question": "que es GCC", "id": 320676, "answers": [{"answer_id": 331166, "document_id": 539585, "question_id": 320676, "text": "GCC (GNU Compiler Collection): Es un sistema de compilaci\u00f3n producido por el Proyecto GNU y usado como el compilador est\u00e1ndar por la mayor\u00eda de los sistemas operativos derivados de Unix, entre ellos Linux. Mayormente utilizado para compilar programas en lenguaje C/C++, pero tambi\u00e9n posee soporte para manejar otros lenguajes de programaci\u00f3n como Objective-C, Fortran, entre otros", "answer_start": 49595, "answer_end": 49975, "answer_category": null}], "is_impossible": false}, {"question": "que es wireshark", "id": 320677, "answers": [{"answer_id": 331167, "document_id": 539585, "question_id": 320677, "text": "Wireshark: Es un analizador de paquetes y protocolos de red usado para capturar y analizar el tr\u00e1fico en una red de computadoras. Com\u00fanmente usado para solucionar problemas en redes y en el desarrollo de protocolos de software y protocolos de comunicaci\u00f3n", "answer_start": 50829, "answer_end": 51084, "answer_category": null}], "is_impossible": false}, {"question": "que es ubuntu", "id": 320678, "answers": [{"answer_id": 331168, "document_id": 539585, "question_id": 320678, "text": "Ubuntu: Ubuntu [17] es una distribuci\u00f3n del sistema operativo Linux y basada en \"Debian\". Ubuntu se destaca por ser una de las m\u00e1s populares distribuciones de Linux usadas en computadores personales. Internet Systems Consortium (ISC)", "answer_start": 49032, "answer_end": 49265, "answer_category": null}], "is_impossible": false}, {"question": "que es DHCP", "id": 320674, "answers": [{"answer_id": 331164, "document_id": 539585, "question_id": 320674, "text": "DHCP es un protocolo definido en el RFC 2131 [1] que le permite a los equipos pertenecientes a una cierta red TCP/IP obtener par\u00e1metros de configuraci\u00f3n en forma autom\u00e1tica tales como direcci\u00f3n IP, m\u00e1scara de subred, puerta de enlace predeterminada, servidores de sistemas de nombres de dominio o Domain Name System (DNS), entre otros. ", "answer_start": 24329, "answer_end": 24665, "answer_category": null}], "is_impossible": false}], "context": "Universidad Central de Venezuela Facultad de Ciencias Escuela de Computaci\u00f3n Laboratorio de Redes M\u00f3viles, Inal\u00e1mbricas y Distribuidas (ICARO) 1. 2. 3. Trabajo Especial de Grado presentado ante la Ilustre Universidad Central de Venezuela por el Bachiller: David Rubel C.I.: 17.124.006 E-mail: davidrubels@gmail.com para optar al t\u00edtulo de Licenciado en Computaci\u00f3n Tutora: Profa. Mar\u00eda Elena Villapol Octubre, 2012. Implementaci\u00f3n de un Sistema del Protocolo de Configuraci\u00f3n Din\u00e1mica de Hosts con Mensajes de Autenticaci\u00f3n 2 Universidad Central de Venezuela Facultad de Ciencias Escuela de Computaci\u00f3n Laboratorio de Comunicaci\u00f3n y Redes ACTA DEL VEREDICTO Quienes suscriben, Miembros del Jurado designado por el Consejo de la Escuela de Computaci\u00f3n para examinar el Trabajo Especial de Grado, presentado por el Bachiller David Rubel Salas C.I.: 17.124.006, con el t\u00edtulo \u201cImplementaci\u00f3n de un Sistema del Protocolo de Configuraci\u00f3n Din\u00e1mica de Hosts con Mensajes de Autenticaci\u00f3n\u201d, a los fines de cumplir con el requisito legal para optar al t\u00edtulo de Licenciado en Computaci\u00f3n, dejan constancia de lo siguiente: Le\u00eddo el trabajo por cada uno de los Miembros del Jurado, se fij\u00f3 el d\u00eda 31 de Octubre de 2012, a la 1 PM, para que sus autores lo defendieran en forma p\u00fablica, en Sala PB3, lo cual estos realizaron mediante una exposici\u00f3n oral de su contenido, y luego respondieron satisfactoriamente a las preguntas que les fueron formuladas por el Jurado, todo ello conforme a lo dispuesto en la Ley de Universidades y dem\u00e1s normativas vigentes de la Universidad Central de Venezuela. Finalizada la defensa p\u00fablica del Trabajo Especial de Grado, el jurado decidi\u00f3 aprobarlo. En fe de lo cual se levanta la presente acta, en Caracas el 31 de Octubre de 2012, dej\u00e1ndose tambi\u00e9n constancia de que actu\u00f3 como Coordinador del Jurado el Profesor Tutor Mar\u00eda Elena Villapol. Prof. Mar\u00eda Elena Villapol (Tutor) Prof. David Perez Prof. Robinson Rivas (Jurado Principal) (Jurado Principal) 3 Resumen T\u00edtulo: Implementaci\u00f3n de un Sistema del Protocolo de Configuraci\u00f3n Din\u00e1mica de Hosts con Mensajes de Autenticaci\u00f3n. Autor: David Rubel Tutor: Mar\u00eda Elena Villapol El auge que ha tenido Internet ha creado la necesidad en la gente de estar conectados a esta red. Para estar conectado a Internet es necesario que un dispositivo de comunicaci\u00f3n posea configurados en forma apropiada varios par\u00e1metros de de la pila TCP/IP. El com\u00fan denominador de la gente posee poco o ning\u00fan conocimiento de c\u00f3mo configurar estos par\u00e1metros, por lo que se ven en la necesidad de depender de alg\u00fan administrador de red que configure dichos dispositivos de comunicaci\u00f3n. El Protocolo de Configuraci\u00f3n Din\u00e1mica de Hosts solventa este inconveniente, permitiendo a los dispositivos en una red TCP/IP obtener informaci\u00f3n de configuraci\u00f3n autom\u00e1ticamente. Sin embargo, esta facilidad tambi\u00e9n se convierte en una desventaja cuando existen personas malintencionadas que quieran acceder a una red ya que DHCP no distingue usuarios, abri\u00e9ndoles el paso para realizar cualquier cantidad de ataques a otros usuarios o sistemas, incluso para el mismo DHCP. Actualmente existe un mecanismo de autenticaci\u00f3n para DHCP descrito en el RFC 3118. En dicho RFC se mencionan dos m\u00e9todos de autenticaci\u00f3n llamados Configuration Token y Delayed Authentication, con los cuales se permite otorgarle direcciones IP s\u00f3lo a aquellos usuarios que poseen una llave y se autentiquen correctamente. Lamentablemente no se ha encontrado ninguna implementaci\u00f3n de DHCP con soporte para dicho mecanismo. Para crear una soluci\u00f3n a esta problem\u00e1tica, en este trabajo se ha modificado una implementaci\u00f3n existente de un cliente y un servidor DHCP para poder hacer uso de la opci\u00f3n de autenticaci\u00f3n en mensajes DHCP cumpliendo con los lineamientos indicados en el RFC 3118. La soluci\u00f3n desarrollada fue sometida a diversas pruebas de funcionamiento, estr\u00e9s y rendimiento para evaluar el comportamiento del sistema DHCP luego de las modificaciones. Los resultados obtenidos durante las pruebas demostraron que se logr\u00f3 desarrollar una soluci\u00f3n funcional sin a\u00f1adir una sobrecarga significativa al comparar el rendimiento de la soluci\u00f3n desarrollada con el de la implementaci\u00f3n original. Palabras Claves: DHCP, Autenticaci\u00f3n, Configuration Token, Delayed Authentication, Implementaci\u00f3n. 4 Tabla de contenido Resumen ................................................................................................................. 3 Tabla de contenido .................................................................................................. 4 \u00cdndice de Figuras ..................................................................................................... 7 \u00cdndice de Tablas ...................................................................................................... 9 1. Introducci\u00f3n .................................................................................................... 10 1.1. Planteamiento del Problema .................................................................... 10 1.2. Objetivo General ...................................................................................... 11 1.3. Objetivos Espec\u00edficos ............................................................................... 11 1.4. Justificaci\u00f3n .............................................................................................. 11 1.5. Estructura del Documento ........................................................................ 12 2. DHCP ............................................................................................................. 13 2.1. Descripci\u00f3n General ................................................................................. 13 2.2. Formato de Trama DHCP ........................................................................ 15 2.3. Tipos de Mensaje ..................................................................................... 16 2.4. Funcionamiento de DHCP ........................................................................ 17 2.5. Proceso de Configuraci\u00f3n por Medio de DHCP ....................................... 18 3. Autenticaci\u00f3n en Mensajes DHCP ................................................................. 20 3.1. Descripci\u00f3n General ................................................................................. 20 3.2. Formato de la Trama ................................................................................ 20 3.3. Configuration Token ................................................................................. 21 3.4. Delayed Authentication ............................................................................ 22 4. Metodolog\u00eda y Herramientas .......................................................................... 24 4.1. Fases para la Elaboraci\u00f3n del Presente Trabajo ..................................... 24 4.1.1. Investigaci\u00f3n de Implementaciones Existentes de DHCP ................. 24 4.1.2. Selecci\u00f3n de Implementaci\u00f3n de DHCP ............................................ 24 4.1.3. An\u00e1lisis de C\u00f3digo Fuente ................................................................. 24 4.1.4. Implementaci\u00f3n de DHCP con autenticaci\u00f3n .................................... 25 4.1.5. Dise\u00f1o de los Escenarios de Prueba ................................................. 25 4.1.6. Realizaci\u00f3n de Pruebas ..................................................................... 25 5 4.1.7. An\u00e1lisis de los Resultados ................................................................. 25 4.2. Herramientas Utilizadas ........................................................................... 25 5. Dise\u00f1o de la Soluci\u00f3n..................................................................................... 27 5.1. Investigaci\u00f3n de Implementaciones Existentes de DHCP ........................ 27 5.2. Selecci\u00f3n de Implementaci\u00f3n de DHCP .................................................. 27 5.2.1. Udhcpc y Udhcpd (Busybox) ............................................................. 27 5.2.2. LoosyDHCP, dhcp4java y JDHCPD .................................................. 28 5.2.3. ISC DHCP ......................................................................................... 28 5.3. An\u00e1lisis de C\u00f3digo Fuente ....................................................................... 28 5.3.1. Estructura de la Implementaci\u00f3n ....................................................... 29 5.3.2. Enfoque a Seguir Para la Modificaci\u00f3n de la Implementaci\u00f3n ........... 30 6. Desarrollo de la Soluci\u00f3n ............................................................................... 32 6.1. Consideraciones de Dise\u00f1o ..................................................................... 32 6.2. Configuration Token ................................................................................. 34 6.3. Delayed Authentication ............................................................................ 35 7. Pruebas .......................................................................................................... 38 7.1. Pruebas de Correcci\u00f3n ............................................................................. 38 7.1.1. Preparaci\u00f3n de las Pruebas .............................................................. 38 7.1.2. Ejecuci\u00f3n de las Pruebas .................................................................. 39 7.1.3. An\u00e1lisis de los Resultados ................................................................. 49 7.2. Pruebas de estr\u00e9s .................................................................................... 50 7.2.1. Preparaci\u00f3n de las Pruebas .............................................................. 50 7.2.2. Ejecuci\u00f3n de las Pruebas .................................................................. 51 7.2.3. An\u00e1lisis de los Resultados ................................................................. 52 7.3. Pruebas de rendimiento ........................................................................... 53 7.3.1. Preparaci\u00f3n de las Pruebas .............................................................. 53 7.3.2. Ejecuci\u00f3n de las Pruebas .................................................................. 53 7.3.3. An\u00e1lisis de los Resultados ................................................................. 55 8. Conclusiones .................................................................................................. 57 8.1. Contribuciones ......................................................................................... 57 8.2. Limitaciones ............................................................................................. 58 6 8.3. Trabajos Futuros ...................................................................................... 59 9. Referencias .................................................................................................... 60 10. Anexos ........................................................................................................ 62 Anexo N\u00ba A Ejecuci\u00f3n del DHCP con Autenticaci\u00f3n ...................................... 62 7 \u00cdndice de Figuras Figura 2.1 Formato de trama DHCP. ..................................................................... 15 Figura 2.2 Formato del campo Options. ................................................................ 16 Figura 2.3 Ejemplo de intercambio de mensajes DHCP. ...................................... 19 Figura 3.1 Formato de opci\u00f3n de autenticaci\u00f3n. ................................................... 20 Figura 3.2 Diagrama de flujo de validaci\u00f3n de mensajes usando Configuration Token......................................................................................................................21 Figura 3.3 Delayed Authentication DHCPDISCOVER. .......................................... 22 Figura 3.4 Delayed Authentication DHCPOFFER, REQUEST, ACK......................22 Figura 3.5 Diagrama de flujo de validaci\u00f3n de mensajes usando Delayed Authentication.........................................................................................................23 Figura 5.1 Inserci\u00f3n de opci\u00f3n de autenticaci\u00f3n a un mensaje DHCP. ................. 31 Figura 5.2 Validaci\u00f3n y eliminaci\u00f3n de la opci\u00f3n de autenticaci\u00f3n en un mensaje DHCP. ................................................................................................................... 31 Figura 6.1 Proceso de autenticaci\u00f3n usando el m\u00e9todo Configuration Token. ..... 35 Figura 6.2 Proceso de autenticaci\u00f3n usando el m\u00e9todo Delayed Authentication. . 37 Figura 7.1 Topolog\u00eda de red para pruebas de correcci\u00f3n. ..................................... 38 Figura 7.2 Topolog\u00eda de red para pruebas de correcci\u00f3n con agentes de relevo DHCP. ................................................................................................................... 38 Figura 7.3 Topolog\u00eda de red para pruebas de correcci\u00f3n con varios clientes y servidores DHCP. .................................................................................................. 39 Figura 7.4 Autenticaci\u00f3n v\u00e1lida usando Configuration Token................................ 40 Figura 7.5 Autenticaci\u00f3n v\u00e1lida usando Delayed Authentication. .......................... 40 Figura 7.6 Ausencia de opci\u00f3n de autenticaci\u00f3n. .................................................. 41 Figura 7.7 Uso de secreto incorrecto en Configuration Token. ............................. 42 Figura 7.8 Llave incorrecta en Delayed Authentication. ........................................ 42 Figura 7.9 Modificaci\u00f3n en archivo de Replay Values del servidor. ...................... 43 Figura 7.10 Valor no aceptable para el m\u00e9todo de detecci\u00f3n de repetici\u00f3n. ......... 43 Figura 7.11 Valor desconocido para el campo de m\u00e9todo de detecci\u00f3n de repetici\u00f3n. .............................................................................................................. 44 Figura 7.12 Presencia de 2 opciones de autenticaci\u00f3n usando Configuration Token. ................................................................................................................... 45 Figura 7.13 Presencia de 2 opciones de autenticaci\u00f3n usando Delayed Authentication. ....................................................................................................... 45 Figura 7.14 Uso de Configuration Token a trav\u00e9s de un agente de relevo. .......... 46 Figura 7.15 Uso de Delayed Authentication a trav\u00e9s de un agente de relevo. ...... 47 Figura 7.16 Extractos del log del servidor DHCP. ................................................. 49 Figura 7.17 Extractos del log del cliente DHCP. .................................................... 49 Figura 7.18 Topolog\u00eda de la red para pruebas de estr\u00e9s........................................50 8 Figura 7.19 Porcentaje de consumo de recursos. ................................................. 52 Figura 7.20 Topolog\u00eda de red para pruebas de rendimiento. ................................ 53 Figura 7.21 Duraci\u00f3n del proceso para obtener una direcci\u00f3n IP (sin autenticaci\u00f3n). ....................................................................................................... 54 Figura 7.22 Duraci\u00f3n del proceso para obtener una direcci\u00f3n IP (Configuration Token). .................................................................................................................. 54 Figura 7.23 Duraci\u00f3n del proceso para obtener una direcci\u00f3n IP (Delayed Authentication). ..................................................................................................... 55 Figura 7.24 Diagrama de cajas de tiempo para obtener una direcci\u00f3n IP. ............ 55 Figura 10.1 Comandos para creaci\u00f3n de directorios y archivos necesarios en el cliente. ................................................................................................................... 62 Figura 10.2 Comando para iniciar el cliente usando Configuration Token con clave \"Secreto\". .............................................................................................................. 63 Figura 10.3 Formato del archivo de identificadores y llaves para Delayed Authentication. ....................................................................................................... 63 Figura 10.4 Comando para iniciar el cliente usando Delayed Authentication con algoritmo MD5. ...................................................................................................... 63 Figura 10.5 Comandos para la creaci\u00f3n de directorios y archivos necesarios en el servidor.................................................................................................................. 64 Figura 10.6 Comando para iniciar el servidor usando Configuration Token con clave \"Secreto\". ..................................................................................................... 64 Figura 10.7 Comando para iniciar el servidor usando Delayed Authentication con algoritmo MD5. ...................................................................................................... 64 9 \u00cdndice de Tablas Tabla 7.1 Configuraci\u00f3n de servidores en ambiente variado................................. 47 Tabla 7.2 Configuraci\u00f3n de clientes en ambiente variado. .................................... 48 Tabla 7.3 Consumo de recursos utilizando ISC DHCP regular. ............................ 51 Tabla 7.4 Consumo de recursos utilizando Configuration Token. ......................... 51 Tabla 7.5 Consumo de recursos utilizando Delayed Authentication. ..................... 51 10 1. Introducci\u00f3n El auge que ha tenido Internet ha creado la necesidad en la gente de estar conectados a esta red. Para estar conectado a Internet es necesario que un dispositivo de comunicaci\u00f3n posea configurados en forma apropiada varios par\u00e1metros de de la pila TCP/IP. El com\u00fan denominador de la gente posee poco o ning\u00fan conocimiento de c\u00f3mo configurar estos par\u00e1metros, por lo que se ven en la necesidad de depender de alg\u00fan administrador de red que configure dichos dispositivos de comunicaci\u00f3n. Por los motivos expuestos anteriormente ser\u00eda deseable tener un mecanismo que pueda ser usado por un dispositivo para obtener autom\u00e1ticamente los par\u00e1metros de configuraci\u00f3n apropiados. El protocolo de configuraci\u00f3n din\u00e1mica de hosts o Dynamic Host Configuration Protocol (DHCP) [1] es un protocolo que le permite a los dispositivos en una red TCP/IP obtener informaci\u00f3n de configuraci\u00f3n autom\u00e1ticamente, eliminando el trabajo en forma manual por parte de un administrador de red. Sin embargo, esta facilidad tambi\u00e9n se convierte en una desventaja cuando existen personas malintencionadas que quieran acceder a una red ya que DHCP no distingue usuarios, abri\u00e9ndoles el paso para realizar cualquier cantidad de ataques a otros usuarios o sistemas, incluso para el mismo DHCP. Existen unas pocas herramientas fuera de DHCP que permiten controlar el acceso a una red, mitigando en cierta forma la problem\u00e1tica expuesta anteriormente, pero la implementaci\u00f3n de estos controles adicionales puede traer consigo una inversi\u00f3n econ\u00f3mica adicional y una configuraci\u00f3n que puede aumentar la complejidad de una red. Por ello se hace deseable la implementaci\u00f3n de un mecanismo embebido en el mismo DHCP que permita controlar a quien se le permite recibir informaci\u00f3n de configuraci\u00f3n de red. 1.1. Planteamiento del Problema DHCP fue desarrollado al comienzo de los a\u00f1os 1990, cuando la seguridad en la Internet, o incluso en redes locales no era una gran preocupaci\u00f3n, por lo que en DHCP no se hab\u00eda implementado ning\u00fan mecanismo de seguridad. Adem\u00e1s dentro del modelo de amenazas para DHCP hay dos problemas de seguridad bien conocidos. En primer caso, un servidor DHCP no autorizado pudiera proveer informaci\u00f3n de configuraci\u00f3n incorrecta a un cliente con el fin de establecer un ataque de \"hombre en el medio\" o un ataque de \"denegaci\u00f3n de servicio\". Segundo, un cliente DHCP no autorizado pudiera obtener informaci\u00f3n de configuraci\u00f3n de un servidor con la intenci\u00f3n de comprometer posteriormente a la red o pudiese causar el agotamiento de direcciones IP a ser otorgadas enviando m\u00faltiples peticiones de configuraci\u00f3n al servidor, causando otro tipo de ataque de denegaci\u00f3n de servicio. 11 Afortunadamente existe un mecanismo de autenticaci\u00f3n que pudiese prevenir esta problem\u00e1tica, el cual fue descrito en el RFC 3118 [5] en el a\u00f1o 2001. Lamentablemente a pesar de ello no se han encontrado implementaciones de DHCP que soporten dicho mecanismo o peor a\u00fan, no ha sido implementado en todos estos a\u00f1os. Por ello la implementaci\u00f3n de tal mecanismo podr\u00eda ser beneficiosa tanto para los usuarios de DHCP como para el sistema en su totalidad. 1.2. Objetivo General El objetivo de este trabajo es el de realizar la modificaci\u00f3n de un cliente y un servidor DHCP para agregar los diferentes mecanismos de autenticaci\u00f3n propuestos en el RFC 3118 [5], con la finalidad de evitar la posible explotaci\u00f3n de vulnerabilidades por parte de agentes no autorizados en una red. 1.3. Objetivos Espec\u00edficos Los objetivos espec\u00edficos de este trabajo son los siguientes: Elegir una implementaci\u00f3n software libre de DHCP (cliente y servidor). Extender la funcionalidad y a\u00f1adir los m\u00e9todos de autenticaci\u00f3n descritos en el RFC 3118 a una implementaci\u00f3n existente de DHCP. Realizar diversas pruebas de funcionamiento, estr\u00e9s y rendimiento para evaluar el comportamiento del sistema DHCP luego de las modificaciones. Documentar los cambios realizados en el c\u00f3digo fuente del cliente y servidor DHCP. Analizar los resultados obtenidos. 1.4. Justificaci\u00f3n El protocolo DHCP es ampliamente utilizado para proveer una forma sencilla y automatizada de configurar apropiadamente una interfaz de red de alg\u00fan dispositivo. Esto hace que sea una herramienta casi necesaria en muchos casos, ya sea para facilitar labores de administraci\u00f3n en ambientes con gran cantidad de computadores o para cubrir la necesidad de usuarios con pocos conocimientos en el \u00e1rea de obtener una configuraci\u00f3n que le permita acceder a Internet. Esta facilidad tambi\u00e9n se puede convertir en una desventaja cuando existen personas malintencionadas que quieran acceder a una red ya que DHCP no distingue usuarios, abri\u00e9ndoles el paso para realizar cualquier cantidad de ataques a otros usuarios o sistemas. Por lo tanto, la implementaci\u00f3n de un mecanismo que permita configurar s\u00f3lo aquellos dispositivos autenticados es un m\u00e9todo viable para mitigar dicho problema. 12 1.5. Estructura del Documento El presente trabajo est\u00e1 estructurado de la siguiente forma: Cap\u00edtulo 1 - Introducci\u00f3n: Se describe brevemente el prop\u00f3sito de DHCP, la problem\u00e1tica con la implementaci\u00f3n actual y la justificaci\u00f3n de este trabajo. Cap\u00edtulo 2 - DHCP: Se describe el funcionamiento de DHCP, los distintos tipos de mensajes enviados, el formato de las tramas y los pasos a seguir para obtener una direcci\u00f3n IP a trav\u00e9s de DHCP. Cap\u00edtulo 3 - Autenticaci\u00f3n en Mensajes DHCP: Se describe la opci\u00f3n de autenticaci\u00f3n, el formato de la opci\u00f3n y los posibles m\u00e9todos de autenticaci\u00f3n propuestos para esta opci\u00f3n. Cap\u00edtulo 4 - Metodolog\u00eda y Herramientas Se describe brevemente las actividades a realizar para la implementaci\u00f3n de la soluci\u00f3n y las herramientas utilizadas para lograr ese fin. Cap\u00edtulo 5 - Procedimiento para la Implementaci\u00f3n de la Soluci\u00f3n: Se describe en detalle las actividades realizadas que permitir\u00e1n el desarrollo de la soluci\u00f3n. Cap\u00edtulo 6 - Desarrollo de la Soluci\u00f3n: Se describe en detalle las consideraciones que fueron tomadas para la modificaci\u00f3n del c\u00f3digo fuente y para la implementaci\u00f3n de los m\u00e9todos de autenticaci\u00f3n. Cap\u00edtulo 7 - Pruebas: Se describe las pruebas a realizar, los escenarios planteados para los mismos y el correspondiente an\u00e1lisis de los resultados obtenidos en cada prueba. Cap\u00edtulo 8 - Conclusiones: Se plantea las conclusiones alcanzadas en este trabajo. 13 2. DHCP Con el pasar del tiempo se ha ido incrementando exponencialmente el n\u00famero de computadoras utilizadas en todo el mundo y por lo tanto, el tama\u00f1o en general de las redes de computadoras. Esto ha tra\u00eddo como consecuencia que las labores de administraci\u00f3n o configuraci\u00f3n realizadas de forma manual sea cada vez menos factible, por lo que surge la necesidad de crear un mecanismo para configurar autom\u00e1ticamente los equipos. 2.1. Descripci\u00f3n General DHCP es un protocolo definido en el RFC 2131 [1] que le permite a los equipos pertenecientes a una cierta red TCP/IP obtener par\u00e1metros de configuraci\u00f3n en forma autom\u00e1tica tales como direcci\u00f3n IP, m\u00e1scara de subred, puerta de enlace predeterminada, servidores de sistemas de nombres de dominio o Domain Name System (DNS), entre otros. Su funcionamiento se divide en dos componentes: un protocolo para el env\u00edo de par\u00e1metros de configuraci\u00f3n y un mecanismo para la asignaci\u00f3n de direcciones de red. El protocolo DHCP funciona bajo un modelo cliente-servidor en el cual los equipos que deseen obtener la configuraci\u00f3n necesaria para comunicarse con cualquier otro equipo a trav\u00e9s de la red o Internet realizan una petici\u00f3n al servidor o los servidores DHCP presentes en la red para obtener una configuraci\u00f3n adecuada que les permita realizar dicha tarea. Por \u00e9ste motivo, tambi\u00e9n se puede decir que DHCP permite cierta centralizaci\u00f3n respecto a la configuraci\u00f3n debido a que basta con realizar cambios \u00fanicamente en la informaci\u00f3n enviada por el servidor para que los cambios se vean reflejados en cada uno de los clientes, facilitando as\u00ed la administraci\u00f3n de redes que poseen gran cantidad de equipos. Los mensajes intercambiados por el cliente y el servidor est\u00e1n basados en los mensajes utilizados por el protocolo BOOTP [15], el cual se usaba previamente a la existencia de DHCP para obtener la direcci\u00f3n IP de un equipo, obtener la ubicaci\u00f3n de red de su imagen de arranque en el caso de terminales sin discos duros, entre otros. Sin embargo, DHCP introduce una mejora notable la cual es que una direcci\u00f3n IP puede ser reutilizada por otro cliente si la direcci\u00f3n est\u00e1 disponible, a diferencia de BOOTP en el que cada direcci\u00f3n IP es asignada previamente y corresponde s\u00f3lo a un cliente. Tanto los mensajes de BOOTP como los mensajes DHCP son enviados a trav\u00e9s del protocolo de transporte User Datagram Protocol (UDP) hacia los puertos 67 y 68 que corresponden al puerto del servidor y el cliente, respectivamente. De este modo se permite cierta compatibilidad hacia atr\u00e1s con BOOTP. 14 Existen tres tipos de asignaci\u00f3n para las direcciones IP: Asignaci\u00f3n autom\u00e1tica: DHCP asigna una direcci\u00f3n IP permanente a un cliente. Asignaci\u00f3n din\u00e1mica: DHCP asigna una direcci\u00f3n IP a un cliente por una cantidad de tiempo limitada o hasta que el cliente avise que desea liberar la direcci\u00f3n. Asignaci\u00f3n manual: La direcci\u00f3n IP del cliente es asignada por el administrador de la red y se utiliza DHCP para comunicarle la direcci\u00f3n asignada al cliente. El servidor DHCP est\u00e1 encargado de asegurarse que no exista m\u00e1s de un cliente con la misma direcci\u00f3n IP, sin importar el tipo de asignaci\u00f3n que se haya utilizado, aunque el cliente tambi\u00e9n puede notificarle por medio de un mensaje al servidor si se ha obtenido una direcci\u00f3n duplicada luego de haber realizado una verificaci\u00f3n de que no haya otro cliente presente con la misma direcci\u00f3n. Adem\u00e1s de asignar direcciones IP, el servidor DHCP tambi\u00e9n provee configuraci\u00f3n adicional, aunque no todos los par\u00e1metros de configuraci\u00f3n son requeridos por un cliente para poder intercambiar paquetes con cualquier host en Internet. El cliente y el servidor pueden negociar la transmisi\u00f3n de s\u00f3lo aquellos par\u00e1metros requeridos por el cliente o aquellos espec\u00edficos para una subred en particular. DHCP no debe requerir un servidor en cada subred, ya que el mismo deber\u00eda funcionar a trav\u00e9s de enrutadores y agentes de relevo BOOTP donde existan, los cuales son dispositivos destinados a reenviar mensajes BOOTP a trav\u00e9s de distintas subredes. Se puede dar la posibilidad de tener m\u00e1s de un servidor DHCP funcionando en la red, en ese caso un cliente podr\u00eda recibir m\u00faltiples respuestas a una petici\u00f3n de par\u00e1metros de configuraci\u00f3n y deber\u00e1 aceptar solamente una de ellas. A pesar de que una de las funciones principales de DHCP es permitir la configuraci\u00f3n autom\u00e1tica de los clientes, debe permitir la asignaci\u00f3n de par\u00e1metros permanente o fija de clientes espec\u00edficos y coexistir con host configurados est\u00e1ticamente. Un servidor DHCP debe retener la configuraci\u00f3n del cliente sin importar que el cliente o el servidor se hayan reiniciado y de ser posible siempre se le deber\u00eda asignar la misma configuraci\u00f3n a un cliente cuando sea requerida. 15 2.2. Formato de Trama DHCP Los mensajes que intercambian cliente y servidor siguen el mismo formato que los mensajes de BOOTP, como se muestran en la Figura 2.1 y en la Figura 2.2, donde se indican una breve descripci\u00f3n de cada campo de la trama, la cantidad de bytes que contienen y el desglosamiento del campo \"options\": Figura 2.1 Formato de trama DHCP. Operaci\u00f3n: Tipo de mensaje (1= BOOTREQUEST - 2= BOOTREPLY). Tipo Hardware: C\u00f3digo que indica el tipo de interfaz de red. Longitud Hardware: Longitud de direcci\u00f3n de hardware. Saltos: Cantidad de saltos realizados a trav\u00e9s de enrutadores. ID Transacci\u00f3n: ID de transacci\u00f3n para asociar mensajes y respuestas. Segundos: Segundos transcurridos desde que el cliente inici\u00f3 la petici\u00f3n. Banderas: El bit m\u00e1s significativo denota el env\u00edo de mensajes por difusi\u00f3n (broadcast) y el resto de los bits son reservados. Direcci\u00f3n Cliente: Direcci\u00f3n IP del cliente (solo se coloca si ya posee una). Tu Direcci\u00f3n: Direcci\u00f3n IP que ser\u00e1 asignada al cliente. Direcci\u00f3n Servidor: Direcci\u00f3n IP del servidor. Direcci\u00f3n Puerta de Enlace: Direcci\u00f3n IP del agente de relevo. Direcci\u00f3n Hardware Cliente: Direcci\u00f3n de hardware del cliente (Direcci\u00f3n MAC). Nombre de Servidor: Indica un nombre de host opcional para el servidor. Archivo: Nombre del archivo de arranque. Usado en BOOTP y mantenido por motivos de compatibilidad hacia atr\u00e1s. Opciones: Campo de longitud variable que contiene par\u00e1metros opcionales. Operaci\u00f3n Tipo Hardware Longitud Hardware Saltos ID Transacci\u00f3n Segundos Banderas Direcci\u00f3n Cliente Tu Direcci\u00f3n Direcci\u00f3n Servidor Direcci\u00f3n Puerta de Enlace Direcci\u00f3n Hardware Cliente Nombre de Servidor (64) Archivo (128) Opciones (variable) 8 16 24 16 Figura 2.2 Formato del campo Options. C\u00f3digo Opci\u00f3n: C\u00f3digo de la opci\u00f3n. Longitud Opci\u00f3n: Longitud en bytes del campo \"Data Opci\u00f3n\" de los datos correspondientes a la opci\u00f3n \"C\u00f3digo Opci\u00f3n\". Data Opci\u00f3n: Datos enviados, como por ejemplo par\u00e1metros de configuraci\u00f3n. 2.3. Tipos de Mensaje Los tipos de mensaje DHCP que existen son los siguientes: DHCPDISCOVER: Es enviado por el cliente para descubrir la presencia de servidores DHCP disponibles en la red local. Son identificados con el tipo de mensaje 1. DHCPOFFER: Es enviado por el servidor en respuesta a un mensaje DHCPDISCOVER, ofreciendo par\u00e1metros de configuraci\u00f3n. Son identificados con el tipo de mensaje 2. DHCPREQUEST: Es enviado por el cliente para pedir la asignaci\u00f3n de los par\u00e1metros ofrecidos por un servidor DHCP y rechazar las ofertas de los dem\u00e1s servidores, para confirmar la correctitud de una direcci\u00f3n asignada previamente, o para extender el tiempo de pr\u00e9stamo de una direcci\u00f3n. Son identificados con el tipo de mensaje 3. DHCPDECLINE: Es enviado por el cliente para indicar que la direcci\u00f3n de red ofrecida por el servidor est\u00e1 siendo usada por otro cliente. Son identificados con el tipo de mensaje 4. DHCPACK: Es enviado por el servidor para confirmar la asignaci\u00f3n de los par\u00e1metros indicados al cliente. Son identificados con el tipo de mensaje 5. DHCPNACK: Es enviado por el servidor para indicar que no se puede asignar la direcci\u00f3n pedida por el cliente, ya sea porque est\u00e9 incorrecta o porque haya expirado el tiempo de pr\u00e9stamo. Son identificados con el tipo de mensaje 6. 0x63 0x82 0x53 0x63 8 16 24 C\u00f3digo Opci\u00f3n #1 Longitud Opci\u00f3n #1 Data Opci\u00f3n #1 (variable) C\u00f3digo Opci\u00f3n #2 Longitud Opci\u00f3n #2 Data Opci\u00f3n #2 (variable) C\u00f3digo Opci\u00f3n #3 Longitud Opci\u00f3n #3 Data Opci\u00f3n #3 (variable) 17 DHCPRELEASE: Es enviado por el cliente para indicarle al servidor que se desea liberar la direcci\u00f3n de red y cancelar el tiempo de pr\u00e9stamo restante. Son identificados con el tipo de mensaje 7. DHCPINFORM: Es enviado por el cliente para pedir \u00fanicamente par\u00e1metros de configuraci\u00f3n local en caso que el cliente ya tenga alguna direcci\u00f3n de red asignada. Son identificados con el tipo de mensaje 8. 2.4. Funcionamiento de DHCP DHCP b\u00e1sicamente cumple dos funciones. La primera es la de proveer almacenamiento persistente de par\u00e1metros de red para los clientes: Por cada cliente, el servidor DHCP almacena una entrada del tipo llave-valor, donde la llave es un ID \u00fanico compuesto del n\u00famero de la subred y un identificador \u00fanico dentro de la misma y el valor contiene los par\u00e1metros de configuraci\u00f3n para el cliente. Por defecto, la llave es de la forma \"N\u00famero de subred - Direcci\u00f3n de hardware\", como por ejemplo la direcci\u00f3n MAC, pero la llave bien pudiera ser de la forma \"N\u00famero de subred - Nombre de host\", proporcionando de \u00e9sta forma una asignaci\u00f3n m\u00e1s eficiente ante eventos como reemplazo de una tarjeta de red o que el cliente haya sido movido a otra subred. El cliente tambi\u00e9n puede especificar alg\u00fan identificador que lo distinga de forma \u00fanica en la red por medio de la opci\u00f3n \"client identifier\", de ser as\u00ed, el cliente deber\u00e1 incluir siempre dicha opci\u00f3n con el mismo valor en cada mensaje DHCP que vaya a transmitir. La segunda funci\u00f3n de DHCP es la de asignaci\u00f3n temporal o permanente de direcciones IP a los clientes, en la cual el cliente hace una petici\u00f3n de uso de una direcci\u00f3n por un per\u00edodo de tiempo y el servidor garantiza no asignar dicha direcci\u00f3n durante ese tiempo de pr\u00e9stamo e intentar\u00e1 asignar esa misma direcci\u00f3n cada vez que el cliente vuelva a hacer una petici\u00f3n, permitiendo de \u00e9sta forma extender de alguna manera el tiempo de pr\u00e9stamo. Una direcci\u00f3n que haya sido asignada de forma permanente solamente podr\u00e1 ser reutilizada si el cliente env\u00eda un mensaje al servidor DHCP indicando que se desea liberar la direcci\u00f3n, aunque tambi\u00e9n para evitar este inconveniente, el servidor podr\u00eda asignar la direcci\u00f3n no infinitamente sino por per\u00edodos de tiempo muy largos para poder detectar si el cliente se encuentra usando esa direcci\u00f3n. En cambio, en algunos ambientes en los que se haga una asignaci\u00f3n din\u00e1mica de direcciones y haya m\u00e1s clientes que direcciones disponibles, se deber\u00e1 reutilizar las direcciones cuyos tiempos de pr\u00e9stamo ya hayan expirado. Al momento de asignar una direcci\u00f3n a un cliente, el servidor DHCP previamente deber\u00eda verificar que otro cliente no est\u00e9 utilizando dicha direcci\u00f3n, como por ejemplo enviando un Echo Request ICMP a la direcci\u00f3n a asignar y si no se recibe respuesta alguna, se puede asignar esa direcci\u00f3n. Adicionalmente, el 18 cliente tambi\u00e9n deber\u00eda verificar que la direcci\u00f3n que ha recibido no est\u00e9 siendo usada por otro cliente, como por ejemplo enviando un ARP Request [2] para esa direcci\u00f3n y si no recibe respuesta alguna es porque es el \u00fanico cliente con esa direcci\u00f3n IP. Para llevar a cabo las funciones descritas anteriormente, debe existir un intercambio de mensajes entre el cliente y el servidor DHCP, los cuales est\u00e1n formados por el mensaje DHCP seguido de un conjunto de opciones. Los primeros cuatro bytes del campo de opciones deben corresponder a los valores decimales \"99, 130, 83, 99\" como es indicado en el RFC 1497 [3] y seguido a esto se incluyen las opciones de DHCP definidas en el RFC 2132 [4] para indicar los par\u00e1metros de configuraci\u00f3n que sean de inter\u00e9s. Hay una opci\u00f3n que es obligatoria en todo mensaje DHCP, que corresponde a la opci\u00f3n \"DHCP message type\" con \"C\u00f3digo Opci\u00f3n= 53\", el cual indicar\u00e1 en un campo el tipo de mensaje DHCP correspondiente y determinar\u00e1 algunas opciones que pueden necesitarse y otras que pueden aparecer o no dependiendo del tipo de mensaje DHCP. 2.5. Proceso de Configuraci\u00f3n por Medio de DHCP Para que un cliente que no tiene direcci\u00f3n de red pase a estar completamente configurado de forma autom\u00e1tica, se debe realizar la siguiente secuencia de pasos, tal como se ilustra en la Figura 2.3: El cliente manda por difusi\u00f3n un mensaje DHCPDISCOVER a su subred local, el cual puede tener o no opciones sugiriendo valores para la direcci\u00f3n de red y/o tiempo de pr\u00e9stamo. Cada servidor puede responder con un mensaje DHCPOFFER indicando la direcci\u00f3n de red disponible para el cliente en el campo \"Tu Direcci\u00f3n\" y otros par\u00e1metros a trav\u00e9s de las opciones del mensaje DHCP. El cliente recibe uno o m\u00e1s mensajes de DHCPOFFER dependiendo si hay varios servidores DHCP y escoge uno de ellos para pedir la asignaci\u00f3n de los par\u00e1metros de configuraci\u00f3n ofrecidos por ese servidor. El cliente env\u00eda por difusi\u00f3n un mensaje DHCPREQUEST que debe incluir la opci\u00f3n \"server identifier\" para indicar el servidor que ha sido seleccionado, la opci\u00f3n \"requested address\" debe ser colocada con el valor \"Tu Direcci\u00f3n\" enviado en el mensaje DHCPOFFER y se puede incluir otras opciones pidiendo valores espec\u00edficos para su configuraci\u00f3n. Los servidores reciben el mensaje DHCPREQUEST enviado por difusi\u00f3n y verifican si el \"server identifier\" corresponde al suyo. En caso de ser as\u00ed, el servidor almacena en un medio persistente la asignaci\u00f3n de par\u00e1metros 19 realizada hacia el cliente y env\u00eda un mensaje DHCPACK conteniendo los par\u00e1metros de configuraci\u00f3n, sino, el servidor tomar\u00e1 el mensaje como una notificaci\u00f3n de que fue rechazada su oferta. Si el servidor es incapaz de satisfacer los requerimientos que el cliente haya solicitado en el mensaje DHCPREQUEST, el servidor deber\u00eda responder con un mensaje DHCPNACK. El cliente recibe el mensaje DHCPACK con los par\u00e1metros de configuraci\u00f3n, toma nota del tiempo de pr\u00e9stamo y procede a revisar que la direcci\u00f3n otorgada no est\u00e9 siendo usada por otro cliente por medio de ARP por ejemplo. Si el cliente detecta que la direcci\u00f3n est\u00e1 siendo usada, debe enviar un mensaje DHCPDECLINE rechazando la direcci\u00f3n y reiniciar el proceso de configuraci\u00f3n, sino, el cliente ya est\u00e1 totalmente configurado. Si el cliente recibe m\u00e1s bien un mensaje DHCPNACK, el cliente reinicia el proceso de configuraci\u00f3n. El cliente puede liberar voluntariamente la direcci\u00f3n que le fue asignada enviando un mensaje DHCPRELEASE al servidor. Figura 2.3 Ejemplo de intercambio de mensajes DHCP. 20 3. Autenticaci\u00f3n en Mensajes DHCP En algunos ambientes es posible que no sea deseable que cualquier host conectado a la red sea capaz de obtener una direcci\u00f3n IP, por ejemplo, debido a pol\u00edticas de seguridad como otorgar una direcci\u00f3n IP solamente a aquellos hosts permitidos. Por ello surge la necesidad de idear alg\u00fan mecanismo para controlar la entrega de direcciones IP. 3.1. Descripci\u00f3n General La autenticaci\u00f3n en los mensajes DHCP es una opci\u00f3n definida en el RFC 3118 [5] que permite generar un tipo de ticket de autenticaci\u00f3n para que s\u00f3lo aquellos hosts que est\u00e9n autorizados sean configurados autom\u00e1ticamente por el servidor DHCP. La autenticaci\u00f3n no se limita solamente a los hosts, sino que tambi\u00e9n se puede utilizar para autenticar los mensajes enviados por el servidor DHCP. 3.2. Formato de la Trama El formato que sigue la opci\u00f3n de autenticaci\u00f3n en mensajes DHCP se puede apreciar en la Figura 3.1 y se describen los campos a continuaci\u00f3n: Figura 3.1 Formato de opci\u00f3n de autenticaci\u00f3n. C\u00f3digo: El c\u00f3digo que corresponde a \u00e9ste tipo de mensajes es el n\u00famero 90. Longitud: Contiene la longitud en bytes de los campos \"Protocolo\", \"Algoritmo\", \"M\u00e9todo Det. Rep.\", \"Detecci\u00f3n de Repetici\u00f3n\" e \"Informaci\u00f3n de Autenticaci\u00f3n\". Protocolo: Indica la t\u00e9cnica en particular para la autenticaci\u00f3n usada en esa opci\u00f3n. Algoritmo: Indica un algoritmo a utilizar en base al protocolo indicado en el campo anterior. M\u00e9todo Det. Rep. (M\u00e9todo de Detecci\u00f3n de Repetici\u00f3n, o RDM): Indica el m\u00e9todo a utilizar para detectar posibles mensajes duplicados. Detecci\u00f3n de Repetici\u00f3n: Contiene un valor utilizado para detectar ataques de repetici\u00f3n que var\u00eda seg\u00fan el \"M\u00e9todo Det. Rep.\". Cabe destacar que LongitudC\u00f3digo Protocolo Algoritmo M\u00e9todo Det. Rep. Detecci\u00f3n de Repetici\u00f3n (64 bits) Informaci\u00f3n de Autenticaci\u00f3n 8 16 24 21 sea cual sea el valor del campo \"Protocolo\", si el valor del campo \"M\u00e9todo Det. Rep.\" es 0, el valor del campo \"Detecci\u00f3n de Repetici\u00f3n\" debe ser un contador mon\u00f3tonamente creciente como por ejemplo la hora actual. Seg\u00fan el RFC 3118, existen dos alternativas para enviar mensajes con informaci\u00f3n de autenticaci\u00f3n llamadas Configuration token y Delayed Authentication, los cuales ser\u00e1n descritos a continuaci\u00f3n. 3.3. Configuration Token Los mensajes de este tipo son identificados por tener un valor de \"0\" en el campo \"Protocolo\", \"Algoritmo\" y \"M\u00e9todo Det. Rep.\". En los mensajes del tipo Configuration Token se hace env\u00edo de un valor conocido previamente por el cliente y el servidor que es utilizado como un m\u00e9todo b\u00e1sico de autenticaci\u00f3n semejante al provisto por una contrase\u00f1a. Si la contrase\u00f1a presente en el mensaje es distinta a la clave compartida, el receptor debe descartar este mensaje. Por este motivo, la protecci\u00f3n ofrecida por este mecanismo es algo d\u00e9bil aunque bastante sencilla ya que no es necesario generar y almacenar constantemente claves. En la Figura 3.2 se puede observar un diagrama de flujo donde se detalla el conjunto de acciones realizadas durante el proceso de validaci\u00f3n de un mensaje DHCP usando este m\u00e9todo de autenticaci\u00f3n. Recepci\u00f3n de mensaje DHCP Descartar mensaje M\u00e9todo de detecci\u00f3n de repetici\u00f3n conocido? Existe opci\u00f3n de autenticaci\u00f3n? Descartar mensaje Descartar mensaje NO SI NO Valor de detecci\u00f3n de repetici\u00f3n v\u00e1lido? SI NO Descartar mensaje Descartar mensaje Descartar mensaje M\u00e9todo de autenticaci\u00f3n conocido? Algoritmo v\u00e1lido? La clave es igual? Mensaje autenticado NO NO NO SI SI SI \u00danica opci\u00f3n de autenticaci\u00f3n? SI Descartar mensaje SI NO Procesar el resto del mensaje DHCP Figura 3.2 Diagrama de flujo de validaci\u00f3n de mensajes usando Configuration Token. 22 3.4. Delayed Authentication Los mensajes de este tipo son identificados por tener un valor de \u201c1\u201d en el campo \"Protocolo\". En la autenticaci\u00f3n retardada, el cliente hace una petici\u00f3n de autenticaci\u00f3n en su mensaje DHCPDISCOVER al servidor, el cual responde con un mensaje que incluye la informaci\u00f3n de autenticaci\u00f3n. Esta informaci\u00f3n de autenticaci\u00f3n consiste en un valor generado al momento para proveer autenticaci\u00f3n de mensaje y de host llamado \u201cC\u00f3digo de autenticaci\u00f3n de mensaje\u201d (Message Authentication Code o MAC). Para la autenticaci\u00f3n retardada se necesita que se tenga una llave secreta compartida entre el cliente y cada servidor DHCP al cual se quiere hacer petici\u00f3n de una direcci\u00f3n IP. Cada llave tiene un identificador \u00fanico que es usado para determinar cu\u00e1l llave fue utilizada para generar el c\u00f3digo MAC en el mensaje DHCP. El formato de los mensajes DHCPDISCOVER con autenticaci\u00f3n se puede apreciar en la Figura 3.3 mientras que el formato de los mensajes DHCPOFFER, DHCPREQUEST y DHCPACK se puede apreciar en la Figura 3.4. Figura 3.3 Delayed Authentication DHCPDISCOVER. Figura 3.4 Delayed Authentication DHCPOFFER, REQUEST, ACK. Detecci\u00f3n de Repetici\u00f3n: Valor definido seg\u00fan el campo \"M\u00e9todo Det. Rep.\". ID Secreto: Identificador \u00fanico para un valor secreto compartido o llave entre emisor y receptor para generar el c\u00f3digo MAC de este mensaje. HMAC-MD5: Hash MD5 obtenido de una funci\u00f3n generadora de c\u00f3digo MAC, definida en el RFC 2104 [6]. LongitudC\u00f3digo Protocolo Algoritmo M\u00e9todo Det. Rep. Detecci\u00f3n de Repetici\u00f3n (64 bits) 8 16 24 LongitudC\u00f3digo Protocolo Algoritmo M\u00e9todo Det. Rep. Detecci\u00f3n de Repetici\u00f3n (64 bits) ID Secreto (32 bits) ID Secreto (cont) HMAC-MD5 (128 bits) 8 16 24 23 Para realizar el c\u00e1lculo del c\u00f3digo MAC se utiliza como entrada el mensaje DHCP incluyendo la cabecera y los campos de opciones, adem\u00e1s de la llave compartida. Cabe destacar que los campos \u201cDirecci\u00f3n Puerta de Enlace\u201d y \u201cSaltos\u201d de la cabecera DHCP y el campo \u201cMAC\u201d de la opci\u00f3n de autenticaci\u00f3n son colocados en cero para el c\u00e1lculo del c\u00f3digo MAC. Un mensaje es tomado como v\u00e1lido por el receptor si el valor del campo \u201cDetecci\u00f3n de Repetici\u00f3n\u201d es aceptable de acuerdo al m\u00e9todo indicado en el campo \u201cM\u00e9todo Det. Rep.\u201d y si el c\u00f3digo MAC calculado por el receptor es igual al c\u00f3digo MAC contenido en la opci\u00f3n de autenticaci\u00f3n. En la Figura 3.5 se puede observar un diagrama de flujo donde se detalla el conjunto de acciones realizadas durante el proceso de validaci\u00f3n de un mensaje DHCP usando este m\u00e9todo de autenticaci\u00f3n. Recepci\u00f3n de mensaje DHCP Descartar mensaje M\u00e9todo de detecci\u00f3n de repetici\u00f3n conocido? Existe opci\u00f3n de autenticaci\u00f3n? Descartar mensaje Descartar mensaje NO SI NO Valor de detecci\u00f3n de repetici\u00f3n v\u00e1lido? SI NO Descartar mensaje Descartar mensaje Descartar mensaje M\u00e9todo de autenticaci\u00f3n conocido? Algoritmo conocido? Identificador de llave conocido? Mensaje autenticado NO NO NO SI SI SI HMAC calculado coincide? SI Descartar mensaje SI NO \u00danica opci\u00f3n de autenticaci\u00f3n? Descartar mensajeNO SI Procesar el resto del mensaje DHCP Figura 3.5 Diagrama de flujo de validaci\u00f3n de mensajes usando Delayed Authentication. 24 4. Metodolog\u00eda y Herramientas En este cap\u00edtulo se describen las fases en las que se dividi\u00f3 la realizaci\u00f3n de este trabajo para cumplir con los objetivos propuestos. Adem\u00e1s se describen las herramientas necesarias para llevar a cabo la elaboraci\u00f3n del mismo. 4.1. Fases para la Elaboraci\u00f3n del Presente Trabajo Para la realizaci\u00f3n de este trabajo, se dividi\u00f3 el desarrollo del mismo en las siguientes fases: Investigaci\u00f3n acerca de implementaciones existentes de DHCP. Selecci\u00f3n de implementaci\u00f3n de DHCP. An\u00e1lisis de c\u00f3digo fuente de la implementaci\u00f3n seleccionada. Implementaci\u00f3n de DHCP con autenticaci\u00f3n. Dise\u00f1o de los escenarios de prueba. Realizaci\u00f3n de pruebas. An\u00e1lisis de los resultados. 4.1.1. Investigaci\u00f3n de Implementaciones Existentes de DHCP En esta fase se realiza la b\u00fasqueda de distintas implementaciones de clientes y servidores DHCP que sigan la filosof\u00eda de \"c\u00f3digo abierto\". Esto con la finalidad de poder agregar el soporte a la autenticaci\u00f3n en mensajes DHCP y llevar a cabo la soluci\u00f3n propuesta en este trabajo. 4.1.2. Selecci\u00f3n de Implementaci\u00f3n de DHCP Esta fase consiste en la elecci\u00f3n de una de las implementaciones que hayan sido encontradas durante la fase anterior. Luego se procede a seleccionar una de ellas basado en varios criterios establecidos previamente. 4.1.3. An\u00e1lisis de C\u00f3digo Fuente Una vez seleccionada una implementaci\u00f3n de DHCP sobre la cual trabajar, se procedi\u00f3 a revisar el c\u00f3digo fuente de la misma para entender c\u00f3mo se encuentra estructurada la aplicaci\u00f3n, c\u00f3mo es el flujo de la misma y qu\u00e9 elementos interact\u00faan para llevar a cabo el proceso de concesi\u00f3n de una direcci\u00f3n IP usando esta implementaci\u00f3n de DHCP. Posteriormente, se puede determinar c\u00f3mo llevar a cabo la soluci\u00f3n propuesta en este trabajo, es decir el env\u00edo, recepci\u00f3n y validaci\u00f3n de mensajes DHCP con autenticaci\u00f3n. 25 4.1.4. Implementaci\u00f3n de DHCP con autenticaci\u00f3n Luego de haber analizado la implementaci\u00f3n seleccionada, se procedi\u00f3 a extender el c\u00f3digo fuente de la misma. Esto con la finalidad de a\u00f1adirle las funcionalidades necesarias para llevar a cabo la autenticaci\u00f3n en mensajes DHCP tal como se describe en el RFC 3118. Adem\u00e1s se agregan ciertos controles para llevar a cabo la validaci\u00f3n de los mensajes. De esta forma se puede determinar si un mensaje deber\u00eda ser aceptado o descartado si el ente que envi\u00f3 el mensaje provee informaci\u00f3n suficiente que demuestre que se encuentra debidamente autenticado o no respectivamente. 4.1.5. Dise\u00f1o de los Escenarios de Prueba En esta fase se plantean los diversos escenarios de prueba que se configuraron para evaluar varios aspectos de la soluci\u00f3n desarrollada en este trabajo. Estas pruebas son dise\u00f1adas teniendo en cuenta c\u00f3mo deber\u00eda de ser el comportamiento de la soluci\u00f3n desarrollada ante casos de autenticaci\u00f3n exitosos, casos de fallo por distintos motivos, topolog\u00eda de la red en la que se encuentran los elementos que componen al sistema DHCP, entre otros. 4.1.6. Realizaci\u00f3n de Pruebas Se realizan las pruebas planificadas para comprobar la estabilidad y el correcto funcionamiento del sistema ante los varios casos donde es usada la opci\u00f3n de autenticaci\u00f3n. Durante la realizaci\u00f3n de las pruebas se recopilan ciertos registros y datos de la aplicaci\u00f3n para su futuro an\u00e1lisis 4.1.7. An\u00e1lisis de los Resultados Finalmente, se podr\u00e1n examinar e interpretar los datos obtenidos en la fase anterior para concluir si se lograron los objetivos planteados en este trabajo. 4.2. Herramientas Utilizadas Para la realizaci\u00f3n del presente trabajo se usaron distintas herramientas de software que se describen a continuaci\u00f3n: 26 Debian GNU/Linux: Debian [16] es una distribuci\u00f3n del sistema operativo Linux y est\u00e1 compuesto de varios paquetes de software siguiendo la filosof\u00eda de software libre bajo la licencia GNU GPL. Ubuntu: Ubuntu [17] es una distribuci\u00f3n del sistema operativo Linux y basada en \"Debian\". Ubuntu se destaca por ser una de las m\u00e1s populares distribuciones de Linux usadas en computadores personales. Internet Systems Consortium (ISC) DHCP: Es la implementaci\u00f3n c\u00f3digo abierto de DHCP m\u00e1s usada en la Internet. Posee un grupo de trabajo que constantemente realiza actualizaciones y una lista de correos donde una comunidad de desarrolladores y usuarios pueden realizar aportes o preguntas acerca del mismo. Es distribuido bajo los t\u00e9rminos de la Licencia ISC [7]. GCC (GNU Compiler Collection): Es un sistema de compilaci\u00f3n producido por el Proyecto GNU y usado como el compilador est\u00e1ndar por la mayor\u00eda de los sistemas operativos derivados de Unix, entre ellos Linux. Mayormente utilizado para compilar programas en lenguaje C/C++, pero tambi\u00e9n posee soporte para manejar otros lenguajes de programaci\u00f3n como Objective-C, Fortran, entre otros [8]. Make (GNU Make): Es una utilidad usada en varios sistemas operativos que permite la creaci\u00f3n automatizada de programas ejecutables y bibliotecas a partir de un conjunto de archivos que contengan el c\u00f3digo fuente del mismo [9]. SU (Substitute User): Es una utilidad que permite cambiar de cuenta de usuario a trav\u00e9s del int\u00e9rprete de comandos. Es generalmente utilizado para elevar los privilegios del usuario actual a aquellos de un superusuario o administrador del sistema local [10]. VMware Workstation: Es un hipervisor que permite la creaci\u00f3n y ejecuci\u00f3n de una o varias m\u00e1quinas virtuales en una m\u00e1quina f\u00edsica, denominada hu\u00e9sped. Cada m\u00e1quina virtual puede ejecutar su propio sistema operativo (por ejemplo Windows, Linux, BSD, entre otros), no necesariamente siendo el mismo en ejecuci\u00f3n bajo el hu\u00e9sped. Desarrollado por VMware, Inc [11]. Wireshark: Es un analizador de paquetes y protocolos de red usado para capturar y analizar el tr\u00e1fico en una red de computadoras. Com\u00fanmente usado para solucionar problemas en redes y en el desarrollo de protocolos de software y protocolos de comunicaci\u00f3n [12]. 27 5. Dise\u00f1o de la Soluci\u00f3n En este cap\u00edtulo se describir\u00e1 el conjunto de tareas que se realizar\u00e1n para poder implementar la soluci\u00f3n a la problem\u00e1tica presentada en este trabajo y as\u00ed cumplir con los objetivos planteados. 5.1. Investigaci\u00f3n de Implementaciones Existentes de DHCP El objetivo principal de este trabajo es la de lograr la implementaci\u00f3n de un cliente y servidor DHCP que tenga soporte para los mensajes de autenticaci\u00f3n. Para ello se sigue una investigaci\u00f3n previa en el tema [13] en la que se especifica la necesidad de implementar dicho mecanismo, la carencia de dicho mecanismo en las implementaciones actuales de DHCP y c\u00f3mo implementar el mismo. Ya que el objetivo principal a alcanzar en este trabajo es netamente lograr la autenticaci\u00f3n en mensajes DHCP y que se puede encontrar una variedad de implementaciones de DHCP ya bien establecidas en la Internet, se consider\u00f3 innecesario desarrollar la soluci\u00f3n desde cero y se opt\u00f3 por seleccionar alguna implementaci\u00f3n que permitiera lograr los objetivos con mayor rapidez. Durante la b\u00fasqueda, se observ\u00f3 que la cantidad de implementaciones c\u00f3digo abierto de clientes DHCP son algo escazas, adem\u00e1s de que en su gran mayor\u00eda est\u00e1n orientadas para sistemas Linux. Por ello se recopil\u00f3 una lista de posibles implementaciones a elegir para el sistema operativo antes mencionado y desarrollar la soluci\u00f3n sobre el mismo. 5.2. Selecci\u00f3n de Implementaci\u00f3n de DHCP Luego de realizar la investigaci\u00f3n descrita en el paso anterior, se procedi\u00f3 a seleccionar a una entre todas las implementaciones encontradas, las cuales se nombran a continuaci\u00f3n: 5.2.1. Udhcpc y Udhcpd (Busybox) Udhcpc y Udhcpd (micro cliente - micro servidor DHCP) son unas implementaciones de DHCP desarrolladas en el lenguaje de programaci\u00f3n C y generalmente distribuidas dentro del paquete de utilidades Busybox [18], que consta de herramientas pensadas para ser ejecutadas en dispositivos con sistemas embebidos. Esto hace que estas implementaciones sean sumamente ligeras y sencillas, sin embargo esto tambi\u00e9n representa un inconveniente ya que s\u00f3lo proveen un conjunto de funcionalidades b\u00e1sicas y carecen de diversos 28 mecanismos de controles o validaciones de mensajes, por lo que el producto final pudiese no cumplir con algunos aspectos deseables de seguridad. 5.2.2. LoosyDHCP, dhcp4java y JDHCPD Las implementaciones LoosyDHCP [19], dhcp4java [20] y JDHCPD [21] est\u00e1n desarrolladas bajo el lenguaje de programaci\u00f3n Java, lo cual pod\u00eda representar un beneficio a favor debido a la portabilidad que provee dicho lenguaje de programaci\u00f3n, es decir el mismo c\u00f3digo funcionar\u00eda indistintamente del sistema operativo. Sin embargo, se encontr\u00f3 que estas implementaciones consist\u00edan \u00fanicamente de servidores DHCP y en una de ellas se indicaba el motivo que restring\u00eda la implementaci\u00f3n de clientes en este lenguaje: Java, al ser un lenguaje de muy alto nivel, no pose\u00eda ning\u00fan m\u00e9todo para acceder a la informaci\u00f3n de la capa de enlace por lo que el cliente no podr\u00eda construir correctamente los mensajes iniciales. Adem\u00e1s, Java coloca una direcci\u00f3n IP autogenerada cuando la direcci\u00f3n IP fuente de un mensaje es la direcci\u00f3n 0.0.0.0 y este es un aspecto necesario para el cliente en el proceso de DHCP, por lo que el desarrollo de la soluci\u00f3n bajo este lenguaje de programaci\u00f3n qued\u00f3 descartado r\u00e1pidamente. 5.2.3. ISC DHCP Esta implementaci\u00f3n c\u00f3digo abierto de DHCP es desarrollada por el Internet Systems Consortium [7] bajo el lenguaje de programaci\u00f3n C y es actualmente la de mayor uso en la Internet, incluso siendo la implementaci\u00f3n utilizada por defecto en varias distribuciones de Linux. Recibe mantenimiento constante por parte de un grupo de trabajo y tambi\u00e9n por medio de aportes de la comunidad de usuarios y desarrolladores. Cuenta con una lista de correos donde el equipo del ISC y la comunidad intercambian comentarios, dudas, soluciones, entre otros, lo que representaba una ventaja sobre las otras implementaciones que fueron evaluadas. Esta es la implementaci\u00f3n que fue seleccionada para a\u00f1adirle soporte para mensajes de autenticaci\u00f3n en DHCP y se eligi\u00f3 la versi\u00f3n 4.2.4-P1. 5.3. An\u00e1lisis de C\u00f3digo Fuente Para poder implementar los cambios necesarios y a\u00f1adir el soporte a los mensajes de autenticaci\u00f3n en DHCP, hay que primero analizar el c\u00f3digo fuente de la implementaci\u00f3n para entender las piezas en las que est\u00e1 estructurado el ISC DHCP y comprender la forma en la que los desarrolladores del ISC DHCP realizan el proceso de construcci\u00f3n, procesamiento, env\u00edo y recepci\u00f3n de los mensajes. De esta forma se puede obtener una idea del enfoque a seguir para modificar el c\u00f3digo adecuadamente, intentando reutilizar la mayor cantidad de c\u00f3digo posible. 29 5.3.1. Estructura de la Implementaci\u00f3n El c\u00f3digo del ISC DHCP se encuentra dividido a lo largo de m\u00e1s de 100 archivos fuentes y bibliotecas, cada uno ubicado dentro de alg\u00fan directorio en particular dependiendo del papel que cumpla, por ejemplo, archivos que son usados \u00fanicamente por el cliente son ubicados en un directorio llamado client, del mismo modo, el servidor posee un directorio server, utilidades en com\u00fan se encuentran en el directorio common, las bibliotecas en general se encuentran en el directorio includes, y as\u00ed sucesivamente. Para poder adaptar la implementaci\u00f3n actual a las indicaciones descritas en el RFC 3118, se observ\u00f3 que los archivos a los que principalmente hab\u00eda que realizarle modificaciones eran los siguientes: dhcpd.c: Este archivo es el punto inicial del servidor. Contiene el c\u00f3digo respectivo para el arranque del demonio y sus par\u00e1metros de ejecuci\u00f3n, rutas de archivos de configuraci\u00f3n, registros de clientes e inicio de rutinas de escucha y despacho de mensajes, entre otras. dhcp.c: Contiene todo lo que concierne a la recepci\u00f3n, procesamiento, clasificaci\u00f3n y env\u00edo de mensajes DHCP por parte del servidor. dhclient.c: En este archivo se encuentra en general todo lo relacionado al cliente, como lo es el arranque del demonio del cliente y sus par\u00e1metros de ejecuci\u00f3n, rutas de archivos de configuraci\u00f3n, chequeo de direcciones IP adquiridas previamente, inicio de rutinas de recepci\u00f3n, procesamiento, clasificaci\u00f3n y env\u00edo de mensajes DHCP por parte del cliente, entre otras. dhcpd.h: Esta biblioteca es una de las piezas centrales del ISC DHCP. En ella se encuentra una gran parte de las estructuras utilizadas en muchas de las funciones de toda la implementaci\u00f3n. Tambi\u00e9n se encuentran los prototipos de muchas de las funciones ubicadas en distintos archivos que se encuentran en los dem\u00e1s directorios para que puedan ser utilizados desde casi cualquier parte del c\u00f3digo que compone al DHCP. dst_all.c: Este archivo en s\u00ed no es original del c\u00f3digo fuente provisto por el ISC, pero es una recopilaci\u00f3n de los archivos contenidos en el directorio dst, que corresponde al Digital Signature Toolkit desarrollado por Trusted Information Systems. Consiste en un conjunto de utilidades para la inicializaci\u00f3n y uso de funciones de cifrado de datos por medio de algoritmos de hashing y llaves. El motivo por el cual se realiz\u00f3 tal recopilaci\u00f3n ser\u00e1 descrito m\u00e1s adelante. 30 5.3.2. Enfoque a Seguir Para la Modificaci\u00f3n de la Implementaci\u00f3n Con la informaci\u00f3n obtenida a partir del an\u00e1lisis del c\u00f3digo fuente, se pudo idear d\u00f3nde hab\u00eda que realizar cambios al c\u00f3digo y c\u00f3mo ser\u00eda el enfoque a seguir para realizar dichos cambios. En particular se deseaba hacer los cambios de tal forma de que el c\u00f3digo a\u00f1adido fuese lo m\u00e1s similar al c\u00f3digo desarrollado por el grupo de trabajo del ISC, es decir usar las mismas funciones de construcci\u00f3n y procesamiento de las distintas opciones para incluir as\u00ed la opci\u00f3n de autenticaci\u00f3n en los mensajes DHCP. Sin embargo, se tuvo que optar por modificar directamente el mensaje DHCP a nivel de bytes ya que no se encontr\u00f3 suficiente documentaci\u00f3n acerca de las funciones y estructuras ya existentes que permitieran hacer un uso correcto de las mismas, como por ejemplo: Complejidad del formato de la opci\u00f3n de autenticaci\u00f3n: Cada opci\u00f3n conocida por el ISC DHCP est\u00e1 declarada en un archivo llamado tables.c, en el que se indica el n\u00famero de c\u00f3digo asignado a la opci\u00f3n, un \"universo\" al que pertenecen y el formato o los tipos de datos que componen dicha opci\u00f3n. Los tipos de datos ya se encuentran predefinidos y son similares a los encontrados en los lenguajes de programaci\u00f3n, como por ejemplo \"entero de 32 bits\", \"cadena de texto\", \"direcci\u00f3n IPv4\", entre otros. El problema radica en que la opci\u00f3n de autenticaci\u00f3n cuenta con una variedad de campos de distintas longitudes e incluso un n\u00famero variable de campos. Esto hace que sea dif\u00edcil designarle una especie de plantilla acerca de c\u00f3mo se encuentra estructurada la opci\u00f3n de autenticaci\u00f3n. Para estos casos particulares es posible crear un universo \u00fanicamente para ser usado por una opci\u00f3n en particular pero esto acarrea el siguiente inconveniente. Complejidad de la estructura \"universe\": La estructura universe, o como se ha llamado anteriormente el universo, se encuentra declarada en tree.h. En ella se determina c\u00f3mo va a ser el manejo de las opciones que pertenecen a ese universo, como lo son las funciones que estar\u00e1n encargadas de la b\u00fasqueda de opciones, agregaci\u00f3n, encapsulaci\u00f3n, eliminaci\u00f3n, an\u00e1lisis, entre otras funciones. Lamentablemente, esta estructura es sumamente compleja, no posee documentaci\u00f3n que ayude a comprender su funcionamiento y por falta de tiempo no se pudo invertir el esfuerzo necesario para entender c\u00f3mo hacer uso de ella. Dado estos inconvenientes se intent\u00f3 obtener respuestas por parte de la comunidad o el grupo de trabajo del ISC a trav\u00e9s de la lista de correos pero lamentablemente ninguno de los dos ofreci\u00f3 apoyo alguno. Por ello se plante\u00f3 modificar a nivel de bytes el mensaje DHCP luego de que fuese construido por el c\u00f3digo original de DHCP y justo antes de ser transmitido a trav\u00e9s del medio de comunicaci\u00f3n. De igual forma, al recibir un mensaje con la opci\u00f3n de autenticaci\u00f3n presente, se proceder\u00eda a verificar la autenticidad del mensaje antes de que el mensaje fuese procesado por el c\u00f3digo original de DHCP. 31 De esta manera el c\u00f3digo a a\u00f1adir funcionar\u00eda como una especie de m\u00f3dulo que funcionase sobre el proceso de DHCP pero sin alterar en ninguna forma el comportamiento original del mismo, asegurando que el c\u00f3digo original de DHCP nunca encontrase rastros de que existe o haya existido la opci\u00f3n de autenticaci\u00f3n en el mensaje. Para ello en el lado del emisor una funci\u00f3n se encargar\u00eda de modificar el mensaje original DHCP, donde se le agregar\u00eda la opci\u00f3n de autenticaci\u00f3n y el mensaje resultante ser\u00eda enviado a trav\u00e9s de la red, tal como se ilustra en la Figura 5.1. De modo similar, en el lado del receptor se ejecutar\u00eda un segmento de c\u00f3digo que se encargar\u00eda de validar y eliminar la opci\u00f3n de autenticaci\u00f3n en un mensaje recibido antes de que el mismo sea procesado por el c\u00f3digo original de DHCP, tal como se ilustra en la Figura 5.2. Figura 5.1 Inserci\u00f3n de opci\u00f3n de autenticaci\u00f3n a un mensaje DHCP. Figura 5.2 Validaci\u00f3n y eliminaci\u00f3n de la opci\u00f3n de autenticaci\u00f3n en un mensaje DHCP. 32 6. Desarrollo de la Soluci\u00f3n Partiendo del an\u00e1lisis realizado en el cap\u00edtulo anterior se pudo idear en l\u00edneas generales c\u00f3mo realizar cada acci\u00f3n que nos permitir\u00eda cumplir con las indicaciones descritas en el RFC 3118 y con los objetivos planteados para este trabajo. Para lograr los objetivos planteados, la implementaci\u00f3n de la soluci\u00f3n seguir\u00e1 una metodolog\u00eda de desarrollo incremental en el que progresivamente fue agregando nuevas funcionalidades hasta lograr un resultado satisfactorio y comprobando que estas no alteran de ninguna forma a las ya existentes. A continuaci\u00f3n se describir\u00e1 ciertas consideraciones generales que se tomaron en cuenta al momento de la implementaci\u00f3n de la soluci\u00f3n y posteriormente se entrar\u00e1 en detalle en lo que concierne al desarrollo de cada uno de los m\u00e9todos de autenticaci\u00f3n que fueron implementados. 6.1. Consideraciones de Dise\u00f1o Durante el desarrollo de la soluci\u00f3n, se ten\u00eda cierta libertad para implementar muchos de los elementos que compondr\u00edan a la aplicaci\u00f3n. Ya que no se pudo reutilizar ciertos fragmentos del c\u00f3digo del ISC DHCP, todo lo que correspond\u00eda al an\u00e1lisis de la opci\u00f3n de autenticaci\u00f3n, marcas de tiempo para prevenir ataques de repetici\u00f3n, secretos o llaves utilizadas durante el proceso de autenticaci\u00f3n, entre otros, ten\u00eda que ser manejado completamente por el c\u00f3digo a agregar. Para ello se dispuso a crear varios archivos donde se almacenar\u00e1 toda esa informaci\u00f3n. En el Anexo N\u00ba A se puede obtener m\u00e1s informaci\u00f3n acerca del contenido de los archivos. Adem\u00e1s, por ambig\u00fcedad del RFC 3118 en algunos aspectos de la inclusi\u00f3n de la opci\u00f3n de autenticaci\u00f3n en los mensajes DHCP, se tuvo que asumir o decidir c\u00f3mo actuar en unas determinadas situaciones que no mencionaba qu\u00e9 hacer expl\u00edcitamente. Las consideraciones que se tomaron son: El procesamiento de la opci\u00f3n de autenticaci\u00f3n deber\u00e1 ser transparente para el c\u00f3digo del DHCP. Luego de ser procesado, la opci\u00f3n de autenticaci\u00f3n es removida del mensaje DHCP. El mensaje resultante ser\u00e1 procesado por el c\u00f3digo original del ISC DHCP como si nunca hubiese existido dicha opci\u00f3n. Un mensaje DHCP debe contener solamente una opci\u00f3n de autenticaci\u00f3n. a\u00fan cuando no hayan indicaciones al respecto en el RFC 3118. Sin embargo en el RFC 3315 [14] acerca de DHCPv6 se encuentra una secci\u00f3n dedicada a la autenticaci\u00f3n donde s\u00ed indican que s\u00f3lo debe estar presente 33 una opci\u00f3n de autenticaci\u00f3n por mensaje. Se opt\u00f3 por cumplir esa indicaci\u00f3n por ser informaci\u00f3n m\u00e1s reciente y probablemente m\u00e1s madura. Los archivos que contienen los registros de llaves utilizadas y marcas de tiempo para prevenir ataques de repetici\u00f3n s\u00f3lo ser\u00e1n actualizados luego de que un mensaje DHCP sea totalmente y satisfactoriamente procesado. Esto har\u00e1 que no se realicen cambios por mensajes inv\u00e1lidos, evitando realizar tareas innecesarias del lado del receptor. Al usar el m\u00e9todo de Configuration Token no ser\u00e1 obligatorio el uso de la opci\u00f3n Client Identifier. En el m\u00e9todo Delayed Authentication s\u00ed es obligatorio, pero se consider\u00f3 que el m\u00e9todo de Configuration Token deb\u00eda permanecer lo suficientemente simple para no requerir mayor intervenci\u00f3n o configuraci\u00f3n por parte del administrador del sistema. Al usar el m\u00e9todo de Configuration Token, la opci\u00f3n de autenticaci\u00f3n deber\u00e1 estar presente en cada mensaje DHCP. En el RFC 3118 no se profundiza mucho en este m\u00e9todo a diferencia de Delayed Authentication, en el que en casi todo mensaje DHCP se agrega la opci\u00f3n de autenticaci\u00f3n porque ya es conocida la llave, por lo que se decidi\u00f3 aplicar el mismo principio para ambos m\u00e9todos de autenticaci\u00f3n. Al usar el m\u00e9todo de Delayed Authentication si no se especific\u00f3 previamente en el archivo de configuraci\u00f3n del cliente alg\u00fan Client Identifier, a\u00f1adiremos dicha opci\u00f3n al momento de construir la opci\u00f3n de autenticaci\u00f3n. El valor del Client Identifier en este caso corresponder\u00e1 a la direcci\u00f3n MAC de la interfaz por la que el cliente est\u00e9 enviando el mensaje, ya que dicho valor es usualmente utilizado por defecto en otras implementaciones de DHCP. Se consider\u00f3 que esto pudiese facilitar el proceso de configuraci\u00f3n de cada cliente porque as\u00ed se evitar\u00eda el descarte de mensajes DHCP por ausencia de un Client Identifier en los mensajes del cliente, por ejemplo por alg\u00fan descuido en la configuraci\u00f3n por parte del administrador. El \u00fanico m\u00e9todo de detecci\u00f3n de ataques de repetici\u00f3n soportado hasta los momentos ser\u00e1 el contador mon\u00f3tonamente creciente, ya que es el \u00fanico especificado en la bibliograf\u00eda [5]. Las llaves a utilizar por cada uno de los dispositivos ser\u00e1n distribuidas siguiendo el enfoque de pre-distribuci\u00f3n de llaves. La distribuci\u00f3n manual de cada conjunto de llaves con sus respectivos identificadores estar\u00e1 a cargo del administrador del sistema debido a que es sumamente dif\u00edcil la obtenci\u00f3n de llaves para los dispositivos que no poseen una direcci\u00f3n IP. 34 6.2. Configuration Token Para comenzar con el desarrollo de la soluci\u00f3n, se procedi\u00f3 primero con el soporte al m\u00e9todo de autenticaci\u00f3n Configuration Token, ya que era el m\u00e1s sencillo de implementar y adem\u00e1s servir\u00eda de esqueleto para el desarrollo del segundo m\u00e9todo de autenticaci\u00f3n. Para ello se agreg\u00f3 una entrada adicional a los argumentos aceptados al llamar al demonio por el int\u00e9rprete de comandos, que corresponde al tipo de m\u00e9todo de autenticaci\u00f3n a utilizar. En este caso corresponde al m\u00e9todo Configuration Token seguido de la contrase\u00f1a compartida, la contrase\u00f1a se guardar\u00e1 en una variable para su posterior uso. De activarse este m\u00e9todo de autenticaci\u00f3n tambi\u00e9n se lee un archivo que contiene los valores de detecci\u00f3n de ataques de repetici\u00f3n respectivos a los dispositivos con los que se haya realizado un intercambio de mensajes DHCP. Luego cada vez que se fuera a enviar un mensaje DHCP se har\u00eda una llamada a una funci\u00f3n justo antes de enviar el mensaje, la cual se encargar\u00e1 de construir y agregar la opci\u00f3n de autenticaci\u00f3n con la informaci\u00f3n necesaria. El motivo por el que se eligi\u00f3 hacer las modificaciones en este punto en particular es para asegurar la transparencia del c\u00f3digo a\u00f1adido para el resto del sistema DHCP y porque en este punto el contenido del mensaje DHCP es f\u00e1cilmente manipulable ya que consiste en una cadena de caracteres o bytes para efectos del lenguaje C. Al usar Configuration Token en el lado del emisor, los valores de los campos protocol, algorithm y RDM se colocan en 0, se obtiene la hora actual en formato Network Time Protocol (NTP) a trav\u00e9s de la funci\u00f3n \"gettimeofday()\" para colocarla en el campo replay detection y se copia la contrase\u00f1a en el campo authentication information. Luego se verifica el nuevo tama\u00f1o del paquete y se ajusta la longitud acordemente, dependiendo si se encuentra todav\u00eda por debajo de la longitud m\u00ednima o si es mayor. Finalmente se env\u00eda el mensaje. Del lado del receptor, lo primero que se verifica es que est\u00e9 presente la opci\u00f3n de autenticaci\u00f3n en el mensaje DHCP. Luego se verifica que el valor de replay detection asociado al emisor del mensaje DHCP sea estrictamente mayor al anteriormente registrado en caso de existir, o en caso de no existir este ser\u00eda el primer mensaje recibido de parte de ese emisor y se toma como v\u00e1lido. Se verifica que el campo protocol sea 0 (el c\u00f3digo asignado a Configuration Token), al igual que los campos algorithm y RDM ya que este m\u00e9todo no posee ning\u00fan algoritmo de cifrado y no admite ning\u00fan otro m\u00e9todo de detecci\u00f3n de ataques de repetici\u00f3n. Finalmente se verifica que la contrase\u00f1a enviada sea exactamente igual a la contrase\u00f1a provista al arranque del demonio por l\u00ednea de comando. Si alguna de esas validaciones falla el mensaje es descartado y se registra un mensaje de error. Si el mensaje est\u00e1 debidamente autenticado se elimina la opci\u00f3n de autenticaci\u00f3n y se vuelve a verificar la presencia de alguna opci\u00f3n de autenticaci\u00f3n, la cual en caso de resultar positiva tambi\u00e9n se descarta el paquete por motivos anteriormente descritos. Si todas esas validaciones culminan exitosamente, se pasa el mensaje resultante al c\u00f3digo original de DHCP. Si el 35 mensaje no es descartado por validaciones realizadas en el c\u00f3digo original, se actualiza y se guarda en un archivo el valor del campo replay detection asociado al respectivo cliente. Esto se hace luego de que haya sido procesado el mensaje y antes de que sea enviado a alguna funci\u00f3n despachadora de respuestas al mensaje actual. El diagrama de secuencia en la Figura 6.1 resume el procesamiento de la opci\u00f3n de autenticaci\u00f3n en mensajes DHCP intercambiados entre el cliente y el servidor. Figura 6.1 Proceso de autenticaci\u00f3n usando el m\u00e9todo Configuration Token. 6.3. Delayed Authentication Para implementar el m\u00e9todo de autenticaci\u00f3n de Delayed Authentication se tomar\u00e1 como base el c\u00f3digo ya desarrollado para el primer m\u00e9todo de autenticaci\u00f3n y se a\u00f1adir\u00e1n las funcionalidades necesarias, las cuales se describen a continuaci\u00f3n. De igual forma que el m\u00e9todo anterior se a\u00f1adi\u00f3 al c\u00f3digo del demonio otra entrada a la lista de argumentos aceptados que corresponder\u00eda al m\u00e9todo de autenticaci\u00f3n Delayed Authentication, seguido del algoritmo de hashing a usar, aunque actualmente s\u00f3lo est\u00e1 soportado el algoritmo MD5. Al activarse este Cliente con Authenticaci\u00f3n Servidor con authenticaci\u00f3n 1 : DHCPDISCOVER- Ejecuci\u00f3n regular del ISC DHCP - Agregar opci\u00f3n de autenticaci\u00f3n - Chequear opci\u00f3n de Authenticaci\u00f3n - Validar campo Replay Detection - Comparar secreto compartido - Ejecuci\u00f3n regular del ISC DHCP - Actualizar archivo de Replay Detection - Ejecuci\u00f3n regular del ISC DHCP - Agregar opci\u00f3n de autenticaci\u00f3n2 : DHCPOFFER - Chequear opci\u00f3n de Authenticaci\u00f3n - Validar campo Replay Detection - Comparar secreto compartido - Ejecuci\u00f3n regular del ISC DHCP - Actualizar archivo de Replay Detection - Ejecuci\u00f3n regular del ISC DHCP - Agregar opci\u00f3n de autenticaci\u00f3n - Chequear opci\u00f3n de Authenticaci\u00f3n - Validar campo Replay Detection - Comparar secreto compartido - Ejecuci\u00f3n regular del ISC DHCP - Actualizar archivo de Replay Detection - Ejecuci\u00f3n regular del ISC DHCP - Agregar opci\u00f3n de autenticaci\u00f3n - Chequear opci\u00f3n de Authenticaci\u00f3n - Validar campo Replay Detection - Comparar secreto compartido - Ejecuci\u00f3n regular del ISC DHCP - Actualizar archivo de Replay Detection 3 : DHCPREQUEST 4 : DHCPACK 36 m\u00e9todo de autenticaci\u00f3n, se guardan los valores del m\u00e9todo usado para la autenticaci\u00f3n, el algoritmo de hashing a usar, se carga la lista de valores de detecci\u00f3n de ataques de repetici\u00f3n, una lista predistribu\u00edda a cada dispositivo que contiene las llaves y sus identificadores respectivos y una lista con las llaves que han sido utilizadas en intercambios de mensajes con otro dispositivo en particular. Adem\u00e1s, algunos procedimientos, estructuras y algoritmos de hashing utilizados durante el proceso de autenticaci\u00f3n deben ser inicializados previamente a su utilizaci\u00f3n, por lo que se har\u00e1 dicha acci\u00f3n la primera vez que se tenga que calcular un hash, ya sea para el env\u00edo de un mensaje o para la validaci\u00f3n de un mensaje recibido. Al usar el m\u00e9todo de Delayed Authentication, en el lado del emisor se coloca el campo protocol en 1, el campo algorithm con el valor respectivo del algoritmo seleccionado, el campo RDM con el valor respectivo al m\u00e9todo de detecci\u00f3n de repetici\u00f3n seleccionado, se obtiene la hora actual en formato NTP a trav\u00e9s de la funci\u00f3n \"gettimeofday()\" para colocarla en el campo replay detection y dependiendo del tipo de mensaje DHCP enviado se colocan datos o no en el campo de Authentication information. Si el mensaje es del tipo DHCPDISCOVER el campo permanece vac\u00edo, pero en caso contrario se coloca el identificador de la llave a usar en el campo Secret-ID, se calcula el c\u00f3digo de autenticaci\u00f3n del mensaje (HMAC) como se especifica en el RFC 2104 [6] y se coloca en el campo HMAC. Luego se verifica el nuevo tama\u00f1o del paquete y se ajusta la longitud acordemente, dependiendo si se encuentra todav\u00eda por debajo de la longitud m\u00ednima o si es mayor. Finalmente se env\u00eda el mensaje. Del lado del receptor, lo primero que se verifica es que est\u00e9 presente la opci\u00f3n de autenticaci\u00f3n en el mensaje DHCP. Luego se verifica que el valor de replay detection asociado al emisor del mensaje DHCP sea estrictamente mayor al anteriormente registrado en caso de existir, o en caso de no existir este ser\u00eda el primer mensaje recibido de parte de ese emisor y se toma como v\u00e1lido. Se verifica que el campo protocol sea 1 (el c\u00f3digo asignado a Delayed Authentication), que el campo algorithm concuerde con el algoritmo en uso por el receptor y que el campo RDM pertenezca a un m\u00e9todo de detecci\u00f3n de ataques de repetici\u00f3n conocido por el receptor. A partir de este punto pueden ocurrir dos situaciones. Si un servidor recibe un mensaje del tipo DHCPDISCOVER, selecciona una llave al azar de entre todas las llaves conocidas, la registra como la llave a utilizar en los mensajes intercambiados con ese cliente en particular y el mensaje se toma como autenticado. Si se recibe otro tipo de mensaje, se almacena el HMAC presente en el mensaje y se procede a calcular el HMAC del mensaje con la llave indicada, la cu\u00e1l debe ser conocida por el receptor. Posteriormente se verifica que el HMAC proporcionado y el HMAC calculado sean iguales. Si alguna de esas validaciones falla el mensaje es descartado y se registra un mensaje de error. 37 Si el mensaje est\u00e1 debidamente autenticado se elimina la opci\u00f3n de autenticaci\u00f3n y se vuelve a verificar la presencia de alguna opci\u00f3n de autenticaci\u00f3n, la cual en caso de resultar positiva tambi\u00e9n se descarta el paquete por motivos anteriormente descritos. Si todas esas validaciones culminan exitosamente se pasa el mensaje resultante al c\u00f3digo original de DHCP. Si el mensaje no es descartado por validaciones realizadas en el c\u00f3digo original, se actualizan y se guardan en sus respectivos archivos los valores del campo replay detection y la llave asociada al respectivo cliente. Esto se hace luego de que haya sido procesado el mensaje y antes de que sea enviado a alguna funci\u00f3n despachadora de respuestas al mensaje actual. El diagrama de secuencia en la Figura 6.2 resume el procesamiento de la opci\u00f3n de autenticaci\u00f3n en mensajes DHCP intercambiados entre el cliente y el servidor. Figura 6.2 Proceso de autenticaci\u00f3n usando el m\u00e9todo Delayed Authentication. Cliente con Authenticaci\u00f3n Servidor con authenticaci\u00f3n 1 : DHCPDISCOVER - Ejecuci\u00f3n regular del ISC DHCP - Agregar opci\u00f3n de autenticaci\u00f3n - Chequear opci\u00f3n de Authenticaci\u00f3n - Validar campo Replay Detection - Asignar llave compartida - Ejecuci\u00f3n regular del ISC DHCP - Actualizar archivo de Replay Detection - Actualizar archivo de llaves usadas - Ejecuci\u00f3n regular del ISC DHCP - Agregar opci\u00f3n de autenticaci\u00f3n - Incluir hash HMAC 2 : DHCPOFFER - Chequear opci\u00f3n de Authenticaci\u00f3n - Validar campo Replay Detection - Comparar hash usando llave compartida - Ejecuci\u00f3n regular del ISC DHCP - Actualizar archivo de Replay Detection - Actualizar archivo de llaves usadas - Ejecuci\u00f3n regular del ISC DHCP - Agregar opci\u00f3n de autenticaci\u00f3n - Incluir hash HMAC - Chequear opci\u00f3n de Authenticaci\u00f3n - Validar campo Replay Detection - Comparar hash usando llave compartida - Ejecuci\u00f3n regular del ISC DHCP - Actualizar archivo de Replay Detection - Actualizar archivo de llaves usadas - Ejecuci\u00f3n regular del ISC DHCP - Agregar opci\u00f3n de autenticaci\u00f3n - Incluir hash HMAC - Chequear opci\u00f3n de Authenticaci\u00f3n - Validar campo Replay Detection - Comparar hash usando llave compartida - Ejecuci\u00f3n regular del ISC DHCP - Actualizar archivo de Replay Detection - Actualizar archivo de llaves usadas 3 : DHCPREQUEST 4 : DHCPACK 38 7. Pruebas En este cap\u00edtulo se describen los escenarios de pruebas que fueron dise\u00f1ados y realizados para evaluar varios aspectos de la implementaci\u00f3n desarrollada. Para ello se prepararon b\u00e1sicamente tres conjuntos de pruebas. 7.1. Pruebas de Correcci\u00f3n En estas pruebas se eval\u00faa que el comportamiento de la implementaci\u00f3n cumple con las indicaciones establecidas en el RFC 3118 en lo que respecta a la correcta validaci\u00f3n de mensajes DHCP. 7.1.1. Preparaci\u00f3n de las Pruebas Para la realizaci\u00f3n de las pruebas de correcci\u00f3n se prepar\u00f3 un esquema de red donde s\u00f3lo se encuentra un cliente y un servidor en la misma sub red como se ilustra en la Figura 7.1. Figura 7.1 Topolog\u00eda de red para pruebas de correcci\u00f3n. En este primer caso se prepararon diversos escenarios en los que el cliente envi\u00f3 mensajes autenticados correctamente y envi\u00f3 mensajes con variados errores en la opci\u00f3n de autenticaci\u00f3n para que los mismos fueran descartados apropiadamente por el servidor. Un segundo caso es el escenario donde se encontraba un agente de relevo DHCP entre cliente y servidor como se ilustra en la Figura 7.2, para comprobar que la soluci\u00f3n funciona a trav\u00e9s de agentes de relevo. Figura 7.2 Topolog\u00eda de red para pruebas de correcci\u00f3n con agentes de relevo DHCP. 39 Por \u00faltimo se realiz\u00f3 una prueba que consisti\u00f3 en colocar varios clientes y servidores en la misma sub red como se muestra en la Figura 7.3, cada uno usando o no alg\u00fan m\u00e9todo de autenticaci\u00f3n y compartiendo alg\u00fan secreto o llaves que permit\u00eda el intercambio de mensajes con otro dispositivo. Es decir, los clientes pod\u00edan adquirir una direcci\u00f3n IP s\u00f3lo de aquellos servidores con los que se compart\u00eda el mismo secreto o conjunto de llaves y utilizaban el mismo m\u00e9todo de autenticaci\u00f3n, o bien si no utilizaban ning\u00fan m\u00e9todo de autenticaci\u00f3n. Figura 7.3 Topolog\u00eda de red para pruebas de correcci\u00f3n con varios clientes y servidores DHCP. 7.1.2. Ejecuci\u00f3n de las Pruebas Los escenarios que se plantearon para evaluar el correcto funcionamiento de la soluci\u00f3n son los siguientes: 7.1.2.1. Opciones de autenticaci\u00f3n v\u00e1lidas En este escenario el cliente y el servidor DHCP se iniciaron usando el mismo m\u00e9todo de autenticaci\u00f3n y utilizando el mismo secreto compartido o conjunto de llaves, por lo que el cliente enviaba mensajes DHCP autenticados satisfactoriamente y pod\u00eda adquirir informaci\u00f3n de configuraci\u00f3n de red por un per\u00edodo de tiempo. En la Figura 7.4 y Figura 7.5 se pueden apreciar partes de una captura de Wireshark donde se muestra la opci\u00f3n de autenticaci\u00f3n v\u00e1lida usando los m\u00e9todos Configuration Token y Delayed Authentication respectivamente. 40 Figura 7.4 Autenticaci\u00f3n v\u00e1lida usando Configuration Token. Figura 7.5 Autenticaci\u00f3n v\u00e1lida usando Delayed Authentication. 41 7.1.2.2. Opci\u00f3n de autenticaci\u00f3n no presente En este escenario el cliente se inici\u00f3 sin usar alg\u00fan m\u00e9todo de autenticaci\u00f3n. El servidor recibi\u00f3 un mensaje DHCPDISCOVER sin opci\u00f3n de autenticaci\u00f3n, por lo que descart\u00f3 el mensaje y el cliente no pudo obtener informaci\u00f3n de configuraci\u00f3n de red. De forma similar, un cliente que recibi\u00f3 un mensaje sin la opci\u00f3n de autenticaci\u00f3n descart\u00f3 dicho mensaje. En la Figura 7.6 se puede apreciar una captura de un mensaje que no posee la opci\u00f3n de autenticaci\u00f3n. Figura 7.6 Ausencia de opci\u00f3n de autenticaci\u00f3n. 7.1.2.3. Uso de clave o llave incorrecta En este escenario para el caso de Configuration Token, el cliente y el servidor usaron un secreto distinto (\"wrong_token\" y \"test_token\" respectivamente), por lo que ambos descartaron cualquier mensaje que se enviaron entre s\u00ed de acuerdo a lo establecido en el RFC 3118. Para el caso de Delayed Authentication, si no se encontraba un identificador de llave o si la llave era distinta, el c\u00e1lculo del hash o no se pod\u00eda hacer o resultaba en un hash distinto, por lo que se descartaba el mensaje. La captura en la Figura 7.7 muestra el uso de un token distinto mientras que la captura en la Figura 7.8 muestra el uso de identificadores no aceptados en Delayed Authentication (el cliente s\u00f3lo posee la llave con ID 1 y el servidor usa una llave con ID 2). 42 Figura 7.7 Uso de secreto incorrecto en Configuration Token. Figura 7.8 Llave incorrecta en Delayed Authentication. 43 7.1.2.4. Valor de detecci\u00f3n de repetici\u00f3n inaceptable En este escenario se modific\u00f3 en el servidor el archivo que contiene los valores de detecci\u00f3n de repeticiones y se cambi\u00f3 la marca de tiempo del cliente a una fecha en el futuro como se aprecia en la Figura 7.9. El servidor recibi\u00f3 un mensaje con un valor de detecci\u00f3n inferior (no aceptable) por lo que el mensaje fue descartado. En la Figura 7.10 se muestra que el valor de detecci\u00f3n de repetici\u00f3n enviado por el cliente es menor que el valor encontrado en el archivo del servidor. Figura 7.9 Modificaci\u00f3n en archivo de Replay Values del servidor. Figura 7.10 Valor no aceptable para el m\u00e9todo de detecci\u00f3n de repetici\u00f3n. 44 7.1.2.5. Valores no aceptados para los campos protocol, algorithm o RDM En este escenario el cliente se modific\u00f3 para enviar valores no aceptados o conocidos por el servidor para los campos mencionados (por simplicidad s\u00f3lo se mostrar\u00e1 una de las pruebas, correspondiente al campo RDM). El servidor descart\u00f3 el mensaje ya que no conoc\u00eda el m\u00e9todo de detecci\u00f3n de ataques de repetici\u00f3n siendo usado por el cliente. La captura en la Figura 7.11 refleja este hecho y se resalta la palabra \"Unknown\", indicando que es un m\u00e9todo no soportado actualmente. Figura 7.11 Valor desconocido para el campo de m\u00e9todo de detecci\u00f3n de repetici\u00f3n. 7.1.2.6. Dos o m\u00e1s opciones de autenticaci\u00f3n presentes en el mensaje En este escenario el cliente se modific\u00f3 para enviar un mensaje DHCPDISCOVER que conten\u00eda dos opciones de autenticaci\u00f3n id\u00e9nticas. El servidor recibi\u00f3 el mensaje y encontr\u00f3 que hab\u00eda varias opciones de autenticaci\u00f3n, por lo que descart\u00f3 el mensaje. Las capturas que muestran el mensaje DHCP con dos opciones de autenticaci\u00f3n se encuentran en la Figura 7.12 y Figura 7.13. 45 Figura 7.12 Presencia de 2 opciones de autenticaci\u00f3n usando Configuration Token. Figura 7.13 Presencia de 2 opciones de autenticaci\u00f3n usando Delayed Authentication. 46 7.1.2.7. Agente de relevo entre un cliente y un servidor En este escenario se ubic\u00f3 al cliente y al servidor en dos sub redes distintas, pero una tercera m\u00e1quina se configur\u00f3 como agente de relevo ya que posee dos interfaces de red, cada una conectada a una de las subredes. El agente de relevo escuchaba y retransmit\u00eda peticiones DHCP hacia un servidor indicado por l\u00ednea de comando. Se enviaron mensajes autenticados a trav\u00e9s del agente de relevo y como resultado este modific\u00f3 el valor del campo giaddr del mensaje DHCP, indicando que el mensaje pas\u00f3 a trav\u00e9s del agente de relevo se\u00f1alado. Las capturas en la Figura 7.14 y la Figura 7.15 reflejan dicha acci\u00f3n. Figura 7.14 Uso de Configuration Token a trav\u00e9s de un agente de relevo. 47 Figura 7.15 Uso de Delayed Authentication a trav\u00e9s de un agente de relevo. 7.1.2.8. Ambiente variado En este escenario se ubic\u00f3 en una misma sub red a un gran n\u00famero de clientes y servidores DHCP funcionando simult\u00e1neamente. Espec\u00edficamente se cont\u00f3 con 10 servidores y 20 clientes cuyas configuraciones se pueden apreciar en la Tabla 7.1 y Tabla 7.2 respectivamente, para un total de 30 m\u00e1quinas. ID servidor Autenticaci\u00f3n Direcci\u00f3n IP Pool direcciones IP Servidor 0 Delayed Auth, conjunto de llaves {K} y ID {A} 10.0.0.200 [10.0.0.1 - 10.0.0.9] Servidor 1 Delayed Auth, conjunto de llaves {K} y ID {A} 10.0.0.201 [10.0.0.11 - 10.0.0.19] Servidor 2 Delayed Auth, conjunto de llaves {K} y ID {A} 10.0.0.202 [10.0.0.21 - 10.0.0.29] Servidor 3 Delayed Auth, conjunto de llaves {K} y ID {B} 10.0.0.203 [10.0.0.31 - 10.0.0.39] Servidor 4 Delayed Auth, conjunto de llaves {K} y ID {B} 10.0.0.204 [10.0.0.41 - 10.0.0.49] Servidor 5 Delayed Auth, conjunto de llaves {K} y ID {B} 10.0.0.205 [10.0.0.51 - 10.0.0.59] Servidor 6 Conf.Token, Token \"icarotoken\" 10.0.0.206 [10.0.0.61 - 10.0.0.69] Servidor 7 Conf.Token, Token \"testtoken\" 10.0.0.207 [10.0.0.71 - 10.0.0.79] Servidor 8 No aplica 10.0.0.208 [10.0.0.81 - 10.0.0.89] Servidor 9 No aplica 10.0.0.209 10.0.0.91 - 10.0.0.199] Tabla 7.1 Configuraci\u00f3n de servidores en ambiente variado. 48 Tabla 7.2 Configuraci\u00f3n de clientes en ambiente variado. Dependiendo de la configuraci\u00f3n que pose\u00edan, un cliente s\u00f3lo pod\u00eda obtener los par\u00e1metros de configuraci\u00f3n de red de aquellos servidores con los que se pod\u00eda autenticar exitosamente y tanto el cliente como el servidor descartaban los mensajes que no estaban debidamente autenticados. Dicho comportamiento se puede ver reflejado en la Figura 7.16 y Figura 7.17 donde se pueden apreciar los logs de un cliente y de un servidor en particular. Del lado del servidor se puede ver que las primeras dos l\u00edneas corresponden a mensajes que fueron descartados por no poseer una opci\u00f3n de autenticaci\u00f3n. Las siguientes cuatro l\u00edneas corresponden a la autenticaci\u00f3n y asignaci\u00f3n de IP exitosa de un cliente. Las siguientes dos l\u00edneas corresponden al descarte de un mensaje por el uso de una llave desconocida y la \u00faltima l\u00ednea corresponde al descarte de un mensaje por usar un m\u00e9todo de autenticaci\u00f3n distinto al utilizado por el servidor. ID Cliente Autenticaci\u00f3n Cliente 0 Delayed Authentication, conjunto de llaves {K} con ID {A} Cliente 1 Delayed Authentication, conjunto de llaves {K} con ID {A} Cliente 2 Delayed Authentication, conjunto de llaves {K} con ID {A} Cliente 3 Delayed Authentication, conjunto de llaves {K} con ID {A} Cliente 4 Delayed Authentication, conjunto de llaves {K} con ID {A} Cliente 5 Delayed Authentication, conjunto de llaves {K} con ID {A} Cliente 6 Delayed Authentication, conjunto de llaves {K} con ID {B} Cliente 7 Delayed Authentication, conjunto de llaves {K} con ID {B} Cliente 8 Delayed Authentication, conjunto de llaves {K} con ID {B} Cliente 9 Delayed Authentication, conjunto de llaves {K} con ID {B} Cliente 10 Delayed Authentication, conjunto de llaves {K} con ID {B} Cliente 11 Delayed Authentication, conjunto de llaves {K} con ID {B} Cliente 12 Configuration Token con token \"icarotoken\" Cliente 13 Configuration Token con token \"icarotoken\" Cliente 14 Configuration Token con token \"icarotoken\" Cliente 15 Configuration Token con token \"testtoken\" Cliente 16 Configuration Token con token \"testtoken\" Cliente 17 Configuration Token con token \"testtoken\" Cliente 18 No aplica Cliente 19 No aplica 49 Servidor DHCP No Authentication option from 00:23:12:e7:37:89, packet discarded. No Authentication option from a0:0b:ba:db:44:d3, packet discarded. DHCPDISCOVER from 00:0c:29:4d:6c:1f via eth0 DHCPOFFER on 10.0.0.13 to 00:0c:29:4d:6c:1f via eth0 DHCPREQUEST for 10.0.0.13 (10.0.0.201) from 00:0c:29:4d:6c:1f via eth0 DHCPACK on 10.0.0.13 to 00:0c:29:4d:6c:1f via eth0 Key ID unknown. HMAC not valid from 00:0c:29:cd:62:ee, packet discarded. Wrong PROTOCOL in use from 00:0c:29:a9:9c:0f, packet discarded. Figura 7.16 Extractos del log del servidor DHCP. Del lado del cliente se puede ver que la primera l\u00ednea corresponde al env\u00edo del mensaje DHCPDISCOVER en b\u00fasqueda de alg\u00fan servidor DHCP. Las siguientes cuatro l\u00edneas corresponden a dos mensajes descartados porque los servidores usaron una llave desconocida. Finalmente las \u00faltimas cinco l\u00edneas corresponden a la recepci\u00f3n de una oferta por parte de un servidor autenticado, la petici\u00f3n y asignaci\u00f3n de la direcci\u00f3n IP ofertada por el tiempo indicado. Cliente DHCP DHCPDISCOVER on eth0 to 255.255.255.255 port 67 interval 3 Key ID unknown. HMAC not valid from 10.0.0.205, packet discarded. Key ID unknown. HMAC not valid from 10.0.0.203, packet discarded. No Authentication option from 10.0.0.209, packet discarded. DHCPOFFER from 10.0.0.201 DHCPREQUEST on eth0 to 255.255.255.255 port 67 DHCPACK from 10.0.0.201 bound to 10.0.0.13 -- renewal in 54 seconds. Figura 7.17 Extractos del log del cliente DHCP. Se puede observar que hay varios mensajes que son descartados en ambas partes por motivos que son indicados por pantalla y registrados en los logs de ejecuci\u00f3n. Cabe destacar que el caso de \u00e9xito en la autenticaci\u00f3n corresponde justamente a una petici\u00f3n realizada por el cliente seleccionado hacia el servidor seleccionado para este ejemplo. 7.1.3. An\u00e1lisis de los Resultados Luego de haber culminado las pruebas, se pudo corroborar que la soluci\u00f3n desarrollada en este trabajo cumple con las funcionalidades necesarias para llevar a cabo correctamente la autenticaci\u00f3n en mensajes DHCP tal como lo describe el RFC 3118, por lo tanto cumple con los objetivos planteados. 50 7.2. Pruebas de estr\u00e9s En estas pruebas se evalu\u00f3 la capacidad que posee un servidor DHCP de atender correctamente las peticiones de varios clientes en un ambiente que constantemente tiene un alto n\u00famero de transacciones por per\u00edodo de tiempo. 7.2.1. Preparaci\u00f3n de las Pruebas Para la realizaci\u00f3n de las pruebas de estr\u00e9s se configur\u00f3 un escenario donde un servidor DHCP estuvo sometido a responder al mayor n\u00famero posible de peticiones en un corto per\u00edodo de tiempo. Como lo muestra la Figura 7.18, el escenario consisti\u00f3 en hacer que un servidor atienda las peticiones de 30 clientes simult\u00e1neamente. Adem\u00e1s, para incrementar el n\u00famero de transacciones se configur\u00f3 en el servidor que la duraci\u00f3n de las direcciones IP otorgadas tuviesen una duraci\u00f3n de uno a dos segundos, lo que en promedio result\u00f3 en la renovaci\u00f3n de 15 a 30 direcciones IP por segundo. Ese n\u00famero de transacciones se mantuvo m\u00e1s o menos constante por una duraci\u00f3n de 80 minutos y a lo largo de la prueba se estuvo monitoreando el consumo de recursos en el lado del servidor, espec\u00edficamente los niveles de uso del CPU y memoria RAM utilizada. Transcurrido dicho tiempo, se decidi\u00f3 detener la prueba al no observar variaciones. Esta prueba se realiz\u00f3 usando el c\u00f3digo original del ISC DHCP, luego utilizando el m\u00e9todo de autenticaci\u00f3n Configuration Token y por \u00faltimo el m\u00e9todo de Delayed Authentication para determinar si el uso de alguno de los m\u00e9todos de autenticaci\u00f3n reduc\u00eda en forma significativa la capacidad del servidor de atender a un determinado n\u00famero de clientes. Figura 7.18 Topolog\u00eda de la red para pruebas de estr\u00e9s. 51 7.2.2. Ejecuci\u00f3n de las Pruebas Las pruebas se realizaron bajo m\u00e1quinas virtuales de Debian Squeeze 6.0.1 con entorno gr\u00e1fico utilizando VMware Workstation 6. Las especificaciones de hardware de las m\u00e1quinas hu\u00e9sped y de las m\u00e1quinas virtuales son las siguientes: M\u00e1quina hu\u00e9sped: CPU: Intel Core 2 Duo E6750 2.66 GHz. RAM: 2 GB DDR2 800 MHz Dual Channel. M\u00e1quina virtual: CPU: Intel Core 2 Duo E6750 2.66 GHz (1 n\u00facleo, 1 hilo). RAM: 256 MB DDR2 800 MHz Dual Channel La medici\u00f3n del consumo de recursos fue realizado a trav\u00e9s de la herramienta top [22] del sistema operativo Linux, observando \u00fanicamente al proceso dhcpd. Por cada intervalo de 10 minutos se registr\u00f3 el valor promedio del porcentaje de uso de CPU y memoria que consum\u00eda dicho proceso en el sistema. No se consider\u00f3 analizar el impacto causado en la red debido a que en las pruebas realizadas se mantuvo relativamente constante la cantidad de data enviada. A\u00fan agregando la opci\u00f3n de autenticaci\u00f3n apenas se llegaba a sobrepasar el tama\u00f1o m\u00ednimo del mensaje DHCP (300 bytes). Como se puede apreciar en la Tabla 7.3, Tabla 7.4 y Tabla 7.5, los valores recolectados corresponden a la ejecuci\u00f3n del servidor DHCP sin m\u00e9todo de autenticaci\u00f3n, con el m\u00e9todo Configuration Token y con el m\u00e9todo Delayed Authentication respectivamente. A modo de resumen se puede observar los resultados obtenidos de los tres casos en la Figura 7.19. Tiempo (m) 0 10 20 30 40 50 60 70 80 % mem (promedio) 1.7 1.7 1.7 1.7 1.7 1.7 1.7 1.7 1.7 % CPU (promedio) 1.3 1.3 1.3 1.3 1.3 1.3 1.3 1.3 1.3 Tabla 7.3 Consumo de recursos utilizando ISC DHCP regular. Tiempo (m) 0 10 20 30 40 50 60 70 80 % mem (promedio) 1.8 1.8 1.8 1.8 1.8 1.8 1.8 1.8 1.8 % CPU (promedio) 1.7 1.7 1.7 1.7 1.7 1.7 1.7 1.7 1.7 Tabla 7.4 Consumo de recursos utilizando Configuration Token. Tiempo (m) 0 10 20 30 40 50 60 70 80 % mem (promedio) 1.9 1.9 1.9 1.9 1.9 1.9 1.9 1.9 1.9 % CPU (promedio) 2 2 2 2 2 2 2 2 2 Tabla 7.5 Consumo de recursos utilizando Delayed Authentication. 52 Figura 7.19 Porcentaje de consumo de recursos. 7.2.3. An\u00e1lisis de los Resultados Como se puede apreciar a partir de los datos obtenidos, el uso de cualquiera de los m\u00e9todos de autenticaci\u00f3n genera un aumento de la utilizaci\u00f3n del CPU con respecto a la ejecuci\u00f3n regular, el cual es aproximadamente un 30% mayor al usar Authentication Token y un 50% mayor al usar Delayed Authentication. A\u00fan as\u00ed, el aumento de utilizaci\u00f3n del CPU es muy poco significativo, menos del 1%, por lo que se pudiese pensar que la utilizaci\u00f3n de alguno de los m\u00e9todos de autenticaci\u00f3n no representa mayor impedimento para que un sistema DHCP funcione correctamente bajo per\u00edodos de alta carga. Tambi\u00e9n cabe destacar que las caracter\u00edsticas de hardware que pose\u00eda el servidor eran algo modestos comparado con lo que puede obtenerse hoy en d\u00eda, por lo que el impacto al usar la autenticaci\u00f3n en otros equipos pudiese ser incluso menor. De igual forma, ser\u00eda interesante determinar con exactitud a partir de qu\u00e9 punto el servidor empezar\u00eda a presentar fallas motivado a excesivo tr\u00e1fico o procesamiento con cada uno de los m\u00e9todos de autenticaci\u00f3n, sin embargo por limitaciones de infraestructura del lugar donde se realizaron las pruebas no se pudo lograr que eso ocurriese. En lo que concierne a memoria consumida, se nota un ligero incremento que muy probablemente se deba a que toda informaci\u00f3n de las asociaciones entre llaves y clientes, valores de detecci\u00f3n de repetici\u00f3n, etc., se cargan en memoria y se mantienen en una lista din\u00e1mica. Se espera que mientras mayor sea la cantidad de clientes atendidos por un servidor naturalmente incremente la cantidad de memoria consumida, pero este incremento no es lo suficientemente significativo para generar alg\u00fan impacto en el equipo. 4,33 MB 4,58 MB 4,84 MB 0 0,2 0,4 0,6 0,8 1 1,2 1,4 1,6 1,8 2 2,2 2,4 DHCP Regular Configuration Token Delayed Authentication % d e l re cu rs o % memoria (promedio) % CPU (promedio) 53 7.3. Pruebas de rendimiento En estas pruebas se evalu\u00f3 el costo adicional en tiempo que conlleva la utilizaci\u00f3n de los m\u00e9todos de autenticaci\u00f3n para la obtenci\u00f3n de los par\u00e1metros de configuraci\u00f3n en un cliente. 7.3.1. Preparaci\u00f3n de las Pruebas Para la realizaci\u00f3n de las pruebas de rendimiento se prepar\u00f3 un escenario sencillo que se ilustra en la Figura 7.20 donde un cliente y un servidor DHCP se encuentran en la misma sub red, con la finalidad de medir con la mayor certeza posible el tiempo que tarda un cliente en adquirir una direcci\u00f3n IP usando los varios m\u00e9todos de autenticaci\u00f3n para compararlos con el tiempo regular. Figura 7.20 Topolog\u00eda de red para pruebas de rendimiento. Para ello se tom\u00f3 el tiempo transcurrido del lado del cliente desde que inici\u00f3 su demonio hasta que recibi\u00f3 un mensaje DHCPACK v\u00e1lido por parte del servidor. El tiempo se midi\u00f3 con ayuda de la funci\u00f3n \"gettimeofday()\" para obtener la hora actual y se registr\u00f3 la hora a la que se inici\u00f3 el demonio, la hora a la que se obtuvo satisfactoriamente la direcci\u00f3n IP y la diferencia de estos dos tiempo dio como resultado el tiempo que fue necesario para obtener la direcci\u00f3n IP. Este experimento se repiti\u00f3 varias veces y se hicieron ciertos c\u00e1lculos para obtener un valor promedio. Adem\u00e1s, para estar seguros de que los resultados son lo m\u00e1s precisos posibles se realizaron las pruebas sobre una instalaci\u00f3n nativa de Linux (Ubuntu 9.04) en lugar de una m\u00e1quina virtual como fue mencionado en la realizaci\u00f3n de las pruebas anteriores. 7.3.2. Ejecuci\u00f3n de las Pruebas Para la realizaci\u00f3n de las pruebas se modific\u00f3 \u00fanicamente el c\u00f3digo fuente del cliente para obtener la hora actual en puntos claves, calcular la diferencia e ir almacenando dichos valores en un archivo separado por comas para su posterior an\u00e1lisis. Adem\u00e1s se prepar\u00f3 un script para automatizar el proceso de la 54 realizaci\u00f3n de las pruebas de la siguiente forma: se inicia el demonio DHCP en el cliente con los par\u00e1metros necesarios, luego de obtener una direcci\u00f3n IP se esperan tres segundos, se procede a liberar la direcci\u00f3n IP asignada y se vuelve a esperar tres segundos. Todo el proceso mencionado anteriormente se repite doscientas cincuenta veces para cada uno de los casos, que son la ejecuci\u00f3n regular del cliente DHCP, la ejecuci\u00f3n usando Configuration Token y la ejecuci\u00f3n usando Delayed Authentication. Luego se procedi\u00f3 a calcular algunos valores estad\u00edsticos como el tiempo promedio, m\u00ednimo, m\u00e1ximo, entre otros, a modo de representar los valores en un histograma donde se viera reflejado el comportamiento de la aplicaci\u00f3n durante las pruebas, las cuales corresponden a la Figura 7.21, Figura 7.22 y Figura 7.23. Finalmente la Figura 7.24 muestra una gr\u00e1fica del estilo de cajas (\"box plot\"), indicando dentro de los rect\u00e1ngulos el rango de valores que con mayor probabilidad tome la duraci\u00f3n del proceso de adquisici\u00f3n de una direcci\u00f3n IP para los escenarios evaluados. Figura 7.21 Duraci\u00f3n del proceso para obtener una direcci\u00f3n IP (sin autenticaci\u00f3n). Figura 7.22 Duraci\u00f3n del proceso para obtener una direcci\u00f3n IP (Configuration Token). 0 0,3 0,6 0,9 1,2 1 26 51 76 101 126 151 176 201 226 T ie m p o ( s ) N\u00famero de repetici\u00f3n DHCP Regular Tiempo adquisici\u00f3n IP Promedio Promedio valores superiores 0 0,3 0,6 0,9 1,2 1 26 51 76 101 126 151 176 201 226 T ie m p o ( s ) N\u00famero de repetici\u00f3n DHCP con Configuration Token Tiempo adquisici\u00f3n IP Promedio Promedio valores superiores 55 Figura 7.23 Duraci\u00f3n del proceso para obtener una direcci\u00f3n IP (Delayed Authentication). Figura 7.24 Diagrama de cajas de tiempo para obtener una direcci\u00f3n IP. 7.3.3. An\u00e1lisis de los Resultados Como se puede apreciar a partir de los resultados obtenidos, el proceso de adquisici\u00f3n de una direcci\u00f3n IP se puede llevar a cabo muy r\u00e1pidamente (alrededor de 0.1 segundos) o en un tiempo un poco m\u00e1s razonable (alrededor de 0.9 segundos), aunque hay una mayor tendencia a caer en la segunda opci\u00f3n. Por ello se compar\u00f3 los promedios de los tiempos correspondientes a la segunda opci\u00f3n y se observ\u00f3 que en los tres casos la cantidad de tiempo requerida para obtener una direcci\u00f3n IP es muy similar, con apenas un incremento de 0.045 0 0,3 0,6 0,9 1,2 1 26 51 76 101 126 151 176 201 226 T ie m p o ( s ) N\u00famero de repetici\u00f3n DHCP con Delayed Authentication Tiempo adquisici\u00f3n IP Promedio Promedio valores superiores 0 0,2 0,4 0,6 0,8 1 No Auth Conf.Token Delayed.Auth T ie m p o ( s) 56 segundos por usar cualquiera de los 2 m\u00e9todos de autenticaci\u00f3n para DHCP. Se presume que el motivo por el cual el servidor a veces asignaba muy r\u00e1pidamente una direcci\u00f3n IP a un cliente era porque el servidor a\u00fan pose\u00eda alguna informaci\u00f3n remanente que relacionaba dicha direcci\u00f3n IP al cliente en cuesti\u00f3n, pero esto no se pudo determinar con exactitud. Teniendo todo esto en cuenta, se puede afirmar que el uso de alguno de los m\u00e9todos de autenticaci\u00f3n genera una carga adicional en la ejecuci\u00f3n regular de DHCP, pero la misma no es lo suficiente significativa como para afectar el rendimiento de DHCP. 57 8. Conclusiones El protocolo DHCP es ampliamente utilizado para proveer una forma sencilla y automatizada de configurar apropiadamente una interfaz de red de alg\u00fan dispositivo. Esto hace que sea una herramienta casi necesaria en muchos casos, ya sea para facilitar labores de administraci\u00f3n en ambientes con gran cantidad de computadores o para cubrir la necesidad de usuarios con pocos conocimientos en el \u00e1rea de obtener una configuraci\u00f3n que le permita acceder a Internet. Esta facilidad tambi\u00e9n se puede convertir en una desventaja cuando existen personas malintencionadas que quieran acceder a una red ya que DHCP no distingue usuarios, abri\u00e9ndoles el paso para realizar cualquier cantidad de ataques a otros usuarios o sistemas. Por lo tanto, la implementaci\u00f3n de un mecanismo que permita configurar s\u00f3lo aquellos dispositivos autenticados es un m\u00e9todo viable para mitigar dicho problema. Este trabajo se enfoc\u00f3 en el an\u00e1lisis de una implementaci\u00f3n existente de DHCP, la realizaci\u00f3n de modificaciones necesarias y pruebas para elaborar una soluci\u00f3n final con soporte para mensajes de autenticaci\u00f3n en DHCP, en este caso para dispositivos sobra funcionando bajo el sistema operativo Linux. Los resultados obtenidos durante las pruebas demuestran que no s\u00f3lo es una soluci\u00f3n sencilla y funcional, sino que adem\u00e1s no sobrecargan en mayor forma a las implementaciones ya existentes, por lo que se evidencia el logro de los objetivos que incentivaron el desarrollo de este trabajo. En conclusi\u00f3n, la implementaci\u00f3n de un mecanismo de seguridad que restrinja a qui\u00e9n se le otorga una direcci\u00f3n IP se puede llevar a cabo sin incluir elementos o equipos adicionales que pudiesen a\u00f1adir complejidad a una red ya existente. 8.1. Contribuciones Este trabajo tiene como principal aporte el proveer una soluci\u00f3n real y factible para la implementaci\u00f3n de mecanismos de autenticaci\u00f3n para la obtenci\u00f3n de una direcci\u00f3n IP en dispositivos funcionando bajo la plataforma Linux. Tambi\u00e9n es un valioso aporte para la comunidad de administradores de sistemas ya que provee una alternativa segura y sencilla para la asignaci\u00f3n de direcciones IP sin el problema de la adquisici\u00f3n de equipos especiales o la sobrecarga en la red que generan otros mecanismos existentes. 58 8.2. Limitaciones Durante el desarrollo del presente trabajo se encontraron las siguientes limitaciones para la realizaci\u00f3n del mismo: Existe un n\u00famero reducido de implementaciones c\u00f3digo abierto de DHCP, especialmente en lo que respecta a los clientes, por lo que las alternativas para escoger alg\u00fan lenguaje de programaci\u00f3n o plataforma sobre la cual trabajar se ven afectadas. De hecho la decisi\u00f3n de trabajar sobre la implementaci\u00f3n del ISC DHCP fue b\u00e1sicamente por no haber encontrado otra implementaci\u00f3n que fuese apropiada para el desarrollo de la soluci\u00f3n final. La etapa de an\u00e1lisis y comprensi\u00f3n del c\u00f3digo fuente de la implementaci\u00f3n escogida consumi\u00f3 una excesiva cantidad de tiempo debido a la gran complejidad del c\u00f3digo correspondiente a los elementos que componen al ISC DHCP. Unido a esto tambi\u00e9n est\u00e1 el hecho que no se cuenta con mayor documentaci\u00f3n que ayude a tener un mejor entendimiento sobre la estructura o funcionamiento para poder modificar m\u00e1s f\u00e1cilmente el c\u00f3digo. Adem\u00e1s dependiendo de la naturaleza de los problemas encontrados, la comunidad de usuarios y la lista de correos pudiesen no ser de gran ayuda. La utilizaci\u00f3n del kit de firmas digitales (Digital Signature Toolkit) encontrado en el c\u00f3digo fuente del ISC DHCP represent\u00f3 un problema, ya que dicho kit fue incluido para cumplir otros prop\u00f3sitos, por lo que el cliente y el servidor no ten\u00edan acceso a las funcionalidades de cifrado provistas en el kit. Para solventar este inconveniente se tuvo que recopilar todo el c\u00f3digo fuente correspondiente al kit, renombrar varias de las funciones y estructuras que lo compon\u00edan e incluirlo en los c\u00f3digos del cliente y servidor ya que de lo contrario generaban conflictos al momento de compilaci\u00f3n. Ser\u00eda deseable que el grupo de trabajo del ISC hiciera las modificaciones pertinentes para habilitar el uso del kit y as\u00ed evitar tener que hacer copias del c\u00f3digo en los directorios pertinentes. La falta de bibliograf\u00eda o trabajos relacionados al m\u00e9todo de autenticaci\u00f3n indicado en el RFC 3118 e implementado en este trabajo afect\u00f3 en general varios aspectos del desarrollo de la soluci\u00f3n. Ya que el tema se encontraba pr\u00e1cticamente en estado de abandono por alrededor de once a\u00f1os, no se contaba con aportes u opiniones de otros investigadores que pudiesen haber sido de ayuda para la elaboraci\u00f3n de la soluci\u00f3n. Adem\u00e1s, no se ten\u00eda otra herramienta con la cual comparar la soluci\u00f3n desarrollada para comprobar aspectos de interoperabilidad con distintas implementaciones. 59 8.3. Trabajos Futuros Para realizar la extensi\u00f3n del presente trabajo o mejorar el mismo se puede trabajar en los siguientes aspectos: A\u00f1adir la utilizaci\u00f3n de opciones de autenticaci\u00f3n para DHCPv6, ya que a pesar de formar parte del est\u00e1ndar descrito en el RFC 3315 en el a\u00f1o 2003 el soporte de los mismos todav\u00eda no ha sido incluido en el ISC DHCP. Se debe a\u00f1adir en el cliente la posibilidad de aceptar mensajes de ofertas que no est\u00e9n debidamente autenticados, a pesar de los riesgos que esto pueda traer. A\u00f1adir o dise\u00f1ar otros m\u00e9todos de autenticaci\u00f3n adicionalmente a los que se encuentran descritos en este trabajo, ya que el m\u00e9todo de Configuration Token es f\u00e1cilmente violentado y Delayed Authentication, por la forma en la que est\u00e1 concebido, es susceptible a ciertos ataques de denegaci\u00f3n de servicio, tanto para el cliente como para el servidor. Incluir otros algoritmos de hashing que sean m\u00e1s seguros que MD5, ya que hoy en d\u00eda no se recomienda mucho su uso para funciones criptogr\u00e1ficas. Cabe destacar que para asignar y utilizar un n\u00famero de c\u00f3digo a alg\u00fan algoritmo (o para cualquier campo que contenga alg\u00fan c\u00f3digo identificador en general) se debe hacer una solicitud previamente al Internet Assigned Numbers Authority 3 , que es el ente encargado de administrar la asignaci\u00f3n de valores de c\u00f3digos utilizados en muchos de los protocolos usados actualmente. Modificar el c\u00f3digo fuente para realizar el manejo de los mensajes de autenticaci\u00f3n a trav\u00e9s de procedimientos m\u00e1s acorde a la forma en que se encuentra implementado el ISC DHCP, lo que pudiera resultar en un c\u00f3digo m\u00e1s elegante y probablemente m\u00e1s eficiente. Sin embargo, dicha tarea depender\u00e1 del nivel de entendimiento que se tenga acerca del c\u00f3digo fuente y de la ayuda que el ISC directamente pueda proveer para ello. 3 http://www.iana.org/ 60 9. Referencias [1] R. Droms. Dynamic Host Configuration Protocol. RFC 2131. Marzo, 1997. [2] D. Plummer. An Ethernet Address Resolution Protocol. RFC 826. Noviembre, 1982. [3] J. Reynolds. BOOTP Vendor Information Extensions. RFC 1497. Agosto, 1993. [4] S. Alexander, R. Droms. DHCP Options and BOOTP Vendor Extensions. RFC 2132. Marzo 1997. [5] R. Droms, W. Arbaugh. Authentication for DHCP Messages. RFC 3118. Junio, 2001. [6] H. Krawczyk, M. Bellare, R. Canetti. HMAC: Keyed-Hashing for Message Authentication. RFC 2104. Febrero, 1997. [7] Internet Systems Consortium. \"Software - (DHCP)\". http://www.isc.org/software/dhcp. Octubre 2012. [8] GCC, the GNU Compiler Collection. \"GCC\". http://gcc.gnu.org/. Octubre 2012. [9] GNU Project. \"GNU Make\". http://www.gnu.org/software/make/. Octubre 2012. [10] su(1) - Linux man page. \"Su\". http://linux.die.net/man/1/su. Octubre 2012. [11] VMware Workstation: Run Multiple OS, Linux, Windows 8 & More. \"VMware Workstation\". www.vmware.com/products/workstation/. Octubre 2012. [12] Wireshark Foundation. \"Wireshark - Go Deep\". http://www.wireshark.org/. Octubre 2012. [13] D. Rubel. \"Propuesta para el Dise\u00f1o e Implementaci\u00f3n de un Servidor DHCP con Autenticaci\u00f3n de Mensajes\". Universidad Central de Venezuela. Junio, 2011. [14] R. Droms, J. Bound, B. Volz, T. Lemon, C. Perkins, M. Carney. Dynamic Host Configuration Protocol for IPv6 (DHCPv6). RFC 3315.Julio 2003. [15] B. Croft, J. Gilmore, Bootstrap Protocol (BOOTP). RFC 951. Septiembre 1985. http://www.isc.org/software/dhcp http://gcc.gnu.org/ http://www.gnu.org/software/make/ http://linux.die.net/man/1/su file:///C:/Users/Maria%20Elena/Dropbox/COMPARTIDO/Colab%20LANC2012%20ICARO/Documento%20Tesis%20Rubel/www.vmware.com/products/workstation/ http://www.wireshark.org/ 61 [16] Debian. \u201cDebian \u2013 The Universal Operating System\u201d. http://www.debian.org/. Octubre 2012. [17] Ubuntu. \u201cUbuntu for you\u201d. http://www.ubuntu.com/ubuntu/. Octubre 2012. [18] BusyBox. http://www.busybox.net/. Octubre 2012. [19] LoosyDHCP. http://sourceforge.net/projects/loosydhcp/. Octubre 2012. [20] dhcp4java. http://sourceforge.net/projects/dhcp4java/. Octubre 2012. [21] JDHCPD. http://sourceforge.net/projects/jdhcpd/. Octubre 2012. [22] top(1) - Linux man page. \"top\". http://linux.die.net/man/1/top/. Octubre 2012. http://www.debian.org/ http://www.ubuntu.com/ubuntu/ http://www.busybox.net/ http://sourceforge.net/projects/loosydhcp/ http://sourceforge.net/projects/dhcp4java/ http://sourceforge.net/projects/jdhcpd/ http://linux.die.net/man/1/top/ 62 10. Anexos Anexo N\u00ba A Ejecuci\u00f3n del DHCP con Autenticaci\u00f3n El proceso para ejecutar el demonio DHCP usando alg\u00fan m\u00e9todo de autenticaci\u00f3n var\u00eda un poco dependiendo si se ejecutar\u00e1 el cliente o el servidor. Inicio del demonio del cliente DHCP Para poder ejecutar el cliente DHCP, la interfaz de red por la que se va a solicitar una direcci\u00f3n IP debe estar levantada pero sin aplicarle ninguna configuraci\u00f3n. Esto se puede realizar colocando el texto \"iface ethN inet manual\" en el archivo \"/etc/network/interfaces\" (recomendado), o a trav\u00e9s del comando \"ifconfig ethN up\", pero habr\u00eda que tener permisos de superusuario para ello y se tendr\u00eda que ejecutar el comando cada vez que se encienda el computador. \"N\" corresponde al identificador de la interfaz de red a usar. Adem\u00e1s debe crearse el directorio y los siguientes archivos dentro del mismo, tal como se ilustra en la Figura 10.1. Para esto se debe poseer privilegios de superusuario. # mkdir /var/db # touch /var/db/client_replays.db /* Solo en Delayed Authentication son necesarios estos archivos*/ # touch /var/db/client_keys.db # touch /var/db/client_bindings.db # touch /var/db/client_last_binding.db Figura 10.1 Comandos para creaci\u00f3n de directorios y archivos necesarios en el cliente. Los archivos creados contendr\u00e1n eventualmente la siguiente informaci\u00f3n: client_replays.db: Almacenar\u00e1 las direcciones IP de los servidores con los que se haya establecido un intercambio de mensajes y sus respectivos valores de detecci\u00f3n de repetici\u00f3n. Comenzar\u00e1 como un archivo vac\u00edo. client_keys.db: Almacenar\u00e1 las llaves que fueron predistribuidas y sus respectivos identificadores. client_bindings.db: Almacenar\u00e1 el identificador de la llave que se asign\u00f3 para intercambiar mensajes con un servidor en particular. Comenzar\u00e1 como un archivo vac\u00edo. client_last_binding.db: Almacenar\u00e1 la \u00faltima asociaci\u00f3n ID_Llave/Servidor, para ser usada en casos que no se pueda determinar f\u00e1cilmente el servidor que le otorg\u00f3 una direcci\u00f3n IP al cliente. Comenzar\u00e1 como un archivo vac\u00edo. 63 Usando Configuration Token en el cliente Para iniciar al cliente usando el m\u00e9todo de Configuration Token, se ejecuta el siguiente comando que se ilustra en la Figura 10.2. # dhclient -ct Secreto ethN Figura 10.2 Comando para iniciar el cliente usando Configuration Token con clave \"Secreto\". Usando Delayed Authentication Para iniciar al cliente usando el m\u00e9todo de Delayed Authentication, el archivo \"/var/db/client_keys.db\" debe tener previamente las llaves con sus identificadores respectivos. Los identificadores pueden tomar valores entre 0 y 4.294.967.295 (m\u00e1ximo valor representable con 32 bits) y las llaves consistir\u00e1n en una cadena de texto con una longitud m\u00e1xima de 64 caracteres sin espacios. Un archivo de ejemplo y su formato puede verse en la Figura 10.3. Finalmente se ejecuta el comando como se ilustra en la Figura 10.4. Por ahora solo se soporta el algoritmo \"md5\". 0 test1 765 llave 1 48421fe 4294967295 Una_Cadena_De_Maximo_64_Caracteres Figura 10.3 Formato del archivo de identificadores y llaves para Delayed Authentication. # dhclient -da md5 ethN Figura 10.4 Comando para iniciar el cliente usando Delayed Authentication con algoritmo MD5. Inicio del demonio del servidor DHCP Para ejecutar el servidor DHCP, se debe tener un archivo de configuraci\u00f3n (dhcpd.conf) v\u00e1lido en el directorio requerido por el servidor. Usualmente el directorio corresponde al directorio \"ETCDIR\" de acuerdo a la distribuci\u00f3n de Linux que se est\u00e9 usando. Para el caso de Debian o Ubuntu, el archivo de configuraci\u00f3n estar\u00e1 ubicado en \"/etc/dhcpd.conf\". Se puede tomar como referencia un archivo de ejemplo ubicado dentro del directorio del c\u00f3digo fuente del ISC DHCP, bajo el directorio \"server\". Adem\u00e1s debe crearse el directorio y los siguientes archivos dentro del mismo, tal como se ilustra en la Figura 10.5. Para esto se debe poseer privilegios de superusuario. 64 # mkdir /var/db # touch dhcpd.leases # touch /var/db/server_replays.db /* Para Delayed Authentication son necesarios estos archivos*/ # touch /var/db/server_keys.db # touch /var/db/server_bindings.db Figura 10.5 Comandos para la creaci\u00f3n de directorios y archivos necesarios en el servidor. Los archivos creados contendr\u00e1n eventualmente la siguiente informaci\u00f3n: dhcpd.leases: Contendr\u00e1 la informaci\u00f3n de las concesiones de direcciones IP y toda la informaci\u00f3n de configuraci\u00f3n otorgada a cada uno de los clientes atendidos. Es manipulado por el c\u00f3digo original del ISC DHCP. server_replays.db: Almacenar\u00e1 las direcciones MAC de los clientes con los que se haya establecido un intercambio de mensajes y sus respectivos valores de detecci\u00f3n de repetici\u00f3n. Comenzar\u00e1 como un archivo vac\u00edo. server_keys.db: Almacenar\u00e1 las llaves que fueron predistribuidas y sus respectivos identificadores. server_bindings.db: Almacenar\u00e1 el identificador de la llave que se asign\u00f3 para intercambiar mensajes con un cliente en particular. Comenzar\u00e1 como un archivo vac\u00edo. Usando Configuration Token Para iniciar al servidor usando el m\u00e9todo de Configuration Token, se ejecuta el siguiente comando que se ilustra en la Figura 10.6. # dhcpd -ct Secreto Figura 10.6 Comando para iniciar el servidor usando Configuration Token con clave \"Secreto\". Delayed Authentication Para iniciar al servidor usando el m\u00e9todo de Delayed Authentication, el archivo \"/var/db/server_keys.db\" debe tener previamente las llaves con sus identificadores respectivos. Los identificadores pueden tomar valores entre 0 y 4.294.967.295 y las llaves consistir\u00e1n en una cadena de texto con una longitud m\u00e1xima de 64 caracteres. Un archivo de ejemplo y su formato puede verse en la Figura 10.3 mostrada anteriormente para el cliente. Finalmente se ejecuta el comando como se ilustra en la Figura 10.7. # dhcpd -da md5 Figura 10.7 Comando para iniciar el servidor usando Delayed Authentication con algoritmo MD5.", "document_id": 539585}]}, {"paragraphs": [{"qas": [{"question": "que es HTML5", "id": 320684, "answers": [{"answer_id": 331174, "document_id": 539587, "question_id": 320684, "text": "HTML5 HTML5 (Hickson, 2010) es la quinta revisi\u00f3n del est\u00e1ndar HTML, actualmente en desarrollo. Como sus predecesores inmediatos (HTML 4.01 y XHTML 1.1), HTML5 es un est\u00e1ndar para estructurar y presentar contenido en la WWW. ", "answer_start": 44806, "answer_end": 45031, "answer_category": null}], "is_impossible": false}, {"question": "que es CSS3", "id": 320685, "answers": [{"answer_id": 331175, "document_id": 539587, "question_id": 320685, "text": "CSS3 CSS3 (Bos, 2005) es la tercera especificaci\u00f3n del est\u00e1ndar CSS, actualmente en desarrollo. CSS es un lenguaje de hojas de estilo que se utiliza para describir la presentaci\u00f3n (el aspecto y el formato) de un documento escrito en un lenguaje de marcado. Su aplicaci\u00f3n m\u00e1s com\u00fan es para estilizar p\u00e1ginas web escritas en HTML y XHTML.", "answer_start": 46134, "answer_end": 46470, "answer_category": null}], "is_impossible": false}, {"question": "que es jquery", "id": 320686, "answers": [{"answer_id": 331176, "document_id": 539587, "question_id": 320686, "text": " jQuery jQuery (The jQuery Project, 2010) es una librer\u00eda de JavaScript que simplifica la manera de interactuar con los documentos HTML, seleccionar elementos DOM, desarrollar animaciones, manejar eventos y agregar interacci\u00f3n de manera as\u00edncrona con el servidor a p\u00e1ginas web. ", "answer_start": 47808, "answer_end": 48086, "answer_category": null}], "is_impossible": false}, {"question": "que es ruby on rails", "id": 320687, "answers": [{"answer_id": 331177, "document_id": 539587, "question_id": 320687, "text": "Ruby on Rails Ruby on Rails (RoR) (Ruby on Rails, 2011) es un framework para desarrollar aplicaciones web escrito en el lenguaje de programaci\u00f3n Ruby que esta optimizado para mejorar la productividad y con un m\u00ednimo de configuraci\u00f3n. RoR incluye herramientas que facilitan las tareas m\u00e1s comunes de desarrollo, como generadores que pueden construir autom\u00e1ticamente algunas de las clases y p\u00e1ginas necesarias para un sitio web b\u00e1sico. ", "answer_start": 49887, "answer_end": 50321, "answer_category": null}], "is_impossible": false}, {"question": "que es haml", "id": 320688, "answers": [{"answer_id": 331178, "document_id": 539587, "question_id": 320688, "text": "Haml Haml (Haml, 2011) es un lenguaje de enmarcado liviano que se utiliza para describir el XHTML de cualquier documento web sin el uso de codificaci\u00f3n en l\u00ednea tradicional. Est\u00e1 dise\u00f1ado para resolver muchas de las fallas en los motores de plantillas, a la vez que hace el enmarcado tan limpio como se pueda. ", "answer_start": 53010, "answer_end": 53320, "answer_category": null}], "is_impossible": false}], "context": "Universidad Central de Venezuela Facultad de Ciencias Escuela de Computaci\u00f3n Trabajo Especial de Grado: Desarrollo de Un M\u00f3dulo Web Para la Gesti\u00f3n de Planes de Estudio en el Sistema de Gesti\u00f3n Acad\u00e9mica CONEST Jos\u00e9 T. Hern\u00e1ndez C. V-16.179.441 Tutora: Prof. Jossie Zambrano Octubre, 2012 2 Resumen La Divisi\u00f3n de Control de Estudios es la dependencia administrativa de la Facultad de Ciencias que se encarga de coordinar y supervisar los procesos relacionados con la inscripci\u00f3n, control de notas y graduaci\u00f3n de las licenciaturas de pregrado. La Divisi\u00f3n presta algunos de sus servicios a trav\u00e9s del Sistema de Gesti\u00f3n Acad\u00e9mica de Control de Estudios (CONEST) facilitando las operaciones de los procesos administrativos de la Facultad. Sin embargo, el sistema CONEST no cuenta con una aplicaci\u00f3n que permita gestionar los planes de estudio de las distintas licenciaturas que ofrece la Facultad. Este Trabajo Especial de Grado tiene como objetivo desarrollar un m\u00f3dulo web del sistema CONEST que permita gestionar los planes de estudio de las licenciaturas de la Facultad de Ciencias. Adem\u00e1s de automatizar parte del trabajo de verificaci\u00f3n de requisitos curriculares realizado por el Departamento de Grado de la Divisi\u00f3n de Control de Estudios. El m\u00e9todo \u00e1gil de desarrollo de software implementado para estructurar, planificar y controlar el proceso de desarrollo del m\u00f3dulo web para la gesti\u00f3n de planes de estudio en el sistema CONEST es una adaptaci\u00f3n de la Programaci\u00f3n Extrema. Palabras Clave: Control de Estudios, Gesti\u00f3n de Planes de Estudio, Verificaci\u00f3n de Requisitos Curriculares, Aplicaci\u00f3n Web, Ruby on Rails. 3 \u00cdndice General Resumen ........................................................................................................................................ 2 Introducci\u00f3n .................................................................................................................................. 7 Cap\u00edtulo 1. Planes de Estudio de la Facultad de Ciencias................................................................. 9 1.1 Licenciatura en Biolog\u00eda ...................................................................................................... 11 1.2 Licenciatura en Computaci\u00f3n ............................................................................................. 15 1.3 Licenciatura en F\u00edsica .......................................................................................................... 17 1.4 Licenciatura en Geoqu\u00edmica................................................................................................ 21 1.5 Licenciatura en Matem\u00e1tica ............................................................................................... 22 1.6 Licenciatura en Qu\u00edmica ..................................................................................................... 26 Cap\u00edtulo 2. Tecnolog\u00edas Web ........................................................................................................ 30 2.1 HTML5 ............................................................................................................................... 31 2.2 CSS3 ................................................................................................................................... 32 2.3 jQuery ................................................................................................................................ 33 2.4 Ruby on Rails ...................................................................................................................... 34 2.5 Haml .................................................................................................................................. 35 2.6 Sass .................................................................................................................................... 36 2.7 MySQL ................................................................................................................................ 36 Cap\u00edtulo 3. M\u00e9todo \u00c1gil de Desarrollo de Software ...................................................................... 37 3.1 Programaci\u00f3n Extrema (XP) ................................................................................................ 38 3.2 Adaptaci\u00f3n del M\u00e9todo \u00c1gil XP .......................................................................................... 40 3.2.1 Planificaci\u00f3n ................................................................................................................ 40 3.2.2 Dise\u00f1o ......................................................................................................................... 41 3.2.3 Codificaci\u00f3n ................................................................................................................. 41 3.2.4 Pruebas ....................................................................................................................... 42 Cap\u00edtulo 4. Marco Aplicativo ........................................................................................................ 44 4.1 Iteraci\u00f3n 0 .......................................................................................................................... 44 4.1.1 Planificaci\u00f3n ................................................................................................................ 44 4.1.2 Dise\u00f1o ......................................................................................................................... 50 4.1.3 Codificaci\u00f3n ................................................................................................................. 51 4.1.4 Pruebas ....................................................................................................................... 51 4 4.2 Iteraci\u00f3n 1 .......................................................................................................................... 52 4.2.1 Planificaci\u00f3n ................................................................................................................ 52 4.2.2 Dise\u00f1o ......................................................................................................................... 52 4.2.3 Codificaci\u00f3n ................................................................................................................. 61 4.2.4 Pruebas ....................................................................................................................... 72 4.3 Iteraci\u00f3n 2 .......................................................................................................................... 76 4.3.1 Planificaci\u00f3n ................................................................................................................ 76 4.3.2 Dise\u00f1o ......................................................................................................................... 77 4.3.3 Codificaci\u00f3n ................................................................................................................. 80 4.3.4 Pruebas ....................................................................................................................... 87 Conclusiones ................................................................................................................................ 90 Recomendaciones ........................................................................................................................ 92 Referencias Bibliogr\u00e1ficas ............................................................................................................ 93 Anexos ......................................................................................................................................... 94 5 \u00cdndice de Figuras Figura 1. Plan de Estudio de Biolog\u00eda. ........................................................................................... 13 Figura 2. Componente Docente de Biolog\u00eda. ................................................................................ 15 Figura 3. Plan de Estudio de Computaci\u00f3n. .................................................................................. 17 Figura 4. Plan de Estudio de F\u00edsica. ............................................................................................... 19 Figura 5. Componente Docente de F\u00edsica. .................................................................................... 21 Figura 6. Plan de Estudio de Geoqu\u00edmica...................................................................................... 22 Figura 7. Plan de Estudio de Matem\u00e1tica. .................................................................................... 24 Figura 8. Componente Docente de Matem\u00e1tica. .......................................................................... 26 Figura 9. Plan de Estudio de Qu\u00edmica. .......................................................................................... 28 Figura 10. Componente Docente de Qu\u00edmica. .............................................................................. 29 Figura 11. Arquitectura Cliente-Servidor. ..................................................................................... 31 Figura 12. Ciclo de Vida Para el Desarrollo \u00c1gil de Software. ........................................................ 37 Figura 13. Formato de las Tarjetas de Historias. ........................................................................... 40 Figura 14. Dise\u00f1o General del Sistema CONEST. ........................................................................... 50 Figura 15. Listado de Planes de Estudio. ....................................................................................... 53 Figura 16. Editar Planes de Estudio. ............................................................................................. 54 Figura 17. Tabla distribucion_requisito_plan. ............................................................................... 55 Figura 18. Listado de Requisitos Curriculares Distribuidos por Semestre. ..................................... 55 Figura 19. Listado de Asignaturas. ................................................................................................ 57 Figura 20. Editar Asignaturas. ...................................................................................................... 58 Figura 21. Tabla materia_en_plan. ............................................................................................... 59 Figura 22. Campos Obligatorios. .................................................................................................. 60 Figura 23. Di\u00e1logos Emergentes. .................................................................................................. 60 Figura 24. Mensajes de Confirmaci\u00f3n. ......................................................................................... 61 Figura 25. Mensajes de Error. ...................................................................................................... 61 Figura 26. Modelo plan.rb. ........................................................................................................... 61 Figura 27. Vista plan_estudio/index.html.haml. ........................................................................... 62 Figura 28. Vista Parcial plan_estudio/_formulario.html.haml. ...................................................... 63 Figura 29. M\u00e9todo plan_estudio/guardar..................................................................................... 64 Figura 30. Vista Parcial plan_estudio/_notificacion.html.haml. .................................................... 64 6 Figura 31. M\u00e9todo plan_estudio/actualizar. ................................................................................. 64 Figura 32. M\u00e9todo plan_estudio/eliminar. ................................................................................... 65 Figura 33. M\u00e9todo plan_estudio/editar. ...................................................................................... 65 Figura 34. Vista plan_estudio/editar.html.haml. .......................................................................... 66 Figura 35. Script plan_estudio.js.coffee. ....................................................................................... 66 Figura 36. Vista Parcial plan_estudio/_distribucion_requisitos_curriculares.html.haml. ............... 67 Figura 37. M\u00e9todo plan_estudio/crear_requisito_curricular. ....................................................... 68 Figura 38. Modelo requisito_graduacion_plan.rb ......................................................................... 68 Figura 39. M\u00e9todo asignatura/autocomplete. .............................................................................. 69 Figura 40. Script asignatura.js.coffee (Autocomplete). ................................................................. 70 Figura 41. M\u00e9todo asignatura/crear_prelacion. ........................................................................... 71 Figura 42. M\u00e9todo asignatura/buscar_planes_estudio_asignatura. .............................................. 71 Figura 43. Script asignatura.js.coffee (Listas Desplegables)........................................................... 72 Figura 44. Verificaci\u00f3n de Requisitos Curriculares. ....................................................................... 77 Figura 45. Asignaturas Aprobadas/Asignaturas No Aprobadas. .................................................... 78 Figura 46. Tabla historial_academico. .......................................................................................... 78 Figura 47. Resultado de la Verificaci\u00f3n de Requisitos Curriculares................................................ 79 Figura 48. Tablas opcion, opcion_plan y requisito_graduacion_opcion_plan. ............................... 79 Figura 49. Verificaci\u00f3n de la Opci\u00f3n Profesional. .......................................................................... 80 Figura 50. M\u00e9todo plan_estudio/verificar_requisitos (Requisitos Curriculares). ........................... 81 Figura 51. Vista Parcial _verificar_requisitos_academicos.html.erb. ............................................. 84 Figura 52. M\u00e9todo plan_estudio/verificar_requisitos (Opci\u00f3n Profesional). ................................. 85 Figura 53. Vista Parcial _resumen_opcion_profesional.html.erb. ................................................. 86 7 Introducci\u00f3n La Universidad Central de Venezuela (UCV) es la instituci\u00f3n de educaci\u00f3n superior m\u00e1s antigua de Venezuela, fundada en 1721. En la actualidad, mantiene una matr\u00edcula estudiantil que ronda los 54.222 estudiantes de pregrado y 8.317 estudiantes de postgrado, con 4.790 profesores y 4.514 empleados administrativos, distribuidos en 9 Facultades en Caracas, 2 Facultades en Maracay, 5 N\u00facleos de Estudios supervisados y 12 Estaciones Experimentales en diferentes regiones del pa\u00eds. La UCV ofrece aproximadamente 351 carreras universitarias entre pregrado y postgrado. Las carreras que se imparten en esta casa de estudios est\u00e1n conformadas por un conjunto de asignaturas y requisitos curriculares que se deben satisfacer para obtener un t\u00edtulo universitario, lo que se conoce como un plan de estudio. La Facultad de Ciencias de la UCV est\u00e1 integrada por 5 Escuelas, donde se forman licenciados en las siguientes carreras: Biolog\u00eda, Computaci\u00f3n, F\u00edsica, Geoqu\u00edmica, Matem\u00e1tica y Qu\u00edmica. La Divisi\u00f3n de Control de Estudios (DCE) es la dependencia administrativa de la Facultad que se encarga de coordinar y supervisar los procesos relacionados con la inscripci\u00f3n, control de notas y graduaci\u00f3n de las licenciaturas de pregrado. El Departamento de Grado de la DCE utiliza los planes de estudio de las distintas licenciaturas cada semestre para verificar que los estudiantes que inscribieron Trabajo Especial de Grado cumplen con todos los requisitos curriculares y las normativas acad\u00e9micas que deben satisfacer para obtener un t\u00edtulo universitario en la licenciatura en que se encuentran inscritos. La Facultad de Ciencias ha desarrollado el Sistema de Gesti\u00f3n Acad\u00e9mica de Control de Estudios (CONEST) que presta servicio a los estudiantes, profesores y empleados administrativos, facilitando las operaciones de los procesos administrativos de la Facultad. Los trabajadores del Departamento de Grado actualmente realizan todas sus labores con un soporte m\u00ednimo del sistema CONEST, verificando de manera manual los requisitos curriculares de cada estudiante con l\u00e1pices de colores y distintos documentos impresos. Esto representa un mayor esfuerzo humano y aumenta la probabilidad de cometer errores. Es por ello que el objetivo de este Trabajo Especial de Grado es desarrollar un m\u00f3dulo web del sistema CONEST basado en tecnolog\u00edas web, que automatice el trabajo de verificaci\u00f3n de requisitos curriculares del proceso de graduaci\u00f3n que se realiza en la DCE, as\u00ed como la gesti\u00f3n de los planes de estudio de las distintas licenciaturas que ofrece la Facultad de Ciencias. Para lograr dicho desarrollo, se utiliza el m\u00e9todo \u00e1gil de desarrollo de software llamado Programaci\u00f3n Extrema (XP), donde se realizan tres iteraciones implementando las fases propuestas en el m\u00e9todo. En la primera iteraci\u00f3n se analiza de manera general el m\u00f3dulo web, en 8 la segunda iteraci\u00f3n se desarrolla la gesti\u00f3n de los planes de estudio de las licenciaturas de la Facultad de Ciencias, y en la tercera iteraci\u00f3n de desarrolla la verificaci\u00f3n de los requisitos curriculares de los estudiantes regulares de pregrado. Este trabajo de investigaci\u00f3n est\u00e1 estructurado de la siguiente manera: Cap\u00edtulo 1. Planes de Estudio de la Facultad de Ciencias: En este cap\u00edtulo se describen los planes de estudio y se presentan los resultados del an\u00e1lisis realizado a todos los planes de estudio de las licenciaturas que ofrece la Facultad de Ciencias. Cap\u00edtulo 2. Tecnolog\u00edas Web: En este cap\u00edtulo se describen las tecnolog\u00edas web implementadas en el desarrollo del m\u00f3dulo web para la gesti\u00f3n de planes de estudio en el sistema CONEST. Cap\u00edtulo 3. M\u00e9todo \u00c1gil de Desarrollo de Software: En este cap\u00edtulo se describen las metodolog\u00edas agiles de desarrollo de software, la Programaci\u00f3n Extrema (XP), y la adaptaci\u00f3n del m\u00e9todo \u00e1gil XP implementado en el proceso de desarrollo del m\u00f3dulo web para la gesti\u00f3n de planes de estudio en el sistema CONEST. Cap\u00edtulo 4. Marco Aplicativo: En este cap\u00edtulo se presentan las iteraciones realizadas durante el desarrollo del m\u00f3dulo web para la gesti\u00f3n de planes de estudio en el sistema CONEST bajo el m\u00e9todo \u00e1gil XP, especificando la planificaci\u00f3n, el dise\u00f1o, la codificaci\u00f3n y las pruebas de las tarjetas de historias correspondientes. Finalmente, se presentan las conclusiones, las recomendaciones y las referencias bibliogr\u00e1ficas. 9 Cap\u00edtulo 1 Planes de Estudio de la Facultad de Ciencias Un plan de estudio (Teruel, 2000) es de manera general una descripci\u00f3n de los requisitos que se necesitan satisfacer para obtener un t\u00edtulo universitario en un \u00e1rea del saber. Estos requisitos incluyen: aprobar el conjunto de asignaturas que la universidad considera obligatorias, el n\u00famero de cr\u00e9ditos que el estudiante debe aprobar en asignaturas electivas, y los requisitos o prelaciones que aplican entre las asignaturas. En la Facultad de Ciencias de la UCV se imparten 6 licenciaturas: Biolog\u00eda, Computaci\u00f3n, F\u00edsica, Geoqu\u00edmica, Matem\u00e1tica y Qu\u00edmica. Los planes de estudio de las licenciaturas de la Facultad son gestionados por la DCE, la cual es una dependencia administrativa que se encarga de coordinar y supervisar los procesos relacionados con la inscripci\u00f3n, control de notas y graduaci\u00f3n de los estudiantes regulares de pregrado. La DCE requiere conocer la estructura y los reglamentos de cada uno de los planes de estudio para revisar, validar y procesar decisiones que en materia acad\u00e9mica incidan en sus procesos administrativos para su debida implementaci\u00f3n. Los planes de estudio son vitales en los procesos de inscripci\u00f3n y graduaci\u00f3n, la DCE integra los recursos tanto humanos como tecnol\u00f3gicos para cerciorarse de que cada estudiante cumpla con todos los requisitos y las prelaciones para cursar las asignaturas, y que cada egresado haya cumplido y aprobado con todos los requisitos y normativas acad\u00e9micas para optar por un t\u00edtulo universitario en las licenciaturas que ofrece la Facultad de Ciencias. Los planes de estudio de las licenciaturas de la Facultad de Ciencias est\u00e1n conformados por un conjunto de asignaturas y reglas. Una asignatura es una unidad acad\u00e9mica que forma parte de una carrera, por lo general dura un per\u00edodo acad\u00e9mico de entre 15 y 16 semanas (excepto en el curso intensivo que tiene una duraci\u00f3n de 7 u 8 semanas), est\u00e1 dirigida por uno o m\u00e1s docentes, cuenta con una lista fija de estudiantes, y este obtiene una nota y unidades de cr\u00e9ditos por cada asignatura aprobada. Sus atributos comunes incluyen: Nombre: Es el nombre completo de la asignatura por el cual es conocida. Ejemplos de nombres de asignaturas son: Sistemas Operativos, Comunicaci\u00f3n de Datos, Lenguajes de Programaci\u00f3n, etc. Abreviaci\u00f3n: Es el nombre corto de la asignatura, se utiliza para mantener la compatibilidad con otros sistemas que est\u00e1n limitados al uso de 15 caracteres. Ejemplos de abreviaciones de asignaturas son: Sist. Operativos, Comun. de Datos, etc. C\u00f3digo: Es una representaci\u00f3n num\u00e9rica de d\u00edgitos que permite identificar la asignatura, los primeros 2 d\u00edgitos representan la Facultad, los siguientes 2 d\u00edgitos representan la Escuela, y los \u00faltimos 4 d\u00edgitos representan la asignatura. La Facultad de Ciencias est\u00e1 representada por el 10 n\u00famero 03. Las Escuelas est\u00e1n representadas de la siguiente manera: 01 (Escuela de Biolog\u00eda), 02 (Escuela de F\u00edsica), 03 (Escuela de Qu\u00edmica), 04 (Escuela de Computaci\u00f3n), 05 (Escuela de Matem\u00e1tica), y 06 (Escuela de Geoqu\u00edmica). Ejemplos de c\u00f3digos de asignaturas son: 03046004, 03046003, 03046204, etc. Unidades de Cr\u00e9dito (UC): Las unidades de cr\u00e9dito se determinan en base al n\u00famero de horas de clase semanales que un estudiante recibe por asignatura. Estas horas incluyen: \uf0b7 Horas Te\u00f3ricas (HT): 1 HT equivale a 1 UC. \uf0b7 Horas de Practica (HP): 2 HP equivalen a 1 UC. \uf0b7 Horas de Laboratorio (HL): 3 HL equivalen a 1 UC. Calificaci\u00f3n: La nota final de las asignaturas se califica con un n\u00famero comprendido entre 0 y 20. En la Facultad de Ciencias se utiliza otro m\u00e9todo para calificar asignaturas y requisitos curriculares con notaciones alfab\u00e9ticas: A (Aprobado), AP (Aplazado), EQ (Equivalencia), y RET (Retirado). Tipo: Las asignaturas pueden ser cursadas seg\u00fan las siguientes modalidades: obligatorias, electivas, optativas. Las asignaturas obligatorias son aquellas que todos los estudiantes est\u00e1n obligados a cursar por su importancia en la formaci\u00f3n y el desarrollo educativo del estudiante. En general, est\u00e1n ubicadas en la primera mitad de la carrera. Las asignaturas electivas son aquellas que el estudiante puede cursar para profundizar su formaci\u00f3n en un determinado campo profesional, pueden ser cursadas como parte de una opci\u00f3n seg\u00fan lo establecido en el reglamento de la licenciatura. Se ubican en los \u00faltimos semestres de la carrera. Las asignaturas optativas son aquellas que el estudiante puede cursar para ampliar su formaci\u00f3n general, m\u00e1s all\u00e1 de la pura formaci\u00f3n profesional, y no son un requisito en todas las licenciaturas de la Facultad. En general, est\u00e1n ubicadas en los \u00faltimos semestres de la carrera. Las asignaturas del Programa de Cooperaci\u00f3n Interfacultades (PCI) son otro tipo de asignaturas optativas que el estudiante puede cursar en otras Facultades de la Universidad. Los planes de estudio de las licenciaturas de la Facultad de Ciencias agrupan las asignaturas por semestres, algunas de estas asignaturas guardan una relaci\u00f3n de prelaci\u00f3n, en funci\u00f3n de conocimientos previos que el estudiante debe manejar para cursar las asignaturas. El objetivo del sistema de prelaciones es facilitar el avance del estudiante en la carrera ya que permite integrar y secuenciar conocimientos y habilidades entre asignaturas. Los planes de estudio podr\u00edan cambiar con el transcurso del tiempo, a aquellos estudiantes que se encuentran en periodo de transici\u00f3n de un plan de estudio a otro es necesario aplicarles la tabla 11 de convalidaciones y equivalencias, siguiendo las normas acordadas por cada Escuela. Otro caso particular a tomar en cuenta es el de los estudiantes que se est\u00e1n reincorporando o cambiando de carrera, ya que se debe verificar las equivalencias de cada una de las asignaturas que apliquen seg\u00fan el caso. La opci\u00f3n profesional es un conjunto de asignaturas que forman al estudiante en un determinado campo profesional. Las opciones buscan profundizar la formaci\u00f3n del estudiante en el \u00e1rea de la carrera de su preferencia, estas opciones son definidas por las Escuelas, soportadas por los centros de investigaci\u00f3n y administradas por el o los departamentos. Para optar por una opci\u00f3n el estudiante debe aprobar un n\u00famero m\u00ednimo de asignaturas, el Seminario y el Trabajo Especial de Grado de la opci\u00f3n correspondiente. Adem\u00e1s, el estudiante puede cursar asignaturas de cualquier opci\u00f3n bajo la modalidad de electiva, siempre y cuando cumpla con las prelaciones exigidas. Es importante resaltar que cada licenciatura tiene su propio reglamento, por lo que cada plan de estudio exige diferentes requisitos para obtener el t\u00edtulo de la carrera. Los estudios de licenciatura en la Facultad de Ciencias tienen una duraci\u00f3n de 10 semestres, y 19 unidades de cr\u00e9dito por semestre (en promedio). Adem\u00e1s, el componente docente es un convenio que existe con la Facultad de Humanidades y Educaci\u00f3n denominado Convenio Cooperativo de Formaci\u00f3n Docente que les permite a los estudiantes de las licenciaturas de Biolog\u00eda, F\u00edsica, Matem\u00e1tica y Qu\u00edmica optar por un t\u00edtulo universitario de Licenciatura en Educaci\u00f3n con una menci\u00f3n cient\u00edfica. El estudiante debe aprobar las asignaturas correspondientes al \u00e1rea cient\u00edfica en la Facultad de Ciencias y las asignaturas correspondientes al \u00e1rea human\u00edstica en la Escuela de Educaci\u00f3n. A continuaci\u00f3n se describen los planes de estudio de las licenciaturas que ofrece la Facultad de Ciencias. 1.1 Licenciatura en Biolog\u00eda El plan de estudio de la Licenciatura en Biolog\u00eda se encuentra vigente desde el a\u00f1o 1968. El Licenciado en Biolog\u00eda se encarga de estudiar en el laboratorio y en condiciones naturales el origen, el desarrollo, la estructura y otros aspectos fundamentales de los organismos vivos. El bi\u00f3logo estudia e investiga diferentes aspectos de las c\u00e9lulas y los seres vivos. Dise\u00f1a los experimentos, explora e investiga y aplica los resultados en la soluci\u00f3n de problemas en las \u00e1reas de biolog\u00eda celular, bot\u00e1nica, ecolog\u00eda, tecnolog\u00eda de alimentos y zoolog\u00eda. El plan de estudio de Biolog\u00eda est\u00e1 estructurado en dos partes. La primera parte corresponde al ciclo b\u00e1sico de la carrera, su objetivo es brindar una formaci\u00f3n b\u00e1sica de los grandes principios de la biolog\u00eda. El ciclo b\u00e1sico tiene una duraci\u00f3n de 7 semestres, est\u00e1 conformado por 34 asignaturas obligatorias para un total de 121 unidades de cr\u00e9dito. 12 La segunda parte corresponde al ciclo de opci\u00f3n de la carrera, su objetivo es profundizar la formaci\u00f3n del estudiante en un determinado campo profesional dentro del campo de la biolog\u00eda. El ciclo de opci\u00f3n dispone de 3 semestres (VIII, IX, X), para la aprobaci\u00f3n de las asignaturas correspondientes a las opciones, con 60 unidades de cr\u00e9dito distribuidas de la siguiente manera: 25 unidades de cr\u00e9dito en asignaturas obligatorias (Seminario I, Seminario II y Trabajo Especial de Grado), y 35 unidades de cr\u00e9dito en asignaturas electivas. Adem\u00e1s, el estudiante deber\u00e1 cursar Ingles I o presentar un examen de suficiencia con un valor de 4 unidades de cr\u00e9dito, adicionales a las 60 se\u00f1aladas anteriormente. La Figura 1 muestra el plan de estudio de Biolog\u00eda y las asignaturas que lo integran. 13 Figura 1. Plan de Estudio de Biolog\u00eda. La Escuela de Biolog\u00eda ofrece las siguientes opciones profesionales: Bot\u00e1nica, Biolog\u00eda Celular, Tecnolog\u00eda de Alimentos, Ecolog\u00eda y Zoolog\u00eda. Para optar por una opci\u00f3n profesional el estudiante debe aprobar un m\u00ednimo de 18 unidades de cr\u00e9dito en asignaturas correspondientes a la opci\u00f3n de su preferencia, excepto en Tecnolog\u00eda de Alimentos donde es necesario aprobar todas las asignaturas de la opci\u00f3n. Finalmente, para obtener el t\u00edtulo de Licenciado en Biolog\u00eda el estudiante debe aprobar al menos 185 unidades de cr\u00e9dito. Para los estudiantes que deseen ingresar al Programa Cooperativo de Formacion Docente, deben tener aprobadas todas las asignaturas hasta el 5to semestre inclusive. El estudiante debe cursar 119 unidades de cr\u00e9dito en asignaturas dictadas por la Facultad de Ciencias y 52 unidades de cr\u00e9dito en asignaturas dictadas por la Escuela de Educacion para optar por el componente docente. La Figura 2 muestra el componente docente de Biolog\u00eda. 14 15 Figura 2. Componente Docente de Biolog\u00eda. 1.2 Licenciatura en Computaci\u00f3n El plan de estudio de la Licenciatura en Computaci\u00f3n se encuentra vigente desde el a\u00f1o 2004. El Licenciado en Computaci\u00f3n ejerce sus tareas profesionales dentro de tres amplias funciones, que se se\u00f1alan a continuaci\u00f3n: \uf0b7 El desarrollo de sistemas y aplicaciones computacionales, donde debe estar preparado para resolver problemas que se presentan en las grandes, medianas, peque\u00f1as organizaciones y a los individuos, proporcion\u00e1ndoles soluciones computacionales y en general sistemas que integren elementos computacionales. \uf0b7 Funciones de gesti\u00f3n de plataforma computacionales y servicios inform\u00e1ticos, a trav\u00e9s de esta funci\u00f3n ejerce su rol de facilitador de la tecnolog\u00eda computacional. Este puesto de trabajo implica gestionar y administrar recursos inform\u00e1ticos para facilitar y soportar procesos y actividades en organizaciones, instituciones y directamente por usuarios finales. \uf0b7 Investigaci\u00f3n e innovaci\u00f3n, el profesional cumple esta funci\u00f3n a partir de la introducci\u00f3n de la tecnolog\u00eda computacional en las diversas actividades de la sociedad, esto es posible por la b\u00fasqueda innovadora y participaci\u00f3n en la investigaci\u00f3n pura y aplicada, la misma es profundizada, a partir de los estudios de cuarto nivel. El plan de estudio de Computaci\u00f3n est\u00e1 estructurado en dos partes. La primera parte corresponde al ciclo b\u00e1sico de la carrera, su objetivo es brindar una formaci\u00f3n b\u00e1sica de los principios de la computaci\u00f3n. El ciclo b\u00e1sico tiene una duraci\u00f3n de 5 semestres, est\u00e1 conformado por 21 asignaturas obligatorias para un total de 107 unidades de cr\u00e9dito. La segunda parte corresponde al ciclo de opci\u00f3n de la carrera, su objetivo es profundizar la formaci\u00f3n del estudiante en un determinado campo profesional dentro del campo de la computaci\u00f3n. El ciclo de opci\u00f3n dispone de 5 semestres (VI, VII, VIII, IX, X), para la aprobaci\u00f3n de las asignaturas correspondientes a las opciones, con 78 unidades de cr\u00e9dito distribuidas de la siguiente manera: 25 unidades de cr\u00e9dito en asignaturas obligatorias (Pasant\u00eda, Seminario y Trabajo Especial de Grado), 43 unidades de cr\u00e9dito en asignaturas electivas, y 10 unidades de 16 cr\u00e9dito en asignaturas obligatorias optativas. Adem\u00e1s, el estudiante deber\u00e1 cursar 8 unidades de cr\u00e9dito en asignaturas optativas, adicionales a las 78 se\u00f1aladas anteriormente. La Figura 3 muestra el plan de estudio de Computaci\u00f3n. 17 Figura 3. Plan de Estudio de Computaci\u00f3n. La Escuela de Computaci\u00f3n ofrece las siguientes opciones profesionales: Sistemas de Informaci\u00f3n, Bases de Datos, Modelos y Programaci\u00f3n Matem\u00e1tica, Ingenier\u00eda de Software e Interacci\u00f3n Humano Computador, Sistemas Distribuidos y Paralelos, Inteligencia Artificial, Tecnolog\u00edas Educativas, C\u00e1lculo Cient\u00edfico, Tecnolog\u00edas en Comunicaci\u00f3n y Redes de Computadoras, Computaci\u00f3n Gr\u00e1fica, y Aplicaciones en Internet. Para optar por una opci\u00f3n profesional el estudiante debe aprobar un m\u00ednimo de 15 unidades de cr\u00e9dito en asignaturas correspondientes a la opci\u00f3n de su preferencia. Finalmente, para obtener el t\u00edtulo de Licenciado en Computaci\u00f3n el estudiante debe aprobar al menos 193 unidades de cr\u00e9dito. 1.3 Licenciatura en F\u00edsica El plan de estudio de la Licenciatura en F\u00edsica se encuentra vigente desde el a\u00f1o 1977. El Licenciado en F\u00edsica en cualquier \u00e1rea de actuaci\u00f3n, le corresponde ser un profesional que apoyado en conocimientos s\u00f3lidos y actualizados de la f\u00edsica, debe ser capaz de tratar problemas nuevos y tradicionales, preocup\u00e1ndose por la b\u00fasqueda de nuevas formas del saber y del hacer cient\u00edfico y/o tecnol\u00f3gico. El F\u00edsico estudia fen\u00f3menos de la naturaleza, como la energ\u00eda en todas sus formas, la estructura de la materia, las leyes que rigen, los movimientos de los cuerpos y la interacci\u00f3n entre ellos. Trabaja en programas multidisciplinarios relacionados con la metalurgia, geof\u00edsica, astrof\u00edsica, oceanograf\u00eda, qu\u00edmica, electr\u00f3nica y medicina. A trav\u00e9s de la investigaci\u00f3n pura y aplicada comprueba y propone nuevas leyes. El plan de estudio de F\u00edsica est\u00e1 estructurado en dos partes. La primera parte corresponde al ciclo b\u00e1sico de la carrera, su objetivo es brindar una formaci\u00f3n b\u00e1sica de los grandes principios de la f\u00edsica. El ciclo b\u00e1sico tiene una duraci\u00f3n de 9 semestres, est\u00e1 conformado por 26 asignaturas obligatorias y 1 asignatura electiva para un total de 142 unidades de cr\u00e9dito. El estudiante puede optar por al menos una de estas electivas: Principios de Biolog\u00eda y Elementos de Computaci\u00f3n. 18 La segunda parte corresponde al ciclo de opci\u00f3n de la carrera, su objetivo es profundizar la formaci\u00f3n del estudiante en un determinado campo profesional dentro del campo de la f\u00edsica. El ciclo de opci\u00f3n dispone de 4 semestres (VII, VIII, IX, X), para la aprobaci\u00f3n de las asignaturas correspondientes a las opciones, con 35 unidades de cr\u00e9dito distribuidas de la siguiente manera: 15 unidades de cr\u00e9dito en asignaturas obligatorias (Trabajo Especial de Grado), y 20 unidades de cr\u00e9dito en asignaturas obligatorias y electivas (seg\u00fan las opciones). Adem\u00e1s, el estudiante deber\u00e1 cursar Ingl\u00e9s I e Ingl\u00e9s II o presentar un examen de suficiencia con un valor de 8 unidades de cr\u00e9dito, adicionales a las 35 se\u00f1aladas anteriormente. La Figura 4 muestra el plan de estudio de F\u00edsica. 19 Figura 4. Plan de Estudio de F\u00edsica. La Escuela de F\u00edsica ofrece las siguientes opciones profesionales: Astrof\u00edsica, F\u00edsica Computacional, F\u00edsica Experimental, Geof\u00edsica, Instrumentaci\u00f3n, F\u00edsica M\u00e9dica y F\u00edsica Te\u00f3rica. Para optar por una opci\u00f3n profesional el estudiante debe aprobar un m\u00ednimo de 20 unidades de cr\u00e9dito en asignaturas correspondientes a la opci\u00f3n de su preferencia. Finalmente, para obtener el t\u00edtulo de Licenciado en F\u00edsica el estudiante debe aprobar al menos 185 unidades de cr\u00e9dito. Para los estudiantes que deseen ingresar al Programa Cooperativo de Formacion Docente, deben tener aprobadas todas las asignaturas hasta el 5to semestre inclusive. El estudiante debe cursar 111 unidades de cr\u00e9dito en asignaturas dictadas por la Facultad de Ciencias y 52 unidades de cr\u00e9dito en asignaturas dictadas por la Escuela de Educacion para optar por el componente docente. La Figura 5 muestra el componente docente de F\u00edsica. 20 21 Figura 5. Componente Docente de F\u00edsica. 1.4 Licenciatura en Geoqu\u00edmica El plan de estudio de la Licenciatura en Geoqu\u00edmica se encuentra vigente desde el a\u00f1o 2000. El Licenciado en Geoqu\u00edmica estudia la composici\u00f3n de los diversos ambientes y materiales que constituyen el planeta, investiga los procesos y leyes que determinan dicha composici\u00f3n. Este profesional contribuye al entendimiento global del sistema tierra y a la b\u00fasqueda y uso racional de los materiales naturales requeridos por la sociedad moderna. El plan de estudio de Geoqu\u00edmica est\u00e1 conformado por 39 asignaturas obligatorias y 4 asignaturas electivas para un total de 191 unidades de cr\u00e9dito distribuidas de la siguiente manera: 171 unidades de cr\u00e9dito en asignaturas obligatorias y electivas, y 20 unidades de cr\u00e9dito en las asignaturas Proyecto Geoqu\u00edmico I y Proyecto Geoqu\u00edmico II. La Figura 6 muestra el plan de estudio de Geoqu\u00edmica. 22 Figura 6. Plan de Estudio de Geoqu\u00edmica. Finalmente, para obtener el t\u00edtulo de Licenciado en Geoqu\u00edmica el estudiante debe aprobar al menos 191 unidades de cr\u00e9dito. 1.5 Licenciatura en Matem\u00e1tica El plan de estudio de la Licenciatura en Matem\u00e1tica se encuentra vigente desde el a\u00f1o 2004. El Licenciado en Matem\u00e1tica est\u00e1 capacitado para comenzar a realizar labores de investigaci\u00f3n y desarrollo de nuevas teor\u00edas; conceptos que posteriormente pueden tener aplicaci\u00f3n en la ciencia, la industria, la computaci\u00f3n, la estad\u00edstica, etc. Resuelve problemas matem\u00e1ticos complejos e incidentales en las investigaciones cient\u00edficas y en las actividades econ\u00f3micas. Ejerce funciones de asesor sobre diversas aplicaciones del an\u00e1lisis matem\u00e1tico. El plan de estudio de Matem\u00e1tica est\u00e1 conformado por 28 asignaturas obligatorias, 3 asignaturas electivas y 2 asignaturas optativas para un total de 194 unidades de cr\u00e9dito distribuidas de la 23 siguiente manera: 160 unidades de cr\u00e9dito en asignaturas obligatorias y electivas, 6 unidades de cr\u00e9dito en asignaturas optativas, y 28 unidades de cr\u00e9dito en las asignaturas Seminario I, Seminario II y Trabajo Especial de Grado. El estudiante puede optar por al menos una de estas asignaturas: Introducci\u00f3n a la Computaci\u00f3n, C\u00e1lculo Num\u00e9rico y C\u00e1lculo Cient\u00edfico. La Figura 7 muestra el plan de estudio de Matem\u00e1tica. 24 Figura 7. Plan de Estudio de Matem\u00e1tica. Finalmente, para obtener el t\u00edtulo de Licenciado en Matem\u00e1tica el estudiante debe aprobar al menos 194 unidades de cr\u00e9dito. Para los estudiantes que deseen ingresar al Programa Cooperativo de Formacion Docente, deben tener aprobadas todas las asignaturas hasta el 5to semestre inclusive. El estudiante debe cursar 101 unidades de cr\u00e9dito en asignaturas dictadas por la Facultad de Ciencias y 52 unidades de cr\u00e9dito en asignaturas dictadas por la Escuela de Educacion para optar por el componente docente. En el III Semestre el estudiante puede optar por al menos una de estas asignaturas: Introducci\u00f3n a la Computaci\u00f3n, C\u00e1lculo Num\u00e9rico y C\u00e1lculo Cient\u00edfico. En el VI Semestre el estudiante puede optar por al menos una de estas asignaturas: Historia de la Matem\u00e1tica y Filosof\u00eda de la Ciencia. Adem\u00e1s, la electiva Opci\u00f3n Docente es alguna de las siguientes asignaturas: Funciones Anal\u00edticas, Topolog\u00eda, Ecuaciones Diferenciales Ordinarias, Geometr\u00eda Diferencial, Algebra III o Teor\u00eda de la Medida. La Figura 8 muestra el componente docente de Matem\u00e1tica. 25 26 Figura 8. Componente Docente de Matem\u00e1tica. 1.6 Licenciatura en Qu\u00edmica El plan de estudio de la Licenciatura en Qu\u00edmica se encuentra vigente desde el a\u00f1o 1968. El Licenciado en Qu\u00edmica estudia la materia, su composici\u00f3n, propiedades y transformaciones en la estructura. Asesora t\u00e9cnicamente o trabaja en el dise\u00f1o y modificaciones de procesos qu\u00edmicos, soluciones de problemas industriales, innovaci\u00f3n tecnol\u00f3gica, evaluaci\u00f3n del impacto ambiental, mejoramiento y s\u00edntesis de productos, control de calidad, an\u00e1lisis de productos diversos. El plan de estudio de Qu\u00edmica est\u00e1 estructurado en dos partes. La primera parte corresponde al ciclo b\u00e1sico de la carrera, su objetivo es brindar una formaci\u00f3n b\u00e1sica de los grandes principios de la qu\u00edmica. El ciclo b\u00e1sico tiene una duraci\u00f3n de 8 semestres, est\u00e1 conformado por 27 asignaturas obligatorias para un total de 114 unidades de cr\u00e9dito. La segunda parte corresponde al ciclo de opci\u00f3n de la carrera, su objetivo es profundizar la formaci\u00f3n del estudiante en un determinado campo profesional dentro del campo de la qu\u00edmica. El ciclo de opci\u00f3n dispone de 5 semestres (VI, VII, VIII, IX, X), para la aprobaci\u00f3n de las asignaturas correspondientes a las opciones, con 69 unidades de cr\u00e9dito distribuidas de la siguiente manera: 39 unidades de cr\u00e9dito en asignaturas obligatorias, y 30 unidades de cr\u00e9dito en las asignaturas Seminario de Investigaci\u00f3n y Trabajo Especial de Grado. Adem\u00e1s, el estudiante deber\u00e1 cursar Ingl\u00e9s I e Ingl\u00e9s II o presentar un examen de suficiencia con un valor de 8 unidades de cr\u00e9dito, adicionales a las 69 se\u00f1aladas anteriormente. La Figura 9 muestra el plan de estudio de Qu\u00edmica. 27 28 Figura 9. Plan de Estudio de Qu\u00edmica. La Escuela de Qu\u00edmica ofrece las siguientes opciones profesionales: B\u00e1sica, Geoqu\u00edmica y Tecnolog\u00eda. Para optar por una opci\u00f3n profesional el estudiante debe aprobar un m\u00ednimo de 39 unidades de cr\u00e9dito en asignaturas, Seminario de Investigaci\u00f3n y el Trabajo Especial de Grado correspondientes a la opci\u00f3n de su preferencia. Finalmente, para obtener el t\u00edtulo de Licenciado en Qu\u00edmica el estudiante debe aprobar al menos 191 unidades de cr\u00e9dito. Para los estudiantes que deseen ingresar al Programa Cooperativo de Formacion Docente, deben tener aprobadas todas las asignaturas hasta el 5to semestre inclusive. El estudiante debe cursar 116 unidades de cr\u00e9dito en asignaturas dictadas por la Facultad de Ciencias y 52 unidades de cr\u00e9dito en asignaturas dictadas por la Escuela de Educaci\u00f3n para optar por el componente docente. La Figura 10 muestra el componente docente de Qu\u00edmica. 29 Figura 10. Componente Docente de Qu\u00edmica. 30 Cap\u00edtulo 2 Tecnolog\u00edas Web Desde el 26 de Febrero de 2007 se encuentra operativo el sistema CONEST, con la finalidad de automatizar la gesti\u00f3n acad\u00e9mica de la Facultad de Ciencias de la UCV. El proyecto surge como una iniciativa de la Facultad de Ciencias para resolver una problem\u00e1tica administrativa, potenciar los servicios de gesti\u00f3n acad\u00e9mica de la Divisi\u00f3n de Control de Estudios (DCE) y modernizar la infraestructura inform\u00e1tica, entre otras cosas, incentivando la participaci\u00f3n de forma activa de estudiantes, docentes y personal administrativo que forman parte de esta comunidad. El sistema CONEST es una aplicaci\u00f3n web desarrollada con software libre. Las aplicaciones web (Hassani, 2005) son aquellas que se acceden a trav\u00e9s de una red tales como internet o una intranet. En otras palabras, es un software de aplicaci\u00f3n codificado en un lenguaje soportado por un navegador web y que depende del mismo para ejecutar la aplicaci\u00f3n. Las aplicaciones web son populares debido a la accesibilidad de los navegadores web. La capacidad de actualizar y mantener aplicaciones web sin distribuir e instalar software en miles de clientes potenciales y la compatibilidad entre plataformas son otras razones de su popularidad. Las aplicaciones web funcionan en una arquitectura cliente-servidor (Beck, 2005). En las arquitecturas cliente-servidor una aplicaci\u00f3n se modela como un conjunto de servicios proporcionados por los servidores y un conjunto de clientes que usan esos servicios. Los clientes necesitan conocer que servidores est\u00e1n disponibles, pero normalmente no conocen la existencia de otros clientes. Con frecuencia clientes y servidores se comunican a trav\u00e9s de una red de comunicaci\u00f3n en hardwares separados utilizando el Protocolo de Transferencia de Hipertexto (HTTP) (Patrick, 2004) el cual es protocolo de red para sistemas de colaboraci\u00f3n de informaci\u00f3n hipermedia distribuidos. HTTP es la base de la comunicaci\u00f3n de datos en la Worl Wide Web (WWW). HTTP funciona como un protocolo petici\u00f3n-respuesta en la arquitectura cliente-servidor. En HTTP un navegador web, por ejemplo, act\u00faa como un cliente, mientras que una aplicaci\u00f3n que se est\u00e1 ejecutando en una computadora que hospeda un sitio web act\u00faa como un servidor. El cliente env\u00eda un mensaje de solicitud HTTP al servidor. El servidor que almacena contenido, proporciona recursos tales como archivos HTML e im\u00e1genes o genera el contenido seg\u00fan sea necesario, o desempe\u00f1a otras funciones por el cliente, devuelve una respuesta HTTP. Una respuesta contiene informaci\u00f3n sobre el estado de finalizaci\u00f3n de la solicitud y puede contener cualquier contenido solicitado por el cliente en el cuerpo del mensaje. La Figura 15 muestra un modelo l\u00f3gico de una arquitectura cliente-servidor utilizando el protocolo HTTP. 31 Figura 11. Arquitectura Cliente-Servidor. El termino aplicaci\u00f3n web generalmente est\u00e1 asociado con las tecnolog\u00edas web que permiten crear herramientas o servicios que facilitan el intercambio interactivo de informaci\u00f3n, interoperabilidad, dise\u00f1o centrado en el usuario y la colaboraci\u00f3n en la WWW. Las tecnolog\u00edas web del lado del cliente permiten que se ejecuten elementos interactivos en el navegador del usuario. Esto hace posible que la navegaci\u00f3n del sitio web sea a trav\u00e9s de men\u00fas din\u00e1micos y las validaciones del lado del cliente. Ciertas operaciones se realizan del lado del cliente debido a que requieren acceso a informaci\u00f3n o funcionalidades que est\u00e1n disponibles en el cliente pero no en el servidor, o porque el usuario debe ingresar datos. A continuaci\u00f3n se describe brevemente y se especifican las caracter\u00edsticas m\u00e1s importantes de las tecnolog\u00edas web del lado del cliente implementadas en el sistema CONEST: 2.1 HTML5 HTML5 (Hickson, 2010) es la quinta revisi\u00f3n del est\u00e1ndar HTML, actualmente en desarrollo. Como sus predecesores inmediatos (HTML 4.01 y XHTML 1.1), HTML5 es un est\u00e1ndar para estructurar y presentar contenido en la WWW. El est\u00e1ndar incorpora nuevas caracter\u00edsticas como los elementos <canvas>, <audio> y <video> as\u00ed como la integraci\u00f3n de contenido Gr\u00e1fico Vectorial Escalable (SVG), que est\u00e1n dise\u00f1ados para mejorar la inclusi\u00f3n y el manejo de contenido gr\u00e1fico y multimedia en la web sin recurrir a extensiones y sus APIs. Otros elementos nuevos tales como <section>, <article>, <header> y <nav> est\u00e1n dise\u00f1ados para mejorar la sem\u00e1ntica de los documentos. Nuevos atributos tambi\u00e9n han sido introducidos, y otros removidos, para mejorar y simplificar la sem\u00e1ntica de las expresiones. 32 Partes de HTML5 van a estar terminadas e implementadas en los navegadores progresivamente antes de que toda la especificaci\u00f3n alcance el estado final de recomendaci\u00f3n del World Wide Web Consortium (W3C). HTML5 incluye las siguientes caracter\u00edsticas: \uf0b7 El elemento canvas para el modo inmediato de dibujo 2D. \uf0b7 Reproducci\u00f3n multimedia temporizada. \uf0b7 Bases de datos para almacenamiento sin conexi\u00f3n de red. \uf0b7 Edici\u00f3n de documentos. \uf0b7 Drag-and-drop. \uf0b7 Mensajer\u00eda entre documentos. \uf0b7 Gesti\u00f3n del historial del navegador. \uf0b7 Microdata. 2.2 CSS3 CSS3 (Bos, 2005) es la tercera especificaci\u00f3n del est\u00e1ndar CSS, actualmente en desarrollo. CSS es un lenguaje de hojas de estilo que se utiliza para describir la presentaci\u00f3n (el aspecto y el formato) de un documento escrito en un lenguaje de marcado. Su aplicaci\u00f3n m\u00e1s com\u00fan es para estilizar p\u00e1ginas web escritas en HTML y XHTML. CSS3 se basa en sus predecesores (CSS1 y CSS2), incluye una serie de selectores como [att^=\"\"], [att$=\"\"] y [att*=\"\"] que permiten seleccionar elementos espec\u00edficos de un documento HTML sin tener que depender de identificadores, clases y scripts innecesarios. Otros atributos nuevos tales como font-face, word-wrap, text-shadow, boder-image y rgba mejoran en gran medida el trabajo de los desarrolladores, por lo que algunas de las tareas de CSS que consumen m\u00e1s tiempo son muy sencillas, permitiendo un mejor c\u00f3digo, m\u00e1s limpio y ligero. El desarrollo de CSS3 est\u00e1 divido en m\u00f3dulos. La especificaci\u00f3n anterior se ha separado en pedazos m\u00e1s peque\u00f1os y se han a\u00f1adido nuevas funcionalidades. Varios de los m\u00f3dulos ya est\u00e1n terminados, incluyendo SVG, Media Queries y Namespaces, mientras que otros todav\u00eda est\u00e1n en desarrollo. Las nuevas funciones se incorporar\u00e1n gradualmente en los navegadores web en los pr\u00f3ximos a\u00f1os. CSS3 incluye las siguientes caracter\u00edsticas: \uf0b7 Atributos de textos como font-face para embeber fuentes de letras. \uf0b7 Margen, borde, relleno y posicionamiento para la mayor\u00eda de los elementos. \uf0b7 Color y opacidad de textos, fondos y otros elementos. \uf0b7 Dise\u00f1o de m\u00faltiples columnas sin utilizar elementos <div>. \uf0b7 Transiciones y animaciones. \uf0b7 Agregar esquinas redondeadas a elementos HTML sin im\u00e1genes de fondo. 33 2.3 jQuery jQuery (The jQuery Project, 2010) es una librer\u00eda de JavaScript que simplifica la manera de interactuar con los documentos HTML, seleccionar elementos DOM, desarrollar animaciones, manejar eventos y agregar interacci\u00f3n de manera as\u00edncrona con el servidor a p\u00e1ginas web. jQuery al igual que otras librer\u00edas, ofrece una serie de funcionalidades basadas en JavaScript que de otra manera requieren de mucho m\u00e1s c\u00f3digo, es decir, con esta librer\u00eda se logran resultados en menos tiempo. jQuery tambi\u00e9n permite crear extensiones sobre la librer\u00eda de JavaScript, esto contribuye a la creaci\u00f3n de p\u00e1ginas web con funciones nuevas y generalmente muy espec\u00edficas. jQuery incluye las siguientes caracter\u00edsticas: \uf0b7 Selecci\u00f3n de elementos DOM. \uf0b7 Interacci\u00f3n y modificaci\u00f3n del \u00e1rbol DOM. \uf0b7 Manejo de eventos. \uf0b7 Manipulaci\u00f3n de CSS. \uf0b7 Efectos y animaciones. \uf0b7 AJAX. \uf0b7 Extensibilidad a trav\u00e9s de plugins. \uf0b7 Compatibilidad con todos los navegadores modernos. Al igual que HTML5, jQuery establece una serie de elementos que reflejan el uso t\u00edpico de los sitios web modernos. La ventaja de HTML5 con respecto a jQuery, es que est\u00e1 dise\u00f1ado para integrar y presentar contenido multimedia en la web sin recurrir a extensiones de terceros y sus APIs. Sin embargo, la especificaci\u00f3n de HTML5 es un trabajo en curso, y partes del est\u00e1ndar a\u00fan no est\u00e1n terminadas. jQuery es una soluci\u00f3n m\u00e1s consolidada y soportada por todos los navegadores modernos. Las tecnolog\u00edas web del lado del servidor son com\u00fanmente utilizadas en aplicaciones web interactivas que permiten a los usuarios acceder bases de datos y recuperar o modificar datos que se encuentran alojados en un servidor. El servidor usa lenguajes como Ruby para procesar peticiones de los clientes, interpretar y generar respuestas utilizando informaci\u00f3n de archivos y bases de datos, y enviarlas de vuelta al cliente en un lenguaje soportado por el navegador. A continuaci\u00f3n se describe brevemente y se especifican las caracter\u00edsticas m\u00e1s importantes de las tecnolog\u00edas web del lado del servidor implementadas en el sistema CONEST. 34 2.4 Ruby on Rails Ruby on Rails (RoR) (Ruby on Rails, 2011) es un framework para desarrollar aplicaciones web escrito en el lenguaje de programaci\u00f3n Ruby que esta optimizado para mejorar la productividad y con un m\u00ednimo de configuraci\u00f3n. RoR incluye herramientas que facilitan las tareas m\u00e1s comunes de desarrollo, como generadores que pueden construir autom\u00e1ticamente algunas de las clases y p\u00e1ginas necesarias para un sitio web b\u00e1sico. Tambi\u00e9n incluye WEBrick, un servidor web sencillo que se distribuye con Ruby, y Rake, un sistema de construcci\u00f3n, distribuido como una gema. Juntos estas herramientas proveen un ambiente de desarrollo. RoR est\u00e1 dividido en varios paquetes, llamados ActiveRecord (un sistema de mapeo objeto- relacional para acceder a la base de datos), ActiveResource (provee servicios web), ActionPack, ActionSupport y ActionMailer. Aparte de los paquetes est\u00e1ndar, los desarrolladores pueden hacer plugins para ampliar los paquetes existentes. RoR supone que hay una \u201cmejor\u201d manera de hacer las cosas, y est\u00e1 dise\u00f1ado para fomentar esa manera (y en algunos casos para rechazar las alternativas). La filosof\u00eda de RoR incluye los siguientes principios: \uf0b7 Don\u2019t Repeat Yourself (DRY): DRY sugiere que escribir el mismo c\u00f3digo una y otra vez es una mala pr\u00e1ctica de programaci\u00f3n. \uf0b7 Convention Over Configuration (CoC): CoC significa que RoR hace suposiciones sobre lo que se quiere hacer y c\u00f3mo se va a hacerlo, en lugar de exigir que se especifique cada detalle a trav\u00e9s de archivos de configuraci\u00f3n. Como muchos frameworks web, RoR usa el patr\u00f3n de dise\u00f1o arquitect\u00f3nico Modelo-Vista- Controlador (MVC) para organizar la programaci\u00f3n de las aplicaciones web. MVC es una arquitectura de software, considerado actualmente como un patr\u00f3n de arquitectura utilizado en la ingenier\u00eda de software. El patr\u00f3n a\u00edsla la l\u00f3gica de negocio de la aplicaci\u00f3n de su interfaz de usuario, permitiendo el desarrollo, prueba y mantenimiento de cada uno de manera independiente. A continuaci\u00f3n se describe brevemente los componentes del patr\u00f3n de dise\u00f1o arquitect\u00f3nico MVC: Modelo: Un modelo representa la informaci\u00f3n (datos) de la aplicaci\u00f3n y las reglas para manipular esos datos. En el caso de RoR, los modelos se utilizan principalmente para gestionar la interacci\u00f3n con las tablas en la base de datos. En muchos casos, una tabla en la base de datos corresponder\u00e1 a un modelo en la aplicaci\u00f3n. La mayor parte de la l\u00f3gica de negocio de la aplicaci\u00f3n se concentra en los modelos. 35 Vista: Las vistas representan las interfaces de usuario de una aplicaci\u00f3n, generalmente son documentos HTML con c\u00f3digo Ruby embebido que s\u00f3lo realiza tareas relacionadas con la presentaci\u00f3n de los datos. Las vistas se encargan de proporcionar datos al navegador web u otras herramientas que se utilicen para realizar peticiones a la aplicaci\u00f3n. Controlador: Los controladores proveen un enlace entre los modelos y las vistas. En RoR, los controladores son responsables de procesar las peticiones entrantes desde el navegador web, interrogar a los modelos para obtener datos, y pasar dichos datos a la vista para que pueda presentarlos. 2.5 Haml Haml (Haml, 2011) es un lenguaje de enmarcado liviano que se utiliza para describir el XHTML de cualquier documento web sin el uso de codificaci\u00f3n en l\u00ednea tradicional. Est\u00e1 dise\u00f1ado para resolver muchas de las fallas en los motores de plantillas, a la vez que hace el enmarcado tan limpio como se pueda. Haml funciona en sustituci\u00f3n de sistemas de plantillas de p\u00e1ginas tales como RHTML. Sin embargo, Haml evita la necesidad de codificar XHTML expl\u00edcitamente en la plantilla, porque el mismo es una descripci\u00f3n del XHTML, con c\u00f3digo para generar contenido din\u00e1micamente. La filosof\u00eda de Haml incluye los siguientes principios: \uf0b7 El enmarcado debe ser limpio: El enmarcado no debe ser utilizado simplemente como una herramienta para hacer que los navegadores desplieguen una p\u00e1gina de la manera en que su autor lo desea. Lo que se despliega no es lo \u00fanico que la gente tiene que ver; tambi\u00e9n tienen que ver, modificar y entender el enmarcado. Por lo tanto, el enmarcado debe ser tan amigable y agradable como el resultado desplegado. \uf0b7 El enmarcado debe ser DRY: XHTML implica muchas repeticiones. La mayor\u00eda de los elementos tienen que ser nombrados al menos dos veces; una vez antes de su contenido y una vez despu\u00e9s. ERB agrega a\u00fan m\u00e1s repeticiones y caracteres innecesarios. Haml evita todo esto apoy\u00e1ndose en la indentaci\u00f3n, no el texto, para determinar donde los elementos y bloques de c\u00f3digo comienzan y terminan. Esto no solo resulta en plantillas m\u00e1s peque\u00f1as, sino tambi\u00e9n hace que el c\u00f3digo sea m\u00e1s limpio. \uf0b7 El enmarcado debe estar bien indentado: Uno de los principales problemas de los lenguajes de plantillas tradicionales es que no solo no fomentan el c\u00f3digo bien indentado, sino que activamente lo hacen dif\u00edcil, o hasta imposible, de escribir. El resultado es confuso, XHTML ilegible. Haml formatea las etiquetas para que est\u00e9n bien identadas y reflejen la estructura subyacente del documento. \uf0b7 La estructura XHTML debe ser clara: XML y XHTML son formatos construidos sobre el concepto de documentos estructurados. Esa estructura es reflejada en el enmarcado, y deber\u00eda ser reflejada igualmente en el meta-enmarcado, como Haml. Debido a que la l\u00f3gica de Haml est\u00e1 basada en la indentaci\u00f3n de los elementos hijos, esta estructura se mantiene naturalmente, haciendo que el documento sea m\u00e1s f\u00e1cil de leer y mas entendible para las personas. 36 2.6 Sass Sass (Sass, 2011) es un metalenguaje de hojas de estilo. Es un lenguaje de scripting que es interpretado a CSS. SassScript es el lenguaje de scripting propiamente. Sass consiste de dos sintaxis. La sintaxis original, llamada \u201cla sintaxis indentada\u201d usa una sintaxis similar a la de Haml. Utiliza la indentaci\u00f3n para separar bloques de c\u00f3digo y saltos de l\u00ednea para separar reglas. La nueva sintaxis \u201cSCSS\u201d usa un formato de bloques similar al de CSS. Utiliza corchetes para denotar bloques de c\u00f3digo y punto y coma para separar reglas dentro de un bloque. Sass extiende CSS al proveer varios mecanismos disponibles en otros lenguajes de programaci\u00f3n m\u00e1s tradicionales, particularmente lenguajes orientado a objetos, pero que no est\u00e1n disponibles en CSS3 como tal. Cuando SassScript es interpretado, crea un bloque de reglas de CSS para varios selectores definidos por el archivo Sass. El interpretador Sass traduce SassScript a CSS. Adicionalmente, Sass puede monitorear un archivo Sass (.sass o .scss) y traducirlo a un archivo .css. Sass incluye las siguientes caracter\u00edsticas: \uf0b7 Variables. \uf0b7 Indentaci\u00f3n. \uf0b7 Mixins. \uf0b7 Parametros. \uf0b7 Herencia de selectores. 2.7 MySQL MySQL (Obfusco, 2003) es un Sistema Manejador de Base de Datos Relacional (RDBMS) que se ejecuta como un servidor que facilita el acceso de m\u00faltiples usuarios a una serie de base de datos. MySQL est\u00e1 escrito en C y C++, funciona en muchas plataformas diferentes, incluyendo Linux, Solaris, Symbian, Mac OS X y Microsoft Windows, entre otros. MySQL es principalmente un RDBMS y por lo tanto no posee una interfaz grafica de usuario para administrar base de datos o gestionar los datos que contiene adentro. Los usuarios pueden usar las herramientas de l\u00ednea de comandos incluidas, o descargarse un software o aplicaci\u00f3n web para administrar base de datos, construir la estructura de base de datos, y gestionar los registros de datos. MySQL incluye las siguientes caracter\u00edsticas: \uf0b7 Soporte de m\u00faltiples plataformas. \uf0b7 Stored procedure. \uf0b7 Triggers. \uf0b7 Indexaci\u00f3n de texto completo. \uf0b7 Motores de almacenamiento independientes (MyISAM para las consultas, InnoDB para las transacciones, MySQL Archive para almacenar el historial de datos). 37 Cap\u00edtulo 3 M\u00e9todo \u00c1gil de Desarrollo de Software El sistema CONEST se construy\u00f3 utilizando un m\u00e9todo \u00e1gil de desarrollo de software. El desarrollo \u00e1gil de software (Asierra, 2004) es un marco de trabajo conceptual usado en la ingenier\u00eda de software para estructurar, planificar y controlar el proceso de desarrollo en sistemas de informaci\u00f3n. El software se desarrolla en unidades de tiempo llamadas iteraciones, la cual debe durar de una a cuatro semanas. Cada iteraci\u00f3n del ciclo de vida incluye: planificaci\u00f3n, an\u00e1lisis de requerimientos, dise\u00f1o, codificaci\u00f3n, revisi\u00f3n y documentaci\u00f3n. La Figura 16 muestra el ciclo de vida general para el desarrollo \u00e1gil de software. Figura 12. Ciclo de Vida Para el Desarrollo \u00c1gil de Software. (Fuente: http://sdc.net.au/services/application-development.aspx). Las metodolog\u00edas \u00e1giles de desarrollo de software est\u00e1n dise\u00f1adas para producir software \u00fatil de forma r\u00e1pida. Generalmente, son procesos en los que se entrelazan la especificaci\u00f3n, el desarrollo y las pruebas. El software no se desarrolla y utiliza en su totalidad, sino en una serie de incrementos, donde en cada incremento se incluye nuevas funcionalidades al sistema. Ejemplos de metodolog\u00edas de desarrollo de software \u00e1giles son: RAD, SCRUM y XP. Todos los m\u00e9todos \u00e1giles comparten un conjunto de principios: \uf0b7 Participaci\u00f3n del cliente: Los clientes deben estar fuertemente implicados en todo el proceso de desarrollo. Su papel es proporcionar y priorizar nuevos requerimientos del sistema y evaluar las iteraciones del sistema. \uf0b7 Entrega incremental: El software se desarrolla en incrementos, donde el cliente especifica los requerimientos a incluir en cada incremento. http://sdc.net.au/services/application-development.aspx 38 \uf0b7 Personas ante procesos: Se deben reconocer y explotar las habilidades del equipo de desarrollo. Se les debe dejar desarrollar sus propias formas de trabajar, sin procesos formales, a los miembros del equipo. \uf0b7 Aceptar el cambio: Se debe contar con que los requerimientos del sistema cambian, por lo que el sistema se dise\u00f1a para dar cabida a estos cambios. \uf0b7 Mantener la simplicidad: Se debe centrar en la simplicidad tanto en el software a desarrollar como en el proceso de desarrollo. Donde sea posible, se trabaja activamente para eliminar la complejidad del sistema. El m\u00e9todo \u00e1gil de desarrollo de software utilizado para controlar el proceso de desarrollo del m\u00f3dulo web para la gesti\u00f3n de planes de estudio en el sistema CONEST es una adaptaci\u00f3n de la Programaci\u00f3n Extrema. A continuaci\u00f3n se describe brevemente y se especifican las caracter\u00edsticas m\u00e1s importantes de la Programaci\u00f3n Extrema. 3.1 Programaci\u00f3n Extrema (XP) La Programaci\u00f3n Extrema (XP) (Beck, 2005) es posiblemente el m\u00e9todo \u00e1gil m\u00e1s conocido y ampliamente utilizado. En XP todos los requerimientos se expresan como escenarios (llamados historias de usuarios), los cuales se implementan directamente como una serie de tareas. Los programadores trabajan en parejas y desarrollan pruebas para cada tarea antes de escribir el c\u00f3digo. Todas las pruebas se deben ejecutar satisfactoriamente cuando el c\u00f3digo nuevo se integre al sistema. XP implica varias pr\u00e1cticas: \uf0b7 Planificaci\u00f3n incremental: Los requerimientos se registran en tarjetas de historias y las historias a incluir en una entrega se determinan seg\u00fan el tiempo disponible y su prioridad relativa. Los desarrolladores dividen estas historias en tareas de desarrollo. \uf0b7 Entregas peque\u00f1as: El m\u00ednimo conjunto \u00fatil de funcionalidad que proporcione valor de negocio se desarrolla primero. Las entregas del sistema son frecuentes e incrementalmente a\u00f1aden funcionalidad a la primera entrega. \uf0b7 Dise\u00f1o sencillo: Solo se lleva a cabo el dise\u00f1o necesario para cumplir los requerimientos actuales. \uf0b7 Desarrollo previamente probado: Se utiliza un sistema de pruebas de unidad automatizado para escribir pruebas para nuevas funcionalidades antes de que estas se implementen. \uf0b7 Refactorizaci\u00f3n: Se espera que todos los desarrolladores refactoricen el c\u00f3digo continuamente tan pronto como encuentren posibles mejoras en el c\u00f3digo. Esto conserva el c\u00f3digo sencillo y mantenible. \uf0b7 Programaci\u00f3n en parejas: Los desarrolladores trabajan es parejas, verificando cada uno el trabajo del otro y proporcionando la ayuda necesaria para hacer siempre un buen trabajo. 39 \uf0b7 Propiedad colectiva: Las parejas de desarrolladores trabajan en todas las \u00e1reas del sistema, de modo que no desarrollen islas de conocimientos y todos los desarrolladores posean todo el c\u00f3digo. Cualquiera puede cambiar cualquier cosa. \uf0b7 Integraci\u00f3n continua: En cuanto acaba el trabajo en un \u00e1rea, se integra en el sistema entero. Despu\u00e9s de la integraci\u00f3n, se deben pasar al sistema todas las pruebas de unidad. \uf0b7 Ritmo sostenible: No se consideran aceptables grandes cantidades de horas extras, ya que a menudo el efecto que tienen es que se reduce la calidad del c\u00f3digo y la productividad a medio plazo. \uf0b7 Cliente presente: Debe estar disponible al equipo de XP un representante de los usuarios finales del sistema (el cliente) a tiempo completo. En un proceso de programaci\u00f3n extrema, el cliente es miembro del equipo de desarrolladores y es responsable de formular al equipo los requerimientos del sistema para su implementaci\u00f3n. Una vez que se han desarrollado las tarjetas de historias, el equipo de desarrolladores las divide en tareas y estima el esfuerzo y recursos requeridos para su implementaci\u00f3n. El cliente establece entonces la prioridad de las historias a implementar, eligiendo aquellas historias que pueden ser utilizadas inmediatamente para entregar un apoyo \u00fatil al negocio. Cuando los requerimientos cambian, las historias sin implementar tambi\u00e9n cambian o se pueden descartar. Si se requieren cambios en un sistema que ya se ha entregado, se desarrollan nuevas tarjetas de historias y, de nuevo, el cliente decide si estos cambios tienen prioridad sobre nuevas funcionalidades. XP adopta un enfoque \u201cextremo\u201d para el desarrollo iterativo. Se pueden construir varias veces al d\u00eda nuevas versiones del software y los incrementos se entregan al cliente cada dos meses aproximadamente. Cuando un programador construye el sistema para crear una versi\u00f3n nueva, debe ejecutar todas las pruebas automatizadas existentes adem\u00e1s de las pruebas para las funcionalidades nuevas. El nuevo software generado solamente se acepta si se ejecutan satisfactoriamente todas las pruebas. Para evitar algunos de los problemas de las pruebas y de las validaciones del sistema. XP pone m\u00e1s \u00e9nfasis en el proceso de pruebas que otros m\u00e9todos \u00e1giles. Las pruebas del sistema son fundamentales en XP, en la que se ha desarrollado un enfoque que reduce la probabilidad de producir nuevos incrementos del sistema que introduzcan errores en el software existente. Las caracter\u00edsticas clave de las pruebas en XP son: \uf0b7 Desarrollo previamente probado. \uf0b7 Desarrollo de pruebas incremental a partir de los escenarios. \uf0b7 Participaci\u00f3n del usuario en el desarrollo de las pruebas y en la validaci\u00f3n. \uf0b7 El uso de bancos de pruebas automatizadas. A continuaci\u00f3n se describe la adaptaci\u00f3n del m\u00e9todo \u00e1gil XP utilizado en el proceso de desarrollo del m\u00f3dulo web para la gesti\u00f3n de planes de estudio en el sistema CONEST. 40 3.2 Adaptaci\u00f3n del M\u00e9todo \u00c1gil XP Las pr\u00e1cticas del m\u00e9todo \u00e1gil XP se agrupan en cuatro fases; Planificaci\u00f3n (incremental), Dise\u00f1o (sencillo y refactorizaci\u00f3n), Codificaci\u00f3n (entregas peque\u00f1as, cliente presente, integraci\u00f3n continua, ritmo sostenible, programaci\u00f3n en parejas y propiedad colectiva) y Pruebas (desarrollo previamente probado). A continuaci\u00f3n se describe como se implementaron las pr\u00e1cticas del m\u00e9todo \u00e1gil XP en cada fase durante el desarrollo del m\u00f3dulo web para la gesti\u00f3n de planes de estudio en el sistema CONEST. 3.2.1 Planificaci\u00f3n En la fase de planificaci\u00f3n se desarrollan las tarjetas de historias, las cuales deben ser definidas con la participaci\u00f3n del cliente para que proporcionen y prioricen los requerimientos. Los requerimientos relacionados con la gesti\u00f3n de los planes de estudio de las licenciaturas de la Facultad de Ciencias y sus normativas, que inciden en el proceso de graduaci\u00f3n de los estudiantes regulares de pregrado se registraron en tarjetas de historias. Las tarjetas de historias est\u00e1n conformadas por un nombre, una descripci\u00f3n y el n\u00famero de d\u00edas estimado para desarrollar el requerimiento. La Figura 17 muestra el formato de las tarjetas de historias. Figura 13. Formato de las Tarjetas de Historias. Las tarjetas de historias no se dividieron en tareas de desarrollo por simplicidad y para reducir la documentaci\u00f3n. En esta fase tambi\u00e9n se planifican las entregas de los requerimientos del m\u00f3dulo web mediante iteraciones programadas, las cuales dividen la implementaci\u00f3n de las tarjetas de historias y se entregan al cliente al final de cada iteraci\u00f3n para hacer pruebas y correcciones. 41 Las iteraciones tienen una duraci\u00f3n de tres meses, y las historias a incluir en una entrega se determinan seg\u00fan el n\u00famero de d\u00edas estimado para desarrollar los requerimientos y su prioridad relativa. 3.2.2 Dise\u00f1o En la fase de dise\u00f1o se esquematiza el m\u00f3dulo web, enfoc\u00e1ndose en cubrir las necesidades inmediatas del cliente, ni m\u00e1s ni menos. En cada iteraci\u00f3n se entreg\u00f3 el mayor valor de negocio produciendo el c\u00f3digo m\u00e1s sencillo que cumpliera con los requerimientos definidos en las tarjetas de historias. En esta fase tambi\u00e9n se revis\u00f3 constantemente el c\u00f3digo, refinando los dise\u00f1os que se consideraron necesarios cuando se encontraban posibles mejoras en el c\u00f3digo, con el fin de minimizar en lo posible las ineficiencias. 3.2.3 Codificaci\u00f3n En la fase de codificaci\u00f3n se desarrolla el m\u00f3dulo web en incrementos seg\u00fan la planificaci\u00f3n de las entregas, creando un programa sencillo que aportara valor de negocio r\u00e1pidamente, que se actualizaba de manera frecuente a\u00f1adiendo funcionalidades a la primera entrega. El m\u00f3dulo web se desarroll\u00f3 siguiendo los est\u00e1ndares de codificaci\u00f3n del sistema CONEST, para asegurar la consistencia, facilitar la comprensi\u00f3n y la refactorizaci\u00f3n del c\u00f3digo. A continuaci\u00f3n se describe brevemente el est\u00e1ndar de codificaci\u00f3n para el desarrollo del sistema CONEST. Las reglas generales para escribir y documentar el c\u00f3digo incluyen: \uf0b7 En espa\u00f1ol. \uf0b7 Sin e\u00f1es, acentos o caracteres especiales. \uf0b7 Sustituir las e\u00f1es por enes. \uf0b7 Omitir los acentos. \uf0b7 Identar el c\u00f3digo con 2 espacios en blanco. \uf0b7 Usar comentarios para documentar cada m\u00e9todo. \uf0b7 Dejar un espacio en blanco antes y despu\u00e9s de un signo igual, excepto en los par\u00e1metros por defecto de un m\u00e9todo. \uf0b7 No dejar espacios en blanco despu\u00e9s de un m\u00e9todo. 42 Las reglas generales para nombrar directorios, archivos, atributos, variables y constantes incluyen: \uf0b7 Directorios, archivos, atributos y variables en min\u00fascula. \uf0b7 Constantes en may\u00fascula. \uf0b7 Separar nombres compuestos con sub guiones. Las reglas generales para nombrar clases incluyen: \uf0b7 De manera capital (Primera letra en may\u00fascula y el resto en min\u00fascula). \uf0b7 No separar nombres compuestos. Las reglas generales para nombrar m\u00e9todos y par\u00e1metros incluyen: \uf0b7 En min\u00fascula. \uf0b7 Separar nombres compuestos con sub guiones. \uf0b7 S\u00ed un m\u00e9todo retorna un booleano debe terminar en ?. \uf0b7 S\u00ed un m\u00e9todo modifica un objeto debe terminar en !. \uf0b7 S\u00ed un m\u00e9todo arroja una excepci\u00f3n de error debe terminar en !. \uf0b7 S\u00ed un m\u00e9todo no tiene par\u00e1metros debe terminar sin (). Es importante resaltar que el cliente estuvo presente durante toda la fase de codificaci\u00f3n del proyecto, trabajando activamente para revisar los requerimientos, las funcionalidades, se\u00f1alar las prioridades y responder las preguntas del programador. Se integr\u00f3 una versi\u00f3n completa del m\u00f3dulo web al sistema CONEST al final de la fase de codificaci\u00f3n del proyecto. Se trabaj\u00f3 30 horas semanales, distribuidas entre los cinco d\u00edas de la semana en jornadas diurnas, trabajando horas extras solo cuando se consideraba necesario. El m\u00f3dulo web fue desarrollado por un solo programador, el cual trabaj\u00f3 todas las \u00e1reas del modulo web, impidiendo el desarrollo de islas de conocimientos. 3.2.4 Pruebas En la fase de pruebas se implementan pruebas funcionales y de aceptaci\u00f3n al final de cada iteraci\u00f3n, estas se generaron a partir de las tarjetas de historias que se desarrollaban durante una iteraci\u00f3n. Se definen los datos de entrada y los resultados esperados para cada tarjeta de historia, y el cliente verifica el correcto funcionamiento del requerimiento que se est\u00e1 probando. Cuando se da 43 por buena la prueba de aceptaci\u00f3n, se considera que la historia correspondiente se ha completado. El sistema de pruebas de unidad automatizado no se implement\u00f3 para favorecer la productividad y las entregas r\u00e1pidas y constantes durante el desarrollo del proyecto. 44 Cap\u00edtulo 4 Marco Aplicativo En este cap\u00edtulo se describe el proceso de desarrollo del m\u00f3dulo web para la gesti\u00f3n de planes de estudio en el sistema CONEST. El m\u00e9todo \u00e1gil de desarrollo de software utilizado para estructurar, planificar y controlar el proceso de desarrollo de este Trabajo Especial de Grado es una adaptaci\u00f3n de la Programaci\u00f3n Extrema (XP). Es importante resaltar que algunas pr\u00e1cticas del m\u00e9todo \u00e1gil XP no se aplicaron en este proyecto tales como el desarrollo previamente probado, la programaci\u00f3n en parejas, la propiedad colectiva y la integraci\u00f3n continua. Sin embargo, se aplicaron el resto de las pr\u00e1cticas tales como la planificaci\u00f3n incremental, las entregas peque\u00f1as, el dise\u00f1o sencillo, la refactorizaci\u00f3n, el ritmo sostenible y la presencia del cliente. Debido al m\u00e9todo \u00e1gil de desarrollo de software utilizado en este Trabajo Especial de Grado, fue necesario definir y desarrollar un conjunto de iteraciones, en las cuales el software se desarrolla en incrementos. A continuaci\u00f3n, se describen las iteraciones realizadas durante el desarrollo del m\u00f3dulo web para la gesti\u00f3n de planes de estudio en el sistema CONEST. 4.1 Iteraci\u00f3n 0 En esta iteraci\u00f3n se analiza de manera general el m\u00f3dulo web; se realiza un levantamiento de los requerimientos necesarios para la implementaci\u00f3n, se desarrollan las tarjetas de historias y se esquematiza su funcionamiento. 4.1.1 Planificaci\u00f3n Los planes de estudio de las licenciaturas de la Facultad de Ciencias se estudiaron para determinar las caracter\u00edsticas comunes y las diferencias de cada plan de estudio. Adem\u00e1s, se analiz\u00f3 el proceso de graduaci\u00f3n que lleva a cabo la DCE mediante entrevistas con los trabajadores del Departamento de Grado, para determinar la manera en que los planes de estudio influyen en dicho proceso. El Departamento de Grado de la DCE utiliza los planes de estudio de las distintas licenciaturas cada semestre para verificar que los estudiantes que inscribieron Trabajo Especial de Grado cumplen con todos los requisitos curriculares y las normativas acad\u00e9micas que deben satisfacer para obtener un t\u00edtulo universitario en la licenciatura en que se encuentran inscritos. En el proceso de graduaci\u00f3n se verifican los siguientes requisitos curriculares: \uf0b7 Aprobar el conjunto de asignaturas obligatorias. \uf0b7 Aprobar el n\u00famero de cr\u00e9ditos en asignaturas electivas. 45 \uf0b7 Convalidaciones y equivalencias entre asignaturas, en caso de que aplique. \uf0b7 Opciones profesionales. \uf0b7 Componente docente. \uf0b7 Servicio comunitario. Es importante resaltar que los trabajadores del Departamento de Grado realizan todas sus labores con un soporte m\u00ednimo del sistema CONEST, verificando de manera manual los requisitos curriculares de cada estudiante con l\u00e1pices de colores y distintos documentos impresos. Esto representa un mayor esfuerzo humano y aumenta la probabilidad de cometer errores. Posteriormente, con el soporte y la supervisi\u00f3n de los tutores se estableci\u00f3 como el m\u00f3dulo web debe gestionar los planes de estudio para facilitar y simplificar las operaciones de los procesos de gesti\u00f3n acad\u00e9mica de la DCE. Y por \u00faltimo, se revis\u00f3 la base de datos actual del sistema CONEST para evaluar el soporte que provee y determinar las estructuras de datos necesarias para desarrollar las nuevas funcionalidades que incorporar\u00e1 el m\u00f3dulo web para la gesti\u00f3n de planes de estudio al sistema CONEST. Tras estudiar los planes de estudio de las licenciaturas de la Facultad de Ciencias y el proceso de graduaci\u00f3n de la DCE, se determin\u00f3 que el m\u00f3dulo web para la gesti\u00f3n de planes de estudio en el sistema CONEST debe satisfacer los siguientes requerimientos: \uf0b7 Gestionar los planes de estudio de las licenciaturas que ofrece la Facultad de Ciencias; requisitos curriculares, distribuci\u00f3n de los requisitos curriculares por semestre, asignaturas, prelaciones, convalidaciones y equivalencias, y opciones profesionales. \uf0b7 Automatizar la verificaci\u00f3n de requisitos curriculares del proceso de graduaci\u00f3n del Departamento de Grado de la DCE. \uf0b7 Aplicar un conjunto de pruebas para verificar el correcto funcionamiento del m\u00f3dulo web. \uf0b7 Integrar el m\u00f3dulo web con el resto del sistema CONEST. Las tarjetas de historias se desarrollan a partir de los requerimientos. En este Trabajo Especial de Grado se definieron las siguientes tarjetas de historias: 1. Dise\u00f1ar una interfaz gr\u00e1fica para verificar requisitos curriculares 1 D\u00eda Definir la informaci\u00f3n necesaria y el formato adecuado para verificar requisitos curriculares en el m\u00f3dulo web 2. Dise\u00f1ar las estructuras de datos para verificar requisitos curriculares 1 D\u00eda Dise\u00f1ar las tablas, atributos, restricciones y asociaciones necesarias para soportar la verificaci\u00f3n de requisitos curriculares en el m\u00f3dulo web 46 3. Desarrollar la verificaci\u00f3n de asignaturas obligatorias 2 D\u00edas Verificar que un estudiante haya aprobado las asignaturas obligatorias en una carrera 4. Desarrollar la verificaci\u00f3n de asignaturas obligatorias optativas 1 D\u00eda Verificar que un estudiante haya aprobado el n\u00famero de cr\u00e9ditos en asignaturas obligatorias optativas en una carrera 5. Desarrollar la verificaci\u00f3n de asignaturas electivas 1 D\u00eda Verificar que un estudiante haya aprobado el n\u00famero de cr\u00e9ditos en asignaturas electivas en una carrera 6. Desarrollar la verificaci\u00f3n de asignaturas complementarias 1 D\u00eda Verificar que un estudiante haya aprobado el n\u00famero de cr\u00e9ditos en asignaturas complementarias en una carrera 7. Desarrollar la verificaci\u00f3n de laboratorios 1 D\u00eda Verificar que un estudiante haya aprobado el n\u00famero de cr\u00e9ditos en asignaturas de laboratorio en una carrera 8. Desarrollar la verificaci\u00f3n de pasant\u00edas 1 D\u00eda Verificar que un estudiante haya aprobado el n\u00famero de cr\u00e9ditos en asignaturas de pasant\u00eda en una carrera 9. Desarrollar la verificaci\u00f3n de seminarios 1 D\u00eda Verificar que un estudiante haya aprobado el n\u00famero de cr\u00e9ditos en asignaturas de seminario en una carrera 10. Desarrollar la verificaci\u00f3n de TEG 1 D\u00eda Verificar que un estudiante haya aprobado el n\u00famero de cr\u00e9ditos en asignaturas de trabajo especial de grado en una carrera 11. Desarrollar la verificaci\u00f3n del servicio comunitario 1 D\u00eda Verificar que un estudiante haya aprobado las asignaturas del servicio comunitario en una carrera 12. Desarrollar la verificaci\u00f3n de asignaturas excedentes 1 D\u00eda Verificar si un estudiante ha aprobado m\u00e1s asignaturas electivas y/o asignaturas complementarias que las que se requieren en una carrera 13. Desarrollar la verificaci\u00f3n de convalidaciones 1 D\u00eda Verificar si un estudiante ha aprobado una asignatura que haya sido convalidada por otra asignatura obligatoria en una carrera 14. Dise\u00f1ar una interfaz gr\u00e1fica para la cabecera 1 D\u00eda Dise\u00f1ar un prototipo de interfaz para la cabecera de la vista para verificar requisitos curriculares 47 15. Revisar los requisitos curriculares de la Licenciatura en Biolog\u00eda 1 D\u00eda Definir los requisitos curriculares del plan de estudio de Biolog\u00eda que se verificaran en el m\u00f3dulo web 16. Revisar los requisitos curriculares de la Licenciatura en Computaci\u00f3n 1 D\u00eda Definir los requisitos curriculares del plan de estudio de Computaci\u00f3n que se verificaran en el m\u00f3dulo web 17. Revisar los requisitos curriculares de la Licenciatura en F\u00edsica 1 D\u00eda Definir los requisitos curriculares del plan de estudio de F\u00edsica que se verificaran en el m\u00f3dulo web 18. Revisar los requisitos curriculares de la Licenciatura en Geoqu\u00edmica 1 D\u00eda Definir los requisitos curriculares del plan de estudio de Geoqu\u00edmica que se verificaran en el m\u00f3dulo web 19. Revisar los requisitos curriculares de la Licenciatura en Matem\u00e1tica 1 D\u00eda Definir los requisitos curriculares del plan de estudio de Matem\u00e1tica que se verificaran en el m\u00f3dulo web 20. Revisar los requisitos curriculares de la Licenciatura en Qu\u00edmica 1 D\u00eda Definir los requisitos curriculares del plan de estudio de Qu\u00edmica que se verificaran en el m\u00f3dulo web 21. Desarrollar un script de bases de datos 1 D\u00eda Crear un script de bases de datos que contenga las asignaturas aprobadas por un estudiante de Computaci\u00f3n 22. Refactorizar el c\u00f3digo para verificar requisitos curriculares 1 D\u00eda Revisar y refinar el algoritmo para verificar requisitos curriculares 23. Dise\u00f1ar una interfaz gr\u00e1fica para el resumen 1 D\u00eda Dise\u00f1ar un prototipo de interfaz para el resumen de la vista para verificar requisitos curriculares 24. Desarrollar el resumen de los datos acad\u00e9micos 1 D\u00eda Mostrar los datos acad\u00e9micos de un estudiante en una carrera 25. Desarrollar el resumen de la verificaci\u00f3n de los requisitos curriculares 1 D\u00eda Mostrar el resultado de la verificaci\u00f3n de los requisitos curriculares de un estudiante en una carrera 26. Dise\u00f1ar las estructuras de datos para verificar opciones profesionales 1 D\u00eda Dise\u00f1ar las tablas, atributos, restricciones y asociaciones necesarias para soportar la verificaci\u00f3n de opciones profesionales en el m\u00f3dulo web 48 27. Desarrollar el resumen de la verificaci\u00f3n de la opci\u00f3n profesional 1 D\u00eda Mostrar el resultado de la verificaci\u00f3n de la opci\u00f3n profesional de un estudiante en una carrera 28. Desarrollar el resumen general 1 D\u00eda Mostrar el resultado general de la verificaci\u00f3n de los requisitos curriculares y la verificaci\u00f3n de la opci\u00f3n profesional de un estudiante en una carrera 29. Refactorizar el c\u00f3digo para mostrar los res\u00famenes 1 D\u00eda Revisar y refinar el algoritmo para mostrar el resumen de la verificaci\u00f3n de requisitos curriculares y el resumen de la verificaci\u00f3n de opciones profesionales 30. Desarrollar la selecci\u00f3n de un estudiante y una carrera 1 D\u00eda Crear un formulario para seleccionar un estudiante y una carrera que haya cursado en la Facultad de Ciencias 31. Migrar el m\u00f3dulo web al sistema CONEST 3.1 2 D\u00edas Migrar las funcionalidades del m\u00f3dulo web desarrolladas en el sistema CONEST 3.0 al sistema CONEST 3.1 32. Dise\u00f1ar las estructuras de datos para distribuir requisitos curriculares 1 D\u00eda Dise\u00f1ar las tablas, atributos, restricciones y asociaciones necesarias para soportar la distribuci\u00f3n de requisitos curriculares en el m\u00f3dulo web 33. Desarrollar el listado de planes de estudio 1 D\u00eda Listar los planes de estudio 34. Desarrollar la creaci\u00f3n de planes de estudio 1 D\u00eda Crear un formulario para crear un plan de estudio 35. Desarrollar la edici\u00f3n de planes de estudio 1 D\u00eda Crear un formulario para editar un plan de estudio 36. Desarrollar la eliminaci\u00f3n de planes de estudio 1 D\u00eda Eliminar un plan de estudio 37. Desarrollar el listado de requisitos curriculares 1 D\u00eda Listar los requisitos curriculares de un plan de estudio 38. Desarrollar la creaci\u00f3n de requisitos curriculares 1 D\u00eda Crear un formulario para crear un requisito curricular en un plan de estudio 39. Desarrollar la edici\u00f3n de requisitos curriculares 1 D\u00eda Crear un formulario para editar un requisito curricular de un plan de estudio 49 40. Desarrollar la eliminaci\u00f3n de requisitos curriculares 1 D\u00eda Eliminar un requisito curricular de un plan de estudio 41. Desarrollar el listado de requisitos curriculares distribuidos por semestre 1 D\u00eda Listar los requisitos curriculares de un plan de estudio distribuidos por semestre 42. Desarrollar la distribuci\u00f3n de requisitos curriculares por semestre 1 D\u00eda Distribuir los requisitos curriculares de un plan de estudio por semestre 43. Desarrollar la redistribuci\u00f3n de requisitos curriculares por semestre 1 D\u00eda Redistribuir los requisitos curriculares de un plan de estudio en un semestre 44. Desarrollar la eliminaci\u00f3n de requisitos curriculares distribuidos por semestre 1 D\u00eda Eliminar un requisito curricular de un plan de estudio en un semestre 45. Desarrollar el listado de asignaturas 1 D\u00eda Listar las asignaturas 46. Desarrollar la creaci\u00f3n de asignaturas 1 D\u00eda Crear un formulario para crear una asignatura 47. Desarrollar la edici\u00f3n de asignaturas 1 D\u00eda Crear un formulario para editar una asignatura 48. Desarrollar la eliminaci\u00f3n de asignaturas 1 D\u00eda Eliminar una asignatura 49. Desarrollar el listado de asignaturas de un plan de estudio 1 D\u00eda Listar las asignaturas de un plan de estudio 50. Desarrollar la asignaci\u00f3n de asignaturas de un plan de estudio 1 D\u00eda Asignar una asignatura a un plan de estudio 51. Desarrollar la edici\u00f3n de asignaturas de un plan de estudio 1 D\u00eda Editar las asignaturas de un plan de estudio 52. Desarrollar la eliminaci\u00f3n de asignaturas de un plan de estudio 1 D\u00eda Eliminar una asignatura de un plan de estudio 53. Desarrollar un PDF para la vista para verificar requisitos curriculares 1 D\u00eda Crear un documento PDF que contenga la verificaci\u00f3n de los requisitos curriculares y el resumen de la verificaci\u00f3n de los requisitos curriculares de un estudiante en una carrera 50 54. Desarrollar las validaciones 2 D\u00edas Validar el formato de todos los campos de los formularios del m\u00f3dulo web 55. Desarrollar los mensajes de error 1 D\u00eda Crear los mensajes de error de todos los formularios del m\u00f3dulo web 56. Desarrollar los mensajes de confirmaci\u00f3n 1 D\u00eda Crear los mensajes de confirmaci\u00f3n de todos los formularios del m\u00f3dulo web 57. Desarrollar un script de bases de datos 1 D\u00eda Crear un script de bases de datos que contenga las tablas, atributos, restricciones y asociaciones para soportar todas las funcionalidades del m\u00f3dulo web 4.1.2 Dise\u00f1o El sistema CONEST cuenta con una interfaz gr\u00e1fica sencilla y organizada, que representa la informaci\u00f3n y las acciones disponibles a un usuario mediante iconos e indicadores visuales, y permite a los usuarios interactuar con el sistema a trav\u00e9s de la manipulaci\u00f3n directa de los elementos de la interfaz, para acceder las funcionalidades b\u00e1sicas del sistema y satisfacer los requerimientos respectivos. El m\u00f3dulo web para la gesti\u00f3n de planes de estudio se desarroll\u00f3 siguiendo la apariencia general y las t\u00e9cnicas de interacci\u00f3n del sistema CONEST para asegurar la consistencia, facilitar el aprendizaje y disminuir la carga cognitiva de los usuarios. El m\u00f3dulo web resuelve la problem\u00e1tica administrativa de los requerimientos solicitados por los trabajadores de la DCE. La Figura 14 muestra el dise\u00f1o general del sistema CONEST. Figura 14. Dise\u00f1o General del Sistema CONEST. 51 El m\u00f3dulo web para la gesti\u00f3n de planes de estudio en el sistema CONEST se desarroll\u00f3 utilizando las herramientas tecnol\u00f3gicas que fueron descritas en el cap\u00edtulo 2: \uf0b7 Lenguaje de programaci\u00f3n Ruby, versi\u00f3n 1.9.7. \uf0b7 Framework para aplicaciones web Rails, versi\u00f3n 3.1.0. \uf0b7 Gestor de paquetes RubyGems, versi\u00f3n 1.6.2. \uf0b7 Lenguaje de enmarcado Haml, versi\u00f3n 3.1.2. \uf0b7 Lenguaje de hojas de estilo Sass, versi\u00f3n 3.1.7. \uf0b7 Lenguaje de programaci\u00f3n CoffeScript, versi\u00f3n 3.1.0. \uf0b7 Librer\u00eda de JavaScript jQuery, versi\u00f3n 1.6.2. \uf0b7 Manejador de bases de datos relacional MySQL, versi\u00f3n 5.1. 4.1.3 Codificaci\u00f3n La mayor parte de la gesti\u00f3n de los planes de estudio de las licenciaturas de la Facultad de Ciencias en el m\u00f3dulo web se realiza a trav\u00e9s de listados y formularios. Los listados muestran los registros de la base de datos organizados en filas, y los usuarios pueden seleccionar un registro del listado para revisar sus datos detalladamente. Los formularios muestran los datos particulares de los registros, de los cuales se toman los datos ingresados por los usuarios, se realizan las validaciones correspondientes y se almacenan en la base de datos. El m\u00f3dulo web se desarroll\u00f3 siguiendo las gu\u00edas de Ruby on Rails para evitar malas pr\u00e1cticas de programaci\u00f3n y las vulnerabilidades de seguridad en el software. 4.1.4 Pruebas Las pruebas funcionales se generaron a partir de las tarjetas de historias. Se definieron los datos de entrada y los resultados esperados para cada prueba, y los tutores, que son usuarios finales del sistema, verificaron el correcto funcionamiento de los requerimientos que se estaban probando al final de cada iteraci\u00f3n. Las pruebas de aceptaci\u00f3n est\u00e1n dirigidas a los trabajadores de la DCE, los cuales realizaron una serie de tareas relacionadas con la gesti\u00f3n de los planes de estudio de las licenciaturas de la Facultad de Ciencias y la verificaci\u00f3n de los requisitos curriculares de los estudiantes regulares de pregrado. Adem\u00e1s, respondieron una encuesta para evaluar los requerimientos funcionales y los requerimientos no funcionales del m\u00f3dulo web. 52 4.2 Iteraci\u00f3n 1 En esta iteraci\u00f3n se describe el proceso de desarrollo de la gesti\u00f3n de los planes de estudio de las licenciaturas de la Facultad de Ciencias en el m\u00f3dulo web, siguiendo las pr\u00e1cticas del m\u00e9todo \u00e1gil XP; especificando la planificaci\u00f3n, el dise\u00f1o, la codificaci\u00f3n y las pruebas de las tarjetas de historias correspondientes. 4.2.1 Planificaci\u00f3n Descripci\u00f3n Dise\u00f1ar la interfaz gr\u00e1fica, las estructuras de datos y desarrollar un algoritmo para gestionar los planes de estudio Tarjetas de Historias 32. Dise\u00f1ar las estructuras de datos para distribuir requisitos curriculares 33. Desarrollar el listado de planes de estudio 34. Desarrollar la creaci\u00f3n de planes de estudio 35. Desarrollar la edici\u00f3n de planes de estudio 36. Desarrollar la eliminaci\u00f3n de planes de estudio 37. Desarrollar el listado de requisitos curriculares 38. Desarrollar la creaci\u00f3n de requisitos curriculares 39. Desarrollar la edici\u00f3n de requisitos curriculares 40. Desarrollar la eliminaci\u00f3n de requisitos curriculares 41. Desarrollar el listado de requisitos curriculares distribuidos por semestre 42. Desarrollar la distribuci\u00f3n de requisitos curriculares por semestre 43. Desarrollar la redistribuci\u00f3n de requisitos curriculares por semestre 44. Desarrollar la eliminaci\u00f3n de requisitos curriculares distribuidos por semestre 45. Desarrollar el listado de asignaturas 46. Desarrollar la creaci\u00f3n de asignaturas 47. Desarrollar la edici\u00f3n de asignaturas 48. Desarrollar la eliminaci\u00f3n de asignaturas 49. Desarrollar el listado de asignaturas de un plan de estudio 50. Desarrollar la asignaci\u00f3n de asignaturas de un plan de estudio 51. Desarrollar la edici\u00f3n de asignaturas de un plan de estudio 52. Desarrollar la eliminaci\u00f3n de asignaturas de un plan de estudio 54. Desarrollar las validaciones 55. Desarrollar los mensajes de error 56. Desarrollar los mensajes de confirmaci\u00f3n 31. Migrar el m\u00f3dulo web al sistema CONEST 3.1 Tiempo Estimado 27 D\u00edas 4.2.2 Dise\u00f1o Como se mencion\u00f3 anteriormente, la mayor parte de la gesti\u00f3n de los planes de estudio de las licenciaturas de la Facultad de Ciencias se realiza a trav\u00e9s de listados y formularios. 53 El listado de planes de estudio muestra todos los planes de estudio en la base de datos organizados en filas. En la primera fila se muestra la cabecera, las columnas de la primera fila muestran la denominaci\u00f3n de los atributos m\u00e1s relevantes de los planes de estudio. A partir de la segunda fila, se muestran los planes de estudio, las columnas de estas filas muestran los datos particulares de cada plan de estudio que correspondan con los atributos de la cabecera. La \u00faltima columna de las filas de los planes de estudio, muestran un icono para eliminar el plan de estudio correspondiente. Al colocar el cursor sobre el icono, se muestra una descripci\u00f3n emergente para informar al usuario sobre la funcionalidad del icono. Los usuarios deber\u00e1n hacer clic en el icono, y confirmar la acci\u00f3n para eliminar un plan de estudio de la base de datos. Los planes de estudio del listado se pueden ordenar alfab\u00e9ticamente de manera descendiente y ascendiente por atributo, mediante unos iconos que se encuentran en cada columna de la cabecera. Luego del listado, se muestra un enlace para crear un plan de estudio nuevo. La Figura 15 muestra el listado de planes de estudio. Figura 15. Listado de Planes de Estudio. Los usuarios pueden crear un plan de estudio nuevo por medio de un formulario. El formulario muestra todos los atributos de los planes de estudio mediante campos de entrada, los cuales deben ser llenados por los usuarios con la informaci\u00f3n solicitada, que se almacenar\u00e1 para su uso posterior o manipulaci\u00f3n. 54 Los usuarios tambi\u00e9n pueden seleccionar un plan de estudio del listado para revisar sus datos particulares tales como el nombre, la carrera a la que pertenece, el r\u00e9gimen de estudio y la fecha de aplicaci\u00f3n. Adem\u00e1s, se muestra toda la informaci\u00f3n relacionada con los planes de estudio, como los requisitos curriculares, la distribuci\u00f3n de los requisitos curriculares por semestre y las opciones profesionales, con la finalidad de acceder convenientemente y gestionar las distintas caracter\u00edsticas de los planes de estudio en un solo lugar. Se utiliz\u00f3 un men\u00fa de acordeones para organizar de manera estructurada las caracter\u00edsticas de los planes de estudio. Los usuarios pueden minimizar y maximizar los acordeones para mostrar su contenido cuando sea necesario. Esta t\u00e9cnica permite mostrar una gran cantidad de informaci\u00f3n en poco espacio. La Figura 16 muestra la p\u00e1gina web para editar planes de estudio. Figura 16. Editar Planes de Estudio. Se pueden gestionar los datos particulares de los requisitos curriculares de los planes de estudio tales como el tipo de asignatura, el n\u00famero m\u00ednimo de unidades de cr\u00e9dito y el n\u00famero m\u00ednimo de asignaturas que se deben aprobar. En la Facultad de Ciencias existen diferentes tipos de asignaturas tales como las obligatorias, obligatorias optativas, electivas, complementarias, laboratorios, pasant\u00edas, seminarios, TEG y servicio comunitario. Cada licenciatura exige aprobar un n\u00famero de asignaturas de diferentes tipos para obtener el t\u00edtulo de la carrera. Adem\u00e1s, dichas asignaturas est\u00e1n distribuidas en 10 55 semestres. Se cre\u00f3 la tabla distribucion_requisito_plan en la base de datos para poder distribuir los requisitos curriculares de un plan de estudio por semestre. La Figura 17 muestra la tabla distribucion_requisito_plan. Figura 17. Tabla distribucion_requisito_plan. El listado de requisitos curriculares distribuidos por semestre muestra el n\u00famero de asignaturas que se deben aprobar en cada semestre, de los requisitos curriculares de un plan de estudio organizados en filas. En la primera fila se muestra la cabecera, las columnas de la primera fila muestran los 10 semestres de la carrera. A partir de la segunda fila, se muestran los requisitos curriculares, las columnas de estas filas muestran el n\u00famero de asignaturas requeridas por cada requisito curricular que correspondan con el semestre de la cabecera. La \u00faltima columna de las filas de los requisitos curriculares de un plan de estudio, muestran el n\u00famero total de asignaturas distribuidas del n\u00famero total de asignaturas que se deben aprobar del requisito curricular correspondiente. La Figura 18 muestra el listado de requisitos curriculares distribuidos por semestre. Figura 18. Listado de Requisitos Curriculares Distribuidos por Semestre. 56 Se pueden gestionar los datos particulares de los requisitos curriculares de un plan de estudio distribuidos por semestre tales como el tipo de asignatura, el semestre, y el n\u00famero de asignaturas que se deben aprobar en dicho semestre. Tambi\u00e9n se pueden gestionar los datos particulares de los requisitos curriculares de las opciones profesionales registradas en un plan de estudio tales como el tipo de asignatura, el n\u00famero m\u00ednimo de unidades de cr\u00e9dito y el n\u00famero m\u00ednimo de asignaturas que se deben aprobar. La gesti\u00f3n de los requisitos curriculares, la distribuci\u00f3n de los requisitos curriculares por semestre y las opciones profesionales de los planes de estudio, se realiza de manera similar a la gesti\u00f3n de los planes de estudio. El listado de asignaturas muestra todas las asignaturas en la base de datos organizadas en filas. En la primera fila se muestra la cabecera, las columnas de la primera fila muestran la denominaci\u00f3n de los atributos m\u00e1s relevantes de las asignaturas. A partir de la segunda fila, se muestran las asignaturas, las columnas de estas filas muestran los datos particulares de cada asignatura que correspondan con los atributos de la cabecera. La \u00faltima columna de las filas de las asignaturas, muestran un icono para eliminar la asignatura correspondiente. Al colocar el cursor sobre el icono, se muestra una descripci\u00f3n emergente para informar al usuario sobre la funcionalidad del icono. Los usuarios deber\u00e1n hacer clic en el icono, y confirmar la acci\u00f3n para eliminar una asignatura de la base de datos. Las asignaturas del listado se pueden ordenar alfab\u00e9ticamente de manera descendiente y ascendiente por atributo, mediante unos iconos que se encuentran en cada columna de la cabecera. Luego del listado, se muestra un enlace para crear una asignatura nueva. Es importante resaltar que existen m\u00e1s de 1900 registros de asignaturas en la base de datos, por este motivo, se utiliz\u00f3 un sistema de paginaci\u00f3n para dividir los registros en conjuntos discretos. Esta t\u00e9cnica permite mostrar en el listado un n\u00famero limitado de asignaturas en varias p\u00e1ginas. Los usuarios pueden navegar a trav\u00e9s de las diferentes p\u00e1ginas para mostrar su contenido cuando sea necesario. Adem\u00e1s, los usuarios pueden buscar asignaturas por nombre por medio de una barra de b\u00fasqueda que se encuentra antes del listado. La Figura 19 muestra el listado de asignaturas. 57 Figura 19. Listado de Asignaturas. Los usuarios pueden crear una asignatura nueva por medio de un formulario. El formulario muestra todos los atributos de las asignaturas mediante campos de entrada, los cuales deben ser llenados por los usuarios con la informaci\u00f3n solicitada, que se almacenar\u00e1 para su uso posterior o manipulaci\u00f3n. Los usuarios tambi\u00e9n pueden seleccionar una asignatura del listado para revisar sus datos particulares tales como el c\u00f3digo, el departamento al que pertenece, el nombre y el nombre corto. Adem\u00e1s, se muestra toda la informaci\u00f3n relacionada con las asignaturas tales como los planes de estudio, las prelaciones, las convalidaciones y las opciones profesionales, con la finalidad de acceder convenientemente y gestionar las distintas caracter\u00edsticas de las asignaturas en un solo lugar. 58 Se utiliz\u00f3 un men\u00fa de acordeones para organizar de manera estructurada las caracter\u00edsticas de las asignaturas. Los usuarios pueden minimizar y maximizar los acordeones para mostrar su contenido cuando sea necesario. La Figura 20 muestra la p\u00e1gina web para editar asignaturas. Figura 20. Editar Asignaturas. Existen asignaturas que se pueden cursar bajo diferentes modalidades en la misma carrera. De este modo, la asignatura Aplicaciones con la Tecnolog\u00eda Internet se puede cursar como obligatoria optativa o como electiva en la carrera de Computaci\u00f3n, por ejemplo. Se crearon los campos tipo_materia_id y es_tipo_principal en la tabla materia_en_plan para poder registrar una asignatura varias veces en el mismo plan de estudio con tipos de asignaturas diferentes. Otro caso particular a tomar en cuenta es el de las asignaturas obligatorias y sus convalidaciones, el campo es_tipo_principal permite determinar cu\u00e1les son las asignaturas obligatorias de una carrera y cu\u00e1les son las asignaturas por las cuales son convalidadas. La Figura 21 muestra la tabla materia_en_plan. 59 Figura 21. Tabla materia_en_plan. Se pueden gestionar los datos particulares de las asignaturas registradas en un plan de estudio tales como la carrera y el plan de estudio a los que pertenece, el tipo de asignatura, el m\u00e9todo de calificaci\u00f3n, el n\u00famero de unidades de cr\u00e9dito que se obtienen por aprobarla, el n\u00famero de horas te\u00f3ricas, el n\u00famero de horas de pr\u00e1ctica y el n\u00famero de horas de laboratorios que reciben los estudiantes en clases semanales, el semestre, si requiere un aula y un horario, si puede ser reparada, si es de servicio, si se programa un examen final, el n\u00famero de unidades de cr\u00e9ditos aprobados requeridos para cursarla y si puede ser retirada. Tambi\u00e9n se pueden gestionar los datos particulares de las prelaciones de las asignaturas registradas en un plan de estudio tales como la carrera y el plan de estudio a los que pertenece, la asignatura que se debe aprobar con anterioridad para poder cursarla y si dicha asignatura se puede cursar en paralelo. Adem\u00e1s, se pueden gestionar los datos particulares de las convalidaciones de las asignaturas registradas en un plan de estudio tales como la carrera y el plan de estudio a los que pertenece, y la asignatura por la cual es convalidada. Tambi\u00e9n se pueden gestionar los datos particulares de las asignaturas registradas en las opciones profesionales de un plan de estudio tales como la carrera y el plan de estudio a los que pertenece, la opci\u00f3n profesional y el tipo de asignatura. 60 La gesti\u00f3n de los planes de estudio, las prelaciones, las convalidaciones y las opciones profesionales de las asignaturas registradas en un plan de estudio se realiza de manera similar a la gesti\u00f3n de las asignaturas. El m\u00f3dulo web mantiene a los usuarios informados sobre el estado de las operaciones que est\u00e1n realizando, a trav\u00e9s de retroalimentaci\u00f3n adecuada dentro de un plazo razonable de tiempo. Los formularios est\u00e1n dise\u00f1ados para comprobar que los campos obligatorios est\u00e1n llenos. Si los campos no lo est\u00e1n, se muestra una notificaci\u00f3n emergente que indica la obligatoriedad, en la esquina superior derecha de cada uno de ellos. Adem\u00e1s, no se puede enviar un formulario al servidor hasta que todos los campos obligatorios est\u00e9n llenos. La Figura 22 muestra la notificaci\u00f3n emergente para indicar los campos obligatorios de los formularios. Figura 22. Campos Obligatorios. Los di\u00e1logos muestran mensajes complementarios sobre la informaci\u00f3n llenada por los usuarios en los campos de entrada de un formulario. Se utilizan en su mayor\u00eda con las listas desplegables, en las cuales las opciones disponibles dependen de los valores de otros campos de entrada, para informar a los usuarios que no hay ninguna opci\u00f3n disponible para los valores seleccionados. La Figura 23 muestra el dialogo emergente utilizado junto con las listas desplegables en cascada. Figura 23. Di\u00e1logos Emergentes. Los mensajes de confirmaci\u00f3n y error est\u00e1n expresados en un lenguaje sencillo (sin c\u00f3digo), con palabras, frases y expresiones que indiquen con precisi\u00f3n el resultado de la operaci\u00f3n realizada, 61 as\u00ed como tambi\u00e9n pueden sugerir una soluci\u00f3n constructiva en caso de que sea necesario. Las Figuras 24 y 25 muestran los mensajes de confirmaci\u00f3n y error respectivamente. Figura 24. Mensajes de Confirmaci\u00f3n. Figura 25. Mensajes de Error. 4.2.3 Codificaci\u00f3n Los planes de estudio se representan en el m\u00f3dulo web para la gesti\u00f3n de planes de estudio en el sistema CONEST por medio del modelo plan.rb, en el cual se definen las propiedades generales de los planes de estudio tales como la clave primaria, las asociaciones entre modelos, las validaciones, las retrollamadas y los m\u00e9todos de la l\u00f3gica de negocio. La Figura 26 muestra el modelo plan.rb. Figura 26. Modelo plan.rb. 62 Para mostrar el listado de planes de estudio, primero se buscan todos los registros en la base de datos, en el m\u00e9todo index del controlador plan_estudio_controller.rb. Luego, en la vista index.html.haml, se determina si la variable donde se guard\u00f3 el resultado de la b\u00fasqueda de los planes de estudio contiene alg\u00fan registro o si est\u00e1 vac\u00eda. Si la variable no est\u00e1 vac\u00eda, se itera sobre el conjunto de resultados, y se muestra en una tabla los datos particulares as\u00ed como los enlaces para editar, activar y eliminar el plan de estudio correspondiente. Si la variable est\u00e1 vac\u00eda, se muestra un mensaje indicando que no se encontr\u00f3 ning\u00fan registro y un enlace para crear un plan de estudio nuevo. El estilo de la tabla y la funcionalidad para ordenar alfab\u00e9ticamente las columnas se obtienen a trav\u00e9s de la clase tablesorter. Adem\u00e1s, se enlaza la hoja de estilo plan_estudio.css.scss para incorporar las reglas de presentaci\u00f3n requeridas por la vista. La Figura 27 muestra la vista index.html.haml (Ver Figura 15). Figura 27. Vista plan_estudio/index.html.haml. Para crear un plan de estudio, primero se crea una instancia nueva, en el m\u00e9todo crear del controlador plan_estudio_controller.rb. Luego, en la vista crear.html.haml, se muestra un formulario en el cual se especifica la variable donde se guardar\u00e1 la informaci\u00f3n de los campos de entrada, la acci\u00f3n que se ejecutar\u00e1 cuando se envi\u00e9 el formulario al servidor, el identificador y la vista parcial de los campos de entrada. 63 Los atributos de los planes de estudio se muestran en la vista parcial _formulario.html.haml mediante campos de entrada. Los campos de entrada se llenan dependiendo de la acci\u00f3n que se est\u00e9 realizando, de este modo, los usuarios llenan todos los campos de entrada del formulario cuando est\u00e9n creando un plan de estudio nuevo, pero no podr\u00e1n modificar la informaci\u00f3n de los campos de entrada correspondientes a la clave primaria cuando est\u00e9n editando un plan de estudio existente. El estilo de las notificaciones emergentes y la funcionalidad para indicar los campos obligatorios de los formularios se obtienen a trav\u00e9s de la clase val\u00eddate[required]. La Figura 28 muestra la vista parcial _formulario.html.haml (Ver Figura 16). Figura 28. Vista Parcial plan_estudio/_formulario.html.haml. Para guardar un plan de estudio nuevo, primero se guarda la informaci\u00f3n de los campos de entrada del formulario, en el m\u00e9todo guardar del controlador plan_estudio_controller.rb. Luego, se intenta almacenar el registro en la base de datos. Si ninguna de las validaciones falla y la operaci\u00f3n de inserci\u00f3n en la base de datos se realiza exitosamente, se redirige a la vista index.html.haml y se muestra un mensaje de confirmaci\u00f3n. En caso contrario, se muestra un mensaje de error. La Figura 29 muestra el m\u00e9todo guardar. 64 Figura 29. M\u00e9todo plan_estudio/guardar. Los mensajes de confirmaci\u00f3n y error se muestran en la vista parcial _notificacion.html.haml. Los estilos de los mensajes se obtienen a trav\u00e9s de las clases ui-state-highlight.ui-corner-all y ui-state- error.ui-corner-all respectivamente. La Figura 30 muestra la vista parcial _notificacion.html.haml. Figura 30. Vista Parcial plan_estudio/_notificacion.html.haml. Para editar un plan de estudio, primero se busca el registro seleccionado del listado en la base de datos, en el m\u00e9todo editar del controlador plan_estudio_controller.rb. Luego, en la vista editar.html.haml, se muestra un formulario en el cual se especifica la variable donde se guardaron los datos particulares del plan de estudio que se mostrar\u00e1n en los campos de entrada, la acci\u00f3n que se ejecutar\u00e1 cuando se envi\u00e9 el formulario al servidor, el identificador y la vista parcial de los campos de entrada. Para actualizar un plan de estudio existente, primero se busca el registro en la base de datos, en el m\u00e9todo actualizar del controlador plan_estudio_controller.rb. Luego, se intenta almacenar los cambios en el registro en la base de datos. Si ninguna de las validaciones falla y la operaci\u00f3n de actualizaci\u00f3n en la base de datos se realiza exitosamente, se redirige a la vista index.html.haml y se muestra un mensaje de confirmaci\u00f3n. En caso contrario, se muestra un mensaje de error. La Figura 31 muestra un fragmento del m\u00e9todo actualizar. Figura 31. M\u00e9todo plan_estudio/actualizar. 65 Para eliminar un plan de estudio existente, primero se busca el registro en la base de datos, en el m\u00e9todo eliminar del controlador plan_estudio_controller.rb. Luego, se intenta borrar el registro de la base datos. Si ninguna de las retrollamadas falla y la operaci\u00f3n de eliminaci\u00f3n en la base de datos se realiza exitosamente, se muestra un mensaje de confirmaci\u00f3n. En caso contrario, se muestra un mensaje de error. La Figura 32 muestra el m\u00e9todo eliminar. Figura 32. M\u00e9todo plan_estudio/eliminar. En el m\u00e9todo editar del controlador plan_estudio_controller.rb, tambi\u00e9n se buscan todos los requisitos curriculares, el n\u00famero de asignaturas que los estudiantes deben aprobar en cada semestre de la carrera por requisito curricular y las opciones profesionales de un plan de estudio. La Figura 33 muestra un fragmento del m\u00e9todo editar. Figura 33. M\u00e9todo plan_estudio/editar. El algoritmo para buscar el n\u00famero de asignaturas obligatorias optativas, electivas, complementarias, laboratorios, pasant\u00edas, seminarios y TEG que se deben aprobar en cada semestre, es similar al algoritmo para buscar el n\u00famero de asignaturas obligatorias, que se muestra en la figura anterior. 66 En la vista editar.html.haml, se muestran todos los listados relacionados con los planes de estudio tales como el listado de requisitos curriculares, el listado de requisitos curriculares distribuidos por semestre y el listado de opciones profesionales, organizados en un men\u00fa de acordeones. La Figura 34 muestra un fragmento de la vista editar.html.haml (Ver Anexo I). Figura 34. Vista plan_estudio/editar.html.haml. El estilo de los acordeones y la funcionalidad para minimizar y maximizar su contenido se obtienen a trav\u00e9s de las clases acordeon y contenido-acordeon, las cuales se desarrollaron en el script plan_estudio.js.coffee. La Figura 35 muestra un fragmento del script plan_estudio.js.coffee. Figura 35. Script plan_estudio.js.coffee. 67 El listado de requisitos curriculares distribuidos por semestre, se muestra en la vista parcial _distribucion_requisitos_curriculares.html.haml. Se itera sobre el conjunto de requisitos curriculares del plan de estudio, y dentro de un ciclo, se determina la distribuci\u00f3n del n\u00famero de asignaturas del requisito curricular correspondiente en cada semestre de la carrera. Adem\u00e1s, se muestra el n\u00famero total de asignaturas distribuidas del n\u00famero m\u00ednimo de asignaturas que se deben aprobar en dicho requisito curricular. La Figura 36 muestra un fragmento de la vista parcial _distribucion_requisitos_curriculares.html.haml. Figura 36. Vista Parcial plan_estudio/_distribucion_requisitos_curriculares.html.haml. El algoritmo para determinar la distribuci\u00f3n de las asignaturas obligatorias optativas, electivas, complementarias, laboratorios, pasant\u00edas, seminarios y TEG en cada semestre, es similar al algoritmo para determinar la distribuci\u00f3n de las asignaturas obligatorias, que se muestra en la figura anterior. Los tipos de asignaturas se restringen cuando se crea un requisito curricular nuevo en un plan de estudio, para prevenir que se registre un tipo de asignatura varias veces en el mismo plan de estudio. La Figura 37 muestra el m\u00e9todo crear_requisito_curricular. 68 Figura 37. M\u00e9todo plan_estudio/crear_requisito_curricular. Luego, en la vista crear_requisito_curricular.html.haml, se determina si la variable donde se guard\u00f3 el resultado de la b\u00fasqueda de los tipos de asignaturas contiene alg\u00fan elemento o si est\u00e1 vac\u00eda. Si no est\u00e1 vac\u00eda, se muestra un formulario, en el cual se especifica la variable donde se guardar\u00e1 la informaci\u00f3n de los campos de entrada, la acci\u00f3n que se ejecutar\u00e1 cuando se envi\u00e9 el formulario al servidor, el identificador y la vista parcial de los campos de entrada. Si la variable est\u00e1 vac\u00eda, se muestra un mensaje indicando que no se encontr\u00f3 ning\u00fan elemento y un enlace para regresar a la vista editar.html.haml (Ver Anexo II). Antes de guardar un requisito curricular en la base de datos, se verifica que el n\u00famero m\u00ednimo de unidades de cr\u00e9dito y el n\u00famero m\u00ednimo de asignaturas del requisito curricular no sean iguales a cero simult\u00e1neamente. Antes de actualizar un requisito curricular en la base de datos, tambi\u00e9n se verifica que el n\u00famero m\u00ednimo de asignaturas que se deben aprobar no sea menor que el n\u00famero total de asignaturas distribuidas en los 10 semestres de la carrera. La Figura 38 muestra un fragmento del modelo requisito_graduacion_plan.rb. Figura 38. Modelo requisito_graduacion_plan.rb Adem\u00e1s, antes de guardar o actualizar la distribuci\u00f3n de un requisito curricular en la base de datos, se verifica que el n\u00famero total de asignaturas distribuidas en los 10 semestres de la carrera no sea mayor que el n\u00famero m\u00ednimo de asignaturas que se deben aprobar en el requisito curricular correspondiente, en el modelo distribucion_requisito_plan.rb. 69 Los algoritmos para listar, crear, guardar, editar, actualizar y eliminar los requisitos curriculares, la distribuci\u00f3n de los requisitos curriculares por semestre y las opciones profesionales de los planes de estudio, as\u00ed como los requisitos curriculares de las opciones profesionales son similares a los algoritmos para listar, crear, guardar, editar, actualizar y eliminar los planes de estudio. Las asignaturas se representan en el m\u00f3dulo web para la gesti\u00f3n de planes de estudio en el sistema CONEST por medio del modelo materia.rb, en el cual se definen las propiedades generales de las asignaturas tales como la clave primaria, las asociaciones entre modelos, las validaciones, las retrollamadas y los m\u00e9todos de la l\u00f3gica de negocio. Para mostrar el listado de asignaturas, primero se buscan todos los registros en la base de datos en conjuntos (de 50 asignaturas cada uno), en el m\u00e9todo index del controlador asignatura_controller.rb. Luego, en la vista index.html.haml, se determina si la variable donde se guard\u00f3 el resultado de la b\u00fasqueda de las asignaturas contiene alg\u00fan registro o si est\u00e1 vac\u00eda. Si la variable no est\u00e1 vac\u00eda, se itera sobre el primer conjunto de resultados, y se muestra en una tabla los datos particulares as\u00ed como los enlaces para editar y eliminar la asignatura correspondiente. Luego de la tabla, se muestran los enlaces para navegar a trav\u00e9s de los diferentes conjuntos de asignaturas. Si la variable est\u00e1 vac\u00eda, se muestra un mensaje indicando que no se encontr\u00f3 ning\u00fan registro y un enlace para crear una asignatura nueva. El estilo de los enlaces y la funcionalidad para mostrar el contenido de los diferentes conjuntos de asignaturas en el listado se obtienen a trav\u00e9s de la gema Kaminari. Para buscar una asignatura por nombre, primero se buscan todos los registros cuyo nombre contenga la cadena de caracteres que el usuario ingres\u00f3 en la barra de b\u00fasqueda, de manera as\u00edncrona en la base de datos a medida que vaya tecleando, en el m\u00e9todo autocomplete del controlador asignatura_controller.rb. Luego, se muestran las asignaturas en un listado emergente debajo de la barra de b\u00fasqueda. La Figura 39 muestra el m\u00e9todo autocomplete. Figura 39. M\u00e9todo asignatura/autocomplete. 70 El estilo del listado emergente y la funcionalidad para buscar as\u00edncronamente las asignaturas en la base de datos se obtienen a trav\u00e9s de la librer\u00eda jQuery, la cual se implement\u00f3 en el script asignatura.js.coffee. La Figura 40 muestra un fragmento del script asignatura.js.coffee. Figura 40. Script asignatura.js.coffee (Autocomplete). Posteriormente, en el m\u00e9todo buscar_asignatura del controlador asignatura_controller.rb, se determina si la asignatura que seleccion\u00f3 el usuario del listado emergente es v\u00e1lida o si es inv\u00e1lida. Si la asignatura es v\u00e1lida, se redirige a la vista editar.html.haml. Si la asignatura no es v\u00e1lida, se muestra un mensaje de error. En el m\u00e9todo editar del controlador asignatura_controller.rb, se busca la asignatura seleccionada del listado en la base de datos, as\u00ed como los planes de estudio y las opciones profesionales en los que est\u00e1 registrada, las prelaciones y las convalidaciones. En la vista editar.html.haml, se muestra un formulario en el cual se especifica la variable donde se guardaron los datos particulares de la asignatura que se mostrar\u00e1n en los campos de entrada, la acci\u00f3n que se ejecutar\u00e1 cuando se envi\u00e9 el formulario al servidor, el identificador y la vista parcial de los campos de entrada. Adem\u00e1s, se muestran los listados relacionados con las asignaturas tales como el listado de planes de estudio, el listado de prelaciones, el listado de convalidaciones y el listado de opciones profesionales, organizados en un men\u00fa de acordeones (Ver Anexo III). Las carreras se restringen cuando se crea una prelaci\u00f3n de una asignatura, para cerciorarse de que solo se puedan registrar prelaciones en los planes de estudio en los cuales est\u00e1 registrada la asignatura. La Figura 41 muestra el m\u00e9todo crear_prelacion. 71 Figura 41. M\u00e9todo asignatura/crear_prelacion. Luego, en la vista crear_prelacion.html.haml, se determina si la variable donde se guard\u00f3 el resultado de la b\u00fasqueda de las carreras contiene alg\u00fan elemento o si est\u00e1 vac\u00eda. Si no est\u00e1 vac\u00eda, se muestra un formulario, en el cual se especifica la variable donde se guardar\u00e1 la informaci\u00f3n de los campos de entrada, la acci\u00f3n que se ejecutar\u00e1 cuando se envi\u00e9 el formulario al servidor, el identificador y la vista parcial de los campos de entrada. Si la variable est\u00e1 vac\u00eda, se muestra un mensaje indicando que no se encontr\u00f3 ning\u00fan elemento y un enlace para regresar a la vista editar.html.haml. La lista desplegable de planes de estudio del formulario mencionado anteriormente se llena din\u00e1micamente dependiendo del valor de la lista desplegable de carreras. Se buscan todos los planes de estudio en los que est\u00e1 registrada la asignatura que pertenezcan a la carrera que el usuario selecciono en la lista desplegable, de manera as\u00edncrona en la base de datos cuando el usuario seleccione una opci\u00f3n, en el m\u00e9todo buscar_planes_estudio_asignatura del controlador asignatura_controller.rb. La Figura 42 muestra el m\u00e9todo buscar_planes_estudio_asignatura. Figura 42. M\u00e9todo asignatura/buscar_planes_estudio_asignatura. La funcionalidad para buscar as\u00edncronamente los planes de estudio en la base de datos se obtiene a trav\u00e9s de la librer\u00eda jQuery, la cual se implement\u00f3 en el script asignatura.js.coffee. Adem\u00e1s, se determina si la variable donde se guard\u00f3 el resultado de la b\u00fasqueda de los planes de estudio contiene alg\u00fan elemento o si est\u00e1 vac\u00eda. Si la variable no est\u00e1 vac\u00eda, se llenan las opciones de la lista desplegable con los planes de estudio. Si la variable est\u00e1 vac\u00eda, se muestra un mensaje indicando que no se encontr\u00f3 ning\u00fan plan de estudio para la carrera seleccionada en un dialogo emergente. La Figura 43 muestra otro fragmento del script asignatura.js.coffee. 72 Figura 43. Script asignatura.js.coffee (Listas Desplegables). Por \u00faltimo, los algoritmos para listar, crear, guardar, editar, actualizar y eliminar los planes de estudio, las prelaciones, las convalidaciones y las opciones profesionales de una asignatura es similar a los algoritmos para listar, crear, guardar, editar, actualizar y eliminar los planes de estudio. 4.2.4 Pruebas Las pruebas funcionales de esta iteraci\u00f3n se basan en la creaci\u00f3n, edici\u00f3n y eliminaci\u00f3n de planes de estudio, asignaturas y opciones profesionales, as\u00ed como la gesti\u00f3n de las caracter\u00edsticas particulares de cada uno de ellos. Caso de Prueba Resultado Esperado Resultado Obtenido Crear un plan de estudio Crear un plan de estudio nuevo Se guard\u00f3 la informaci\u00f3n b\u00e1sica del plan de estudio y se mostr\u00f3 un mensaje de confirmaci\u00f3n Editar un plan de estudio Modificar un plan de estudio existente Se actualiz\u00f3 la informaci\u00f3n b\u00e1sica del plan de estudio y se mostr\u00f3 un mensaje de confirmaci\u00f3n Eliminar un plan de estudio Eliminar un plan de estudio existente Se borr\u00f3 la informaci\u00f3n b\u00e1sica del plan de estudio y se mostr\u00f3 un mensaje de confirmaci\u00f3n Activar un plan de estudio Registrar el plan de estudio activo de la carrera Se registr\u00f3 el plan de estudio como el plan activo de la carrera y se mostr\u00f3 un mensaje de confirmaci\u00f3n Intentar eliminar un Tratar de eliminar un plan Se cancel\u00f3 la acci\u00f3n correctamente y se 73 plan de estudio activo de estudio activo mostr\u00f3 un mensaje de error Crear un requisito curricular Crear un requisito curricular nuevo en un plan de estudio Se guard\u00f3 el requisito curricular en el plan de estudio y se mostr\u00f3 un mensaje de confirmaci\u00f3n Editar un requisito curricular Modificar un requisito curricular de un plan de estudio Se actualiz\u00f3 el requisito curricular del plan de estudio y se mostr\u00f3 un mensaje de confirmaci\u00f3n Eliminar un requisito curricular Eliminar un requisito curricular de un plan de estudio Se borr\u00f3 el requisito curricular del plan de estudio y se mostr\u00f3 un mensaje de confirmaci\u00f3n Distribuir un requisito curricular Distribuir un requisito curricular de un plan de estudio por semestres Se guard\u00f3 el n\u00famero de asignaturas en cada semestre de un requisito curricular y se mostr\u00f3 un mensaje de confirmaci\u00f3n Redistribuir un requisito curricular Redistribuir un requisito curricular de un plan de estudio por semestres Se actualiz\u00f3 el n\u00famero de asignaturas en cada semestre de un requisito curricular y se mostr\u00f3 un mensaje de confirmaci\u00f3n Intentar distribuir un n\u00famero mayor de asignaturas Tratar de distribuir un n\u00famero de asignaturas mayor que el requerido por un requisito curricular Se cancel\u00f3 la acci\u00f3n correctamente y se mostr\u00f3 un mensaje de error Crear una opci\u00f3n profesional Crear una opci\u00f3n profesional nueva Se guard\u00f3 la informaci\u00f3n b\u00e1sica de la opci\u00f3n profesional y se mostr\u00f3 un mensaje de confirmaci\u00f3n Editar una opci\u00f3n profesional Modificar una opci\u00f3n profesional existente Se actualiz\u00f3 la informaci\u00f3n b\u00e1sica de la opci\u00f3n profesional y se mostr\u00f3 un mensaje de confirmaci\u00f3n Eliminar una opci\u00f3n profesional Eliminar una opci\u00f3n profesional existente Se borr\u00f3 la informaci\u00f3n b\u00e1sica de la opci\u00f3n profesional y se mostr\u00f3 un mensaje de confirmaci\u00f3n Registrar una opci\u00f3n profesional Registrar una opci\u00f3n profesional en un plan de estudio Se registr\u00f3 la opci\u00f3n profesional en el plan de estudio y se mostr\u00f3 un mensaje de confirmaci\u00f3n Editar un registro de una opci\u00f3n profesional Modificar una opci\u00f3n profesional registrada en un plan de estudio Se actualiz\u00f3 la opci\u00f3n profesional registrada en el plan de estudio y se mostr\u00f3 un mensaje de confirmaci\u00f3n Eliminar un registro de una opci\u00f3n profesional Eliminar una opci\u00f3n profesional registrada en un plan de estudio Se borr\u00f3 la opci\u00f3n profesional registrada en el plan de estudio y se mostr\u00f3 un mensaje de confirmaci\u00f3n Crear un requisito curricular en una opci\u00f3n profesional Crear un requisito curricular nuevo en una opci\u00f3n profesional Se guard\u00f3 el requisito curricular en la opci\u00f3n profesional y se mostr\u00f3 un mensaje de confirmaci\u00f3n Editar un requisito curricular de una opci\u00f3n profesional Modificar un requisito curricular de una opci\u00f3n profesional Se actualiz\u00f3 el requisito curricular de la opci\u00f3n profesional y se mostr\u00f3 un mensaje de confirmaci\u00f3n Eliminar un requisito curricular de una opci\u00f3n profesional Eliminar un requisito curricular de una opci\u00f3n profesional Se borr\u00f3 el requisito curricular de la opci\u00f3n profesional y se mostr\u00f3 un mensaje de confirmaci\u00f3n 74 Crear una asignatura Crear una asignatura nueva Se guard\u00f3 la informaci\u00f3n b\u00e1sica de la asignatura y se mostr\u00f3 un mensaje de confirmaci\u00f3n Editar una asignatura Modificar una asignatura existente Se actualiz\u00f3 la informaci\u00f3n b\u00e1sica de la asignatura y se mostr\u00f3 un mensaje de confirmaci\u00f3n Eliminar una asignatura Eliminar una asignatura existente Se borr\u00f3 la informaci\u00f3n b\u00e1sica de la asignatura y se mostr\u00f3 un mensaje de confirmaci\u00f3n Registrar una asignatura Registrar una asignatura en un plan de estudio Se registro la asignatura en el plan de estudio y se mostro un mensaje de confirmaci\u00f3n Editar un registro de una asignatura Modificar una asignatura registrada en un plan de estudio Se actualiz\u00f3 la asignatura registrada en el plan de estudio y se mostro un mensaje de confirmaci\u00f3n Eliminar un registro de una asignatura Eliminar una asignatura registrada en un plan de estudio Se borr\u00f3 la asignatura registrada en el plan de estudio y se mostro un mensaje de confirmaci\u00f3n Activar el tipo principal de una asignatura Registrar el tipo principal de una asignatura en un plan de estudio Se registr\u00f3 cual es el tipo principal de una asignatura registrada varias veces en el mismo plan de estudio y se mostr\u00f3 un mensaje de confirmaci\u00f3n Intentar eliminar el tipo principal de una asignatura Tratar de eliminar el registro principal de una asignatura en un plan de estudio Se cancel\u00f3 la acci\u00f3n correctamente y se mostro un mensaje de error Crear una prelaci\u00f3n Crear una prelaci\u00f3n nueva de una asignatura registrada en un plan de estudio Se guard\u00f3 la prelaci\u00f3n de la asignatura registrada en el plan de estudio y se mostro un mensaje de confirmaci\u00f3n Editar una prelaci\u00f3n Modificar una prelaci\u00f3n de una asignatura registrada en un plan de estudio Se actualiz\u00f3 la prelaci\u00f3n de la asignatura registrada en el plan de estudio y se mostro un mensaje de confirmaci\u00f3n Eliminar una prelaci\u00f3n Eliminar una prelaci\u00f3n de una asignatura registrada en un plan de estudio Se borr\u00f3 la prelaci\u00f3n de la asignatura registrada en el plan de estudio y se mostro un mensaje de confirmaci\u00f3n Crear una convalidaci\u00f3n Crear una convalidaci\u00f3n nueva de una asignatura registrada en un plan de estudio Se guard\u00f3 la convalidaci\u00f3n de la asignatura registrada en el plan de estudio y se mostro un mensaje de confirmaci\u00f3n Editar una convalidaci\u00f3n Modificar una convalidaci\u00f3n de una asignatura registrada en un plan de estudio Se actualiz\u00f3 la convalidaci\u00f3n de la asignatura registrada en el plan de estudio y se mostro un mensaje de confirmaci\u00f3n Eliminar una convalidaci\u00f3n Eliminar una convalidaci\u00f3n de una asignatura registrada en un plan de Se borr\u00f3 la convalidaci\u00f3n de la asignatura registrada en el plan de estudio y se mostro un mensaje de 75 estudio confirmaci\u00f3n Registrar una asignatura en una opci\u00f3n profesional Registrar una asignatura en una opci\u00f3n profesional de un plan de estudio Se registr\u00f3 la asignatura en la opci\u00f3n profesional y se mostro un mensaje de confirmaci\u00f3n Editar un registro de una asignatura en una opci\u00f3n profesional Modificar una asignatura registrada en una opci\u00f3n profesional de un plan de estudio Se actualiz\u00f3 la asignatura registrada en la opci\u00f3n profesional y se mostro un mensaje de confirmaci\u00f3n Eliminar un registro de una asignatura en una opci\u00f3n profesional Eliminar una asignatura registrada en una opci\u00f3n profesional de un plan de estudio Se borr\u00f3 la asignatura registrada en la opci\u00f3n profesional y se mostro un mensaje de confirmaci\u00f3n 76 4.3 Iteraci\u00f3n 2 En esta iteraci\u00f3n se describe el proceso de desarrollo de la verificaci\u00f3n de los requisitos curriculares de los estudiantes regulares de pregrado en el m\u00f3dulo web, siguiendo las pr\u00e1cticas del m\u00e9todo \u00e1gil XP; especificando la planificaci\u00f3n, el dise\u00f1o, la codificaci\u00f3n y las pruebas de las tarjetas de historias correspondientes. 4.3.1 Planificaci\u00f3n Descripci\u00f3n Dise\u00f1ar la interfaz gr\u00e1fica, las estructuras de datos y desarrollar un algoritmo para verificar los requisitos curriculares de los estudiantes Tarjetas de Historias 1. Dise\u00f1ar una interfaz gr\u00e1fica para verificar requisitos curriculares 2. Dise\u00f1ar las estructuras de datos para verificar requisitos curriculares 3. Desarrollar la verificaci\u00f3n de asignaturas obligatorias 4. Desarrollar la verificaci\u00f3n de asignaturas obligatorias optativas 5. Desarrollar la verificaci\u00f3n de asignaturas electivas 6. Desarrollar la verificaci\u00f3n de asignaturas complementarias 7. Desarrollar la verificaci\u00f3n de laboratorios 8. Desarrollar la verificaci\u00f3n de pasant\u00edas 9. Desarrollar la verificaci\u00f3n de seminarios 10. Desarrollar la verificaci\u00f3n de TEG 11. Desarrollar la verificaci\u00f3n del servicio comunitario 12. Desarrollar la verificaci\u00f3n de asignaturas excedentes 13. Desarrollar la verificaci\u00f3n de convalidaciones 14. Dise\u00f1ar una interfaz gr\u00e1fica para la cabecera 15. Revisar los requisitos curriculares de la Licenciatura en Biolog\u00eda 16. Revisar los requisitos curriculares de la Licenciatura en Computaci\u00f3n 17. Revisar los requisitos curriculares de la Licenciatura en F\u00edsica 18. Revisar los requisitos curriculares de la Licenciatura en Geoqu\u00edmica 19. Revisar los requisitos curriculares de la Licenciatura en Matem\u00e1tica 20. Revisar los requisitos curriculares de la Licenciatura en Qu\u00edmica 21. Desarrollar un script de bases de datos 22. Refactorizar el c\u00f3digo para verificar requisitos curriculares 23. Dise\u00f1ar una interfaz gr\u00e1fica para el resumen 24. Desarrollar el resumen de los datos acad\u00e9micos 25. Desarrollar el resumen de la verificaci\u00f3n de los requisitos curriculares 26. Dise\u00f1ar las estructuras de datos para verificar opciones profesionales 27. Desarrollar el resumen de la verificaci\u00f3n de la opci\u00f3n profesional 28. Desarrollar el resumen general 29. Refactorizar el c\u00f3digo para mostrar los res\u00famenes 30. Desarrollar la selecci\u00f3n de un estudiante y una carrera 53. Desarrollar un PDF para la vista para verificar requisitos curriculares 57. Desarrollar un script de bases de datos Tiempo Estimado 33 D\u00edas 77 4.3.2 Dise\u00f1o Los trabajadores del Departamento de Grado de la DCE verifican los requisitos curriculares de los estudiantes regulares de pregrado utilizando distintos documentos impresos, entre los cuales se destacan los planes de estudio de las licenciaturas de la Facultad de Ciencias y los kardex de los estudiantes. La p\u00e1gina web para verificar requisitos curriculares muestra todas las asignaturas (tanto aprobadas como no aprobadas por un estudiante) de una carrera organizadas en filas. En la primera fila se muestra la cabecera, las columnas de la primera fila muestran la denominaci\u00f3n de los atributos m\u00e1s relevantes del kardex. A partir de la segunda fila, se muestran las asignaturas, las columnas de estas filas muestran los datos particulares de cada asignatura que correspondan con los atributos de la cabecera. Las asignaturas est\u00e1n agrupadas por semestre, de manera similar al plan de estudio de la licenciatura correspondiente. La Figura 44 muestra un fragmento de la p\u00e1gina web para verificar requisitos curriculares. Figura 44. Verificaci\u00f3n de Requisitos Curriculares. 78 Se utilizaron diferentes colores y grados de opacidad para diferenciar las asignaturas aprobadas y las asignaturas que a\u00fan no han sido aprobadas por un estudiante en una carrera. La Figura 45 muestra el efecto utilizado para diferenciar las asignaturas aprobadas y las no aprobadas. Figura 45. Asignaturas Aprobadas/Asignaturas No Aprobadas. Una asignatura se puede registrar varias veces en el mismo plan de estudio con tipos de asignaturas diferentes. Se cre\u00f3 el campo tipo_materia_id en la tabla historial_academico para poder determinar los tipos de las asignaturas aprobadas por un estudiante en una carrera. La Figura 46 muestra la tabla historial_academico. Figura 46. Tabla historial_academico. Las asignaturas del servicio comunitario se muestran luego de las asignaturas de un plan de estudio, as\u00ed como el excedente de asignaturas electivas y/o complementarias, en caso de que un estudiante haya aprobado m\u00e1s asignaturas que las requeridas en una carrera. El resumen de la verificaci\u00f3n de los requisitos curriculares muestra el n\u00famero de asignaturas que se deben aprobar (por cada requisito curricular) en una carrera organizadas en filas. En la primera fila se muestra la cabecera, las columnas de la primera fila muestran la denominaci\u00f3n de los atributos que se verificaron de los requisitos curriculares. A partir de la segunda fila, se muestran los tipos de asignaturas de los requisitos curriculares, las columnas de estas filas muestran el resultado de la verificaci\u00f3n de cada requisito curricular que corresponda con los atributos de la 79 cabecera. Se utilizaron iconos visuales para se\u00f1alar los requisitos curriculares que un estudiante no satisface. La Figura 47 muestra el resumen de la verificaci\u00f3n de los requisitos curriculares. Figura 47. Resultado de la Verificaci\u00f3n de Requisitos Curriculares. Existen opciones profesionales que se pueden obtener en diferentes planes de estudio. De este modo, la opci\u00f3n profesional Aplicaciones con la Tecnolog\u00eda Internet se puede obtener en los planes de estudio de Computaci\u00f3n de los a\u00f1os 2000 y 2004, por ejemplo. Se crearon las tablas opcion, opcion_plan y requisito_graduacion_opcion_plan en la base de datos para poder registrar una opci\u00f3n profesional en varios planes de estudio, as\u00ed como sus requisitos curriculares. La Figura 48 muestra las tablas opcion, opcion_plan y requisito_graduacion_opcion_plan. Figura 48. Tablas opcion, opcion_plan y requisito_graduacion_opcion_plan. El resumen de la verificaci\u00f3n de la opci\u00f3n profesional muestra todas las asignaturas (tanto aprobadas como no aprobadas por un estudiante) de una opci\u00f3n profesional organizadas en filas. En la primera fila se muestra la cabecera, las columnas de la primera fila muestran la denominaci\u00f3n de los atributos de las asignaturas. A partir de la segunda fila, se muestran las asignaturas, las columnas de estas filas muestran los datos particulares de cada asignatura que correspondan con los atributos de la cabecera. La Figura 49 muestra el resumen de la verificaci\u00f3n de la opci\u00f3n profesional. 80 Figura 49. Verificaci\u00f3n de la Opci\u00f3n Profesional. Por \u00faltimo, se muestra el resultado general de la verificaci\u00f3n de los requisitos curriculares de un estudiante en una carrera, en el cual se muestra un mensaje indicando si satisface o no satisface todos los requisitos curriculares necesarios para obtener un t\u00edtulo universitario. 4.3.3 Codificaci\u00f3n Para verificar los requisitos curriculares de un estudiante en una carrera, primero se busca el plan de estudio activo de la carrera, las asignaturas obligatorias, el n\u00famero m\u00ednimo de unidades de cr\u00e9dito y el n\u00famero m\u00ednimo de asignaturas obligatorias optativas, electivas, complementarias, laboratorios, pasant\u00edas, seminarios, TEG y servicio comunitario que se deben aprobar, las convalidaciones y las asignaturas que ha aprobado en la base de datos, en el m\u00e9todo verificar_requisitos del controlador plan_estudio_controller.rb. La Figura 50 muestra un fragmento del m\u00e9todo verificar_requisitos. 81 Figura 50. M\u00e9todo plan_estudio/verificar_requisitos (Requisitos Curriculares). 82 El algoritmo para buscar el n\u00famero de asignaturas electivas, complementarias, laboratorios, pasant\u00edas, seminarios, TEG y servicio comunitario que se deben aprobar en una carrera, es similar al algoritmo para buscar el n\u00famero de asignaturas obligatorias optativas que se deben aprobar, que se muestra en la figura anterior. Adem\u00e1s, el algoritmo para buscar las asignaturas obligatorias optativas, electivas, complementarias, laboratorios, pasant\u00edas, seminarios, TEG y servicio comunitario aprobadas por un estudiante en una carrera, es similar al algoritmo para buscar las asignaturas obligatorias aprobadas por un estudiante, que se muestra en la figura anterior. Es importante resaltar que las asignaturas de tipo m\u00e9todo y PCI son consideradas como asignaturas electivas y complementarias respectivamente, en caso de que un estudiante haya aprobado alguna asignatura de estos tipos en una carrera. Luego, en la vista parcial _verificar_requisitos_academicos.html.erb, se verifica dentro de un ciclo si un estudiante ha aprobado todas las asignaturas obligatorias (o las asignaturas por las cuales han sido convalidadas) y el n\u00famero de asignaturas obligatorias optativas, electivas, complementarias, laboratorios, pasant\u00edas, seminarios y TEG requeridas en cada semestre de una carrera. La Figura 51 muestra un fragmento de la vista parcial _verificar_requisitos_academicos.html.erb (Ver Figura 44). 83 84 Figura 51. Vista Parcial _verificar_requisitos_academicos.html.erb. El algoritmo para verificar si un estudiante ha aprobado el n\u00famero de asignaturas electivas, complementarias, laboratorios, pasant\u00edas, seminarios y TEG en cada semestre de una carrera, es similar al algoritmo para verificar si ha aprobado el n\u00famero de asignaturas obligatorias optativas, que se muestra en la figura anterior. En la vista parcial _verificar_servicio_comunitario.html.erb, se verifica si un estudiante ha aprobado mas asignaturas electivas y/o complementarias que las requeridas en una carrera, as\u00ed como se verifica si ha aprobado todas las asignaturas del servicio comunitario. En el m\u00e9todo verificar_requisitos del controlador plan_estudio_controller.rb, tambi\u00e9n se determina la opci\u00f3n profesional de un estudiante en una carrera, en funci\u00f3n de los seminarios y TEG que haya aprobado o inscrito en el semestre en curso. Adem\u00e1s, se buscan todos los requisitos curriculares de la opci\u00f3n profesional en la base de datos. La Figura 52 muestra otro fragmento del m\u00e9todo verificar_requisitos. 85 Figura 52. M\u00e9todo plan_estudio/verificar_requisitos (Opci\u00f3n Profesional). El algoritmo para buscar los TEG que se deben aprobar en una opci\u00f3n profesional, es similar al algoritmo para buscar los seminarios que se deben aprobar, que se muestra en la figura anterior. En la vista parcial _resumen_opcion_profesional.html.erb, se verifica dentro de un ciclo si un estudiante ha aprobado todas las asignaturas electivas, seminarios y TEG que se deben aprobar en una opci\u00f3n profesional. La Figura 53 muestra un fragmento de la vista parcial _resumen_opcion_profesional.html.erb (Ver Figura 49). 86 Figura 53. Vista Parcial _resumen_opcion_profesional.html.erb. Por \u00faltimo, en la vista _revision_requisitos_notas.erb, se verifica si un estudiante satisface todos los requisitos curriculares para obtener el t\u00edtulo de una carrera, y se muestran cada uno de los requisitos curriculares que no satisface en caso contrario. 87 4.3.4 Pruebas Las pruebas funcionales de esta iteraci\u00f3n se basan en la verificaci\u00f3n de los requisitos curriculares de los estudiantes regulares de pregrado de la Facultad de Ciencias. Caso de Prueba Resultado Esperado Resultado Obtenido Buscar un estudiante con una carrera Buscar un estudiante inscrito en una sola carrera Se busc\u00f3 la carrera en la cual est\u00e1 inscrito el estudiante para verificar sus requisitos curriculares Buscar un estudiante con m\u00e1s de una carrera Buscar un estudiante inscrito en m\u00e1s de una carrera Se buscaron las carreras en las cuales est\u00e1 inscrito el estudiante y se mostraron en un dialogo emergente Buscar un estudiante sin carrera Buscar un estudiante que no est\u00e9 inscrito en ninguna carrera Se mostro un mensaje de error en un dialogo emergente Verificar los requisitos de un estudiante de primer semestre Verificar los requisitos curriculares de un estudiante del primer semestre de una carrera Se verificaron los requisitos curriculares del estudiante y se mostr\u00f3 el resumen curricular Verificar los requisitos de un estudiante de Biolog\u00eda Verificar los requisitos curriculares de un estudiante que este terminando la carrera de Biolog\u00eda Se verificaron los requisitos curriculares del estudiante y se mostr\u00f3 el resumen curricular Verificar los requisitos de un estudiante de Computaci\u00f3n Verificar los requisitos curriculares de un estudiante que este terminando la carrera de Computaci\u00f3n Se verificaron los requisitos curriculares del estudiante y se mostr\u00f3 el resumen curricular Verificar los requisitos de un estudiante de F\u00edsica Verificar los requisitos curriculares de un estudiante que este terminando la carrera de F\u00edsica Se verificaron los requisitos curriculares del estudiante y se mostr\u00f3 el resumen curricular Verificar los requisitos de un estudiante de Geoqu\u00edmica Verificar los requisitos curriculares de un estudiante que este terminando la carrera de Geoqu\u00edmica Se verificaron los requisitos curriculares del estudiante y se mostr\u00f3 el resumen curricular Verificar los requisitos de un estudiante de Matem\u00e1tica Verificar los requisitos curriculares de un estudiante que este terminando la carrera de Matem\u00e1tica Se verificaron los requisitos curriculares del estudiante y se mostr\u00f3 el resumen curricular Verificar los requisitos de un estudiante de Qu\u00edmica Verificar los requisitos curriculares de un estudiante que este terminando la carrera de Qu\u00edmica Se verificaron los requisitos curriculares del estudiante y se mostr\u00f3 el resumen curricular Verificar los requisitos de un estudiante con convalidaciones Verificar los requisitos curriculares de un estudiante con asignaturas convalidadas en una carrera Se verificaron los requisitos curriculares del estudiante y se mostr\u00f3 el resumen curricular 88 Verificar los requisitos de un estudiante con excedente de asignaturas Verificar los requisitos curriculares de un estudiante que haya aprobado m\u00e1s asignaturas que las requeridas en una carrera Se verificaron los requisitos curriculares del estudiante y se mostr\u00f3 el resumen curricular Verificar los requisitos de un estudiante sin opci\u00f3n Verificar los requisitos curriculares de un estudiante sin opci\u00f3n profesional en una carrera Se verificaron los requisitos curriculares del estudiante y se mostr\u00f3 el resumen curricular Verificar los requisitos de un estudiante con opci\u00f3n Verificar los requisitos curriculares de un estudiante con opci\u00f3n profesional en una carrera Se verificaron los requisitos curriculares del estudiante y se mostr\u00f3 el resumen curricular En esta iteraci\u00f3n tambi\u00e9n se realizaron las pruebas de aceptaci\u00f3n (con cuatro trabajadores de la DCE), las cuales se basan en la gesti\u00f3n de los planes de estudio de las licenciaturas de la Facultad de Ciencias y la verificaci\u00f3n de los requisitos curriculares de los estudiantes regulares de pregrado. Las principales funcionalidades del m\u00f3dulo web se dividieron en tres grupos diferentes, con el fin de permitir que los trabajadores que participaran en las pruebas, probaran las funcionalidades espec\u00edficas del m\u00f3dulo web que correspondieran con las labores de su trabajo. En las pruebas de aceptaci\u00f3n los trabajadores de la DCE realizaron las siguientes tareas: Planes de Estudio 1. Crear plan de estudio con datos introducidos por el usuario 2. Activar plan de estudio 3. Intentar eliminar plan de estudio activo 4. Crear requisito curricular con datos introducidos por el usuario 5. Distribuir requisito curricular con datos introducidos por el usuario 6. Editar distribuci\u00f3n requisito curricular con datos introducidos por el usuario 7. Intentar editar distribuci\u00f3n requisito curricular con total asignaturas distribuidas > m\u00ednimo asignaturas 8. Intentar editar requisito curricular con m\u00ednimo asignaturas < total asignaturas distribuidas Asignaturas 1. Crear asignatura con datos introducidos por el usuario 2. Registrar asignatura en plan de estudio con datos introducidos por el usuario 3. Activar asignatura principal 4. Intentar eliminar asignatura principal 5. Crear convalidaci\u00f3n con datos introducidos por el usuario 6. Buscar asignatura 89 7. Registrar asignatura en opci\u00f3n profesional con datos introducidos por el usuario Opciones Profesionales/Verificaci\u00f3n Requisitos Curriculares 1. Crear opci\u00f3n profesional con datos introducidos por el usuario 2. Registrar opci\u00f3n profesional en plan de estudio con datos introducidos por el usuario 3. Crear requisito curricular opci\u00f3n profesional con datos introducidos por el usuario 4. Intentar eliminar profesional con registros historial acad\u00e9mico 5. Buscar estudiante predefinido 6. Validar requisitos curriculares de estudiante predefinido Luego de realizar las pruebas de aceptaci\u00f3n, los trabajadores de la DCE respondieron una encuesta para evaluar los requerimientos funcionales y los requerimientos no funcionales del m\u00f3dulo web. A continuaci\u00f3n se presenta el resultado de la encuesta realizada por los trabajadores de la DCE: 100% 100% 75% 100% 100% 0% 0% 0% 0% 0% 0% 0% 25% 0% 0% Accesibilidad Usabilidad Tolerancia a Fallos Interfaz de Usuario Agrupaci\u00f3n de la Informaci\u00f3n Bueno Moderado Malo 90 Conclusiones El objetivo general de este Trabajo Especial de Grado es desarrollar un m\u00f3dulo web basado en tecnolog\u00edas web, que permita gestionar los planes de estudio de las licenciaturas de la Facultad de Ciencias, as\u00ed como automatizar el trabajo de verificaci\u00f3n de requisitos curriculares del proceso de graduaci\u00f3n realizado por la Divisi\u00f3n de Control de Estudios (DCE). Se facilitaron las labores de los trabajadores del Departamento de Grado de la DCE mediante la automatizaci\u00f3n de la verificaci\u00f3n de los requisitos curriculares de los estudiantes regulares de pregrado de la Facultad de Ciencias, delegando las labores mon\u00f3tonas al m\u00f3dulo web, permitiendo que los trabajadores se dediquen a labores m\u00e1s importantes. Adem\u00e1s, los estudiantes de la Facultad de Ciencias pueden verificar los requisitos curriculares de su carrera y generar los documentos PDF relacionados, desde cualquier computadora que disponga de una conexi\u00f3n a internet. El sistema CONEST no contaba con una aplicaci\u00f3n que permitiera gestionar los planes de estudio de las distintas licenciaturas que ofrece la Facultad de Ciencias, este trabajo se realizaba manipulando directamente la base de datos del sistema CONEST. Esto representa un mayor esfuerzo humano, y requiere de una persona con conocimientos tecnol\u00f3gicos para realizar el trabajo sin comprometer la integridad de la base de datos. En este sentido, se simplific\u00f3 y se redujo la carga de trabajo de los administradores de la DCE mediante la automatizaci\u00f3n de la gesti\u00f3n de los planes de estudio de las licenciaturas que ofrece la Facultad de Ciencias, estos se estudiaron para determinar las caracter\u00edsticas comunes y las diferencias de cada plan de estudio, as\u00ed como las validaciones y las relaciones entre las asignaturas y las opciones profesionales que los conforman. Al contar con las funcionalidades que ofrece el m\u00f3dulo web, los administradores de la DCE deben cumplir un perfil m\u00e1s general para gestionar los planes de estudio de las licenciaturas de la Facultad de Ciencias en el sistema CONEST. Se realizaron un conjunto de pruebas funcionales para verificar el correcto funcionamiento del m\u00f3dulo web con la participaci\u00f3n de los tutores (que son usuarios finales del sistema). Adem\u00e1s, se realizaron las pruebas de aceptaci\u00f3n con los trabajadores de la DCE. Los resultados de estas pruebas fueron positivos, y los usuarios que participaron en las mismas mostraron inter\u00e9s en utilizar las funcionalidades del m\u00f3dulo web para realizar sus labores. El m\u00f3dulo web no se puso en producci\u00f3n con el resto del sistema CONEST, debido a los cambios realizados en las estructuras de datos durante el desarrollo de este proyecto. Estos cambios afectar\u00edan el funcionamiento del resto de los m\u00f3dulos del sistema CONEST sin una migraci\u00f3n previa de la base de datos y la refactorizaci\u00f3n de la codificaci\u00f3n. El m\u00f3dulo web para la gesti\u00f3n de planes de estudio en el sistema CONEST se desarroll\u00f3 utilizando tecnolog\u00edas web actuales, entre las cuales se destacan el lenguaje de programaci\u00f3n Ruby y el 91 framework de desarrollo de aplicaciones web Rails. Esta experiencia fue muy enriquecedora ya que pude profundizar mis conocimientos previos del framework y mejorar mis habilidades para desarrollar aplicaciones web siguiendo las pr\u00e1cticas de programaci\u00f3n recomendadas en las p\u00e1ginas de Ruby on Rails Guides y Rails on Rails Screencasts. Es importante resaltar que durante el proceso de desarrollo de este Trabajo Especial de Grado, se public\u00f3 una actualizaci\u00f3n importante del framework Rails (versi\u00f3n 3.1). Por este motivo, se actualiz\u00f3 el framework y se refactoriz\u00f3 el c\u00f3digo del m\u00f3dulo web para cumplir con los est\u00e1ndares de programaci\u00f3n de la nueva versi\u00f3n de Rails. Otro aspecto importante a tomar en cuenta, es la adaptaci\u00f3n del m\u00e9todo \u00e1gil XP implementado para estructurar, planificar y controlar el proceso de desarrollo del m\u00f3dulo web. Algunas pr\u00e1cticas del m\u00e9todo \u00e1gil XP no se aplicaron en este proyecto tales como el desarrollo previamente probado, la programaci\u00f3n en parejas, la propiedad colectiva y la integraci\u00f3n continua. Sin embargo, se aplicaron el resto de las pr\u00e1cticas del m\u00e9todo, lo cual facilit\u00f3 la planificaci\u00f3n y las entregas del proyecto, dividiendo los requerimientos en iteraciones, que se fueron desarrollando progresivamente seg\u00fan su prioridad. Finalmente, gracias al desarrollo de este Trabajo Especial de Grado se cumplieron satisfactoriamente los principales objetivos de este proyecto, logrando un aporte significativo al sistema CONEST, ya que hasta el momento no contaba con una aplicaci\u00f3n que permitiera gestionar los planes de estudio de las distintas licenciaturas que ofrece la Facultad de Ciencias, as\u00ed como verificar los requisitos curriculares de los estudiantes regulares de pregrado. 92 Recomendaciones A pesar de los beneficios que ahora pueden disfrutar los trabajadores de la DCE y los estudiantes de pregrado de la Facultad de Ciencias a trav\u00e9s del m\u00f3dulo web para la gesti\u00f3n de planes de estudio en el sistema CONEST, se pueden considerar algunas mejoras y nuevas funcionalidades que permitan el mantenimiento preventivo y correctivo del sistema CONEST, como las que se mencionan a continuaci\u00f3n: \uf0b7 Los planes de estudio est\u00e1n intr\u00ednsecamente relacionados con los procesos administrativos y las normativas acad\u00e9micas de las licenciaturas de la Facultad de Ciencias, por este motivo, se recomienda refactorizar el sistema CONEST para que soporte los cambios realizados en las estructuras de datos durante el desarrollo de este Trabajo Especial de Grado. Siendo el m\u00f3dulo de inscripci\u00f3n, uno de los m\u00e1s afectados ya que este debe determinar cu\u00e1les son las asignaturas que puede cursar un estudiante bas\u00e1ndose en su avance en la carrera, considerando las prelaciones entre las asignaturas y el tipo principal de las asignaturas registradas m\u00faltiples veces en un mismo plan de estudio, ambas, caracter\u00edsticas fundamentales desarrolladas en el m\u00f3dulo web para la gesti\u00f3n de planes de estudio en el sistema CONEST. \uf0b7 En el caso de las convalidaciones, los Consejos de Escuela de la Facultad de Ciencias aprueban las convalidaciones generales de las asignaturas que correspondan con su carrera, los trabajadores de la DCE no cuentan con un mecanismo para conocer las convalidaciones aprobadas por los distintos Consejos de Escuela, por este motivo, se recomienda desarrollar una aplicaci\u00f3n que le permita a los trabajadores de la DCE conocer los detalles de las nuevas convalidaciones para registrarlas en el m\u00f3dulo web. \uf0b7 Con respecto a la verificaci\u00f3n de requisitos curriculares, cada semestre se verifican los requisitos curriculares de los estudiantes que inscribieron TEG. Los trabajadores del Departamento de Grado de la DCE utilizan un documento impreso, para conocer cu\u00e1les son dichos estudiantes. Se recomienda desarrollar una aplicaci\u00f3n que le permita a los trabajadores del Departamento de Grado consultar cu\u00e1les son los estudiantes que inscribieron TEG en el semestre actual, as\u00ed como imprimir el historial acad\u00e9mico y la verificaci\u00f3n de requisitos curriculares correspondientes, en caso de ser necesario. \uf0b7 El componente docente es un convenio que existe con la Facultad de Humanidades y Educaci\u00f3n que les permite a los estudiantes de las licenciaturas de Biolog\u00eda, F\u00edsica, Matem\u00e1tica y Qu\u00edmica optar por un t\u00edtulo universitario de Licenciatura en Educaci\u00f3n con una menci\u00f3n cient\u00edfica. Se recomienda crear los planes de estudio de los componentes docentes que ofrece la Facultad de Ciencias utilizando el m\u00f3dulo web para poder verificar los requisitos curriculares de los estudiantes inscritos en dichas carreras. 93 Referencias Bibliogr\u00e1ficas Asierra. (14 de Junio de 2004). Desarrollo \u00e1gil de software - Wikipedia, la enciclopedia libre. Recuperado el 15 de Enero de 2011, de Wikipedia, la enciclopedia libre: http://es.wikipedia.org/wiki/Desarrollo_%C3%A1gil_de_software Beck, K. (2005). Extreme Programming Explained: Embrace Change. Boston: Pearson Education, Inc. Bos, B. (15 de Diciembre de 2005). CSS current work & how to participate. Recuperado el 20 de Diciembre de 2010, de World Wide Web Consortium (W3C): http://www.w3.org/Style/CSS/current-work.en.html Haml. (2011). #haml.about. Recuperado el 23 de Mayo de 2011, de #haml: http://haml-lang.com/ Hassani, K. (3 de Abril de 2005). Web application - Wikipedia, the free encyclopedia. Recuperado el 18 de Enero de 2011, de http://en.wikipedia.org/wiki/Web_application Hickson, I. (19 de Octubre de 2010). HTML5. Recuperado el 20 de Diciembre de 2010, de World Wide Web Consortium (W3C): http://dev.w3.org/html5/spec/Overview.html Obfusco, F. (24 de Noviembre de 2003). MySQL - Wikipedia, the free encyclopedia. Recuperado el 20 de Diciembre de 2010, de Wikipedia, the free encyclopedia: http://en.wikipedia.org/wiki/MySQL Patrick. (27 de Julio de 2004). Hypertext Transfer Protocol - Wikipedia, the free encyclopedia. Recuperado el 20 de Diciembre de 2010, de Wikipedia, the free encyclopedia: http://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol Ruby on Rails. (2011). http://rubyonrails.org/documentation. Recuperado el 20 de Diciembre de 2010, de http://rubyonrails.org: http://rubyonrails.org/documentation Sass. (2011). Sass - Syntactically Awesome Stylesheets. Recuperado el 23 de Mayo de 2011, de Sass - Syntactically Awesome Stylesheets: http://sass-lang.com/about.html Teruel, A. (20 de Septiembre de 2000). Justificaciones del dise\u00f1o de Delta Pensum 1.x: Las clases Pensum, Calendario Curricular. Recuperado el 22 de Febrero de 2010, de http://www.ldc.usb.ve/~teruel/ci4712/dp/dp1x/whyPensum.html The jQuery Project. (2010). Main Page - jQuery JavaScript Library. Recuperado el 20 de Diciembre de 2010, de jQuery: The Write Less, Do More, JavaScript Library: http://docs.jquery.com/Main_Page 94 Anexo I: Editar Plan de Estudio 95 Anexo II: Crear Requisito Curricular 96 Anexo III: Editar Asignatura", "document_id": 539587}]}, {"paragraphs": [{"qas": [{"question": "que son almacenes de datos", "id": 320692, "answers": [{"answer_id": 331182, "document_id": 539589, "question_id": 320692, "text": "Almacenes de Datos El t\u00e9rmino Almacenes de Datos fue introducido por Bill Inmon a principios de la d\u00e9cada de los \u00b490, quien lo defini\u00f3 como: \u201cEs una colecci\u00f3n de datos orientado a temas, integrado, variable en el tiempo y no vol\u00e1til para ayudar al proceso de toma de decisiones gerenciales\u201d. ", "answer_start": 40872, "answer_end": 41164, "answer_category": null}], "is_impossible": false}, {"question": "que es ETL", "id": 320693, "answers": [{"answer_id": 331183, "document_id": 539589, "question_id": 320693, "text": "Proceso ETL (Extracci\u00f3n, Transformaci\u00f3n y Carga) Se define como el proceso a trav\u00e9s del cual se gestionan datos obtenidos de m\u00faltiples fuentes, con el fin de recolectarlos, limpiarlos y cargarlos en Bases de Datos Especializadas, denominadas Almacenes de Datos, para analizar y apoyar una determinada L\u00ednea de Producto o Unidad de Negocios (Inteligencias de Negocios, 2009).", "answer_start": 55453, "answer_end": 55827, "answer_category": null}], "is_impossible": false}, {"question": "que es la preservacion digital", "id": 320689, "answers": [{"answer_id": 331179, "document_id": 539589, "question_id": 320689, "text": "Preservaci\u00f3n Digital La preservaci\u00f3n digital es el conjunto de medidas, que se establecen con el fin de asegurar la perdurabilidad de la capacidad de visualizar, recuperar y utilizar colecciones digitales frente a las infraestructuras, elementos tecnol\u00f3gicos y de organizaci\u00f3n que cambian con mucha rapidez. ", "answer_start": 27491, "answer_end": 27799, "answer_category": null}], "is_impossible": false}, {"question": "que es el internet archive", "id": 320690, "answers": [{"answer_id": 331180, "document_id": 539589, "question_id": 320690, "text": "Internet Archive El Internet Archive Wayback Machine es un servicio que permite a la gente a visitar las versiones archivadas de sitios Web. ", "answer_start": 31274, "answer_end": 31415, "answer_category": null}], "is_impossible": false}, {"question": "que es the wayback machine", "id": 320691, "answers": [{"answer_id": 331181, "document_id": 539589, "question_id": 320691, "text": " The Wayback Machine Wayback Machine es un sitio que se dedica a archivar Internet. Es decir, rastrea Internet cada cierto tiempo, como lo hacen los buscadores tipo Google, y copia todas las webs que encuentra y que son p\u00fablicamente accesibles, formando una gigantesca biblioteca de webs, permitiendo su acceso de manera gratuita. ", "answer_start": 32322, "answer_end": 32653, "answer_category": null}], "is_impossible": false}], "context": "Introd Universidad Central de Venezuela Facultad de Ciencias Escuela de Computaci\u00f3n Prototipo de un Archivo de Documentos Digitales provenientes de la Web. Contenido Web y Almacenes de Datos Trabajo Especial de Grado presentado ante la ilustre Universidad Central de Venezuela Por el Bachiller: Carlos A. Blanco B. - C.I. 14.519.963 Para optar al t\u00edtulo de Licenciado en Computaci\u00f3n Tutor: Profa. Mercy Ospina Caracas, Julio 2012 2 UNIVERSIDAD CENTRAL DE VENEZUELA FACULTAD DE CIENCIAS ESCUELA DE COMPUTACI\u00d3N ACTA Quienes suscriben, miembros del jurado designado por el Consejo de la Escuela de Computaci\u00f3n, para examinar el Trabajo Especial de Grado titulado \u201cPrototipo de un Archivo de Documentos Digitales provenientes de la Web. Contenido Web y Almacenes de Datos\u201d y presentado por el Br. Carlos A. Blanco B., a los fines de optar al t\u00edtulo de Licenciado en Computaci\u00f3n, dejamos constancia de lo siguiente: Le\u00eddo como fue dicho trabajo, por cada uno de los miembros del jurado, se fij\u00f3 el d\u00eda 25 de Julio del 2012, a las 08:00 AM horas, para que los autores lo defendieran en forma p\u00fablica, lo que estos hicieron en la Sala PBIII de la Escuela de Computaci\u00f3n, mediante una presentaci\u00f3n oral de su contenido, luego de lo cual respondieron a las preguntas formuladas. Finalizada la defensa p\u00fablica del Trabajo Especial de Grado, el jurado decidi\u00f3 aprobar con la nota de 20 puntos. En fe de lo cual se levanta la presente Acta, en Caracas el d\u00eda 25 de Julio del 2012. _____________________ Prof(a). Mercy Ospina (Tutora) _____________________ _____________________ Prof(a). Tina Di Vasta Prof. Carlos Acosta (Jurado) (Jurado) RESUMEN 3 RESUMEN Universidad Central de Venezuela Facultad de Ciencias Escuela de Computaci\u00f3n Laboratorio de Sistemas Paralelos y Distribuidos Prototipo para un Archivo de Documentos Digitales provenientes de la Web. Contenido Web y Almacenes de Datos Autor: Carlos A. Blanco B. \u2013 C.I. 14.519.963 Tutora: Profa. Mercy Ospina Fecha: Junio de 2012 En la actualidad se puede observar que el mayor contenido de informaci\u00f3n existente en el mundo se encuentra en el internet, esta informaci\u00f3n que va creciendo de manera din\u00e1mica se actualiza en cada momento y puede tener una vida corta. Un gran problema que se puede presentar es que mucha informaci\u00f3n se puede perder por distintos motivos haciendo que no se pueda acceder a ella. Teniendo en cuenta este problema, el proyecto en el cual se basa el presente Trabajo Especial de Grado propone salvaguardar esta informaci\u00f3n para que se pueda acceder a ella desde una base de datos documental (Base de Datos No Relacional Basada en Documentos) llamada MongoDB, y adem\u00e1s crear un Almac\u00e9n de Datos que va a ser alimentado con distinta informaci\u00f3n obtenida de las p\u00e1ginas web almacenada para poder lograr distintas m\u00e9tricas que se mostraran al usuario. Este Trabajo Especial de Grado presenta el dise\u00f1o de dicho Almac\u00e9n de Datos dividido en dos m\u00f3dulos del proyecto general, estos son el proceso ETL (Extracci\u00f3n, Transformaci\u00f3n y Carga) que se encarga de alimentar el Almac\u00e9n de Datos, y la Interfaz el Usuario, en la que se muestra distintas m\u00e9tricas obtenidas del Almac\u00e9n de Datos y la p\u00e1gina web al usuario. Palabras Claves: Almacenes de Datos (DW), Ruby on Rails, MongoDB, Metodologia XP \u00cdNDICE 4 TABLA DE CONTENIDO RESUMEN ................................................................................................................................ 3 \u00cdNDICE DE CUADROS ............................................................................................................... 7 \u00cdNDICE DE FIGURAS................................................................................................................. 8 INTRODUCCI\u00d3N .................................................................................................................... 10 CAPITULO 1 - PLANTEAMIENTO DEL PROBLEMA ................................................................ 13 1.1 Titulo ...................................................................................................................... 13 1.2 Planteamiento del Problema ................................................................................. 13 1.3 Objetivo General y Espec\u00edfico ................................................................................ 14 1.3.1 Objetivo General .................................................................................................. 14 1.3.2 Objetivos Espec\u00edficos ........................................................................................... 14 1.4 Descripci\u00f3n de la soluci\u00f3n ..................................................................................... 15 CAPITULO 2 - MARCO CONCEPTUAL ................................................................................... 18 2.1 Preservaci\u00f3n Digital ............................................................................................... 18 2.1.1 Amenazas T\u00e9cnicas .............................................................................................. 18 2.1.2 Amenazas dentro de la Organizaci\u00f3n .................................................................. 19 2.1.3 Plan de Preservaci\u00f3n ........................................................................................... 19 2.1.4 Dificultades .......................................................................................................... 20 2.2 Internet Archive ..................................................................................................... 20 2.2.1 Origen .................................................................................................................. 20 2.2.2 Ejemplos de Archivos Web .................................................................................. 21 2.3 Almacenes de Datos............................................................................................... 26 2.3.1 Objetivos de los Almacenes de Datos ................................................................. 27 \u00cdNDICE 5 2.3.2 Caracter\u00edsticas de los Almacenes de Datos ......................................................... 28 2.3.3 Proceso ETL (Extracci\u00f3n, Transformaci\u00f3n y Carga) ............................................. 36 2.3.4 Dise\u00f1o de un Almac\u00e9n de Datos .......................................................................... 39 2.3.5 Tipos de Almacenes de Datos .............................................................................. 40 2.3.6 Diferencia entre una Base de Datos Operacional y un Almac\u00e9n de Datos ......... 42 CAPITULO 3 - MARCO TECNOL\u00d3GICO ................................................................................. 44 3.1 MonetDB ................................................................................................................ 44 3.1.1 Caracter\u00edsticas ..................................................................................................... 44 3.2 MongoDB ............................................................................................................... 46 3.2.1 MongoDB: Descripci\u00f3n y licencia ........................................................................ 49 3.2.2 Terminolog\u00eda b\u00e1sica en MongoDB ....................................................................... 49 3.2.3 Formato de los documentos en MongoDB ......................................................... 50 3.3 Ruby on Rails .......................................................................................................... 53 3.3.1 Lenguaje de Programaci\u00f3n Ruby ......................................................................... 53 3.3.2 FrameWorks Rails ................................................................................................ 54 3.3.3 RubyGems ............................................................................................................ 59 CAPITULO 4 - MARCO METODOL\u00d3GICO .............................................................................. 62 4.1 Metodolog\u00eda XP (Programaci\u00f3n Extrema) ............................................................. 62 4.1.1 Valores del Extreme Programing ......................................................................... 65 4.1.2 Ventajas del M\u00e9todo XP ...................................................................................... 66 4.1.3 Adaptaci\u00f3n del Proceso XP .................................................................................. 67 4.2 Metodolog\u00eda de Kimball para el Dise\u00f1o de un Almacen de Datos ........................ 71 CAPITULO 5 - MARCO APLICATIVO ...................................................................................... 74 5.1 Plan de Iteraciones ................................................................................................. 74 \u00cdNDICE 6 5.1.1 iteraci\u00f3n 0 ............................................................................................................ 74 5.1.2 iteraci\u00f3n 1 ............................................................................................................ 78 5.1.3 iteraci\u00f3n 2 ............................................................................................................ 83 5.1.4 iteraci\u00f3n 3 ............................................................................................................ 95 CONCLUSIONES ................................................................................................................... 114 RECOMENDACIONES .......................................................................................................... 116 BIBLIOGRAF\u00cdA ..................................................................................................................... 117 AP\u00c9NDICE ............................................................................................................................ 120 5.2 Modelo del Almac\u00e9n de Datos ............................................................................. 120 5.3 Diccionario de Datos del Almac\u00e9n de Datos ........................................................ 121 \u00cdNDICE 7 \u00cdNDICE DE CUADROS Cuadro 1 - Formato de Historia de Usuarios ........................................................................ 67 Cuadro 2 - Nombre de Actores y sus Roles .......................................................................... 68 Cuadro 3 - Formato del Cuadro de Interacciones ................................................................ 69 Cuadro 4 - Formato de Casos de Pruebas ............................................................................ 71 Cuadro 5 - Gemas Instaladas ................................................................................................ 76 Cuadro 6 - Query para crear la Tabla Dimension Tiempo .................................................... 79 Cuadro 7 - Query para crear la Tabla Dimension Sitios ........................................................ 80 Cuadro 8 - Query para crear la Tabla Dimension Metadata ................................................ 80 Cuadro 9 - Query para crear la tabla de Hechos P\u00e1gina ....................................................... 81 Cuadro 10 - Ejemplo de un Query en MonetDB usando el JOIN .......................................... 82 Cuadro 11 - Estructura de Datos en MongoDB .................................................................... 85 Cuadro 12 - Descripci\u00f3n de la Tabla de Hechos FACT_P\u00e1gina ........................................... 121 Cuadro 13 - Descripci\u00f3n de la Tabla de Dimensiones DIM_Sitio ....................................... 122 Cuadro 14 - Descripci\u00f3n de la Tabla de Dimensiones DIM_Metadata .............................. 122 Cuadro 15 - Descripci\u00f3n de la Tabla de Dimensiones Tiempo ........................................... 123 \u00cdNDICE 8 \u00cdNDICE DE FIGURAS Figura 1 \u2013 Proceso de las Funcionalidades del Sistema ....................................................... 17 Figura 2 \u2013 Almacenes de Datos Orientados a Temas ........................................................... 30 Figura 3 - Almacenes de Datos Integraci\u00f3n ......................................................................... 33 Figura 4 - Almacenes de Datos Variable en el Tiempo ......................................................... 35 Figura 5 - Almacenes de Datos No Vol\u00e1til ............................................................................ 36 Figura 6 - Proceso ETL ........................................................................................................... 39 Figura 7 - Modelo Estrella (Almacenes de Datos) ................................................................ 41 Figura 8 - Modelo Copo de Nieve (Almacenes de Datos) ..................................................... 42 Figura 9 - Diferencias entre una Base de Datos Operacional y un Almac\u00e9n de Datos ......... 43 Figura 11 - Ejemplo de Formato de un Documento (MongoDB) ......................................... 51 Figura 11 - Modelo Vista Controlador (Ruby On Rails) ........................................................ 57 Figura 12 - Estructura de Carpetas (Ruby on Rails) .............................................................. 58 Figura 13 - Diagrama de los ciclos de desarrollo de software .............................................. 64 Figura 14- Cambios realizados en la Librer\u00eda Scraper ........................................................... 86 Figura 15 - Funci\u00f3n Analizador de Documentos................................................................... 87 Figura 16 - C\u00f3digo para obtener valores m\u00e1ximo de las Dimensiones ................................ 88 Figura 17 - Ejemplo de Query para calcular el M\u00e1ximo de una Clave Primaria ................... 88 Figura 18 - C\u00f3digo para Insertar en la Tabla Dimension Tiempo ......................................... 89 Figura 19 - Ejemplo de un Query para Insertar elementos .................................................. 90 Figura 20 - Ejemplo de los Datos en la Tabla Dimension Tiempo ........................................ 91 Figura 21 - Ejemplo de los Datos en la Tabla Dimension Metadata ..................................... 91 Figura 22 - Ejemplo de los Datos en la Tabla Dimension Sitios ............................................ 91 Figura 23 - Ejemplo de los Datos en la Tabla de Hechos P\u00e1ginas ......................................... 92 Figura 24 - C\u00f3digo del Proceso ETL en el caso de que el contenido sea de tipo HTML ....... 92 Figura 25 - Tabla de Hechos P\u00e1ginas cuando el contenido procesado no es HTML ............ 93 Figura 26 - C\u00f3digo del Proceso ETL cuando el mime no es HTML ........................................ 93 \u00cdNDICE 9 Figura 27- Vista del index.html.erb ...................................................................................... 98 Figura 28 - Controlador de la p\u00e1gina index.html.erb ........................................................... 99 Figura 29 - Query Utilizado en el controlador de index.html.erb ........................................ 99 Figura 30 - Vista del pre_calendario.html.erb .................................................................... 100 Figura 31 - Controlador de pre_calendario.html.erb ......................................................... 101 Figura 32 - Query utilizado en el controlador de pre_calendario.html.erb ....................... 101 Figura 33 - Script donde se almacena los eventos en el calendario .................................. 102 Figura 34 - Vista del calendario.html.erb ........................................................................... 103 Figura 35 - Parte del c\u00f3digo del controlador de calendario.html.erb ................................ 104 Figura 36 - Porci\u00f3n del C\u00f3digo donde se imprime el Grafico 1 .......................................... 105 Figura 37 - C\u00f3digo del Grafico 1 en el controlador de calendario.html.erb ...................... 105 Figura 38 - Query utilizado en el Grafico 1 ......................................................................... 105 Figura 39 - M\u00e9todo que define las variables usadas para la Grafica 1............................... 106 Figura 40 - Vista de procesar_p\u00e1gina.html.erb .................................................................. 107 Figura 41 -C\u00f3digo de cambio de direcci\u00f3n absoluta por direcci\u00f3n relativas ..................... 108 Figura 42 - Query utilizado en el proceso de la Figura 45 .................................................. 109 Figura 43 - Porci\u00f3n del c\u00f3digo donde se crea los archivos que no son HTML ................... 111 Figura 44 - Vista para el Frame de Grafico 2 ...................................................................... 112 Figura 45 - Controlador para el Frame de Grafico 2 ........................................................... 112 Figura 50 - Query para obtener los datos necesarios para el Grafico 2 ............................. 113 Figura 47 - Variables necesarias para el Grafico 2.............................................................. 113 Figura 48 - Modelo del Almac\u00e9n de Datos ......................................................................... 120 INTRODUCCI\u00d3N 10 INTRODUCCI\u00d3N Actualmente se observa que una gran parte de la informaci\u00f3n producida en casi todos los \u00e1mbitos de la actividad humana se almacena en medios digitales, usando como soporte los computadores y las redes. Sin embargo, la persistencia de la informaci\u00f3n no est\u00e1 garantizada de por s\u00ed, depende de factores humanos, t\u00e9cnicos y econ\u00f3micos para que sean preservados a lo largo del tiempo. Imaginemos por un momento que las grandes bibliotecas del mundo permitieran que varias de sus obras fueran destruidas debido a falta de espacio, recorte presupuestario, accidentes o simplemente mala praxis. Muchas de las obras son preservadas para la consulta del p\u00fablico actual y para las generaciones futuras. Al igual que el contenido en medios impresos, el digital es un resultado de la actividad intelectual humana, entonces \u00bfpor qu\u00e9 no darle el mismo peso y valor a \u00e9stas contribuciones? es cierto que el manejo de colecciones de contenido digital se presenta en formatos y maneras diferentes lo que las hace dif\u00edcilmente medibles, por lo tanto dif\u00edciles de gestionar. Preservar esta informaci\u00f3n que incluye, por ejemplo, informaciones cient\u00edficas, datos de investigaci\u00f3n, productos de medios de comunicaci\u00f3n, obras de artes digitales, entre otros; plantea retos y problemas que deben ser afrontados de manera integral desde un punto de vista humano y tecnol\u00f3gico. Pensar en realizar un gran archivo general de la web supone la disponibilidad vasta de recursos de almacenamiento y de conectividad. Casos como los del sitio Internet Archive y el su proyecto de \u00e9sta (The WayBack Machine) han logrado desde 1996 almacenar gran parte del contenido web en el Internet. Otros trabajos se han enfocado en confeccionar archivos locales, por pa\u00eds, especializados en su cultura y necesidades de INTRODUCCI\u00d3N 11 preservaci\u00f3n y que puedan interactuar con otros de una manera distribuida (Rauber, 2002). Venezuela no es ajena a estos problemas, m\u00e1s cuando su desarrollo de contenidos en la web ha ido en aumento en los \u00faltimos a\u00f1os, hoy m\u00e1s que nunca es necesario preservar la informaci\u00f3n digital ya que se observa en ella registrada una buena parte de la historia y acontecimientos recientes del pa\u00eds. Tomando en cuenta lo antes mencionado los Almacenes de Datos pueden ser utilizados para almacenar informaci\u00f3n obtenida de los contenidos web para as\u00ed lograr distintas m\u00e9tricas para un futuro an\u00e1lisis por parte del usuario final. Con el contenido web almacenado en la base de datos No relacional, basada en documentos (MongoDB) se puede llevar un historial de los cambios realizados sobre el contenido web, con esto el usuario puede observar la evoluci\u00f3n del contenido web con respecto a su funcionalidad, dise\u00f1o, entre otras. Tambi\u00e9n tiene una gran ventaja que si la p\u00e1gina deja de existir todav\u00eda puede ver las versiones anteriores de la p\u00e1gina antes que dejara de existir. Para facilitar la lectura del documento al lector, a continuaci\u00f3n se muestra la estructura de los distintos cap\u00edtulos en esta Tesis de Grado: \uf0b7 CAPITULO 1 - Planteamiento del Problema: en este cap\u00edtulo se describe el objetivo general, los objetivos espec\u00edficos, la soluci\u00f3n planteada para los distintos objetivos, y una descripci\u00f3n general de la soluci\u00f3n. \uf0b7 CAPITULO 2 - Marco Conceptual: se presenta las distintas definiciones b\u00e1sicas que sirven como bases para entender mucho mejor de lo que se trata esta Tesis de Grado. \uf0b7 CAPITULO 3 - Marco Tecnol\u00f3gico: en este cap\u00edtulo se explica de toda la tecnolog\u00eda utilizada para el desarrollo del sistema. \uf0b7 CAPITULO 4 - Marco Metodol\u00f3gico: presenta la metodolog\u00eda utilizada para el desarrollo de este proyecto. INTRODUCCI\u00d3N 12 \uf0b7 CAPITULO 5 - Marco aplicativo: en este cap\u00edtulo se explica la aplicaci\u00f3n de la Metodolog\u00eda XP al caso de estudio. Finalmente se presentan las Conclusiones, recomendaciones, ap\u00e9ndice y bibliograf\u00eda consultada a lo largo de Trabajo Especial de Grado. El presente trabajo se enmarca dentro del proyecto de investigaci\u00f3n financiado por el Consejo de Desarrollo Cient\u00edfico y Human\u00edstico (CDCH) de la Universidad Central de Venezuela (UCV). Proyecto No. PG-037353-2008 CAPITULO 1 \u2013 PLANTEAMIENTO DEL PROBLEMA 13 CAPITULO 1 - PLANTEAMIENTO DEL PROBLEMA 1.1 Titulo Prototipo para un Archivo de Documentos Digitales provenientes de la Web. Contenido Web y Almacenes de Datos. 1.2 Planteamiento del Problema En la actualidad, una de las herramientas con mayor auge de utilizaci\u00f3n a nivel mundial a distancia es la gran red de comunicaciones llamada Internet. Esta se ha convertido en un medio id\u00f3neo para mantener un contacto en tiempo real, tanto a nivel empresarial como personal entre sus usuarios, adem\u00e1s de un funcionamiento tangible en el \u00e1mbito de informaci\u00f3n, educaci\u00f3n, comercializaci\u00f3n y entretenimiento. Esta gran red de informaci\u00f3n se presenta con una amplia gama de sitios Web donde se puede indagar temas de cualquier \u00edndole. Se tiene por ejemplo: sitios de descargas de archivos, blogs, sitios de informaci\u00f3n de empresas, sitios de comercio electr\u00f3nico, wiki, sitios de comunidades virtuales, sitios de juegos, entre otros. Varios son los esfuerzos para preservar documentos, libros, entre otros, para su consulta p\u00fablica y para las generaciones futuras. Cada d\u00eda m\u00e1s informaci\u00f3n se encuentra en formato digital, las noticias se generan y se publican en la Web. Preservar este tipo de informaci\u00f3n es una necesidad para el mundo. Esta preservaci\u00f3n de informaci\u00f3n digital se denomina Archivo Web, que tambi\u00e9n permiten el acceso a versiones anteriores de p\u00e1ginas Web que ya no existen. En el marco de las directrices para la preservaci\u00f3n del patrimonio digital de la UNESCO (2003) sobre la digitalizaci\u00f3n y la accesibilidad en l\u00ednea del material cultural y la conservaci\u00f3n digital, se encuentra el proyecto del Centro de Computaci\u00f3n Paralela y Distribuida (CCPD) el cual cubre el desarrollo de un prototipo para la Construcci\u00f3n del Archivo de Documentos Digitales provenientes de la Web, con el fin de conservar los CAPITULO 1 \u2013 PLANTEAMIENTO DEL PROBLEMA 14 productos culturales \u201carchivos digitales\u201d, para que puedan convertirse en un patrimonio cultural e intelectual perdurable para las generaciones presentes y venideras de Venezuela. 1.3 Objetivo General y Espec\u00edfico En la siguiente secci\u00f3n se va a definir los objetivos generales y especifico para el desarrollo de esta Tesis Especial de Grado 1.3.1 Objetivo General \uf0b7 Dise\u00f1ar e implementar un Almac\u00e9n de Datos que facilite el an\u00e1lisis de las distintas m\u00e9tricas obtenidas de la informaci\u00f3n almacenada de las versiones de documentos provenientes de la web adem\u00e1s se implementa una aplicaci\u00f3n web para el acceso a estos documentos y sus m\u00e9tricas al usuario final. 1.3.2 Objetivos Espec\u00edficos \uf0b7 Dise\u00f1ar un Almac\u00e9n de Datos que se adapte mas a la estructura de la informaci\u00f3n disponible en la web y as\u00ed poder obtener f\u00e1cilmente las distintas m\u00e9tricas que se van a mostrar al usuario final Actividades: o Dise\u00f1ar un Almac\u00e9n de Datos en base a las caracter\u00edsticas de los documentos web descritos en el est\u00e1ndar de HTML (Lenguaje de Marcado de Hipertexto). o Implementar el Almac\u00e9n de Datos usando MonetDB. \uf0b7 Dise\u00f1ar y construir un proceso ETL (Extraccion, Transformacion y Carga) para introducir la informaci\u00f3n o datos obtenidos desde la web. Actividades: o Implementar el proceso ETL (Extraccion, Transformacion y Carga) con Ruby para MonetDB. CAPITULO 1 \u2013 PLANTEAMIENTO DEL PROBLEMA 15 o Extraer la informaci\u00f3n necesaria para alimentar el Almac\u00e9n de Datos desde la base de datos iticve_db en MongoDB. \uf0b7 Ejecutar el proceso ETL con un conjunto de datos previamente definidos. Actividades: o Seleccionar previamente el conjunto de datos que se va a cargar en el Almac\u00e9n de Datos. o Probar los resultados obtenidos para ver si son los resultados esperados. \uf0b7 Dise\u00f1ar y desarrollar una aplicaci\u00f3n Web para que el usuario pueda acceder a los documentos web almacenado y a las m\u00e9tricas que son obtenidas del Almac\u00e9n de Datos. Actividades: o Implementar la aplicaci\u00f3n web usando Ruby on Rails. o Extraer informaci\u00f3n del Almac\u00e9n de Datos seg\u00fan la URL (Identificador Uniforme de Recurso) de la p\u00e1gina web que ingrese el usuario. o Mostrar un calendario con las distintas versiones almacenada de la p\u00e1gina solicitada por el usuario. o Al seleccionar una fecha en calendario se procede a extraer el contenido completo de la p\u00e1gina web desde MongoDB y finalmente se le muestra al usuario los datos extra\u00eddos. 1.4 Descripci\u00f3n de la soluci\u00f3n Partiendo de los documentos almacenados en MongoDB se procede a extraer los datos con el proceso ETL, el proceso ETL solamente extrae la metadata de los nuevos documentos y los viejos \u00edtems que ya est\u00e1n almacenados en el Almac\u00e9n de Datos los ignora. CAPITULO 1 \u2013 PLANTEAMIENTO DEL PROBLEMA 16 De los documentos web almacenados en MongoDB podemos obtener los siguientes elemetnos: URI (Identificador Uniforme de Recurso), Mime, Informaci\u00f3n para las M\u00e9tricas, MongoID. Estos atributos se procesan y se almacenan en el Almac\u00e9n de Datos (MonetDB). Finalmente en la interfaz de usuario, el usuario ingresa una URI v\u00e1lida y se procede a buscar las distintas versiones almacenada de la URI ingresada, si se encuentran alguna versi\u00f3n se extrae todos los datos necesario para mostrar esa p\u00e1gina web con todo su contenido. Al tener los datos de la p\u00e1gina se le muestra un calendario al usuario donde puede seleccionar las distintas versiones de la p\u00e1gina, estas versiones se muestran en el calendario seg\u00fan el d\u00eda, mes, a\u00f1o, hora, minuto y segundo en la cual fue almacenada la informaci\u00f3n de la p\u00e1gina en el Almac\u00e9n de Datos. Cada vez que se inserta nuevos datos en el Almac\u00e9n de Datos se almacena la fecha y hora en que se almaceno. Finalmente cuando el usuario selecciona una versi\u00f3n de la p\u00e1gina se extrae los archivos necesarios para poder mostrar la p\u00e1gina y se le muestra al usuario. CAPITULO 1 \u2013 PLANTEAMIENTO DEL PROBLEMA 17 Figura 1 \u2013 Proceso de las Funcionalidades del Sistema A continuaci\u00f3n se muestra el proceso (Figura 1): 1. Extraer datos necesario del MongoDB para almacenar en el Almac\u00e9n de Datos 2. Al Tener los datos procesados se almacenan en el Almac\u00e9n de Datos. 3. Buscar el URL ingresado por el usuario en el Almac\u00e9n de Datos para obtener los datos necesarios de la p\u00e1gina web. 4. Extraer archivos necesarios para poder mostrar la p\u00e1gina seg\u00fan los datos extra\u00eddos del Almac\u00e9n de Datos. CAPITULO 2 \u2013 MARCO CONCEPTUAL 18 CAPITULO 2 - MARCO CONCEPTUAL 2.1 Preservaci\u00f3n Digital La preservaci\u00f3n digital es el conjunto de medidas, que se establecen con el fin de asegurar la perdurabilidad de la capacidad de visualizar, recuperar y utilizar colecciones digitales frente a las infraestructuras, elementos tecnol\u00f3gicos y de organizaci\u00f3n que cambian con mucha rapidez. La preservaci\u00f3n digital, plantea nuevos desaf\u00edos para la disciplina de la conservaci\u00f3n. Si tomamos en consideraci\u00f3n que la preservaci\u00f3n est\u00e1 orientada a largo plazo, nos encontramos con un primer problema: La informaci\u00f3n digital, no ha sido pensada para su mantenimiento en el tiempo. A diferencia de materiales tradicionales, que tienden a ir desapareciendo de manera gradual, desvaneci\u00e9ndose o amarille\u00e1ndose con el paso del tiempo la informaci\u00f3n digital no se pierde de manera paulatina, esta existe o simplemente no existe. (Swiatecka, 2008) 2.1.1 Amenazas T\u00e9cnicas \uf0b7 La obsolencia del hardware o Una computadora tiene una estimaci\u00f3n de vida de 3 a 5 a\u00f1os. No s\u00f3lo porque t\u00e9cnicamente puede empezar a fallar, sino sobre todo porque nuevo software exige memorias m\u00e1s grandes, m\u00e1s velocidad, entre otras. o Problema general de la obsolescencia planificada de las mercanc\u00edas. \uf0b7 La obsolescencia del software o Un documento digital s\u00f3lo existe mediante su recuperaci\u00f3n: es inseparable del programa necesario para abrirlo. o Debido a la evoluci\u00f3n de organizaciones, el software deja de satisfacer los requerimientos del usuario, e induce a una de las principales causas del desplazamiento del software. CAPITULO 2 \u2013 MARCO CONCEPTUAL 19 \uf0b7 La obsolescencia de los formatos digitales. o La evoluci\u00f3n de formatos est\u00e1 estrechamente vinculada con la evoluci\u00f3n de los programas de software. En la mayor\u00eda de los casos no hay compatibilidad hacia atr\u00e1s (o una compatibilidad deficiente) de los nuevos formatos. o Es pol\u00edtica general de algunos desarrolladores de software propietario hacer que las nuevas versiones de sus programas almacenen los datos en formatos que no pueden ser le\u00eddos por versiones anteriores. \uf0b7 Envejecimiento o deterioro f\u00edsico de los soportes digitales. o Puede ser inherente al soporte, por agentes externos como da\u00f1os f\u00edsicos al soporte, almacenamiento incorrecto o porque el soporte se queda obsoleto (Swiatecka, 2008). 2.1.2 Amenazas dentro de la Organizaci\u00f3n \uf0b7 La seguridad de la colecci\u00f3n (por ejemplo: alteraciones no autorizada de la colecci\u00f3n) \uf0b7 Brechas en la memoria institucional debido a la rotaci\u00f3n de personal \uf0b7 Mantenimiento de registro y metadatos administrativos inadecuados 2.1.3 Plan de Preservaci\u00f3n \uf0b7 Las estrategias tienen que ser bien definidas. \uf0b7 Con reglas y procedimientos a seguir. \uf0b7 Requieren de un esfuerzo peri\u00f3dico y planificado. \uf0b7 Los asuntos asociados con la larga duraci\u00f3n necesitan ser discutidos desde el comienzo de cualquier iniciativa de digitalizaci\u00f3n de objetos. \uf0b7 Las soluciones exitosas requieren la integraci\u00f3n de consideraciones administrativas y t\u00e9cnicas. \uf0b7 La responsabilidad debe exponerse expl\u00edcita y seriamente. CAPITULO 2 \u2013 MARCO CONCEPTUAL 20 \uf0b7 Esta pol\u00edtica debe ser revisada peri\u00f3dicamente (Swiatecka, 2008). 2.1.4 Dificultades \uf0b7 Compromiso institucional de preservaci\u00f3n a largo plazo insuficiente y falta de pol\u00edticas y procedimientos de preservaci\u00f3n. \uf0b7 Escasez de recursos humanos y financieros. \uf0b7 Intereses variables (y asincr\u00f3nicos) de quienes participan en la creaci\u00f3n, mantenimiento y distribuci\u00f3n de colecciones de documentos digitales. \uf0b7 No existe un Plan de Conservaci\u00f3n del Patrimonio Digital nacional, como en otros pa\u00edses (Pandora, DNEP, KulturaW3, entre otras) (Swiatecka, 2008). Despu\u00e9s de que se hablo explica la Preservaci\u00f3n Digital, se explicara de los que es el Internet Archive que trata de la Preservaci\u00f3n Web y se dar\u00e1 unos ejemplos de p\u00e1ginas que se dedican a la Preservaci\u00f3n Web 2.2 Internet Archive El Internet Archive Wayback Machine es un servicio que permite a la gente a visitar las versiones archivadas de sitios Web. Por dar un ejemplo los visitantes de la Wayback Machine pueden escribir una direcci\u00f3n URL, seleccione un intervalo de fechas, y luego comenzar a navegar en una versi\u00f3n archivada de la Web (Archive, 2001). 2.2.1 Origen Creada en 1996, se encuentra en el Presidio de San Francisco (California). La colaboraci\u00f3n que llev\u00f3 a cabo la amplitud de esa p\u00e1gina fue gracias a Alexa Internet y de otros colaboradores aparte de la colaboraci\u00f3n de la Biblioteca del Congreso. Tiene una gran cantidad de archivos miscel\u00e1neos como audio, video y texto, algunos de ellos en dominio p\u00fablico, o de licencias a base del Creative Commons o cualquier otra licencia que permita la distribuci\u00f3n (Archive, 2001). Ah continuaci\u00f3n se va hablar de 3 distintas Archive Web conocidas en el mundo, primero comenzamos con las que se uso como base para este proyecto: CAPITULO 2 \u2013 MARCO CONCEPTUAL 21 2.2.2 Ejemplos de Archivos Web 2.2.2.1 The Wayback Machine Wayback Machine es un sitio que se dedica a archivar Internet. Es decir, rastrea Internet cada cierto tiempo, como lo hacen los buscadores tipo Google, y copia todas las webs que encuentra y que son p\u00fablicamente accesibles, formando una gigantesca biblioteca de webs, permitiendo su acceso de manera gratuita. S\u00f3lo archiva los sitios que Alexa conoce. No se pueden buscar palabras clave dentro del archivo, sino solamente URL de direcciones, y seleccionar la fecha. Las webs que copian tardan un tiempo en aparecer en el archivo. No es instant\u00e1neo. El rastreo de Internet respeta las directivas de exclusi\u00f3n de robots, por lo que quien no quiere aparecer en el archivo le basta con configurar de manera adecuada el fichero robots.txt de su web. O solicitar despu\u00e9s que le borren del archivo. Wayback Machine es parte de Internet Archive, una biblioteca digital sin \u00e1nimo de lucro de San Francisco (EE.UU.), dedicada a ofrecer acceso p\u00fablico general gratis de p\u00e1ginas webs, m\u00fasica, pel\u00edculas y libros digitales. Trabaja en colaboraci\u00f3n con la Universidad de Toronto (Canad\u00e1) y m\u00e1s de 150 bibliotecas y universidades de todo el mundo (qbit\u00e1cora, 2010). Utilidad: \uf0b7 Acceder a webs que ya no existen, como por ejemplo, las alojadas en el hospedaje Gocetes, que cerr\u00f3 el 26-10-2009. \uf0b7 Examinar c\u00f3mo era una web en el pasado, c\u00f3mo ha cambiado. \uf0b7 Investigar sobre algo del pasado. CAPITULO 2 \u2013 MARCO CONCEPTUAL 22 A veces no se puede o casi no se puede acceder a la direcci\u00f3n ra\u00edz de una web, pero s\u00ed a alguna direcci\u00f3n interior, y navegar a partir de esa direcci\u00f3n por el sitio tal y como era hace a\u00f1os (qbit\u00e1cora, 2010). Defectos: \uf0b7 A veces falla, y el sitio buscado no fue archivado. \uf0b7 A veces funciona muy lento. Normal, porque es gigantesco. \uf0b7 Tampoco lo almacena todo: La funcionalidad din\u00e1mica hecha con Java Script, formularios, o bases de datos (la web profunda) no se guardan, por lo que puede que se vea distinto de c\u00f3mo era la web original. Pero el texto est\u00e1 ah\u00ed, guardado, y tambi\u00e9n fotos. Incluso a veces se ah llegado a descargar alg\u00fan v\u00eddeo. Siempre que una web o una direcci\u00f3n ya no existan, se prueba a ver si se encuentra en the Wayback Machine, y esto resulta muy \u00fatil. Sin embargo, mucha gente todav\u00eda no la conoce (qbit\u00e1cora, 2010). 2.2.2.2 Archivo Web de Catalu\u00f1a PADICAT es el archivo web de Catalu\u00f1a, creado por la instituci\u00f3n p\u00fablica responsable de recoger, conservar y difundir el patrimonio bibliogr\u00e1fico de Catalu\u00f1a, la Biblioteca de Catalunya. La informaci\u00f3n sobre PADICAT est\u00e1 disponible: \uf0b7 En la informaci\u00f3n institucional del repositorio, que contiene explicaciones sobre los objetivos, la historia y el equipo de PADICAT. \uf0b7 En la radiograf\u00eda de las p\u00e1ginas web integradas a PADICAT. \uf0b7 En los datos de hardware y software del repositorio. \uf0b7 En las \u00faltimas novedades y las apariciones de PADICAT en los medios de comunicaci\u00f3n. \uf0b7 En la informaci\u00f3n para periodistas en la sala de prensa. CAPITULO 2 \u2013 MARCO CONCEPTUAL 23 \uf0b7 En los contenidos para profesionales de bibliotecas, archivos y museos (Padicat, 2011). \u00bfQu\u00e9 es padicat? PADICAT (Patrimoni Digital de Catalunya) es una iniciativa de la Biblioteca de Catalunya para capturar, preservar y difundir el archivo web de Catalu\u00f1a. La Biblioteca de Catalunya, responsable de capturar, conservar y difundir el patrimonio bibliogr\u00e1fico de Catalu\u00f1a, y por extensi\u00f3n el patrimonio digital, cuenta con la colaboraci\u00f3n tecnol\u00f3gica del Centre de Serveis Cient\u00edfics i Acad\u00e8mics de Catalunya (CESCA) para preservar y dar acceso a versiones antiguas de p\u00e1ginas web publicadas en Internet, des de 2005 (Padicat, 2011). Misi\u00f3n y Objetivos La misi\u00f3n del PADICAT es capturar, conservar y difundir el patrimonio digital de Catalu\u00f1a nacido en Internet. El sistema se basa en la aplicaci\u00f3n de una serie de programas inform\u00e1ticos que permiten la captura, el almacenamiento, la organizaci\u00f3n y el acceso permanente a las p\u00e1ginas web publicadas en Internet. Sus objetivos son: \uf0b7 Compilar masivamente el dominio .cat. \uf0b7 Impulsar el dep\u00f3sito sistem\u00e1tico de la producci\u00f3n web de las entidades y las empresas de Catalu\u00f1a. \uf0b7 Promover l\u00edneas de investigaci\u00f3n procesando de manera monogr\u00e1fica los recursos de eventos de la vida p\u00fablica catalana, como campa\u00f1as electorales en Internet, el fen\u00f3meno de la m\u00fasica en l\u00ednea, o los museos en Internet. CAPITULO 2 \u2013 MARCO CONCEPTUAL 24 Despu\u00e9s de unas etapas de nacimiento (2005-2006), crecimiento (2007-2008) y consolidaci\u00f3n (2009-2011), a partir del 2012 se persigue sistematizar la capacidad de crecimiento con la meta de incorporar anualmente unas 75.700 versiones de aproximadamente 32.000 p\u00e1ginas web, procedentes de: \uf0b7 Compilaci\u00f3n semestral de 30.000 recursos del dominio .cat. \uf0b7 Compilaci\u00f3n semestral de 550 recursos de las 450 entidades con las que se ha llegado a un convenio de cooperaci\u00f3n. \uf0b7 Compilaci\u00f3n semestral de los 800 recursos procedentes de recomendaciones de los usuarios. \uf0b7 Compilaci\u00f3n \u00fanica de 1.000 recursos de colecciones monogr\u00e1ficas. \uf0b7 Compilaci\u00f3n diaria de una parte sustancial de 30 publicaciones seriadas en l\u00ednea. A estas metas concretas se a\u00f1aden cuatro ejes permanentes de trabajo: \uf0b7 Definici\u00f3n de las estrategias de preservaci\u00f3n digital para el patrimonio nacido en Internet. PADICAT proporciona radiograf\u00edas peri\u00f3dicas de la web catalana; detecta los formatos que experimentan a corto plazo problemas de ilegibilidad; identifica los lenguajes m\u00e1s usados, etc. \uf0b7 Impulso a l\u00edneas de investigaci\u00f3n a partir de la creaci\u00f3n de colecciones monogr\u00e1ficas que cuentan con la implicaci\u00f3n de expertos de cada materia. \uf0b7 Creaci\u00f3n y mantenimiento de la hemeroteca digital en Internet, con la captura sistematizada de publicaciones digitales en serie. Actualmente, con una muestra representativa en cuanto a tipos y contenidos, seleccionando las nacidas digitales, sin equivalente anal\u00f3gico. \uf0b7 Cooperaci\u00f3n con otros archivos web y dep\u00f3sitos de preservaci\u00f3n digital, de bibliotecas, archivos y museos, para dar una respuesta eficiente a los retos de preservaci\u00f3n digital y acceso a los recursos depositados (Padicat, 2011). CAPITULO 2 \u2013 MARCO CONCEPTUAL 25 2.2.2.3 Pandora Archivo Web de Australia El proyecto est\u00e1 liderado por la National Library of Australia (Australia). Se inicia en el a\u00f1o 1996 y sigue el modelo selectivo. Su alcance se centra en la selecci\u00f3n de publicaciones en l\u00ednea y webs sobre Australia, de autor australiano o sobre tema australiano. La catalogaci\u00f3n es exhaustiva y les posibilidades de b\u00fasqueda, muy avanzadas. Dispone de un software propio, Pandas, que se ha implementado en otros proyectos. El archivo web de Australia, Pandora, fue creado en 1996 por la National Library of Australia para garantizar el acceso permanente a una selecci\u00f3n de publicaciones en l\u00ednea y sedes web de y sobre Australia. A falta de una ley que regule el dep\u00f3sito legal digital (la vigente es de 1968), la pol\u00edtica de la biblioteca y los socios de proyecto, que forman el comit\u00e9 cient\u00edfico de la pol\u00edtica selectiva, es llegar a acuerdos con las entidades editoras de los documentos susceptibles de ser capturados. Existe una gu\u00eda publicada con los criterios de selecci\u00f3n de las sedes capturadas. Los datos estad\u00edsticos de septiembre de 2005 muestran que el archivo contiene 27 millones de ficheros y tiene un crecimiento mensual de 30 GB. Es consultable en l\u00ednea. Los inconvenientes del sistema australiano est\u00e1n relacionados con su propia naturaleza: el criterio de la selecci\u00f3n es forzosamente subjetivo, pese a la transparencia de la pol\u00edtica de selecci\u00f3n. El contexto (los enlaces a los cuales apunta el recurso), quedan desligados del documento, porque pueden no estar incluidos en la selecci\u00f3n. Finalmente, el coste de tratamiento (selecci\u00f3n, captura peri\u00f3dica, catalogaci\u00f3n, etc.) de cada \u00edtem es muy elevado. Por contra, los beneficios se concentran en la calidad del tratamiento y la presentaci\u00f3n del patrimonio. La accesibilidad en l\u00ednea, en abierto, es posible por los acuerdos subscritos con los productores (que comporta el acceso a los recursos de la infranet). Los datos de la catalogaci\u00f3n son compartibles con el resto de equipamientos CAPITULO 2 \u2013 MARCO CONCEPTUAL 26 australianos (o internacionales). Se procura un crecimiento tem\u00e1tico equilibrado de la colecci\u00f3n. Vistos los modelos integral y selectivo, la tercera v\u00eda a considerar es la mixta. Como se ha mencionado, buena parte de los dep\u00f3sitos digitales nacionales planteados inicialmente como integrales han ido adoptando medidas para incluir recursos muy significativos, como publicaciones peri\u00f3dicas, en sus fondos (Fonollosa, 2005). 2.3 Almacenes de Datos El t\u00e9rmino Almacenes de Datos fue introducido por Bill Inmon a principios de la d\u00e9cada de los \u00b490, quien lo defini\u00f3 como: \u201cEs una colecci\u00f3n de datos orientado a temas, integrado, variable en el tiempo y no vol\u00e1til para ayudar al proceso de toma de decisiones gerenciales\u201d. Tambi\u00e9n Ralph Kimball define Almacenes de Datos de una forma m\u00e1s sencilla y pr\u00e1ctica pero igual de importante: \u201cEs una copia de los datos transaccionales espec\u00edficamente estructurados para consultas y an\u00e1lisis\u201d. Un Almac\u00e9n de Datos es una base de datos orientada al an\u00e1lisis de la informaci\u00f3n hist\u00f3rica contenida en ella. Dependiendo las necesidades de an\u00e1lisis de la organizaci\u00f3n puede almacenarse desde unos meses hasta varios a\u00f1os de informaci\u00f3n. El modelo que soporta la informaci\u00f3n que contiene se encuentra dise\u00f1ado, estructurado e implementado con la finalidad y prop\u00f3sito del an\u00e1lisis y navegaci\u00f3n de los datos. Se entiende por navegaci\u00f3n de los datos, la posibilidad de ver informaci\u00f3n correspondiente a diferentes contextos o entornos, por ejemplo, analizar las ventas anuales, trimestrales, mensuales y poder \u201cabrirlas\u201d seg\u00fan zonas, vendedor o clientes (Bi-Argentina, 2008). CAPITULO 2 \u2013 MARCO CONCEPTUAL 27 2.3.1 Objetivos de los Almacenes de Datos 1. Hace que la informaci\u00f3n de la organizaci\u00f3n sea accesible: los contenidos de los Almacenes de Datos son entendibles y navegables, y el acceso a ellos son caracterizado por el r\u00e1pido desempe\u00f1o. Estos requerimientos no tienen fronteras y tampoco limites fijos. Cuando hablamos de entendible significa, que los niveles de la informaci\u00f3n sean correctos y obvios. Y Navegables significa el reconocer el destino en la pantalla y llegar a donde queramos con solo un clic. R\u00e1pido desempe\u00f1o significa, cero tiempos de espera. Todo lo dem\u00e1s es un compromiso y por consiguiente algo que queremos mejorar. 2. Hacer que la informaci\u00f3n de la organizaci\u00f3n sea consistente: la informaci\u00f3n de una parte de la organizaci\u00f3n puede hacerse coincidir con la informaci\u00f3n de la otra parte de la organizaci\u00f3n. Si dos medidas de la organizaci\u00f3n tienen el mismo nombre, entonces deben significar la misma cosa. Y a la inversa, si dos medidas no significan la misma cosa, entonces son etiquetados diferentes. Informaci\u00f3n consistente significa, informaci\u00f3n de alta calidad. Significa que toda la informaci\u00f3n es contabilizada y completada. Todo lo dem\u00e1s es un compromiso y por consiguiente algo que queremos mejorar. 3. Es informaci\u00f3n adaptable y el\u00e1stica: el Almac\u00e9n de Datos est\u00e1 dise\u00f1ado para cambios continuos. Cuando se le hacen nuevas preguntas al Almac\u00e9n de Datos, los datos existentes y las tecnolog\u00edas no cambian ni se corrompen. Cuando se agregan datos nuevos al Almac\u00e9n de Datos, los datos existentes y las tecnolog\u00edas tampoco cambian ni se corrompen. El dise\u00f1o de Data Marts separados que hacen al Almac\u00e9n de Datos, deben ser distribuidos e incrementados. Todo lo dem\u00e1s es un compromiso y por consiguiente algo que queremos mejorar. 4. Es un seguro baluarte que protege los valores de la informaci\u00f3n: el Almac\u00e9n de Datos no solamente controla el acceso efectivo a los datos, si no que da a los due\u00f1os de la informaci\u00f3n gran visibilidad en el uso y abusos de los datos, a\u00fan despu\u00e9s de haber dejado el Almac\u00e9n de Datos. Todo lo dem\u00e1s es un compromiso y por consiguiente algo que queremos mejorar. CAPITULO 2 \u2013 MARCO CONCEPTUAL 28 5. Es la fundaci\u00f3n de la toma de decisiones: el Almac\u00e9n de Datos tiene los datos correctos para soportar la toma de decisiones. Solo hay una salida verdadera del Almac\u00e9n de Datos: las decisiones que son hechas despu\u00e9s de que el Almac\u00e9n de Datos haya presentado las evidencias. La original etiqueta que preside el Almac\u00e9n de Datos sigue siendo la mejor descripci\u00f3n de lo que queremos construir: un sistema de soporte a las decisiones. (Herrera, 2007). 2.3.2 Caracter\u00edsticas de los Almacenes de Datos Orientado al tema: una primera caracter\u00edstica de los Almacenes de Datos es que la informaci\u00f3n se clasifica en base a los aspectos que son de inter\u00e9s para la empresa. Siendo as\u00ed, los datos tomados est\u00e1n en contraste con los cl\u00e1sicos procesos orientados a las aplicaciones. El ambiente operacional se dise\u00f1a alrededor de las aplicaciones y funciones tales como pr\u00e9stamos, ahorros, tarjeta bancaria y dep\u00f3sitos para una instituci\u00f3n financiera. Por ejemplo, una aplicaci\u00f3n de ingreso de \u00f3rdenes puede acceder a los datos sobre clientes, productos y cuentas. La base de datos combina estos elementos en una estructura que acomoda las necesidades de la aplicaci\u00f3n. En el ambiente de Almacenes de Datos se organiza alrededor de sujetos tales como cliente, vendedor, producto y actividad. Por ejemplo, para un fabricante, \u00e9stos pueden ser clientes, productos, proveedores y vendedores. Para una universidad pueden ser estudiantes, clases y profesores. Para un hospital pueden ser pacientes, personal m\u00e9dico, medicamentos, entre otros. La alineaci\u00f3n alrededor de las \u00e1reas de los temas afecta el dise\u00f1o y la implementaci\u00f3n de los datos encontrados en los Almacenes de Datos. Las principales \u00e1reas de los temas influyen en la parte m\u00e1s importante de la estructura clave. Las aplicaciones est\u00e1n relacionadas con el dise\u00f1o de la base de datos y del proceso. En el Almac\u00e9n de Datos se enfoca el modelamiento de datos y el dise\u00f1o de la base de datos. El dise\u00f1o del proceso (en su forma cl\u00e1sica) no es separado de este ambiente. CAPITULO 2 \u2013 MARCO CONCEPTUAL 29 Las diferencias entre la orientaci\u00f3n de procesos y funciones de las aplicaciones y la orientaci\u00f3n a temas (ver figura 2), radican en el contenido de la data a escala detallada. En los Almacenes de Datos se excluye la informaci\u00f3n que no ser\u00e1 usada por el proceso de sistemas de soporte de decisiones, mientras que la informaci\u00f3n de las orientadas a las aplicaciones, contiene datos para satisfacer de inmediato los requerimientos funcionales y de proceso, que pueden ser usados o no por el analista de soporte de decisiones. Otra diferencia importante est\u00e1 en la interrelaci\u00f3n de la informaci\u00f3n. Los datos operacionales mantienen una relaci\u00f3n continua entre dos o m\u00e1s tablas basadas en una regla comercial que est\u00e1 vigente. Las de los Almacenes de Datos miden un espectro de tiempo y las relaciones encontradas en el Almac\u00e9n de Datos son muchas. Muchas de las reglas comerciales (y sus correspondientes relaciones de datos) se representan en el Almac\u00e9n de Datos, entre dos o m\u00e1s tablas (Herrera, 2007). CAPITULO 2 \u2013 MARCO CONCEPTUAL 30 Figura 2 \u2013 Almacenes de Datos Orientados a Temas Integrado: el aspecto m\u00e1s importante del ambiente de Almacenes de Datos es que la informaci\u00f3n encontrada al interior est\u00e1 siempre integrada. La integraci\u00f3n de datos se muestra de muchas maneras: en convenciones de nombres consistentes, en la medida uniforme de variables, en la codificaci\u00f3n de estructuras consistentes, en atributos f\u00edsicos de los datos consistentes, fuentes m\u00faltiples y otros. El contraste de la integraci\u00f3n encontrada en los Almac\u00e9n de Datos con la carencia de integraci\u00f3n del ambiente de aplicaciones, se muestran en la figura 3, con diferencias bien marcadas. CAPITULO 2 \u2013 MARCO CONCEPTUAL 31 A trav\u00e9s de los a\u00f1os, los dise\u00f1adores de las diferentes aplicaciones han tomado sus propias decisiones sobre c\u00f3mo se deber\u00eda construir una aplicaci\u00f3n. Los estilos y dise\u00f1os personalizados se muestran de muchas maneras. Se diferencian en la codificaci\u00f3n, en las estructuras claves, en sus caracter\u00edsticas f\u00edsicas, en las convenciones de nombramiento y otros. La capacidad colectiva de muchos de los dise\u00f1adores de aplicaciones, para crear aplicaciones inconsistentes, es asombrosa. \uf0b7 Codificaci\u00f3n. Los dise\u00f1adores de aplicaciones codifican el campo G\u00c9NERO en varias formas. Un dise\u00f1ador representa G\u00c9NERO como una \"M\" y una \"F\", otros como un \"1\" y un \"0\", otros como una \"X\" y una \"Y\" e inclusive, como \"masculino\" y \"femenino\". No importa mucho c\u00f3mo el G\u00c9NERO llega al Almac\u00e9n de Datos. Probablemente \"M\" y \"F\" sean tan buenas como cualquier otra representaci\u00f3n. Lo importante es que sea de cualquier fuente de donde venga, el G\u00c9NERO debe llegar al Almac\u00e9n de Datos en un estado integrado uniforme. Por lo tanto, cuando el G\u00c9NERO se carga en el Almac\u00e9n de Datos desde una aplicaci\u00f3n, donde ha sido representado en formato \"M\" y \"F\", los datos deben convertirse al formato del Almac\u00e9n de Datos. \uf0b7 Medida de atributos. Los dise\u00f1adores de aplicaciones miden las unidades de medida de las tuber\u00edas en una variedad de formas. Un dise\u00f1ador almacena los datos de tuber\u00edas en cent\u00edmetros, otros en pulgadas, otros en millones de pies c\u00fabicos por segundo y otros en yardas. Al dar medidas a los atributos, la transformaci\u00f3n traduce las diversas unidades de medida usadas en las diferentes bases de datos para transformarlas en una medida est\u00e1ndar com\u00fan. Cualquiera que sea la fuente, cuando la informaci\u00f3n de la tuber\u00eda llegue al Almac\u00e9n de Datos necesitar\u00e1 ser medida de la misma manera. \uf0b7 Convenciones de Nombramiento. El mismo elemento es frecuentemente referido por nombres diferentes en las diversas aplicaciones. El proceso de transformaci\u00f3n asegura que se use preferentemente el nombre de usuario. CAPITULO 2 \u2013 MARCO CONCEPTUAL 32 \uf0b7 Fuentes M\u00faltiples. El mismo elemento puede derivarse desde fuentes m\u00faltiples. En este caso, el proceso de transformaci\u00f3n debe asegurar que la fuente apropiada sea usada, documentada y movida al dep\u00f3sito. Los puntos de integraci\u00f3n afectan casi todos los aspectos de dise\u00f1o - las caracter\u00edsticas f\u00edsicas de los datos, la disyuntiva de tener m\u00e1s de una de fuente de datos, el problema de est\u00e1ndares de denominaci\u00f3n inconsistentes, formatos de fecha inconsistentes y otros. Cualquiera que sea la forma del dise\u00f1o, el resultado es el mismo, la informaci\u00f3n necesita ser almacenada en el Almac\u00e9n de Datos en un modelo globalmente aceptable y singular, aun cuando los sistemas operacionales subyacentes almacenen los datos de manera diferente. Cuando el analista de sistema de soporte de decisiones observe el Almac\u00e9n de Datos, su enfoque deber\u00e1 estar en el uso de los datos que se encuentre en el dep\u00f3sito, antes que preguntarse sobre la confiabilidad o consistencia de los datos (Herrera, 2007). CAPITULO 2 \u2013 MARCO CONCEPTUAL 33 Figura 3 - Almacenes de Datos Integraci\u00f3n Variable en el tiempo: los datos son relativos a un periodo de tiempo y estos deben ser integrados peri\u00f3dicamente, los mismos son almacenados como fotos que se corresponden a un periodo de tiempo. Toda la informaci\u00f3n del Almac\u00e9n de Datos es requerida en alg\u00fan momento. Esta caracter\u00edstica b\u00e1sica de los datos en un dep\u00f3sito, es muy diferente de la informaci\u00f3n encontrada en el ambiente operacional. En \u00e9stos, la informaci\u00f3n se requiere al momento de acceder. En otras palabras, en el ambiente operacional, cuando se accede a una unidad de informaci\u00f3n, se espera que los valores requeridos se obtengan a partir del momento de acceso. CAPITULO 2 \u2013 MARCO CONCEPTUAL 34 Como la informaci\u00f3n en el Almac\u00e9n de Datos es solicitada en cualquier momento (es decir, no \"ahora mismo\"), los datos encontrados en el dep\u00f3sito se llaman de \"tiempo variante\". Los datos hist\u00f3ricos son de poco uso en el procesamiento operacional. La informaci\u00f3n del dep\u00f3sito por el contraste, debe incluir los datos hist\u00f3ricos para usarse en la identificaci\u00f3n y evaluaci\u00f3n de tendencias. El tiempo variante se muestra de varias maneras (ver Figura 4): \uf0b7 La m\u00e1s simple es que la informaci\u00f3n representa los datos sobre un horizonte largo de tiempo, desde cinco a diez a\u00f1os. El horizonte de tiempo representado para el ambiente operacional es mucho m\u00e1s corto, desde valores actuales hasta sesenta a noventa d\u00edas. Las aplicaciones que tienen un buen rendimiento y est\u00e1n disponibles para el procesamiento de transacciones, deben llevar una cantidad m\u00ednima de datos si tienen cualquier grado de flexibilidad. Por ello, las aplicaciones operacionales tienen un corto horizonte de tiempo, debido al dise\u00f1o de aplicaciones r\u00edgidas. \uf0b7 La segunda manera en la que se muestra el tiempo variante en el Almac\u00e9n de Datos est\u00e1 en la estructura clave. Cada estructura clave en el Almac\u00e9n de Datos contiene, impl\u00edcita o expl\u00edcitamente, un elemento de tiempo como d\u00eda, semana, mes, etc. El elemento de tiempo est\u00e1 casi siempre al pie de la clave concatenada, encontrada en el Almac\u00e9n de Datos. En ocasiones, el elemento de tiempo existir\u00e1 impl\u00edcitamente, como el caso en que un archivo completo se duplica al final del mes, o al cuarto. \uf0b7 La tercera manera en que aparece el tiempo variante es cuando la informaci\u00f3n del Almac\u00e9n de Datos, una vez registrada correctamente, no puede ser actualizada. La informaci\u00f3n del Almac\u00e9n de Datos es, para todos los prop\u00f3sitos pr\u00e1cticos, una serie larga de \"snapshots\" (vistas instant\u00e1neas). Por supuesto, si los snapshots de los datos se han tomado incorrectamente, entonces pueden ser cambiados. Asumiendo que los snapshots se han tomado adecuadamente, ellos no son CAPITULO 2 \u2013 MARCO CONCEPTUAL 35 alterados una vez hechos. En algunos casos puede ser no \u00e9tico, e incluso ilegal, alterar los snapshots en el Almac\u00e9n de Datos. Los datos operacionales, siendo requeridos a partir del momento de acceso, pueden actualizarse de acuerdo a la necesidad (Herrera, 2007). Figura 4 - Almacenes de Datos Variable en el Tiempo No vol\u00e1til: los datos que son almacenados no sufren ninguna actualizaci\u00f3n solo son incrementados. El per\u00edodo cubierto para un Almac\u00e9n de Datos va de 2 a 10 a\u00f1os. La informaci\u00f3n es \u00fatil s\u00f3lo cuando es estable. Los datos operacionales cambian sobre una base momento a momento. La perspectiva m\u00e1s grande, esencial para el an\u00e1lisis y la toma de decisiones, requiere una base de datos estable. Hay algunas consecuencias muy importantes de esta diferencia b\u00e1sica, entre el procesamiento operacional y del Almac\u00e9n de Datos. En el nivel de dise\u00f1o, la necesidad de CAPITULO 2 \u2013 MARCO CONCEPTUAL 36 ser precavido para actualizar las anomal\u00edas no es un factor en el Almac\u00e9n de Datos, ya que no se hace la actualizaci\u00f3n de datos (ver figura 5). Esto significa que en el nivel f\u00edsico de dise\u00f1o, se pueden tomar libertades para optimizar el acceso a los datos, particularmente al usar la normalizaci\u00f3n y des normalizaci\u00f3n f\u00edsica. Otra consecuencia de la simplicidad de la operaci\u00f3n del Almac\u00e9n de Datos est\u00e1 en la tecnolog\u00eda subyacente, utilizada para correr los datos en el dep\u00f3sito. Teniendo que soportar la actualizaci\u00f3n de registro por registro en modo on-line (como es frecuente en el caso del procesamiento operacional) requiere que la tecnolog\u00eda tenga un fundamento muy complejo debajo de una fachada de simplicidad (Herrera, 2007). Figura 5 - Almacenes de Datos No Vol\u00e1til 2.3.3 Proceso ETL (Extracci\u00f3n, Transformaci\u00f3n y Carga) Se define como el proceso a trav\u00e9s del cual se gestionan datos obtenidos de m\u00faltiples fuentes, con el fin de recolectarlos, limpiarlos y cargarlos en Bases de Datos Especializadas, denominadas Almacenes de Datos, para analizar y apoyar una determinada L\u00ednea de Producto o Unidad de Negocios (Inteligencias de Negocios, 2009). CAPITULO 2 \u2013 MARCO CONCEPTUAL 37 Extracci\u00f3n: el inicio de una Estrategia ETL consiste en adquirir o sustraer los datos brutos desde los Sistemas de Origen; es, en esencia, un proceso de almacenamiento masivo de datos, capaz de integrar, en una misma Metodolog\u00eda de Negocios, toda la informaci\u00f3n empresarial proveniente de diferentes fuentes; de hecho, cada sistema por separado organiza sus datos de diversas maneras. Los formatos de las fuentes de datos brutos, por lo general, se ubican en Bases de Datos Relacionales o lo que se denomina como Ficheros Planos; no obstante, pueden incluir Bases de Datos No Relacionales u otras Estructuras de Datos diferentes. La Extracci\u00f3n convierte los datos a un Formato Est\u00e1ndar, con el cual se inicia el Proceso de Transformaci\u00f3n. Una parte intr\u00ednseca del proceso de extracci\u00f3n es la de analizar los datos extra\u00eddos, de lo cual resulta un chequeo que verifica si los datos cumplen con las pautas estipuladas y se adaptan al formato est\u00e1ndar dise\u00f1ado. De no ser as\u00ed, los datos son rechazados. La Tarea de Extracci\u00f3n debe causar un impacto m\u00ednimo en el sistema origen. Si los datos a extraer son muchos, el sistema de origen se podr\u00eda ralentizar e incluso colapsar; provocando que \u00e9ste no pueda implementarse con normalidad para su uso cotidiano. Por esta raz\u00f3n, en sistemas grandes las operaciones de extracci\u00f3n suelen programarse en horarios o d\u00edas donde este impacto sea nulo o m\u00ednimo (Inteligencias de Negocios, 2009). Transformaci\u00f3n: en esta fase se aplican una serie de Procedimientos de Negocios sobre los datos extra\u00eddos, con el objeto de convertirlos en datos aptos para ser cargados. Algunas fuentes de datos, requerir\u00e1n una peque\u00f1a manipulaci\u00f3n de los mismos, no obstante, en otros casos, puede ser necesario aplicar algunas transformaciones espec\u00edficas m\u00ednimo (Inteligencias de Negocios, 2009). Carga: la fase de carga es el momento cuando los datos, provenientes de la fase anterior, son incluidos en el sistema de destino. Dependiendo de los requerimientos de la organizaci\u00f3n, este proceso puede abarcar una amplia variedad de acciones diferentes; en algunas bases de datos, se sobrescribe la informaci\u00f3n antigua con nuevos datos; el Almac\u00e9n de Datos, por ejemplo, mantienen un historial de los registros de manera que se CAPITULO 2 \u2013 MARCO CONCEPTUAL 38 pueda hacer una auditor\u00eda de los mismos y disponer de un rastro del comportamiento de un determinado valor a lo largo del tiempo. Existen dos formas b\u00e1sicas de desarrollar el Proceso de Carga: la primera es la denominada Acumulaci\u00f3n simple, la cual consiste en realizar un resumen de todas las transacciones comprendidas en el per\u00edodo de tiempo seleccionado y transportar el resultado como una \u00fanica transacci\u00f3n hacia el Almac\u00e9n de Datos; almacenando siempre un Valor Calculado que expresa el promedio de la magnitud considerada. La segunda forma de Proceso de Carga es el Rolling que se aplica en los casos en los cuales se almacena informaci\u00f3n resumida a distintos niveles, correspondientes a distintas agrupaciones de la unidad de tiempo o diferentes niveles jer\u00e1rquicos, en alguna o varias de las dimensiones de la magnitud almacenada, por ejemplo, totales diarios, totales semanales, etc. La fase de carga interact\u00faa directamente con la base de datos de destino. Al realizar esta operaci\u00f3n se aplicar\u00e1n todas las restricciones que se hayan definido en \u00e9sta, por ejemplo, valores \u00fanicos, integridad referencial, campos obligatorios, rangos de valores. Estas restricciones est\u00e1n bien definidas, en tanto garantizan la calidad de los datos en el Proceso ETL (Inteligencias de Negocios, 2009). El Proceso ETL se puede observar en la figura 6. CAPITULO 2 \u2013 MARCO CONCEPTUAL 39 Figura 6 - Proceso ETL 2.3.4 Dise\u00f1o de un Almac\u00e9n de Datos Con la vista puesta de entrar en detalle a hablar sobre el dise\u00f1o de un Almac\u00e9n de Datos, vamos a definir conceptos b\u00e1sicos: tabla de hecho, dimensi\u00f3n y m\u00e9trica. Si bien en las estructuras relacionales existentes en nuestras bases de datos transaccionales tenemos que crear un dise\u00f1o l\u00f3gico siguiendo las formas normales, en el Almac\u00e9n de Datos no debe seguirse ese patr\u00f3n de dise\u00f1o. La idea principal es que la informaci\u00f3n sea presentada des normalizada para optimizar la consultas. Para ello debemos identificar en el seno de la organizaci\u00f3n, los procesos de negocio, las vistas para el proceso de negocio y medidas cuantificables asociadas a los mismos. De esta manera hablaremos de: \uf0b7 Tabla de hecho: es la representaci\u00f3n en el Almac\u00e9n de Datos de los procesos de negocio de la organizaci\u00f3n. Por ejemplo, una venta puede identificarse como un proceso de negocio de manera que es factible, si corresponde en nuestra organizaci\u00f3n, considerar la tabla de hecho ventas. CAPITULO 2 \u2013 MARCO CONCEPTUAL 40 \uf0b7 Dimensi\u00f3n: es la representaci\u00f3n en el Almac\u00e9n de Datos de una vista para un cierto proceso de negocio. Si regresamos al ejemplo de una venta, para la misma tenemos el cliente que ha comprado, la fecha en la que se ha realizado, etc. Estos conceptos pueden ser considerados como vistas para este proceso de negocio. Puede ser interesante recuperar todas las compras realizadas por un cliente. Ello nos hace entender por qu\u00e9 la identificamos como una dimensi\u00f3n. \uf0b7 M\u00e9trica: son los indicadores de negocio de un proceso de negocio. Aquellos conceptos cuantificables que permiten medir nuestro proceso de negocio. Por ejemplo, en una venta tenemos el importe de la misma (Curto, 2007). 2.3.5 Tipos de Almacenes de Datos En base a lo presentado en (Curto, 2007) se tiene que los tipos de Almacenes de Datos son: Esquema en estrella: consiste en estructurar la informaci\u00f3n en procesos, vistas y m\u00e9tricas recordando a una estrella (ver figura 7). Es decir, tendremos una visi\u00f3n multidimensional de un proceso que medimos a trav\u00e9s de unas m\u00e9tricas. A nivel de dise\u00f1o, consiste en una tabla de hechos (lo que en los algunos libros se llamara como fact table) en el centro para el hecho objeto de an\u00e1lisis y una o varias tablas de dimensi\u00f3n (dimension table) por cada dimensi\u00f3n de an\u00e1lisis que participa de la descripci\u00f3n de ese hecho. En la tabla de hecho encontramos los atributos destinados a medir (cuantificar) el hecho: sus m\u00e9tricas. Mientras, en las tablas de dimensi\u00f3n, los atributos se destinan a elementos de nivel (que representan los distintos niveles de las jerarqu\u00edas de dimensi\u00f3n) y a atributos de dimensi\u00f3n (encargados de la descripci\u00f3n de estos elementos de nivel). En el esquema en estrella la tabla de hechos es la \u00fanica tabla del esquema que tiene m\u00faltiples joins que la conectan con otras tablas (foreign keys hacia otras tablas). El resto de tablas del esquema (tablas de dimensi\u00f3n) \u00fanicamente hacen join con esta tabla de hechos. Las tablas de dimensi\u00f3n se encuentran adem\u00e1s totalmente de normalizadas, es decir, toda la informaci\u00f3n referente a una dimensi\u00f3n se almacena en la misma tabla. CAPITULO 2 \u2013 MARCO CONCEPTUAL 41 Figura 7 - Modelo Estrella (Almacenes de Datos) Esquema en copo de nieve: El esquema en copo de nieve es un esquema de representaci\u00f3n derivado del esquema en estrella, en el que las tablas de dimensi\u00f3n se normalizan en m\u00faltiples tablas (ver figura 8). Por esta raz\u00f3n, la tabla de hechos deja de ser la \u00fanica tabla del esquema que se relaciona con otras tablas, y aparecen nuevas joins gracias a que las dimensiones de an\u00e1lisis se representan ahora en tablas de dimensi\u00f3n normalizadas. En la estructura dimensional normalizada, la tabla que representa el nivel base de la dimensi\u00f3n es la que hace join directamente con la tabla de hechos. La diferencia entre ambos esquemas (estrella y copo de nieve) reside entonces en la estructura de las tablas de dimensi\u00f3n. Para conseguir un esquema en copo de nieve se ha de tomar un esquema en estrella y conservar la tabla de hechos, centr\u00e1ndose \u00fanicamente en el modelado de las tablas de dimensi\u00f3n, que si bien en el esquema en estrella se encontraban totalmente de normalizadas, ahora se dividen en sub-tablas tras un proceso de normalizaci\u00f3n. Es posible distinguir dos tipos de esquemas en copo de nieve, un esquema copo de nieve completo (en el que todas las tablas de dimensi\u00f3n en el esquema en estrella aparecen ahora normalizadas en el esquema copo de nieve) o un esquema copo de nieve parcial (s\u00f3lo se lleva a cabo la normalizaci\u00f3n de algunas de ellas). (Curto, 2007) CAPITULO 2 \u2013 MARCO CONCEPTUAL 42 Figura 8 - Modelo Copo de Nieve (Almacenes de Datos) 2.3.6 Diferencia entre una Base de Datos Operacional y un Almac\u00e9n de Datos En un Almac\u00e9n de Datos se almacena toda la informaci\u00f3n de inter\u00e9s para una organizaci\u00f3n que luego queramos analizar, mientras que, en una base de datos operacional se almacenan todas las transacciones de la organizaci\u00f3n, tanto datos \u00fatiles como no \u00fatiles. (Buigues, 2012) En la figura 9 podemos ver qu\u00e9 se diferencian una base de datos operacional de un Almac\u00e9n de Datos CAPITULO 2 \u2013 MARCO CONCEPTUAL 43 Figura 9 - Diferencias entre una Base de Datos Operacional y un Almac\u00e9n de Datos CAPITULO 3 \u2013 MARCO TECNOL\u00d3GICO 44 CAPITULO 3 - MARCO TECNOL\u00d3GICO 3.1 MonetDB Es un manejador de Base de Datos Orientados a Columnas que mejora la velocidad de las bases de datos XQuery y SQL bajo las reglas del Sistema Administrador de Base de Datos Su objetivo es introducir innovaciones en todas las capas de un DBMS, por ejemplo, un modelo del almacenamiento basado en la fragmentaci\u00f3n vertical, una arquitectura moderna de la ejecuci\u00f3n de las consultas, unos \u00edndices autom\u00e1ticos y configurables, una optimizaci\u00f3n del tiempo de ejecuci\u00f3n de las consultas y una arquitectura modular del programa (Softpedia, 2007). 3.1.1 Caracter\u00edsticas SQL: \uf0b7 Es basado en el core est\u00e1ndar de SQL\u201999 incluyendo soporte para claves for\u00e1neas, consultas anidadas y vistas. \uf0b7 Soporta M\u00f3dulos de almacenamiento persistente, triggers y funciones definidas por el usuario escrito en el lenguaje C. \uf0b7 Soporta tipos de secuencias del est\u00e1ndar SQL\u201903. \uf0b7 Soporta aplicaciones geogr\u00e1ficas con el est\u00e1ndar OPEN-SIG. \uf0b7 Soporta la mayor\u00eda del est\u00e1ndar del SQL/XML. Paquetes del software MONETDB: \uf0b7 El c\u00f3digo fuente del Kernel est\u00e1 escrito en ANSI-C y compatible con POSIX. \uf0b7 La librer\u00eda de c\u00f3digos fuentes cumple con las \u00faltimas versiones del lenguaje. \uf0b7 El c\u00f3digo fuente est\u00e1 escrito en un estilo de programaci\u00f3n literal, para estimular la proximidad del c\u00f3digo y su documentaci\u00f3n. CAPITULO 3 \u2013 MARCO TECNOL\u00d3GICO 45 \uf0b7 El c\u00f3digo fuente fue compilado y testeado con muchas opciones de compilaci\u00f3n en distintas plataforma para asegurar la portabilidad. Servidor MonetDB: \uf0b7 Un total esquema de almacenamiento descompuesto usando mapeo de archivos en memoria. \uf0b7 Soporta base de datos escalables en plataforma de 32bits y 64bits. \uf0b7 La conectividad se puede realizar a trav\u00e9s de TCP/IP, SSH y otras conocidas. \uf0b7 Selecci\u00f3n, creaci\u00f3n y mantenimiento de los \u00edndices es de manera autom\u00e1tica. \uf0b7 Los operadores relacionales materializan sus resultados y se auto optimizan. \uf0b7 El back-end de la base de datos es multi-hilos y guarda una instancia f\u00edsica de la base de datos. Otras Caracter\u00edsticas importante: \uf0b7 Es un sistema manejador de base de datos de alto rendimiento: MonetDB es un c\u00f3digo abierto DBMS de f\u00e1cil acceso para aplicaciones en base a SQL y base de datos para proyectos de investigaci\u00f3n. \uf0b7 Es un sistema de multi-modelos: MonetDB soporta m\u00faltiples lenguajes de consultas a parte de su lenguaje propio, llamado MonetDB Assembly Language (MAL) que apunta a ANSI SQL-2003 y W3C Xquery con facilidades de actualizaci\u00f3n. El sistema est\u00e1 dise\u00f1ado para proveer una base com\u00fan entre los dos lenguajes y prepara un soporte para lenguajes en base a otro modelo de datos. \uf0b7 Es un Kernel de base de datos almacenados por columnas: MonetDB y hecho en una representaci\u00f3n canon\u00edca de los elementos de la base de datos, llamado Binary Assciation Tables (BATs), MonetDB es una de las principales manejadores de base de datos que usan almacenamiento por columnas, un BAT es usado por cada columna de una tabla. La p\u00e1ginaci\u00f3n en la memoria es sustituida por una que utiliza el sistema BAT que puede intercambiar cientos de megas en la memoria cuando es necesario. CAPITULO 3 \u2013 MARCO TECNOL\u00d3GICO 46 \uf0b7 Un sistema de Base de Datos: MonetDB est\u00e1 en continuo desarrollo para soportar m\u00e1s aplicaciones de distintos campos, se est\u00e1 proyectando para el uso de grandes Base de Datos cuando antes se usaba para puros productos CRM. \uf0b7 Es un software de c\u00f3digo abierto (MonetDB). 3.2 MongoDB MongoDB es una Base de Datos No Relacional Basada en Documentos, as\u00ed no se usa las tablas y relaciones entre tablas, en MongoDB lo m\u00e1s parecido que encontraremos a una tabla son las colecciones, que vienen a ser una especie de listas donde vamos almacenando los diferentes objetos y sus atributos. Se abandona el enfoque relacional por bases de datos m\u00e1s orientadas a objetos y de esta manera es como se procesa la informaci\u00f3n (Ubuntu Life, 2010). \u00bfBase de Datos No Relacional Basada en Documentos? A estas alturas es extra\u00f1o toparse con alguien que no haya o\u00eddo hablar de las Base de Datos No Relacional Basada en Documentos. No obstante, no todos los desarrolladores habitualmente tienen claro el por qu\u00e9 de su popularidad, posiblemente debido a que no han tenido a\u00fan la oportunidad de trabajar con alguno de los sistemas que se basan en este concepto. En la carrera de la inform\u00e1tica, muchos han aprendido que los sistemas de bases de datos se clasifican mayormente en tres tipos: Las bases de datos relacionales, las orientadas a objetos, y las relacionales orientadas a objetos. Sin embargo, pronto uno se da cuenta que, en la pr\u00e1ctica, la mayor\u00eda de los motores de bases de datos m\u00e1s populares se basan en la arquitectura relacional, y todos ellos utilizan el lenguaje de consultas SQL (con variaciones) para operar con los datos. Tanto es as\u00ed, que SQL se convirti\u00f3 con el paso de los a\u00f1os en un est\u00e1ndar \u201cde facto\u201d, debido a su uso. (Paramio, 2011) Su mayor ventaja es que est\u00e1n preparados para ser muy r\u00e1pidos. Seg\u00fan su tipo, cada una sigue una estrategia completamente diferente para persistir la informaci\u00f3n. CAPITULO 3 \u2013 MARCO TECNOL\u00d3GICO 47 Cabe destacar que normalmente no sustituyen a la base de datos cl\u00e1sica SQL, sino que surgen por otra necesidad. Una necesidad de rendimiento extremo. Si se utilizan de una manera \u00fanica, o se combinan con una base de datos SQL es una decisi\u00f3n de arquitectura del sistema (P\u00e9rez, 2011). \u00bfPor qu\u00e9 aparecen los sistemas de Base de Datos No Relacional Basada en Documentos? Las bases de datos relacionales no tienen nada de malo: Precisamente gracias al transcurso de los a\u00f1os, se ha logrado aprender t\u00e9cnicas bastante comunes para normalizarlas en la medida de lo posible, escalarlas seg\u00fan crece la demanda, y utilizarlas como sistema de persistencia para almacenar informaci\u00f3n desde nuestro lenguaje procedural u orientado a objetos favorito (entre otros). La cuota de uso de software como SQLite, MySQL, PostgreSQL u Oracle, por poner cuatro ejemplos conocidos, es muy alta, encontr\u00e1ndose en la mayor parte de los desarrollos modernos. Pero lleg\u00f3 la web, el software como servicio, los servicios en la nube y las startups de \u00e9xito con millones de usuarios. Y con todo ello llegaron los problemas de alta escalabilidad. Si bien los modelos relacionales se pueden adaptar para hacerlos escalar incluso en los entornos m\u00e1s dif\u00edciles, s\u00ed que es cierto que, a menudo, se hacen cada vez menos intuitivos a medida que aumenta la complejidad. Triples y cu\u00e1druples joins en consultas SQL que asustan al m\u00e1s pintado nada m\u00e1s verlas, a veces poco eficientes, y sistemas de almacenamiento de resultados en cach\u00e9s para acelerar la resoluci\u00f3n de las peticiones y evitar ejecutar cada vez estas pesadas operaciones, son el pan de cada d\u00eda en muchos de estos proyectos de software. Los sistemas de Base de Datos No Relacional Basada en Documentos intentan atacar este problema proponiendo una estructura de almacenamiento m\u00e1s vers\u00e1til, aunque sea a costa de perder ciertas funcionalidades como las transacciones que engloban operaciones en m\u00e1s de una colecci\u00f3n de datos, o la incapacidad de ejecutar el producto cartesiano de dos tablas (tambi\u00e9n llamado JOIN) teniendo que recurrir a la des normalizaci\u00f3n de datos. CAPITULO 3 \u2013 MARCO TECNOL\u00d3GICO 48 \u00bfEn qu\u00e9 se diferencian exactamente? Si se tuviera que resumir las caracter\u00edsticas comunes en estos sistemas, se dir\u00eda que son principalmente tres: Ausencia de esquema en los registros de datos, escalabilidad horizontal sencilla, y velocidad (aunque esto \u00faltimo no siempre es cierto, pues muchos de estos sistemas a\u00fan no est\u00e1n suficientemente maduros). La primera caracter\u00edstica significa que los datos no tienen una definici\u00f3n de atributos fija, es decir: Cada registro (o documento, como se les suele llamar en estos casos) puede contener una informaci\u00f3n con diferente forma cada vez, pudiendo as\u00ed almacenar s\u00f3lo los atributos que interesen en cada uno de ellos, facilitando el polimorfismo de datos bajo una misma colecci\u00f3n de informaci\u00f3n. Tambi\u00e9n se pueden almacenar estructuras de datos complejas en un s\u00f3lo documento, como por ejemplo almacenar la informaci\u00f3n sobre una publicaci\u00f3n de un blog (t\u00edtulo, cuerpo de texto, autor, etc.) junto a los comentarios y etiquetas vertidos sobre el mismo, todo en un \u00fanico registro. Hacerlo as\u00ed aumenta la claridad (al tener todos los datos relacionados en un mismo bloque de informaci\u00f3n) y el rendimiento (no hay que hacer un JOIN para obtener los datos relacionados, pues \u00e9stos se encuentran directamente en el mismo documento). Con escalabilidad horizontal se refiere a la posibilidad de aumentar el rendimiento del sistema simplemente a\u00f1adiendo m\u00e1s nodos, sin necesidad en muchos casos de realizar ninguna otra operaci\u00f3n m\u00e1s que indicar al sistema cu\u00e1les son los nodos disponibles. Muchos sistemas De Base de Datos No Relacional Basada en Documentos permiten utilizar consultas del tipo Map-Reduce, las cuales pueden ejecutarse en todos los nodos a la vez (cada uno operando sobre una porci\u00f3n de los datos) y reunir luego los resultados antes de devolverlos al cliente. La gran mayor\u00eda permiten tambi\u00e9n indicar otras cosas como el n\u00famero de r\u00e9plicas en que se har\u00e1 una operaci\u00f3n de escritura, para garantizar la disponibilidad. Y gracias al sharding y a no tener que replicar todos los datos en cada uno de los nodos, la informaci\u00f3n que se mueve entre las distintas instancias del motor de base de datos no tiene por qu\u00e9 ser demasiado intensiva. Por supuesto, se seguir\u00e1 encontr\u00e1ndose con problemas de escalabilidad inherentes al tipo de software que CAPITULO 3 \u2013 MARCO TECNOL\u00d3GICO 49 estemos construyendo, pero seguramente se podr\u00e1 resolver m\u00e1s f\u00e1cilmente con la ayuda de estas caracter\u00edsticas. Por \u00faltimo, muchos de estos sistemas realizan operaciones directamente en memoria, y s\u00f3lo vuelcan los datos a disco cada cierto tiempo. Esto permite que las operaciones de escritura sean realmente r\u00e1pidas. Por supuesto, trabajar de este modo puede sacrificar f\u00e1cilmente la durabilidad de los datos, y en caso de cuelgue o apag\u00f3n se podr\u00edan perder operaciones de escritura o perder la consistencia. Normalmente, esto lo resuelven permitiendo que una operaci\u00f3n de escritura haya de realizarse en m\u00e1s de un nodo antes de darla por v\u00e1lida, o disminuyendo el tiempo entre volcado y volcado de datos a disco. Pero claro, a\u00fan as\u00ed, existe ese riesgo. (Paramio, 2011) 3.2.1 MongoDB: Descripci\u00f3n y licencia MongoDB es un sistema de base de datos multiplataforma orientado a documentos, de esquema libre. Como ya se explico, esto significa que cada entrada o registro puede tener un esquema de datos diferentes, con atributos o \u201ccolumnas\u201d que no tienen por qu\u00e9 repetirse de un registro a otro. Est\u00e1 escrito en C++, lo que le confiere cierta cercan\u00eda al bare metal, o recursos de hardware de la m\u00e1quina, de modo que es bastante r\u00e1pido a la hora de ejecutar sus tareas. Adem\u00e1s, est\u00e1 licenciado como GNU AGPL 3.0, de modo que se trata de un software de licencia libre. Funciona en sistemas operativos Windows, Linux, OS X y Solaris. Las caracter\u00edsticas que m\u00e1s destacar\u00eda de MongoDB son su velocidad y su completo pero sencillo sistema de consulta de los contenidos de la base de datos. Se podr\u00eda decir que alcanza un balance perfecto entre rendimiento y funcionalidad, incorporando muchos de los tipos de consulta que utilizar\u00edamos en nuestro sistema relacional preferido, pero sin sacrificar en rendimiento (Paramio, 2011). 3.2.2 Terminolog\u00eda b\u00e1sica en MongoDB En MongoDB, cada registro o conjunto de datos se denomina documento. Los documentos se pueden agrupar en colecciones, las cuales se podr\u00eda decir que son el equivalente a las tablas en una base de datos relacional (s\u00f3lo que las colecciones pueden CAPITULO 3 \u2013 MARCO TECNOL\u00d3GICO 50 almacenar documentos con muy diferentes formatos, en lugar de estar sometidos a un esquema fijo). Se pueden crear \u00edndices para algunos atributos de los documentos, de modo que MongoDB mantendr\u00e1 una estructura interna eficiente para el acceso a la informaci\u00f3n por los contenidos de estos atributos (Paramio, 2011). 3.2.3 Formato de los documentos en MongoDB Los distintos documentos se almacenan en formato BSON, o Binary JSON, que es una versi\u00f3n modificada de JSON que permite b\u00fasquedas r\u00e1pidas de datos. Para hacer una idea, BSON guarda de forma expl\u00edcita las longitudes de los campos, los \u00edndices de los arrays, y dem\u00e1s informaci\u00f3n \u00fatil para el escaneo de datos. Es por esto que, en algunos casos, el mismo documento en BSON ocupa un poco m\u00e1s de espacio de lo que ocupar\u00eda de estar almacenado directamente en formato JSON. Pero una de las ideas claves en los sistemas De Base de Datos No Relacional Basada en Documentos es que el almacenamiento es barato, y es mejor aprovecharlo si as\u00ed se introduce un considerable incremento en la velocidad de localizaci\u00f3n de informaci\u00f3n dentro de un documento. Sin embargo, en la pr\u00e1ctica, nunca se ver\u00e1 el formato en que verdaderamente se almacenan los datos, y trabajaremos siempre sobre un documento en JSON tanto al almacenar como al consultar informaci\u00f3n. Un ejemplo de un documento en MongoDB podr\u00eda ser c\u00f3mo se Muestra en la Figura 11: CAPITULO 3 \u2013 MARCO TECNOL\u00d3GICO 51 Figura 10 - Ejemplo de Formato de un Documento (MongoDB) Este documento pretende representar la manera en que podr\u00edan almacenarse los datos correspondientes a un post de un blog. Los atributos \u201c_id\u201d (o clave principal) pueden tener el formato que se desee, aunque MongoDB utiliza un valor parecido a un UUID en hexadecimal por defecto si no se ha especificado ninguno. A pesar de parecer un valor completamente aleatorio, utilizan como base una semilla basada en la MAC de la interfaz de red de la m\u00e1quina (y otros detalles de la misma) para evitar que dos m\u00e1quinas diferentes puedan generar el mismo valor para la clave de un documento. Y los primeros bytes corresponden a una marca de tiempo, de modo que las claves se ordenan de forma natural por orden de creaci\u00f3n (o casi, pues est\u00e1 claro que las distintas m\u00e1quinas corriendo MongoDB deben tener la fecha y hora sincronizadas) sin tener que mirar cu\u00e1l fue el \u00faltimo valor usado. Una soluci\u00f3n inteligente, es mucho m\u00e1s eficiente que un campo auto num\u00e9rico, en especial para evitar que una m\u00e1quina bloquee la inserci\u00f3n de registros en una colecci\u00f3n s\u00f3lo para asegurarse que no se dan condiciones de carrera al intentar CAPITULO 3 \u2013 MARCO TECNOL\u00d3GICO 52 dos m\u00e1quinas diferentes escribir un documento con el mismo valor para \u201c_id\u201d. Por cierto, este atributo \u201c_id\u201d es el \u00fanico obligatorio para un documento. Las etiquetas y los comentarios est\u00e1n en el propio documento que representa al post, en lugar de guardarlos en colecciones separadas y utilizar claves for\u00e1neas para referenciar a los mismos. Sin embargo, en el atributo \u201cliked_by\u201d s\u00ed que guardamos una relaci\u00f3n de claves, que corresponden a los usuarios que han marcado el post como que les ha gustado. Utilizar una forma u otra depender\u00e1 de las necesidades de acceso a estos datos En este caso, por ejemplo, se sabe que no se va a mostrar informaci\u00f3n sobre los usuarios que han marcado un post con un \u201cme gusta\u201d, pero s\u00ed queremos ver cu\u00e1ntos lo han marcado as\u00ed, o si el usuario actual ya lo ha marcado o no, con lo que almacenar \u00fanicamente las claves de esos usuarios y guardar su informaci\u00f3n personal detallada en otra colecci\u00f3n es lo m\u00e1s conveniente. Por supuesto, no es necesario pedir a MongoDB que nos devuelva todo el documento cada vez que lo consultamos. Si por ejemplo se va a mostrar \u00fanicamente un listado de posts recientes, seguramente sea suficiente obtener el atributo \u201ctitle\u201d, con los documentos ordenados por \u201cpublished_at\u201d. As\u00ed, ahorramos ancho de banda entre el motor de base de datos y la aplicaci\u00f3n, al mismo tiempo que memoria dado que no hay que instanciar todo el documento. Adem\u00e1s, si tenemos muchos miles de visitantes, el atributo \u201cliked_by\u201d podr\u00eda llegar a crecer bastante. A veces, toca des normalizar para poder tener a mano la informaci\u00f3n necesaria a la hora de mostrar un post. Es por eso que en el atributo \u201cauthor_info\u201d utiliza una versi\u00f3n intermedia: Si bien tenemos la clave principal del usuario que ha escrito este post, como es habitual que mostremos el nombre del autor, se ha almacenado tambi\u00e9n dicho nombre en el documento que representa al post, para que no sea necesario realizar una segunda consulta a la colecci\u00f3n \u201cusuarios\u201d. Estas des normalizaciones dependen nuevamente del uso que se den a los datos. En este caso, tengo claro que el nombre de un usuario no va a cambiar demasiado, as\u00ed que recorrer todos los posts para cambiar este valor en caso de que el usuario realice esta operaci\u00f3n, si bien es una modificaci\u00f3n que podr\u00eda llevar un CAPITULO 3 \u2013 MARCO TECNOL\u00d3GICO 53 tiempo considerable para ejecutarse, no es una operaci\u00f3n habitual frente a la consulta del nombre del autor, y por tanto compensa. Incluso se podr\u00eda llegar a tratar el post como algo m\u00e1s permanente, de modo que aunque un usuario cambiara su nombre a posteriori, el nombre utilizado para firmar los posts anteriores no var\u00ede, o sencillamente los posts puedan firmarse con diferentes pseud\u00f3nimos. El modelado del esquema de datos con MongoDB depende m\u00e1s de la forma en que se consultara o se actualizaran los datos que de las limitaciones del propio sistema (Paramio, 2011). 3.3 Ruby on Rails Ruby on Rails (RoR o Rails) es un entorno de desarrollo web de c\u00f3digo abierto escrito en Ruby y optimizado para satisfacci\u00f3n de los programadores y de la productividad. Te permite escribir aplicaciones web siguiendo el paradigma de la arquitectura Modelo Vista Controlador (MVC) (Alvarez, 2008). 3.3.1 Lenguaje de Programaci\u00f3n Ruby Es un lenguaje de scripts, multiplataforma, netamente orientado a objetos es software libre, fue creado por Yukihiro Matsumoto conocido como Matz. La primera versi\u00f3n fue liberada en 1995, hereda varias caracter\u00edsticas de lenguajes como: Perl, Smalltalk, Eiffel, Ada y Lisp. Como lo indica su propio autor, es un lenguaje \u201caparentemente sencillo pero internamente complejo\u201d. Esto quiere decir que mientras m\u00e1s nos abstraemos en el paradigma orientado a objetos notaremos realmente la complejidad del lenguaje, se considera un lenguaje muy intuitivo casi a un nivel de lenguaje humano. Ruby fue dise\u00f1ado para un desarrollo r\u00e1pido y sencillo. Cada d\u00eda este lenguaje va ganando m\u00e1s adeptos, tanto as\u00ed que la empresa Sun Microsystems, est\u00e1 apoyando un proyecto llamado JRuby que es un int\u00e9rprete de Ruby escrito 100% en Java. CAPITULO 3 \u2013 MARCO TECNOL\u00d3GICO 54 Entre las caracter\u00edsticas del lenguaje se encuentran: \uf0b7 Posibilidad de hacer llamadas directamente al sistema operativo. \uf0b7 Muy potente para el manejo de cadenas y expresiones regulares. \uf0b7 No se necesita declarar las variables. \uf0b7 La sintaxis es simple y consistente. \uf0b7 Gesti\u00f3n de memoria autom\u00e1tica. \uf0b7 Todo es un objeto. \uf0b7 M\u00e9todos Singleton (Santos, 2006). 3.3.2 FrameWorks Rails Ruby on Rails es una plataforma de trabajo para realizar desarrollos web. Se puede definir como un framework de software libre. Ruby hace referencia al lenguaje de programaci\u00f3n que se utiliza: todo se escribe en Ruby. Por otro lado, on Rails (sobre ra\u00edles) indica que el framework \u201cnos va guiando\u201d para hacer f\u00e1ciles nuestros desarrollos. Por framework entendemos un entorno o conjunto de programas o herramientas agrupadas. Por software libre entendemos software que cualquier usuario puede ejecutar, copiar, modificar, distribuir, cambiar o mejorar. Ruby es un lenguaje de alto nivel, es decir, de sintaxis m\u00e1s aproximada a la forma de expresarnos de los humanos que otros lenguajes. Por ejemplo el m\u00e9todo \u201cpluralize\u201d nos permite obtener el plural de una palabra y el m\u00e9todo \u201csingularize\u201d obtener el singular. Lo gracioso es que el lenguaje es casi humano: pluralize \u201ccat\u201d nos devuelve \u201ccats\u201d pero pluralize \u201cperson\u201d nos devuelve \u201cpeople\u201d, que es el plural en ingl\u00e9s de person. El n\u00famero de usuarios de Ruby est\u00e1 yendo en aumento en los \u00faltimos a\u00f1os; sus usuarios lo defienden dando varios argumentos entre los que podr\u00edamos destacar que \u201cfunciona de forma eficiente\u201d y por otro lado valoran mucho la sencillez de su sintaxis, que se aproxima a lo que podr\u00eda ser el ingl\u00e9s escrito, un lenguaje \u201ccasi natural\u201d. Todo lo que se escribe en Ruby on Rails se escribe en Ruby, luego el framework se encarga de transformarlo en otros lenguajes en funci\u00f3n de las necesidades: por ejemplo, en Java Script para mostrar un formulario en una p\u00e1gina web o en SQL para realizar comunicaciones con una base de datos. El hecho de manejar un solo CAPITULO 3 \u2013 MARCO TECNOL\u00d3GICO 55 lenguaje hace que Ruby on Rails resulte sencillo de utilizar. Como contrapartida, la transformaci\u00f3n desde Ruby on Rails a otros lenguajes da lugar a que el c\u00f3digo que subyace (el c\u00f3digo que existe detr\u00e1s de nuestro desarrollo web) no va a ser tan limpio y depurado como si hubi\u00e9ramos utilizado directamente los lenguajes correspondientes. Aunque Ruby es multiplataforma, es decir, se puede ejecutar bajo distintos sistemas operativos, es bajo Linux como se consigue un mejor rendimiento. Ruby on Rails debemos correrlo en Linux, en otras plataformas, por ejemplo Windows, su uso resulta problem\u00e1tico. Como es propio en el software libre, hay una comunidad de programadores trabajando en Ruby on Rails. En Espa\u00f1a existe una comunidad bastante activa. Ruby on Rails evoluciona al ir apareciendo sucesivamente nuevas versiones. Las migraciones (cambio de versi\u00f3n) con las \u00faltimas versiones pueden calificarse de sencillas y tambi\u00e9n reversibles, es decir, si despu\u00e9s de hacer una migraci\u00f3n se comprueba que existen problemas, se puede revertir el proceso con pocas complicaciones. Esto no significa que no puedan aparecer problemas, sino que con versiones antiguas estos procesos eran mucho m\u00e1s complicados (Rancel, 2011). Rails est\u00e1 basado en dos principios de desarrollo: \uf0b7 No lo vuelvas a repetir: El primer principio avisa de que con esta forma de trabajo podemos crear aplicaciones sin necesidad de duplicar c\u00f3digo, por lo que la programaci\u00f3n se hace mucho m\u00e1s r\u00e1pida que con otros lenguajes. Adem\u00e1s, al tener menos c\u00f3digo, se hace m\u00e1s sencillo el localizar un error y es m\u00e1s claro e intuitivo para el programador. Esta primera idea significa poder tener, por ejemplo, un formulario definido que pueda ser llamado en cualquier parte del c\u00f3digo y las veces que se desee mediante una sola l\u00ednea. \uf0b7 Convenci\u00f3n antes que Configuraci\u00f3n: El segundo principio se\u00f1ala que no existen archivos de configuraci\u00f3n. En lugar de eso, podemos utilizar una serie de convenciones simples ya existentes. Por ejemplo, el tener una clase \u2018Cliente\u2019 en el CAPITULO 3 \u2013 MARCO TECNOL\u00d3GICO 56 modelo que herede de la clase \u2018ActiveRecord::Base\u2019 significar\u00eda para Rails que existe una tabla en la base de datos llamada \u2018clientes\u2019, y que debe ser mapeada con esa clase \u2018Cliente\u2019. Esto hace muy sencillo crear una aplicaci\u00f3n desde cero siguiendo esta serie de convenciones, pero tambi\u00e9n puede ser adaptado a nuestros gustos si nos debemos apoyar en una base de datos ya existente, por ejemplo. Si en nuestra base de datos nuestra tabla \u2018clientes\u2019 tiene otro nombre, mediante una simple l\u00ednea de c\u00f3digo podremos indic\u00e1rselo a Rails (Martinez, 2010). Aspectos T\u00e9cnicos: Ruby on Rails se basa en el MVC (Modelo \u2013 Vista \u2013 Controlador) (ver figura 11). De forma simplificada, diremos que existe: \uf0b7 Un elemento Action View (Modelo), encargado de controlar las vistas: aquello que se muestra al usuario o se env\u00eda. Action View se encarga de \u201cmostrar\u201d los datos adecuadamente: HTML para navegadores, XML para servicios web o aplicaciones o WML para tel\u00e9fonos m\u00f3viles. \uf0b7 Otro elemento, Active Record (Vista), encargado de gestionar el modelo de datos. \uf0b7 Otro elemento, Action Controller (Controlador), que se encarga de \u201cdirigir\u201d o comunicar modelo y vista. CAPITULO 3 \u2013 MARCO TECNOL\u00d3GICO 57 Figura 11 - Modelo Vista Controlador (Ruby On Rails) Un proyecto de Ruby on Rails se organiza en carpetas. Orientativamente se va a tener al menos las siguientes carpetas (ver figura 12): \uf0b7 app: carpeta donde va a ir pr\u00e1cticamente todo el c\u00f3digo del proyecto. \uf0b7 config: carpeta donde especificamos aspectos como la configuraci\u00f3n de la base de datos entre otros aspectos de configuraci\u00f3n. \uf0b7 public: carpeta destinada a contener ficheros Java Script y hojas de estilo (CSS) entre otros. \uf0b7 scripts: carpeta con varias herramientas para creaci\u00f3n de contenidos. CAPITULO 3 \u2013 MARCO TECNOL\u00d3GICO 58 Figura 12 - Estructura de Carpetas (Ruby on Rails) Ruby on Rails utiliza como elementos fundamentales plugins: peque\u00f1os fragmentos de c\u00f3digo que permiten realizar tareas muy concretas. Por ejemplo hay un plugin que permite que un usuario se registre y que cuando se registre se le env\u00ede un e- mail. Los desarrolladores de Ruby on Rails tienen su propia colecci\u00f3n de plugins y sus desarrollos se basan principalmente en ellos. La comunidad de programadores publica los plugins en el sitio web \u201cGitHub Social Coding\u201d (github.com) donde quedan a disposici\u00f3n del resto de usuarios. \u00bfPara qu\u00e9 estar generando c\u00f3digo que ya est\u00e1 generado? Por tanto, para aquellas personas que empiecen con Ruby on Rails, es muy recomendable que dediquen sus primeros d\u00edas a explorar algunos de los plugins disponibles, su implementaci\u00f3n y funcionamiento: encontrar\u00e1n m\u00e1s plugins de los que van a tener tiempo a revisar o probar. Hay que tener en cuenta que los desarrolladores profesionales CAPITULO 3 \u2013 MARCO TECNOL\u00d3GICO 59 basan sus proyectos en aproximadamente un 90 % de c\u00f3digo en plugins y un 10 % de c\u00f3digo propio. Por algo ser\u00e1. Los plugins est\u00e1n desarrollados para versiones concretas de Ruby on Rails, por tanto no tenemos garant\u00edas de que vayan a funcionar cuando realizamos una migraci\u00f3n. Esto es uno de los aspectos \u201cproblem\u00e1ticos\u201d de Ruby on Rails. Como siempre, procede ser cautelosos, y mantener copias de seguridad que eviten p\u00e9rdidas de informaci\u00f3n si aparecen problemas. Ruby on Rails puede generar aplicaciones que usen servidores Apache. Se suelen usar bases de datos MySql, pero tambi\u00e9n se pueden usar otras como Oracle. Podemos rese\u00f1ar que trabajando bajo este framework podemos, en principio, cambiar de base de datos sin tener que hacer nada: por ejemplo, pasarnos de MySql a Oracle sin mayores problemas ya que el framework se encarga autom\u00e1ticamente de las adaptaciones necesarias. Cuando creamos una aplicaci\u00f3n con Ruby on Rails es muy sencillo hacer tests para comprobar que la aplicaci\u00f3n responde tal y como esperamos antes de poner la aplicaci\u00f3n en uso. El framework ejecuta un test y nos devuelve un informe. Es muy recomendable ir haciendo pruebas conforme se va realizando el desarrollo con Ruby on Rails, ya que no existe compilaci\u00f3n como en otros lenguajes. Por tanto, testear aunque parezca una p\u00e9rdida de tiempo en realidad va a evitarnos tener que hacer tediosas correcciones por fallos en el comienzo del desarrollo de un proyecto (Rancel, 2011). 3.3.3 RubyGems RubyGems es un gestor de paquetes para el lenguaje de programaci\u00f3n Ruby que proporciona un formato est\u00e1ndar y auto contenido (llamado gemas) para poder distribuir programas o librer\u00edas en Ruby, una herramienta destinada a gestionar la instalaci\u00f3n de \u00e9stos, y un servidor para su distribuci\u00f3n (Xqbot, 2009). CAPITULO 3 \u2013 MARCO TECNOL\u00d3GICO 60 Gemas: Las Gemas son plugins y/o c\u00f3digos a\u00f1adidos a nuestros Proyectos de Ruby on Rails, que nos permiten nuevas funcionalidades como nuevos create, nuevas funciones pre-escritas (Como login de Usuarios) o nuevas herramientas para el desarrollo. El gestor de gemas es un comando que nos permite listar las gemas instaladas, buscar gemas remotas o localmente (de las instaladas), instalar, actualizar y eliminar gemas. Se puede saber si est\u00e1 instalado simplemente ejecutando: gem \u2013version Instalar una gema: Por ejemplo, si queremos usar el c\u00f3digo siguiente: require \"Rubygems\"; require \"json\"; puts [ \"hola a todos\", 12, \"C/Sin nombre, 25\" ].to_json Tendremos que instalar previamente la gema json. Para instalarla, solo tenemos que ejecutar el siguiente comando: $ sudo gem install json [sudo] password for marubio: Building native extensions. This could take a while... Successfully installed json-1.6.4 1 gem installed Installing ri documentation for json-1.6.4... Installing RDoc documentation for json-1.6.4... Como se puede apreciar, se instala la gema y se genera la documentaci\u00f3n para ri y rdoc. La generaci\u00f3n de la documentaci\u00f3n es bastante lenta y si tenemos que instalar muchas gemas, puede ser algo tedioso. Se puede eliminar esta tarea agregando al comando de instalaci\u00f3n: --no-ri --no-rdoc CAPITULO 3 \u2013 MARCO TECNOL\u00d3GICO 61 Ahora, cuando se listen los paquetes instalados podremos ver: $ sudo gem list *** LOCAL GEMS *** json (1.6.4) Nos indica la versi\u00f3n, ya que podr\u00edamos tener varias versiones instaladas y conviviendo, y desde el c\u00f3digo emplear la que requiramos espec\u00edficamente. Si se quiere instalar una versi\u00f3n espec\u00edfica de un paquete, podemos hacerlo agregando la opci\u00f3n, por ejemplo: --v=1.6.1 (Bombadil, 2012) CAPITULO 4 \u2013 MARCO METODOL\u00d3GICO 62 CAPITULO 4 - MARCO METODOL\u00d3GICO En este cap\u00edtulo se describe el m\u00e9todo que se utiliza para el desarrollo del sistema propuesto. El m\u00e9todo a utilizar es la programaci\u00f3n extrema es perfecta para proyectos peque\u00f1os y medianos, pero es a\u00fan mejor para grandes proyectos o de alto riesgo. En la programaci\u00f3n extrema se da por supuesto que es imposible prever todo antes de empezar a codificar. Es imposible capturar todos los requisitos del sistema, saber qu\u00e9 es todo lo que tiene que hacer ni hacer un dise\u00f1o correcto al principio. Es bastante normal hacer un dise\u00f1o, ponerse a codificar, ver que hay faltantes o errores en el dise\u00f1o, empezar a codificar fuera del dise\u00f1o y al final el c\u00f3digo y el dise\u00f1o, o no se parecen, o hemos echado un mont\u00f3n de tiempo en cambiar la documentaci\u00f3n de dise\u00f1o para que se parezca al c\u00f3digo. En vez de tratar de luchar contra todo eso, lo asume y busca una forma de trabajar que se adapte f\u00e1cilmente a esas circunstancias. B\u00e1sicamente la idea de la programaci\u00f3n extrema consiste en trabajar estrechamente con el cliente, haci\u00e9ndole mini-versiones con mucha frecuencia (cada dos semanas). En cada mini-versi\u00f3n se debe hacer el m\u00ednimo de c\u00f3digo y lo m\u00e1s simple posible para que funcione correctamente. Ah continuaci\u00f3n se explicara un poco sobre el M\u00e9todo XP. 4.1 Metodolog\u00eda XP (Programaci\u00f3n Extrema) A principios de 1990, un hombre llamado Kent Beck estaba pensando en diferentes maneras para desarrollar software. Hasta que en 1996, puso en pr\u00e1ctica Kent su nueva metodolog\u00eda en el proyecto de DaimChrysler utiliz\u00f3 distintas t\u00e9cnicas de desarrollo de software, esta nueva metodolog\u00eda para desarrollar software, fue nombrada Extreme programming. CAPITULO 4 \u2013 MARCO METODOL\u00d3GICO 63 Extreme programming es una nueva disciplina del desarrollo de software que se basa en la comunicaci\u00f3n, simplicidad, retroalimentaci\u00f3n y valor. La simplicidad ayuda a que los desarrolladores de software encuentren soluciones m\u00e1s simples a problemas, seg\u00fan el cliente lo estipula. Los desarrolladores tambi\u00e9n crean caracter\u00edsticas en el dise\u00f1o que pudieran ayudar a resolver problemas en un futuro. La comunicaci\u00f3n prevalece en todas las pr\u00e1cticas de extreme programming. Comunicaci\u00f3n cara a cara es la mejor forma de comunicaci\u00f3n, entre los desarrolladores y el cliente. M\u00e9todo muy \u00e1gil. Gracias a esto el equipo esta pude realizar cambios que al cliente no le gustaron. Tambi\u00e9n apoya agilidad con la extensi\u00f3n del conocimiento t\u00e1cito dentro del equipo del desarrollo, evitando la necesidad de mantener la documentaci\u00f3n escrita. La Retroalimentaci\u00f3n continua del cliente permite a los desarrolladores llevar y dirigir el proyecto en una direcci\u00f3n correcta hacia donde el cliente quiera. El valor requiere que los desarrolladores vayan a la par con el cambio, porque sabemos que este cambio es inevitable, pero el estar preparado con una metodolog\u00eda ayuda a ese cambio. La metodolog\u00eda se dise\u00f1a para entregar el software seg\u00fan las necesidades de cliente y cuando sea necesaria. Extreme programming establece cuatro variables para cualquier proyecto de software: costo, tiempo, calidad y alcance. Un problema de esto es la calidad, porque muchas veces se ignora, porque nadie es capaz de trabajar bien cuando est\u00e1 sometido a mucha presi\u00f3n. El costo del proyecto se incrementa cuando se necesita m\u00e1quinas m\u00e1s r\u00e1pidas, mas especialistas t\u00e9cnicos en determinadas \u00e1reas o mejores oficinas para el equipo de desarrollo. CAPITULO 4 \u2013 MARCO METODOL\u00d3GICO 64 La calidad puede representar un cambio extra\u00f1o; debido a que a mayor calidad menor tiempo de realizaci\u00f3n del proyecto. Por lo tanto el equipo de desarrolladores est\u00e1 encargado de la tarea de hacer las pruebas con los mejores resultados posibles para as\u00ed tener una idea de cu\u00e1l es el problema y como lo van a resolver de una manera simple y eficiente, para que la calidad del proyecto se mantenga al 100% y tener una facilidad de adaptarse a los cambios del c\u00f3digo lo que hace este proceso m\u00e1s r\u00e1pido. El alcance del proyecto, en la cual el equipo determina: la estimaci\u00f3n de las tareas a realizar, que es lo que el cliente quiere, la implementaci\u00f3n de los requisitos m\u00e1s importantes de manera que este siempre sea funcional. En extreme programming el costo del cambio maneja un papel muy importante, porque comparado con otras metodolog\u00edas para implementar software, es mucho m\u00e1s barato, debido a que las pruebas se van haciendo seg\u00fan las versiones liberadas. (Paredes Villarreal, 2007) Diagrama de los ciclos de desarrollo de software se muestra en la figura 13. Figura 13 - Diagrama de los ciclos de desarrollo de software CAPITULO 4 \u2013 MARCO METODOL\u00d3GICO 65 4.1.1 Valores del Extreme Programing \uf0b7 El Juego de Planificaci\u00f3n: Son una serie de actividades planificadas que son llamados juegos planificados por extreme programming, son asumidos durante el transcurso del proyecto. Un juego inicial planeado se emprende durante el inicio del proyecto e implica una sesi\u00f3n con el cliente de reflexi\u00f3n con algunos personas claves como desarrolladores para determinar los requisitos iniciales y el contorno, conocidos en la metodolog\u00eda como historias. Si el proyecto contin\u00faa, se sigue con un emprende \u201cPlanning game de lanzamiento\u201d donde el cliente escribe otras historias en tarjetas y los desarrolladores buscan t\u00e9rminos de Unidades Ideales de Ingenier\u00eda. \uf0b7 Desarrollo de Probar-Conducir: Esta es la forma de prueba de unidad y de prueba de aceptaci\u00f3n, donde las pruebas se escriben antes de la implementaci\u00f3n del c\u00f3digo. \uf0b7 El reorganizado sin piedad: Los desarrolladores requieren mejorar el c\u00f3digo sin que este cambie su funci\u00f3n para realizar un c\u00f3digo simple. Esto dar\u00e1 oportunidad a modificarlo cuando haya necesidad de cambiar una caracter\u00edstica. \uf0b7 Integraci\u00f3n continua: Al cabo de un d\u00eda el sistema deber\u00e1 de ser integrado por una m\u00e1quina, cada vez que los programadores tengan una funcionalidad ya probada unitariamente. Si al a\u00f1adir la funcionalidad al sistema este sigue funcionando correctamente, la tarea fue realizada con \u00e9xito. De lo contrario, esto permite que los desarrolladores detecten errores en la integraci\u00f3n del sistema en una etapa antes ejecutando las pruebas de unidad del proyecto. \uf0b7 Cliente en el sitio: Los desarrolladores tienen acceso continuo con el cliente para poner en claro las historias y discutir el desarrollo de ediciones y proporcionar retroalimentaci\u00f3n. \uf0b7 Lanzamientos peque\u00f1os: Al final de cada iteraci\u00f3n el sistema es ejecutado y el cliente lo observa. Se ejecuta primero unos meses antes de estar completamente CAPITULO 4 \u2013 MARCO METODOL\u00d3GICO 66 terminado, las otras versiones ser\u00e1n m\u00e1s frecuentes entre un d\u00eda y un mes. La mayor\u00eda de estas ejecuciones es para conseguir retroalimentaci\u00f3n del cliente. \uf0b7 Aplique los est\u00e1ndares de la codificaci\u00f3n: El c\u00f3digo es la forma principal de documentaci\u00f3n y por lo tanto debe de estar escrito de una manera clara y constante, que pueda ser identificado f\u00e1cilmente por cualquier programador de otro equipo. \uf0b7 Met\u00e1fora del sistema: Un lenguaje de met\u00e1foras se utiliza para describir la arquitectura del sistema. Esto ayuda a la comunicaci\u00f3n entre los mismos desarrolladores y entre los desarrolladores y el cliente. \uf0b7 Reuni\u00f3n: Una reuni\u00f3n de 15 minutos en el comienzo de cada d\u00eda para discutir problemas encontrados el d\u00eda anterior y los problemas que se resolver\u00e1n durante el d\u00eda. (Paredes Villarreal, 2007) 4.1.2 Ventajas del M\u00e9todo XP Evidentemente, para que algo est\u00e9 siendo tomado tan en cuenta como la Extreme Programming, debe ofrecer una serie de ventajas a la hora de ponerlo en pr\u00e1ctica que haga que el esfuerzo de entender y aplicar sus pr\u00e1cticas, sea insignificante con respecto a los beneficios obtenidos. \uf0b7 Se consiguen productos usables con mayor rapidez. \uf0b7 El proceso de integraci\u00f3n es continuo, por lo que el esfuerzo final para la integraci\u00f3n es nulo. \uf0b7 Se consigue integrar todo el trabajo con mucha mayor facilidad. \uf0b7 Se atienden las necesidades del cliente con mayor exactitud. Esto se consigue gracias a las continuas versiones que se ofrecen al usuario. \uf0b7 Se consiguen productos m\u00e1s fiables y robustos contra los fallos gracias al dise\u00f1o de los test de forma previa a la codificaci\u00f3n. \uf0b7 Obtenemos c\u00f3digo m\u00e1s simple y m\u00e1s f\u00e1cil de entender, reduciendo el n\u00famero de errores. (Paredes Villarreal, 2007) CAPITULO 4 \u2013 MARCO METODOL\u00d3GICO 67 4.1.3 Adaptaci\u00f3n del Proceso XP Aqu\u00ed se explicara algunos elementos de la metodolog\u00eda XP que se van a utilizar en el desarrollo del Sistema. \uf0b7 Iteraciones Todo proyecto que siga la metodolog\u00eda XP. Se ha de dividir en iteraciones para lograr la evoluci\u00f3n del proyecto de manera escalable, estas iteraciones normalmente son propuestas por tiempo de duraci\u00f3n, para el desarrollo de esta Tesis de Grado se decidi\u00f3 que cada iteraci\u00f3n represente un objetivo. \uf0b7 Historias de usuario El primer paso a seguir con la metodolog\u00eda XP es elaborar Historias de Usuario con el cliente, son formatos muy son diligenciadas por el cliente, con un lenguaje no t\u00e9cnico. Son usadas para estimar tiempos de desarrollo de la aplicaci\u00f3n que describen, tambi\u00e9n se verifica en la fase de Pruebas para afirmar que el programa cumple con la Historia de Usuario espec\u00edfica. Cuando se implementa una historia de Usuario, el cliente se re\u00fane con los desarrolladores para concretar y detallar lo que contiene la Historia a realizar. El formato que se va a utilizar para una Historia de Usuario es el siguiente: Numero: Nombre: Usuario: Iteraci\u00f3n Asignada: Tipo: Tiempo Estimado: Descripci\u00f3n: Cuadro 1 - Formato de Historia de Usuarios CAPITULO 4 \u2013 MARCO METODOL\u00d3GICO 68 \uf0b7 Roles de la Programaci\u00f3n Extrema Los actores son todas las personas involucradas en el desarrollo del proyecto, los cuales a su vez cumplen distintos roles o responsabilidades seg\u00fan su importancia y nivel de participaci\u00f3n. A continuaci\u00f3n se destacan los roles existentes en el presente proceso de desarrollo: \uf0d8 Programador: El programador escribe las pruebas unitarias y produce el c\u00f3digo del sistema. \uf0d8 Cliente: Escribe las historias de los usuarios y las pruebas funcionales para validar su implementaci\u00f3n. El cliente da una gran prioridad a las historias de usuarios y decide cual implementar en cada iteraci\u00f3n centr\u00e1ndose en aportar mayor valor al negocio. \uf0d8 Encargado de Pruebas: Ayuda al cliente a escribir las pruebas funcionales. Se encarga de ejecutar las pruebas con regularidad, difunde los resultados obtenidos al equipo y es el responsable de las herramientas que dan soporte a las pruebas. \uf0d8 Encargado de Seguimiento: Es el que proporciona la realimentaci\u00f3n al equipo. Realiza el seguimiento del proceso de cada iteraci\u00f3n y verifica el grado de acierto entre las estimaciones realizadas y el tiempo real dedicado en ello para la mejora de futuras estimaciones. Nombre del Actor / Roles Programador Cliente Encargado de Pruebas Encargado de Seguimiento Carlos Blanco X X Mercy Ospina X X Cuadro 2 - Nombre de Actores y sus Roles CAPITULO 4 \u2013 MARCO METODOL\u00d3GICO 69 \uf0b7 Actividades XP La Metodolog\u00eda XP est\u00e1 compuesta principalmente de cuatros actividades, estas actividades van a estar incluidas en cada una de las iteraciones necesarias para el desarrollo de la Tesis de Grado. A continuaci\u00f3n se dar\u00e1 una explicaci\u00f3n de cada una de ellas. \uf0d8 Planificaci\u00f3n: En cualquier proyecto que usa la metodolog\u00eda XP se parte de las historia de usuarios para conocer detalles como funcionalidades y actividades, se utilizan tambi\u00e9n para estimar el tiempo de desarrollo requerido para las distintas iteraciones (Jeffries, 2001). Tambi\u00e9n se utilizan en la fase de pruebas, para verificar si el programa cumple con lo que especifica la historia de usuario. Cuando llega la hora de implementar una historia de usuario, el cliente y los desarrolladores se re\u00fanen para concretar y detallar lo que tiene que hacer dicha historia. Para las iteraciones se usara el siguiente formato: Numero de Iteraci\u00f3n: Numero de Historia: Fecha de Inicio: Fecha de Fin: Descripci\u00f3n: Tipo: Cuadro 3 - Formato del Cuadro de Interacciones \uf0d8 Dise\u00f1o: La metodolog\u00eda XP sugiere que hay que conseguir dise\u00f1os simples y sencillos. Hay que procurar hacerlo todo lo menos complicado posible para conseguir un dise\u00f1o f\u00e1cilmente entendible e implem\u00e9ntable que a la larga costar\u00e1 menos tiempo y esfuerzo desarrollar. Tambi\u00e9n en la fase de dise\u00f1o se puede Refactorizar que es mejorar y modificar la estructura y codificaci\u00f3n de c\u00f3digos ya creados sin alterar su funcionalidad. Refactorizar supone revisar de nuevo estos c\u00f3digos para CAPITULO 4 \u2013 MARCO METODOL\u00d3GICO 70 procurar optimizar su funcionamiento. Es muy com\u00fan rehusar c\u00f3digos ya creados que contienen funcionalidades que no ser\u00e1n usadas y dise\u00f1os obsoletos. Esto es un error porque puede generar c\u00f3digo completamente inestable y muy mal dise\u00f1ado; por este motivo, es necesario refactorizar cuando se va a utilizar c\u00f3digo ya creado (Jeffries, 2001). \uf0d8 Codificaci\u00f3n: en la codificaci\u00f3n el cliente es una parte m\u00e1s del equipo de desarrollo; su presencia es indispensable en las distintas fases de XP. A la hora de codificar una historia de usuario su presencia es a\u00fan m\u00e1s necesaria. No olvidemos que los clientes son los que crean las historias de usuario y negocian los tiempos en los que ser\u00e1n implementadas. Antes del desarrollo de cada historia de usuario el cliente debe especificar detalladamente lo que \u00e9sta har\u00e1 y tambi\u00e9n tendr\u00e1 que estar presente cuando se realicen los test que verifiquen que la historia implementada cumple la funcionalidad especificada. La codificaci\u00f3n debe hacerse ateniendo a est\u00e1ndares de codificaci\u00f3n ya creados. Programar bajo est\u00e1ndares mantiene el c\u00f3digo consistente y facilita su comprensi\u00f3n y escalabilidad. XP sugiere un modelo de trabajo usando repositorios de c\u00f3digo d\u00f3nde las parejas de programadores publican cada pocas horas sus c\u00f3digos implementados y corregidos junto a los test que deben pasar. De esta forma el resto de programadores que necesiten c\u00f3digos ajenos trabajar\u00e1n siempre con las \u00faltimas versiones. Para mantener un c\u00f3digo consistente, publicar un c\u00f3digo en un repositorio es una acci\u00f3n exclusiva para cada pareja de programadores (Jeffries, 2001). \uf0d8 Pruebas: Uno de los pilares de la metodolog\u00eda XP es el uso de test para comprobar el funcionamiento de los c\u00f3digos que vayamos implementando. Un punto importante es crear test que no tengan ninguna dependencia del c\u00f3digo que en un futuro evaluar\u00e1. Hay que crear los test abstray\u00e9ndose del futuro CAPITULO 4 \u2013 MARCO METODOL\u00d3GICO 71 c\u00f3digo, de esta forma aseguraremos la independencia del test respecto al c\u00f3digo que eval\u00faa. El uso de los test es adecuado para observar la refactorizaci\u00f3n. Los test permiten verificar que un cambio en la estructura de un c\u00f3digo no tiene porqu\u00e9 cambiar su funcionamiento. Al ser las distintas funcionalidades de la aplicaci\u00f3n no demasiado extensas, no se har\u00e1n test que analicen partes de las mismas, sino que las pruebas se realizar\u00e1n para las funcionalidades generales que debe cumplir el programa especificado en la descripci\u00f3n de requisitos (Jeffries, 2001). Para esta Tesis de grado se usara pruebas del programador que consiste en una t\u00e9cnica simple que consistir\u00e1 en evaluar par\u00e1metros de entrada seleccionado por los programadores y observar las salidas constatando que cumplan con lo esperado. Para estas pruebas se usara el siguiente formato: Numero de Caso de Prueba: Numero de Historia de Usuario: Descripci\u00f3n: Resultados Esperados: Resultados Obtenidos: Cuadro 4 - Formato de Casos de Pruebas 4.2 Metodolog\u00eda de Kimball para el Dise\u00f1o de un Almacen de Datos Ah continuaci\u00f3n se explicara los 4 pasos para el dise\u00f1o de un Almac\u00e9n de Datos seg\u00fan Kimball (Rivadera, 2010) \uf0b7 Elegir el proceso de negocio: el primer paso es elegir el \u00e1rea a modelizar. Esta es una decisi\u00f3n de la direcci\u00f3n, y depende fundamentalmente del an\u00e1lisis de requerimientos y de los temas anal\u00edticos anotados en la etapa anterior. CAPITULO 4 \u2013 MARCO METODOL\u00d3GICO 72 \uf0b7 Establecer el nivel de granularidad: la granularidad significa especificar el nivel de detalle. La elecci\u00f3n de la granularidad depende de los requerimientos del negocio y lo que es posible a partir de los datos actuales. La sugerencia general es comenzar a dise\u00f1ar el Almacen de Datos al mayor nivel de detalle posible, ya que se podr\u00eda luego realizar agrupamientos al nivel deseado. En caso contrario no ser\u00eda posible abrir (drill-down) las sumarizaciones en caso de que el nivel de detalle no lo permita. \uf0b7 Elegir las dimensiones: las dimensiones surgen naturalmente de las discusiones al momento de dise\u00f1ar, y facilitadas por la elecci\u00f3n del nivel de granularidad y de la matriz de procesos/dimensiones. Las tablas de dimensiones tienen un conjunto de atributos (generalmente textuales) que brindan una perspectiva o forma de an\u00e1lisis sobre una medida en una tabla hechos. \uf0b7 Identificar las tablas de hechos y medidas: el \u00faltimo paso consiste en identificar las medidas que surgen de los procesos de negocios. Una medida es un atributo (campo) de una tabla que se desea analizar, sumarizando o agrupando sus datos, usando los criterios de corte conocidos como dimensiones. Las medidas habitualmente se vinculan con el nivel de granularidad y se encuentran en tablas que denominamos tablas de hechos. Cada tabla de hechos tiene como atributos una o m\u00e1s medidas de un proceso organizacional, de acuerdo a los requerimientos. Un registro contiene una medida expresada en n\u00fameros, como ser cantidad, tiempo, dinero, etc., sobre la cual se desea realizar una operaci\u00f3n de agregaci\u00f3n (promedio, conteo, suma, etc.) en funci\u00f3n de una o m\u00e1s dimensiones. La granularidad es el nivel de detalle que posee cada registro de una tabla de hechos. \uf0b7 Identificaci\u00f3n de atributos de dimensiones y tablas de hechos: la segunda parte de la sesi\u00f3n inicial de dise\u00f1o consiste en completar cada tabla con una lista de atributos bien formada. Esta lista se forma colocando en las filas los atributos de la tabla, y en las columnas la siguiente informaci\u00f3n: CAPITULO 4 \u2013 MARCO METODOL\u00d3GICO 73 \uf0d8 Caracter\u00edsticas relacionadas con la futura tabla dimensional del almac\u00e9n de datos, por ejemplo tipo de datos, si es clave primaria, valores de ejemplo, etc. \uf0d8 El origen de los datos (por lo general atributos de las tablas transaccionales). \uf0d8 Reglas de conversi\u00f3n, transformaci\u00f3n y carga, que nos dicen como transformar los datos de las tablas de origen a las del almac\u00e9n de datos. CAPITULO 5 \u2013 MARCO APLICATIVO 74 CAPITULO 5 - MARCO APLICATIVO 5.1 Plan de Iteraciones El ciclo de vida de XP se enfatiza en el car\u00e1cter iterativo e incremental del desarrollo, una iteraci\u00f3n de desarrollo es un per\u00edodo de tiempo en el que se realiza un conjunto de funcionalidades determinadas que en el caso de XP corresponden a un conjunto de historias de usuarios. Las iteraciones son relativamente cortas ya que se piensa que entre m\u00e1s r\u00e1pido se le entreguen desarrollos al cliente, m\u00e1s retroalimentaci\u00f3n se va a obtener y esto va a representar una mejor calidad del producto a largo plazo. Existe una fase de an\u00e1lisis inicial orientada a programar las iteraciones de desarrollo y cada iteraci\u00f3n incluye planificaci\u00f3n, dise\u00f1o, codificaci\u00f3n y pruebas, fases superpuestas de tal manera que no se separen en el tiempo (Patricio, 2006). A continuaci\u00f3n se presenta las diferentes iteraciones relacionada con el proyecto: 5.1.1 ITERACI\u00d3N 0 \uf0b7 Planificaci\u00f3n: Como primera iteraci\u00f3n se va a instalar el ambiente de trabajo eso incluye los lenguajes necesarios y todas sus dependencias necesarias para la ejecuci\u00f3n correcta del proyecto. Tambi\u00e9n en esta iteraci\u00f3n se realiza el dise\u00f1o del Almac\u00e9n de Datos en la cual se va a implementar en la siguiente iteraci\u00f3n. Numero de Iteraci\u00f3n: 0 Numero de Historia: 1 y 2 Fecha de Inicio: 01/01/2011 Fecha de Fin: 20/01/2011 Descripci\u00f3n: Instalaci\u00f3n del ambiente de trabajo y dise\u00f1o del Almac\u00e9n de Datos Tipo: Desarrollo CAPITULO 5 \u2013 MARCO APLICATIVO 75 \uf0b7 Historias de Usuario: Numero: 1 Nombre: Dise\u00f1o del Almac\u00e9n de Datos Usuario: Carlos Blanco Iteraci\u00f3n Asignada: 0 Tipo: Nueva Tiempo Estimado: 9 d\u00edas Descripci\u00f3n: Se realiza el dise\u00f1o del Almac\u00e9n de Datos, estableciendo la tabla de hechos, las distintas dimensiones y las variables contenida en cada tabla. Numero: 2 Nombre: Instalaci\u00f3n del ambiente de trabajo Usuario: Carlos Blanco Iteraci\u00f3n Asignada: 0 Tipo: Nueva Tiempo Estimado: 10 d\u00edas Descripci\u00f3n: Se procede a instalar todas las herramientas necesaria para el correcto funcionamiento de todo lo necesario para el desarrollo. Estas herramientas son: MonetDB, MongoDB, Ruby on Rails, RubyGems y Java \uf0b7 Descripci\u00f3n: En esta primera iteraci\u00f3n se va a instalar primero los lenguajes necesarios para el desarrollo del proyecto estos lenguajes son los siguientes: \uf0d8 Ruby 1.8.7 (2011-06-30 patchlevel 352) [i686-linux] \uf0d8 Java(TM) SE Runtime Environment (build 1.6.0_26-b03) Al tener instalados estos lenguajes se instala el manejador de Almacenes de Datos MonetDB en su versi\u00f3n (11.7.9-20120312) y el manejador de base de datos no relacional basada en documentos MongoDB en su versi\u00f3n (2.0.1), posteriormente se instala la versi\u00f3n de Rubygems (1.5.3). CAPITULO 5 \u2013 MARCO APLICATIVO 76 Finalmente se instala las distintas gemas que no est\u00e1n incluidas por defecto en Rubygems pero que son necesarias para el desarrollo del proyecto, las gemas instaladas se mostraran en el cuadro 5: actionmailer (2.3.5) actionpack (2.3.5) activerecord (2.3.5) activeresource (2.3.5) activesupport (2.3.5) bson (1.4.0) bson_ext (1.4.0) mongo (1.4.0) nokogiri (1.5.0) open4 (1.2.0) popen4 (0.1.2) rails (2.3.5) rake (0.9.2.2) sqlite3 (1.3.4) sqlite3-Ruby (1.3.3) Cuadro 5 - Gemas Instaladas Se puede observar que la versi\u00f3n de Rails utilizada es la 2.3.5, todas las versiones seleccionadas se usan porque representa su versi\u00f3n m\u00e1s estable. \uf0b7 Pruebas: En la fase de prueba de la iteraci\u00f3n 0 se realizo las siguientes pruebas: Numero de Caso de Prueba: 1 Numero de Historia de Usuario: 2 Descripci\u00f3n: Imprimir por pantalla cualquier dato para probar el funcionamiento de los lenguajes Ruby y Java. Resultados Esperados: Mostrar alg\u00fan dato en pantalla usando los imprimir en pantalla de cada lenguaje. Resultados Obtenidos: Se imprimi\u00f3 en pantalla el cl\u00e1sico Hola Mundo en ambos lenguajes CAPITULO 5 \u2013 MARCO APLICATIVO 77 Numero de Caso de Prueba: 2 Numero de Historia de Usuario: 2 Descripci\u00f3n: Usar la base de datos de prueba de MonetDB y realizar cualquier consulta. Resultados Esperados: Mostrar alg\u00fan dato en pantalla ejecutando un query Resultados Obtenidos: Se imprimi\u00f3 en pantalla todos los datos de una tabla usando el query de Select * from Numero de Caso de Prueba: 4 Numero de Historia de Usuario: 2 Descripci\u00f3n: Hacer consultas de la base de datos iticve_db desde Ruby usando la librer\u00eda mongo (1.4.0). Resultados Esperados: Mostrar alg\u00fan dato en pantalla ejecutando un query en de MongoDB usando Ruby Resultados Obtenidos: Se imprimi\u00f3 en pantalla los datos de la base de datos iticve_db usando el comando \u00edtems.find(), \u00edtems es la colecci\u00f3n donde est\u00e1n los datos. Numero de Caso de Prueba: 5 Numero de Historia de Usuario: 2 Descripci\u00f3n: Crear cualquier ambiente de trabajo web para verificar el correcto funcionamiento de Rails. Resultados Esperados: Mostrar una p\u00e1gina usando el Frameworks Ruby on Rails. Resultados Obtenidos: Se mostro la pantalla de un proyecto creado en Ruby on Rails usando la direcci\u00f3n web \u201clocahost\u201d Numero de Caso de Prueba: 6 Numero de Historia de Usuario: 2 Descripci\u00f3n: Crear un query sencillo en java para realizar una consulta a la base de datos de ejemplo en MonetDB. Resultados Esperados: Mostrar los resultado de un query en MonetDB usando JAVA Resultados Obtenidos: Se cre\u00f3 un archivo con query sencillo en java y al ejecutarlo se realizo con \u00e9xito el query mostrando los resultados por pantalla. CAPITULO 5 \u2013 MARCO APLICATIVO 78 Numero de Caso de Prueba: 7 Numero de Historia de Usuario: 2 Descripci\u00f3n: Usar la librer\u00eda popen4 en Ruby para ejecutar el query escrito en java desde Ruby y los resultados imprimirlos por pantalla. Resultados Esperados: Mostrar los resultado de un query en MonetDB usando la librer\u00eda Popen4 a trav\u00e9s de Ruby. Resultados Obtenidos: Se cre\u00f3 un archivo con query sencillo en java, ese archivo se ejecuto en Ruby usando Popen4 y el resultado del query se mostraron en Ruby. 5.1.2 ITERACI\u00d3N 1 \uf0b7 Planificaci\u00f3n: En esta iteraci\u00f3n se crea el Almac\u00e9n de Datos en el manejador de Almacenes de Datos MonetDB, partiendo del dise\u00f1o creado en la iteraci\u00f3n anterior tenemos los datos necesarios para crear las distintas tablas de dimensiones y la tabla de hechos, todas las tablas con sus distintas variables respectivas. Numero de Iteraci\u00f3n: 1 Numero de Historia: 3 Fecha de Inicio: 21/01/2011 Fecha de Fin: 28/01/2011 Descripci\u00f3n: Implementaci\u00f3n del Almac\u00e9n de Datos Tipo: Desarrollo \uf0b7 Historia de Usuario: Numero: 3 Nombre: Implementaci\u00f3n del Almac\u00e9n de Datos Usuario: Carlos Blanco Iteraci\u00f3n Asignada: 1 Tipo: Nueva Tiempo Estimado: 7 d\u00edas Descripci\u00f3n: Partiendo del Dise\u00f1o del Almac\u00e9n de Datos se procede a implementar el dise\u00f1o en MonetDB CAPITULO 5 \u2013 MARCO APLICATIVO 79 \uf0b7 Dise\u00f1o: Utilizando el lenguaje SQL utilizado por el MonetDB, se crear los distintos querys para crear las diferentes tablas y variables del Almac\u00e9n de Datos. Al tener estos querys se puede salvar en un archivo para poder crear las tablas y variables de nuevo en cualquier otra m\u00e1quina. \uf0b7 Codificaci\u00f3n: A continuaci\u00f3n mostramos los querys para crear distintas tablas y variables en el idioma SQL: CREATE TABLE \"sys\".\"dim_tiempo\" ( \"id_time\" INTEGER NOT NULL DEFAULT next value for \"sys\".\"seq_5515\", \"dia\" VARCHAR(2), \"mes\" VARCHAR(2), \"ano\" VARCHAR(4), \"hora\" VARCHAR(2), \"minutos\" VARCHAR(2), \"segundos\" VARCHAR(2), CONSTRAINT \"dim_tiempo_id_time_pkey\" PRIMARY KEY (\"id_time\") ); Cuadro 6 - Query para crear la Tabla Dimension Tiempo CAPITULO 5 \u2013 MARCO APLICATIVO 80 CREATE TABLE \"sys\".\"dim_sitios\" ( \"id_sitio\" INTEGER NOT NULL DEFAULT next value for \"sys\".\"seq_5501\", \"lang\" VARCHAR(30), \"host\" VARCHAR(30), \"server\" VARCHAR(30), \"protocol\" VARCHAR(30), \"domain\" VARCHAR(30), CONSTRAINT \"dim_sitios_id_sitio_pkey\" PRIMARY KEY (\"id_sitio\") ); Cuadro 7 - Query para crear la Tabla Dimension Sitios CREATE TABLE \"sys\".\"dim_metadata\" ( \"id_metadata\" INTEGER NOT NULL DEFAULT next value for \"sys\".\"seq_5530\", \"name\" VARCHAR(50), \"os\" VARCHAR(20), \"html_version\" VARCHAR(50), \"description\" VARCHAR(50), \"domain\" VARCHAR(50), CONSTRAINT \"dim_metadata_id_metadata_pkey\" PRIMARY KEY (\"id_metadata\") ); Cuadro 8 - Query para crear la Tabla Dimension Metadata CAPITULO 5 \u2013 MARCO APLICATIVO 81 CREATE TABLE \"sys\".\"fact_p\u00e1gina\" ( \"id_metadata\" INTEGER NOT NULL, \"id_time\" INTEGER NOT NULL, \"id_sitio\" INTEGER NOT NULL, \"id_mongo\" VARCHAR(30) NOT NULL, \"uri\" VARCHAR(100), \"w3c_validation\" VARCHAR(10), \"http_status\" VARCHAR(5), \"ip\" VARCHAR(20), \"cantidad_flash\" VARCHAR(4), \"cantidad_videos\" VARCHAR(4), \"cantidad_div\" VARCHAR(4), \"cantidad_sonidos\" VARCHAR(4), \"cantidad_css\" VARCHAR(4), \"cantidad_tables\" VARCHAR(4), \"cantidad_jpg\" VARCHAR(4), \"cantidad_bmp\" VARCHAR(4), \"cantidad_gif\" VARCHAR(4), \"cantidad_png\" VARCHAR(4), \"cantidad_scripts\" VARCHAR(4), CONSTRAINT \"fact_p\u00e1gina_id_metadata_fkey\" FOREIGN KEY (\"id_metadata\") REFERENCES \"sys\".\"dim_metadata\" (\"id_metadata\"), CONSTRAINT \"fact_p\u00e1gina_id_sitio_fkey\" FOREIGN KEY (\"id_sitio\") REFERENCES \"sys\".\"dim_sitios\" (\"id_sitio\"), CONSTRAINT \"fact_p\u00e1gina_id_time_fkey\" FOREIGN KEY (\"id_time\") REFERENCES \"sys\".\"dim_tiempo\" (\"id_time\") ); Cuadro 9 - Query para crear la tabla de Hechos P\u00e1gina CAPITULO 5 \u2013 MARCO APLICATIVO 82 \uf0b7 Pruebas: Las pruebas en esta iteraci\u00f3n se realizaron de la siguiente manera: Numero de Caso de Prueba: 8 Numero de Historia de Usuario: 3 Descripci\u00f3n: Insertar valores de pruebas validos en las distintas tablas. Resultados Esperados: Al insertar nuevos valores en alguna tabla en MonetDB no se produzca ning\u00fan error. Resultados Obtenidos: se insertaron datos en las distintas tablas de dimensiones y de hechos sin producir ning\u00fan error Numero de Caso de Prueba: 9 Numero de Historia de Usuario: 3 Descripci\u00f3n: Realizar distintos querys para observar sus resultados. Resultados Esperados: Con los datos de prueba que est\u00e1n en las distintas tablas, se realiza un query avanzado y se muestra el resultado Resultados Obtenidos: se ejecuto un query avanzado usando distintos Join y se mostraron los datos que tienen las distintas tablas. El query se muestra en el cuadro 10. Select T4.lang,T4.host,T4.server,T4.protocol,T4.domain,T3.name,T3.os,T3.html_version, T3.description, T1.w3c_validation, T1.http_status, T1.\"IP\", T1.cantidad_flash, T1.cantidad_videos, T2.\"day\", T2.\"month\", T2.\"year\", T2.\"hour\", T2.\"minutes\" from \"DIM_Sitio\" as T4 inner join(\"DIM_Metadata\" as T3 inner join(\"FACT_P\u00e1gina\" as T1 inner Join \"DIM_Tiempo\" as T2 on(T1.id_time = T2.id_time)) on (T3.id_metadata = T1.id_metadata)) on (T4.id_sitio = T1.id_sitio); Cuadro 10 - Ejemplo de un Query en MonetDB usando el JOIN CAPITULO 5 \u2013 MARCO APLICATIVO 83 5.1.3 ITERACI\u00d3N 2 \uf0b7 Planificaci\u00f3n: En esta iteraci\u00f3n se va a desarrollar la funcionalidad m\u00e1s importante del todo el proyecto, que es el proceso ETL (Extracci\u00f3n, Transformaci\u00f3n y Carga). Este proceso es importante en el mundo de los Almacenes de Datos, ya que se extrae la informaci\u00f3n necesaria desde cualquier fuente, luego transforma estos datos seg\u00fan las reglas del negocio y luego carga estos datos en Almac\u00e9n de Datos. Numero de Iteraci\u00f3n: 2 Numero de Historia: 4, 5, 6 y 7 Fecha de Inicio: 01/10/2011 Fecha de Fin: 10/12/2011 Descripci\u00f3n: Proceso ETL Tipo: Desarrollo \uf0b7 Historias de Usuario: Numero: 4 Nombre: Adaptaci\u00f3n del Analizador de Documentos Usuario: Carlos Blanco Iteraci\u00f3n Asignada: 2 Tipo: Mejora Tiempo Estimado: 15 d\u00edas Descripci\u00f3n: Al analizador de Documentos proporcionado por Mar\u00eda Gabriela Gaetano se le realizara unas modificaciones para que se adapte a las necesidades del Proceso ETL. CAPITULO 5 \u2013 MARCO APLICATIVO 84 Numero: 5 Nombre: Implementaci\u00f3n en Java de los Querys SQL Usuario: Carlos Blanco Iteraci\u00f3n Asignada: 5 Tipo: Nueva Tiempo Estimado: 5 D\u00edas Descripci\u00f3n: Se crea un archivo java llamando querys.java, donde va a tener todos los querys necesarios para la corrida de las distintas funciones. Este archivo es compilado y se llamara en Ruby a trav\u00e9s de la funci\u00f3n Popen4 para luego recibir los resultados de los querys y trabajar con los resultados en Ruby. Numero: 6 Nombre: Propuesta del Proceso ETL Usuario: Carlos Blanco Iteraci\u00f3n Asignada: 2 Tipo: Nueva Tiempo Estimado: 5 d\u00edas Descripci\u00f3n: Se desarrolla la propuesta del proceso ETL, en la cual se decide de c\u00f3mo obtener los datos necesarios para alimentar las distintas variables del Almac\u00e9n de Datos. Numero: 7 Nombre: Implementar proceso ETL Usuario: Carlos Blanco Iteraci\u00f3n Asignada: 2 Tipo: Nueva Tiempo Estimado: 40 d\u00edas Descripci\u00f3n: Se procede a desarrollar todo el proceso ETL, eso incluye extraer los datos necesario del MongoDB procesarlos para luego transformarlos en informaci\u00f3n que finalmente ser\u00e1 cargada en el Almac\u00e9n de Datos (MonetDB) CAPITULO 5 \u2013 MARCO APLICATIVO 85 \uf0b7 Dise\u00f1o: En el proceso ETL, se sabe de d\u00f3nde se extrae la informaci\u00f3n que se va a cargar en el Almac\u00e9n de Datos, esta informaci\u00f3n proviene de la informaci\u00f3n almacenada en la base de datos MongoDB que se llama iticve_db, la estructura de datos de esta informaci\u00f3n se muestra en el (Cuadro 11). De cada elemento que se encuentra en la estructura mencionada podemos obtener distintos datos necesarios, como son: MongoID (Clave Primaria en MongoDB), URL, tipo de contenido (mime) y contenido del archivo ya que la estructura representa distintos tipos de archivos de una p\u00e1gina web como pueden ser: los archivos HTML, archivos de im\u00e1genes, archivos de hojas de estilos (CSS), etc. Finalmente al procesar estos distintos datos seg\u00fan la regla de negocio se procede a cargar estos datos en el Almac\u00e9n de Datos. { \"_id\" : ObjectId(\"4f82268bb2db8520bc000002\"), \"uri\" : \"http://www.blogprueba.com/style.CSS\", \"contenido\" : \"BAgiAgoRLyoNCglTaW1wbGUgQml6IGJ5IEFkb25pcyBSb25xdWlsbG8gZm9y\\nIEZyZWUgV2Vic2l0Z SBUZW1wbGF0ZXMNCgl3d3cuZnJlZXdlYnNpdGV0ZW1w\\nbGF0LmVzIC8gd3d3LmRvbmkudXMNCg lJbWFnZXMgYnkgSW1hZ2UgQmFzZSBo\\ \", (Se ve de esta manera el contenido porque esta codificado) \"document\" : \"true\", \"fetch_date\" : \"ISODate(2012-04-08T19:30:11-04:30)\", \"mime\" : \"text/CSS\" } Cuadro 11 - Estructura de Datos en MongoDB \uf0b7 Codificaci\u00f3n: Primero se realiza unas modificaciones en la librer\u00eda Scraper que es requerida por el analizador de documentos, estos cambios es incluir unas CAPITULO 5 \u2013 MARCO APLICATIVO 86 expresiones regulares que detecte las l\u00edneas que contengan: im\u00e1genes, scripts, flash, etc. en el contenido HTML de las p\u00e1ginas, estos cambios se observan en la figura 14. Figura 14- Cambios realizados en la Librer\u00eda Scraper Despu\u00e9s de realizar estos cambios creamos nuestra funci\u00f3n analizador (ver figura 15) que lo que hace es contar las cantidades de elementos se\u00f1alados en la figura anterior, tambi\u00e9n obtenemos otros datos como el titulo, metadata y tipo de codificaci\u00f3n de la p\u00e1gina web. Todos estos datos son almacenados en distintas variables para posteriormente se cargan en el Almac\u00e9n de Datos. CAPITULO 5 \u2013 MARCO APLICATIVO 87 Figura 15 - Funci\u00f3n Analizador de Documentos Al comenzar el proceso ETL lo primero que se hace es obtener todos los datos desde MongoDB, luego se obtiene el m\u00e1ximo de las claves primarias (que son num\u00e9ricas) de las dimensiones Tiempo, Sitios y Metadata. Esto se hace a la hora de insertar un nuevo elemento en estas tablas para saber el nuevo valor que debe tener la siguiente clave primaria, tambi\u00e9n se hace un query que se llama CAPITULO 5 \u2013 MARCO APLICATIVO 88 sel_factp\u00e1gina para obtener todos los MongoID almacenados en la tabla de hecho p\u00e1ginas. Esto se puede observar en la figura 16: Figura 16 - C\u00f3digo para obtener valores m\u00e1ximo de las Dimensiones Como se hab\u00eda mencionado los querys se realizan a trav\u00e9s de java, estos querys son ejecutado desde Ruby gracia a la librer\u00eda Popen4, cuando ejecutamos el query nos devuelve un string que parseamos para obtener los resultados que deseamos. Por ejemplo: Se retorna los datos 0 1 2 3 4 5 y estos datos se almacenan en un string en Ruby, que luego transformamos en un arreglo [0, 1, 2, 3, 4, 5], transformado en un arreglo ya podemos acceder m\u00e1s f\u00e1cil a estos valores. Un ejemplo de un query utilizado para calcular el m\u00e1ximo n\u00famero de las claves primarias en alguna de las tablas se puede observar en la figura 17: Figura 17 - Ejemplo de Query para calcular el M\u00e1ximo de una Clave Primaria CAPITULO 5 \u2013 MARCO APLICATIVO 89 Cuando usamos la librer\u00eda Popen4 es como que ejecutaremos el comando en consola. En nuestro proyecto usamos es Java entonces la ejecuci\u00f3n seria en consola as\u00ed: java querys args(0) args(1) args(2) \u2026, el primer argumento es para saber que query vamos a ejecutar en el caso de la Figura 21 es \u201csel_metadatas\u201d. En otros casos los dem\u00e1s argumentos es para otros valores que se van a usar en el query, como en el caso de las inserciones se pasan a trav\u00e9s de los otro argumentos los valores que se van a insertar en la tabla. En el proceso ETL se toma una sola vez los valores del tiempo como: dia, mes, a\u00f1o, hora y minutos (ver figura 18) se insertan en la tabla de dimensi\u00f3n de tiempo, as\u00ed todos los elementos que se inserte en la tabla de hechos p\u00e1ginas tendr\u00e1n el mismo identificador de tiempo. Figura 18 - C\u00f3digo para Insertar en la Tabla Dimension Tiempo Se puede observar en la figura 18 que en el comando Popen4, los destinos argumentos pasados al comando Java, recordemos que el primer argumento es para indicar que query (Ejemplo de un query ver figura 19) vamos a ejecutar y los dem\u00e1s argumentos son valores necesarios para el funcionamiento del query, en este ejemplo los otros argumentos son para insertarlos en la tabla dimensi\u00f3n tiempo. CAPITULO 5 \u2013 MARCO APLICATIVO 90 Figura 19 - Ejemplo de un Query para Insertar elementos Despu\u00e9s de insertar nuestros valores de tiempo en la tabla de dimensi\u00f3n tiempo se contin\u00faa con el proceso ETL, podemos observar el c\u00f3digo donde partimos de un gran ciclo usando la variable query, tenemos que recordar que esta variable contiene un arreglo con todos los elementos que se encuentra en la base de datos iticve_db de MongoDB (Figura 24). Para cada elemento del arreglo query obtenemos el mime, uri (URL) y el contenido. Con el mime podemos saber qu\u00e9 tipo de contenido es el elemento que se est\u00e1 procesando en ese momento. En el caso que sea HTML se procede a decodificar el contenido para luego pasarlo por el analizador de documentos para obtener distintas m\u00e9tricas, tambi\u00e9n obtenemos el titulo, la codificaci\u00f3n del documento y la versi\u00f3n de HTML, antes de insertar el nuevo contenido en las distintas tablas como son la de metadata, sitios y p\u00e1ginas se verifica primero el arreglo query2 que contiene todos los MongoID que se encuentra almacenado actualmente en el Almac\u00e9n de Datos , esto se hace para evitar datos duplicados. Despu\u00e9s de esta verificaci\u00f3n se comprueba si en la tabla de dimensiones sitios ya se encuentra el host de la URL de la p\u00e1gina que estamos procesando, si no se encuentra se inserta los elementos en la tabla de dimensi\u00f3n sitios y metadata, como tambi\u00e9n se insertar los valores en la tabla de hechos p\u00e1ginas, si el host ya se encuentra en la tabla de sitios no se inserta ning\u00fan nuevo valor en la tabla sitios, lo que se hace es obtener el valor de la clave primaria relacionada con el host ya existe. En la siguientes figuras (20-21-22-23) podemos observar un ejemplo de c\u00f3mo queda almacenado los valores en las distintas tablas. CAPITULO 5 \u2013 MARCO APLICATIVO 91 Figura 20 - Ejemplo de los Datos en la Tabla Dimension Tiempo En la figura 220 podemos ver los valores de tiempo obtenidos cuando se inicia la ejecuci\u00f3n del proceso ETL, recordemos que estos valores se toman una sola vez por cada ejecuci\u00f3n del proceso, todos los valores que se vayan insertar en la tabla de hecho p\u00e1gina en la corrida tendr\u00e1n el mismo valor de id_time obtenido despu\u00e9s de insertar los datos de tabla tiempo. Figura 21 - Ejemplo de los Datos en la Tabla Dimension Metadata Figura 22 - Ejemplo de los Datos en la Tabla Dimension Sitios Podemos observar en la figura 22, que el host www.blogprueba.com ya se encuentra en la tabla, si procesamos otra p\u00e1gina que sea del mismo host no se agrega valores nuevos a la tabla si no que se toma el valor del id_sitios, para cuando se vaya insertar valores relacionados a ese host en la tabla de Hechos CAPITULO 5 \u2013 MARCO APLICATIVO 92 Figura 23 - Ejemplo de los Datos en la Tabla de Hechos P\u00e1ginas En la figura 23 se muestra los datos como quedan al ser insertados en la tabla de hechos P\u00e1ginas. Figura 24 - C\u00f3digo del Proceso ETL en el caso de que el contenido sea de tipo HTML CAPITULO 5 \u2013 MARCO APLICATIVO 93 En el caso que el contenido en el mime no sea del tipo HTML(ver figura 26), el proceso ETL es el mismo que en caso anterior con la diferencia que no se procesa el contenido, al no ser contenido HTML nos referimos a que puede ser una imagen, un scripts, un contenido flash, un video, un CSS, entre otras. (ver figura 25) Figura 25 - Tabla de Hechos P\u00e1ginas cuando el contenido procesado no es HTML Figura 26 - C\u00f3digo del Proceso ETL cuando el mime no es HTML CAPITULO 5 \u2013 MARCO APLICATIVO 94 \uf0b7 Pruebas: Para la iteraci\u00f3n 2 se realizaron las siguientes pruebas: Numero de Caso de Prueba: 10 Numero de Historia de Usuario: 4 Descripci\u00f3n: Comprobar funcionamiento del analizador de documentos Resultados Esperados: Al utilizar el analizador de documento en una p\u00e1gina web se tiene que mostrar por pantalla las distintas cantidades de elementos como son las im\u00e1genes, scripts, etc. Resultados Obtenidos: Al utilizar el analizador de documentos en una p\u00e1gina de prueba se mostro por pantalla la cantidades de elementos correctos, como por ejemplo: cantidad JPEG 5, cantidad de BMP 0, cantidad de flash: 1. Numero de Caso de Prueba: 11 Numero de Historia de Usuario: 5 Descripci\u00f3n: Prueba de los distintos querys utilizados por el proceso ETL Resultados Esperados: Se espera el correcto funcionamiento de los querys como son los distintos Select y los Insert, necesario para el funcionamiento del proceso ETL Resultados Obtenidos: Al ejecutar los distintos querys con datos de pruebas reales, se ejecutaron todos de manera correcta y los datos almacenado eran los que se esperaban. Numero de Caso de Prueba: 12 Numero de Historia de Usuario: 7 Descripci\u00f3n: Prueba general del proceso ETL Resultados Esperados: El correcto funcionamiento del proceso ETL usando como datos de entradas el contenido de la base de datos en MongoDB. Resultados Obtenidos: Los datos ingresados por el proceso ETL en el Almac\u00e9n de Datos eran los esperados, seg\u00fan los datos de entradas. CAPITULO 5 \u2013 MARCO APLICATIVO 95 5.1.4 ITERACI\u00d3N 3 \uf0b7 Planificaci\u00f3n: Como ultima iteraci\u00f3n tenemos la interfaz de usuario, en esta interfaz el usuario podr\u00e1 ver distintas versiones de una p\u00e1gina seg\u00fan la URL que ingrese en la pantalla principal, para seleccionar entre las distintas versiones el usuario seleccionara la versi\u00f3n que desea ver seleccion\u00e1ndola a trav\u00e9s de un calendario, al seleccionar la versi\u00f3n deseada el cliente navegara la p\u00e1gina seleccionada. Numero de Iteraci\u00f3n: 3 Numero de Historia: 8, 9, 10, 11 y 12 Fecha de Inicio: 15/01/2012 Fecha de Fin: 01/03/2012 Descripci\u00f3n: Creaci\u00f3n de la Interfaz de Usuario Tipo: Desarrollo \uf0b7 Historias de Usuario: Numero: 8 Nombre: Desarrollo de la p\u00e1gina WEB Usuario: Carlos Blanco Iteraci\u00f3n Asignada: 3 Tipo: Nueva Tiempo Estimado: 5 d\u00edas Descripci\u00f3n: Se desarrolla la p\u00e1gina web (HTML) que va a ser vista por el cliente. Numero: 9 Nombre: Creaci\u00f3n del ambiente de trabajo en Ruby on Rails (Aplicaci\u00f3n Web) Usuario: Carlos Blanco Iteraci\u00f3n Asignada: 3 Tipo: Nueva Tiempo Estimado: 5 d\u00edas CAPITULO 5 \u2013 MARCO APLICATIVO 96 Descripci\u00f3n: Se crea el ambiente de trabajo usando Ruby on Rails, los distintos controladores y p\u00e1ginas se ir\u00e1n desarrollando en el transcurso de las necesidades que surjan, las vistas estar\u00e1n en base a la interfaz anteriormente implementada. Numero: 10 Nombre: Desarrollar Calendario para la Aplicaci\u00f3n Web Usuario: Carlos Blanco Iteraci\u00f3n Asignada: 3 Tipo: Nueva Tiempo Estimado: 5 d\u00edas Descripci\u00f3n: Se desea implementar un calendario que en \u00e9l se muestre las distintas versiones de la p\u00e1ginas, partiendo de la URL ingresada por el usuario. Las distintas versiones se mostraran en el d\u00eda, mes y a\u00f1o seg\u00fan la fecha en la cual fueron procesadas por el proceso ETL. Numero: 11 Nombre: Extraer archivos necesarios de la P\u00e1gina Web Usuario: Carlos Blanco Iteraci\u00f3n Asignada: 3 Tipo: Nueva Tiempo Estimado: 30 d\u00edas Descripci\u00f3n: Cuando el usuario seleccione la versi\u00f3n que desea ver en el calendario, se procede a crear los archivos necesarios para mostrar el contenido de la p\u00e1gina web, la informaci\u00f3n necesaria para estos archivos se extraer\u00e1 desde la Base de Datos en MongoDB. CAPITULO 5 \u2013 MARCO APLICATIVO 97 Numero: 12 Nombre: Crear graficas para mostrar las m\u00e9tricas Usuario: Carlos Blanco Iteraci\u00f3n Asignada: 3 Tipo: Nueva Tiempo Estimado: 5 d\u00edas Descripci\u00f3n: En la aplicaciones web se mostrara unas graficas de barras en que se mostrara lo siguiente: 1- Cantidades de versiones totales de la p\u00e1gina web en cada mes y en total en el a\u00f1o, partiendo del URL ingresado por el usuario. 2- Al seleccionar una versi\u00f3n desde el calendario, se mostrara una grafica en la que muestra la cantidad de elementos contenida en el archivo HTML, Ejemplo: Cantidad de im\u00e1genes, Flash, etc. \uf0b7 Dise\u00f1o: Para desarrollar la interfaz de usuario se va a utilizar Ruby on Rails, con este Frameworks se va a tener distintas vistas que representan las distintas p\u00e1ginas web, los respectivos controladores que es el c\u00f3digo encargado de manejar las distintas acciones de las distintas p\u00e1ginas web. Entre las p\u00e1ginas que se van a desarrollar tenemos como p\u00e1ginas principal el index, donde el usuario ingresa la URL de la p\u00e1gina a consultar, al ingresar una URL valida se procede a mostrar la p\u00e1gina de pre calendario donde se le va a mostrar los a\u00f1os en la cual hay versiones de la p\u00e1gina, despu\u00e9s de seleccionar un a\u00f1o se muestra un calendario donde muestra todas las versiones correspondiente al a\u00f1o que el usuario hab\u00eda seleccionado, finalmente selecciona una versi\u00f3n de la p\u00e1gina en el calendario y finalmente puede visualizar la p\u00e1ginaque hab\u00eda seleccionado y navegar por ella con todos sus elementos. CAPITULO 5 \u2013 MARCO APLICATIVO 98 \uf0b7 Codificaci\u00f3n: En la codificaci\u00f3n se va a explicar las distintas vistas con sus respectivos controladores, el orden en que se explica ser\u00e1 el mismo orden en el que el usuario va navegando por el sistema. El usuario comienza con la p\u00e1gina index que ser\u00eda nuestra p\u00e1gina inicial en el sistema, en esta p\u00e1gina se comprobara primero si el URL que est\u00e1 ingresando el usuario existe en el Almac\u00e9n de Datos, si existe se procede a la siguiente p\u00e1gina del sistema que ser\u00eda la de pre calendario. A continuaci\u00f3n se muestra dos im\u00e1genes (Figura 27 y 28) que representan la vista y el controlador del index. Figura 27- Vista del index.html.erb CAPITULO 5 \u2013 MARCO APLICATIVO 99 Figura 28 - Controlador de la p\u00e1gina index.html.erb Figura 29 - Query Utilizado en el controlador de index.html.erb El query mostrado en la Figura 29 su funci\u00f3n es la de retornar un entero, si el entero es mayor a cero eso quiere decir que existe incidencias del URL ingresado por el usuario en el Almac\u00e9n de Datos. CAPITULO 5 \u2013 MARCO APLICATIVO 100 Despu\u00e9s de comprobarse si hay incidencia del URL ingresado por el usuario en el Almac\u00e9n de Datos, se continua con la p\u00e1gina pre_calendario (ver figura 30), en esta p\u00e1gina lo que se muestra son los a\u00f1os en el que existe versiones de la p\u00e1gina que desea ver el usuario, para que seleccione un a\u00f1o y contin\u00fae con la p\u00e1gina de calendario. Figura 30 - Vista del pre_calendario.html.erb CAPITULO 5 \u2013 MARCO APLICATIVO 101 Figura 31 - Controlador de pre_calendario.html.erb Figura 32 - Query utilizado en el controlador de pre_calendario.html.erb En el query de la figura 32 se retorna todos los elementos que se encuentre en la tabla de dimensi\u00f3n tiempo que coincidan con el id_time que obtenemos de la tabla de hecho seg\u00fan la URL ingresada por el usuario. CAPITULO 5 \u2013 MARCO APLICATIVO 102 Despu\u00e9s que el usuario selecciona un a\u00f1o, se muestra la p\u00e1gina de calendario, en la que se muestra todas las versiones almacenada en el Almac\u00e9n de Datos para el a\u00f1o que se selecciono anteriormente. Las versiones se muestran seg\u00fan el dia, mes y hora en la que fue almacenada en el Almac\u00e9n de Datos. Por ejemplo si una versi\u00f3n fue almacenada el 1\u00ba de Enero del 2012 a las 13 horas, en el calendario se mostrara un evento el dia 1\u00ba de Enero del 2012, el evento tendr\u00e1 por nombre la hora en la que fue almacenada la versi\u00f3n. El usuario para continuar tiene que darle click en alguno de estos eventos y a continuaci\u00f3n se le abrir\u00e1 una nueva p\u00e1gina donde se le muestra la p\u00e1gina que \u00e9l desea ver. Figura 33 - Script donde se almacena los eventos en el calendario CAPITULO 5 \u2013 MARCO APLICATIVO 103 En la figura 33 se puede observar el script donde se crean los distintos eventos en el calendarios, estos eventos son creados en el controlador y pasados a trav\u00e9s de una variable que es diferentes para cada mes del a\u00f1os, estas variables contiene la estructura de datos necesaria para que el calendario funcione sin ning\u00fan problema y muestre los distintos eventos en todo el a\u00f1o. Figura 34 - Vista del calendario.html.erb CAPITULO 5 \u2013 MARCO APLICATIVO 104 En la figura 34 se muestra en c\u00f3digo HTML donde se mandan a imprimir los distintos meses del a\u00f1o. Figura 35 - Parte del c\u00f3digo del controlador de calendario.html.erb El Query utilizado en la Figura 35, tiene la misma funci\u00f3n que el query mostrado en la Figura 32, con la diferencia que los resultados se acotan al a\u00f1o que el usuario selecciono en la p\u00e1gina de pre_calendario. Tambi\u00e9n en la p\u00e1gina de calendario se muestra un grafico de barra en la que se muestra la cantidad de versiones por mes en el a\u00f1o seleccionado por el usuario, este grafico se usa para demostrar esas m\u00e9tricas al usuario. A continuaci\u00f3n se mostrara unas im\u00e1genes (Figura 36 y 37) que muestra el c\u00f3digo usado para este grafico. CAPITULO 5 \u2013 MARCO APLICATIVO 105 Figura 36 - Porci\u00f3n del C\u00f3digo donde se imprime el Grafico 1 En la figura 40 se muestra la porci\u00f3n de c\u00f3digo en donde imprime el grafico en la vista del calendario.html.erb, este grafico se muestra como un grafico de barra usando flash y Java Script, el c\u00f3digo para obtener el valor de las distintas variables para el grafico se ve en la figura 39 Figura 37 - C\u00f3digo del Grafico 1 en el controlador de calendario.html.erb Figura 38 - Query utilizado en el Grafico 1 CAPITULO 5 \u2013 MARCO APLICATIVO 106 En el query mostrado en la figura 38 se obtiene la cantidad de versiones una p\u00e1gina para un mes y a\u00f1o determinado, el resultado se retorna como un entero. Figura 39 - M\u00e9todo que define las variables usadas para la Grafica 1 Finalmente despu\u00e9s que el usuario seleccione la versi\u00f3n de la p\u00e1gina en el calendario se abre una ventana con la p\u00e1gina completa que el usuario deseaba ver, incluyendo todos sus elementos como son las im\u00e1genes, flash, etc. En este proceso se crean los archivos desde la base de datos en MongoDB, partiendo los MongoID que se obtuvieron seg\u00fan la versi\u00f3n seleccionada por el usuario, teniendo los MongoID sabemos que archivos en espec\u00edfico se van a seleccionar para la versi\u00f3n de la p\u00e1gina web que se desea ver. A continuaci\u00f3n se van a mostrar unas im\u00e1genes (Figura 40 y 41) con los distintos c\u00f3digos usados para este proceso. CAPITULO 5 \u2013 MARCO APLICATIVO 107 Figura 40 - Vista de procesar_p\u00e1gina.html.erb En la Figura 40 podemos observar que la vista de procesar_p\u00e1gina la dividimos en dos frames, en el frame de arriba se mostrara la Grafica 2 que se explicara m\u00e1s adelante y en el Frame de abajo se abrir\u00e1 la versi\u00f3n de la p\u00e1gina que selecciono el usuario. CAPITULO 5 \u2013 MARCO APLICATIVO 108 Figura 41 -C\u00f3digo de cambio de direcci\u00f3n absoluta por direcci\u00f3n relativas En la figura 41 podemos observar como comienza este proceso, primero se crea una lista con todos los MongoID para poder extraer de la base de datos de MongoDB los elementos necesarios para mostrar la versi\u00f3n que selecciono el usuario anteriormente, luego se crean los diferentes directorios para almacenar el contenido de la p\u00e1gina web, el directorio ra\u00edz va a tener como nombre un id de sesi\u00f3n usuario que es un numero al random que cambia cada vez que el usuario incia el sistema abriendo la aplicaci\u00f3n web en una secci\u00f3n, as\u00ed aseguramos que los archivos de los distintos usuarios que est\u00e9n usando el sistema al mismo tiempo no se combinen, de subcarpetas va a tener un directorio para cada grupo de elementos web como por ejemplo: para las im\u00e1genes se va a tener una carpeta llamada img, etc. CAPITULO 5 \u2013 MARCO APLICATIVO 109 Cuando se terminen de crear los directorio extraemos el contenido para los distintos MongoID que estamos trabajando (recordemos la estructura de cada datos de MongoDB en el Cuadro 11), cuando el elemento mime es igual a HTML, decodificamos el contenido usando base64.decode64 para obtener el contenido de manera legible del HTML, ese contenido HTML lo convertimos en un documento Nokogiri, que es una librer\u00eda que nos permite parsear los documentos HTML, as\u00ed podemos cambiar de manera sencilla las direcciones absolutas por direcciones relativas, lo podemos observar en el siguiente ejemplo: if !link.attributes[\"href\"].nil? archivos = link.attributes[\"href\"].value.to_s.split(\"/\") link.attributes[\"href\"].value = \"./CSS/#{archivos.last}\" end En este ejemplo cambiamos la direcci\u00f3n de donde se encuentra originalmente una hoja de estilo (CSS) por una direcci\u00f3n en donde se va encontrar en el servidor de manera local. Figura 42 - Query utilizado en el proceso de la Figura 45 En el query de la figura 42 utilizado para el controlador de procesar_p\u00e1gina, obtenemos la lista de MongoID seg\u00fan el URL ingresado por el usuario y se acota el CAPITULO 5 \u2013 MARCO APLICATIVO 110 resultado al pasarle tambi\u00e9n al query la fecha y hora que selecciono el usuario en el calendario. Despu\u00e9s de cambiar las direcciones absolutas a direcciones relativas en el documento HTML, se crean los archivos HTML en el directorio creado al principio del proceso. Cuando el archivo a procesar no es un HTML, se crea los archivos en sus carpetas correspondiente despu\u00e9s que se decodifique el contenido con base64.decode4, el nombre de cada archivo lo obtenemos de la URL almacenada en la estructura en MongoDB, de ese URL tomamos el ultimo valor y tenemos el nombre del archivo a crear. Por ejemplo: http://www.prueba.com/index.html el nombre del archivo a crear es index.html as\u00ed es igual con los dem\u00e1s elementos. A continuaci\u00f3n se mostrara en la Figura 43 la porci\u00f3n de c\u00f3digo para crear los dem\u00e1s elementos que no son HTML. CAPITULO 5 \u2013 MARCO APLICATIVO 111 Figura 43 - Porci\u00f3n del c\u00f3digo donde se crea los archivos que no son HTML Anteriormente que procesar_p\u00e1gina conten\u00eda dos frames, el de arriba para el Grafico 2 y el de abajo donde se va a mostrar la versi\u00f3n de la p\u00e1gina seleccionada por el usuario. En el frame de arriba se muestra una grafica que muestra la cantidad total de los elementos seleccionados como m\u00e9tricas para mostrar el usuario, este CAPITULO 5 \u2013 MARCO APLICATIVO 112 grafico mostrara la cantidad total de JPEG, BMP, flash, scripts, etc. De la p\u00e1gina que usuario selecciono. Estos datos son obtenidos en el Almac\u00e9n de Datos. A continuaci\u00f3n se mostrara unas im\u00e1genes (Figura 44 y 45) con los c\u00f3digos relacionado con este grafico. Figura 44 - Vista para el Frame de Grafico 2 Figura 45 - Controlador para el Frame de Grafico 2 El proceso es muy parecido para el Grafico 1, lo que varia es el query que se usa para tomar los datos necesarios para el grafico 2, que se mostrara a continuaci\u00f3n en la Figura 50. CAPITULO 5 \u2013 MARCO APLICATIVO 113 Figura 46 - Query para obtener los datos necesarios para el Grafico 2 El query retorna la cantidad_flash, cantidad_jpg, cantidad_bmp, cantidad_gif, cantidad_png y cantidad_scripts almacenadas en la tabla de hechos P\u00e1ginas en el Almac\u00e9n de Datos, este resultado se filtra usando el URL que ingreso el usuario al principio del sistema y usando tambi\u00e9n id_time seg\u00fan la fecha y hora que est\u00e1 relacionada con la selecciono del usuario en el calendario. En la figura 47 se muestra el c\u00f3digo donde se define las distintas variables necesarias para el correcto funcionamiento del Grafico 2. Figura 47 - Variables necesarias para el Grafico 2 CONCLUSIONES 114 CONCLUSIONES Al concluir este trabajo de grado se logr\u00f3 los objetivos planteados en el cap\u00edtulo 1 de este documento, ah continuaci\u00f3n se explicara un poco sobre las metas cumplidas: Para el dise\u00f1o del Almac\u00e9n de Datos se utilizo la metodolog\u00eda de Kimball que nos plantea el dise\u00f1o en 4 pasos, al aplicar estos pasos se pudo dise\u00f1ar la tabla de hechos, las tablas de dimensiones, las m\u00e9tricas y la granularidad necesaria para cumplir con uno de los objetivos anteriormente planteados. Los distintos atributos de las tablas incluyendo las m\u00e9tricas se obtuvieron de los documentos web almacenados en la Base de Datos NoSql orientada a documento MongoDB. Al tener el dise\u00f1o del Almacen de datos, se implementa en la Base de Datos Orientada a Columnas MonetDB, se utilizo el lenguaje SQL para los distintos querys necesario para la implementaci\u00f3n del Almacen de Datos. Con el Almacen de Datos implementado se procede a alimentar los distintos atributos de la tabla de hechos y las tablas de dimensiones utilizando distintos datos obtenidos de los documentos web almacenados, para lograr esto se desarrollo el proceso ETL, que se encarga de todo el proceso para alimentar al Almacen de Datos. Finalmente se desarrollo la aplicaci\u00f3n web utilizando el Framework Ruby on Rails que usa el Lenguaje Ruby como base; la aplicaci\u00f3n web sirve para que los usuarios en general puedan ver las distintas versiones de los documentos web almacenados y poder navegar en estos documentos, tambi\u00e9n pueden ver las distintas m\u00e9tricas almacenadas en el Almacen de Datos a trav\u00e9s de unas graficas que se muestran. Hay que destacar que La metodolog\u00eda XP ayud\u00f3 bastante para el desarrollo de este proyecto, ya que permiti\u00f3 organizar desarrollo del sistema en diferentes iteraciones, en la cual cada iteraci\u00f3n ten\u00eda su fase de planificaci\u00f3n, dise\u00f1o, codificaci\u00f3n y pruebas. La fase de CONCLUSIONES 115 prueba fue fundamental para mejorar mucho el c\u00f3digo de algunas iteraciones, tambi\u00e9n ayudo a mejorar otros aspectos del proyecto. Para finalizar se espera que este modulo ayude al proyecto del Centro de Computaci\u00f3n Paralela y Distribuida (CCPD) logre su meta principal es la preservaci\u00f3n digital de los documentos web. RECOMENDACIONES 116 RECOMENDACIONES En el presente trabajo de grado se trabaj\u00f3 en la base de datos que proviene de MongoDB esta base de datos se llama iticve_db, los datos que se insertan en esa base de datos son muy limitados, no almacenan hojas de estilos, frash, scripts entre otros. Se recomienda totalmente incorporar m\u00e1s funcionalidades al spider para que almacene mucho m\u00e1s elementos relacionados con las p\u00e1ginas web en el MongoDB. Otra importante recomendaci\u00f3n es la de tratar de poner operativa la librer\u00eda que conecta Ruby con MonetDB que es el manejador de Almacenes de Datos, ya que usando la librer\u00eda Popen4 que ejecuta los querys usando java y luego los resultados los almacena como string en Ruby, se pierde ciclos del procesador por la cual puede afectar el rendimiento del sistema cuando se va a ejecutar querys pesados. En la funci\u00f3n de procesar_p\u00e1gina, en donde se cambia las direcciones absolutas a direcciones relativas se cambiaron las direcciones de los elementos m\u00e1s comunes de un documento HTML, como son las hojas de estilos, los scripts, los flash, etc. Se recomienda trabajar m\u00e1s en esta parte para agregar mucho m\u00e1s elementos HTML. Las carpetas donde se almacenan los archivos de las p\u00e1ginas que son extra\u00eddas desde MongoDB por petici\u00f3n del usuario no se borran, se recomienda crear un script que elimine estas carpetas con alguna condici\u00f3n, para evitar que se sobrecargue el disco duro del servidor con todas estas carpetas creadas cuando el usuario selecciona una versi\u00f3n a ver de una p\u00e1gina. Como el principal principio de todo el sistema es el de guardar p\u00e1ginas web especialmente de Venezuela se deber\u00e1 desarrollar unos m\u00f3dulos para que se almacene nada mas p\u00e1ginas hechas por venezolano o almacenadas en Venezuela. BIBLIOGRAF\u00cdA 117 BIBLIOGRAF\u00cdA Alvarez, W. (28 de Diciembre de 2008). Obtenido de http://damncorner.blogspot.com/2008/12/la-aventura-de-ruby-on-rails-el-inicio.html Archive, I. (2001). Obtenido de http://archive.org/about/faqs.php Bi-Argentina. (10 de Marzo de 2008). Obtenido de http://www.bi-argentina.com.ar/que- es-un-data-warehouse/ Bombadil. (02 de Enero de 2012). Obtenido de http://bosqueviejo.net/2012/01/02/las- gemas-de-ruby/ Buigues, A. (14 de Enero de 2012). Obtenido de http://anabuigues.com/2010/01/14/data- warehouse-y-las-bases-de-datos-operacionales/ Curto, J. (19 de Noviembre de 2007). Obtenido de http://informationmanagement.wordpress.com/2007/11/19/diseno-de-un-data- warehouse-estrella-y-copo-de-nieve/ Curto, J. (16 de Octubre de 2007). Obtenido de http://informationmanagement.wordpress.com/2007/10/16/diseno-de-un-data- warehouse-definiciones/ Fonollosa, C. L. (Diciembre de 2005). Obtenido de http://www.ub.edu/bid/15lluec2.htm Herrera, C. (30 de 10 de 2007). Obtenido de http://www.adictosaltrabajo.com/tutoriales/tutoriales.php?pagina=datawarehouse#sdfo otnote1anc Inteligencias de Negocios. (2009). Inteligencias de Negocios. Obtenido de http://www.leroot.com/site/index.php?option=com_content&view=article&id=63&Itemid =69 BIBLIOGRAF\u00cdA 118 Jeffries, R. (08 de Noviembre de 2001). What is Extreme Programming? Obtenido de http://xprogramming.com/xpmag/whatisxp Martinez, D. (21 de Julio de 2010). Obtenido de http://blog.danielmartinez.info/?p=27 MonetDB. (s.f.). Obtenido de http://www.monetdb.nl/Assets/embedded.pdf Padicat. (2011). Obtenido de http://www.padicat.cat/es/conocenos Paramio, C. (26 de Abril de 2011). Obtenido de http://www.genbetadev.com/bases-de- datos/el-concepto-nosql-o-como-almacenar-tus-datos-en-una-base-de-datos-no- relacional Paramio, C. (10 de Mayo de 2011). Obtenido de http://www.genbetadev.com/bases-de- datos/una-introduccion-a-mongodb Paredes Villarreal, F. A. (2007). Obtenido de http://homepages.mty.itesm.mx/al792696/Extremeprogramming.doc Patricio, L. (2006). Metodolog\u00edas \u00c1giles para el desarrollo de software: Extreme Programming. Universidad Polit\u00e9cnica de Valencia. P\u00e9rez, F. F. (23 de Febrero de 2011). Obtenido de http://www.adictosaltrabajo.com/tutoriales/tutoriales.php?pagina=introduccion_bases_d e_datos_nosql qbit\u00e1cora. (19 de Abril de 2010). Obtenido de http://qbitacora.wordpress.com/2010/04/19/wayback-machine-archivando-internet/ Rancel, M. R. (2011). Obtenido de http://www.aprenderaprogramar.com/index.php?option=com_content&view=article&id= 73:ruby-on-rails-plataforma-de-software-libre-para-desarrollos-web&catid=46:lenguajes- y-entornos&Itemid=163 Rivadera, G. R. (2010). La Metodolog\u00eda de Kimball para el Dise\u00f1o de almacenes. BIBLIOGRAF\u00cdA 119 Santos, R. D. (2006). Obtenido de http://www.maestrosdelweb.com/editorial/rubyonrails/ Santos, R. D. (s.f.). Maestros del Web. Obtenido de http://www.maestrosdelweb.com/editorial/rubyonrails/ Sinnexus. (2007). Obtenido de http://www.sinnexus.com/business_intelligence/datawarehouse.aspx Softpedia. (2007). Obtenido de http://www.softpedia.com/es/programa-MonetDB- 69281.html Swiatecka, A. (31 de Enero de 2008). Obtenido de http://www.slideshare.net/anansi/preservacin-digital-2 Ubuntu Life. (13 de Abril de 2010). Obtenido de http://ubuntulife.wordpress.com/2010/04/13/introduccion-a-la-base-de-datos-nosql- mongodb-instalacion-primeros-pasos-y-ejemplo-de-conexion-con-java/ Xqbot. (3 de Julio de 2009). Obtenido de http://es.wikipedia.org/wiki/RubyGems AP\u00c9NDICE 120 AP\u00c9NDICE 5.2 Modelo del Almac\u00e9n de Datos Figura 48 - Modelo del Almac\u00e9n de Datos Se puede observar en la Figura 48, que el Almac\u00e9n de Datos sigue un modelo de estrella. AP\u00c9NDICE 121 5.3 Diccionario de Datos del Almac\u00e9n de Datos Tabla de Hechos FACT_p\u00e1gina Campos Descripci\u00f3n id_metadata Clave foranea de la tabla DIM_Metadata Id_time Clave foranea de la tabla DIM_Tiempo Id_sitio Clave foranea de la tabla DIM_Sitio W3c_validation Se almacena Si o No si la p\u00e1gina tiene una validaci\u00f3n W3c en otro caso se almacena NULL. http_status Se almacena SI o No si la p\u00e1gina esta online si no se sabe se almacena NULL. IP Se almacena la direcci\u00f3n IP de la p\u00e1gina si se conoce en otro caso se almacena NULL. cantidad_flash Se almacena la cantidad de flash que contenga la p\u00e1gina. cantidad_videos Se almacena la cantidad de videos que contenga la p\u00e1gina. cantidad_frames Se almacena la cantidad de frames que contenga la p\u00e1gina. cantidad_sonidos Se almacena la cantidad de sonidos que contenga la p\u00e1gina como (mp3, midi, etc.) cantidad_css Se almacena la cantidad de hojas de estilos (CSS) que contenga la p\u00e1gina. cantidad_tables Se almacena la cantidad de tables que contenga la p\u00e1gina. cantidad_jpg Se almacena la cantidad de im\u00e1genes JPEG que contenga la p\u00e1gina. cantidad_bmp Se almacena la cantidad im\u00e1genes BMP de que contenga la p\u00e1gina. cantidad_gif Se almacena la cantidad im\u00e1genes gif de que contenga la p\u00e1gina. cantidad_png Se almacena la cantidad de im\u00e1genes png que contenga la p\u00e1gina. cantidad_scripts Se almacena la cantidad de scripts que contenga la p\u00e1gina. Cuadro 12 - Descripci\u00f3n de la Tabla de Hechos FACT_P\u00e1gina AP\u00c9NDICE 122 Tabla de Dimensiones DIM_Sitio Campos Descripci\u00f3n Id_sitio Clave primaria de la tabla DIM_Sitio lang Almacena en qu\u00e9 idioma esta la p\u00e1gina en otro caso almacena NULL. host Almacena el host en que esta almacenada la p\u00e1gina. server Almacena el nombre del servidor en donde est\u00e1 la p\u00e1gina en otro caso almacena NULL. protocol Almacena el protocola que usa la p\u00e1gina. domain Almacena el dominio en que esta la p\u00e1gina. Cuadro 13 - Descripci\u00f3n de la Tabla de Dimensiones DIM_Sitio Tabla de Dimensiones DIM_Metadata Campos Descripci\u00f3n Id_metadata Clave primaria de la tabla DIM_Metadata nombre Almacena el titulo de la p\u00e1gina, en otro caso almacena NULL. OS Almacena el Sistema Operativo del servidor donde est\u00e1 alojada la p\u00e1gina, en otro caso almacena NULL. html_version Almacena la versi\u00f3n de HTML de la p\u00e1gina, en otro caso almacena NULL. descripci\u00f3n Almacena la descripci\u00f3n de la p\u00e1gina, en otro caso almacena NULL. encoding Almacena la codificaci\u00f3n de la p\u00e1gina, en otro caso almacena NULL. content Almacena el tipo de contenido de la p\u00e1gina, en otro caso almacena NULL. Cuadro 14 - Descripci\u00f3n de la Tabla de Dimensiones DIM_Metadata AP\u00c9NDICE 123 Tabla de Dimensiones DIM_Tiempo Campos Descripci\u00f3n Id_time Clave primaria de la tabla DIM_Tiempo dia Almacena el dia en que fue almacenada la informaci\u00f3n de la p\u00e1gina en el Almac\u00e9n de Datos mes Almacena el mes en que fue almacenada la informaci\u00f3n de la p\u00e1gina en el Almac\u00e9n de Datos ano Almacena el a\u00f1o en que fue almacenada la informaci\u00f3n de la p\u00e1gina en el Almac\u00e9n de Datos hora Almacena la hora en que fue almacenada la informaci\u00f3n de la p\u00e1gina en el Almac\u00e9n de Datos minutos Almacena los minutos en que fue almacenada la informaci\u00f3n de la p\u00e1gina en el Almac\u00e9n de Datos Cuadro 15 - Descripci\u00f3n de la Tabla de Dimensiones Tiempo", "document_id": 539589}]}, {"paragraphs": [{"qas": [{"question": "que son superficies difusas", "id": 320680, "answers": [{"answer_id": 331170, "document_id": 539586, "question_id": 320680, "text": "Superficies difusas Son superficies que reflejan la luz de manera uniforme en todas las direcciones posibles,", "answer_start": 27154, "answer_end": 27263, "answer_category": null}], "is_impossible": false}, {"question": "que es ray tracing", "id": 320682, "answers": [{"answer_id": 331172, "document_id": 539586, "question_id": 320682, "text": "Trazado de rayos El trazado de rayos (ray tracing) fue uno de los primeros esfuerzos para lograr la ilumina- ci\u00f3n global, introducida por Whitted [8]. En su trabajo se describe una extensi\u00f3n al algoritmo de lanzado de rayos (ray casting) para poder determinar la visibilidad de las superficies e incluir el efecto de refracci\u00f3n y reflecci\u00f3n de superficies especulares perfectas. La t\u00e9cnica original presenta una alta recursividad, por lo que termina siendo ineficiente. ", "answer_start": 29766, "answer_end": 30236, "answer_category": null}], "is_impossible": false}, {"question": "que es la radiosidad", "id": 320683, "answers": [{"answer_id": 331173, "document_id": 539586, "question_id": 320683, "text": "La t\u00e9cnica de radiosidad (radiosity) fue propuesta por Goral et al. [13] para resolver la interacci\u00f3n de la luz para superficies difusas. Por lo tanto, solo resuelve parcialmente el pro- blema de la iluminaci\u00f3n global. Su idea principal es calcular el promedio de radiosidad Bi en cada elemento de superficie o parche i para una escena tridimensional. Esta t\u00e9cnica presenta la ventaja de que una vez realizado el c\u00e1lculo de la iluminaci\u00f3n, es posible el despliegue de manera interactiva, ya que no depende del punto de visi\u00f3n.", "answer_start": 30694, "answer_end": 31220, "answer_category": null}], "is_impossible": false}, {"question": "que es la computacion grafica", "id": 320679, "answers": [{"answer_id": 331169, "document_id": 539586, "question_id": 320679, "text": "La computaci\u00f3n gr\u00e1fica es una rama de las ciencias de la computaci\u00f3n que se encarga del estudio, dise\u00f1o y modificaci\u00f3n de im\u00e1genes en la pantalla de un computador utilizando he- rramientas proporcionadas por diferentes ciencias como la f\u00edsica, la t\u00e9rmica, la geometr\u00eda, la \u00f3ptica, etc.", "answer_start": 13190, "answer_end": 13475, "answer_category": null}], "is_impossible": false}, {"question": "que son superficies especulares", "id": 320681, "answers": [{"answer_id": 331171, "document_id": 539586, "question_id": 320681, "text": "Superficies especulares Las superficies especulares perfectas son aquellas que reflejan y refractan la luz en una direcci\u00f3n espec\u00edfica.", "answer_start": 27877, "answer_end": 28012, "answer_category": null}], "is_impossible": false}], "context": "Universidad Central de Venezuela Facultad de Ciencias Escuela de Computaci\u00f3n Centro de Computaci\u00f3n Gr\u00e1fica Iluminaci\u00f3n global en tiempo real basada en la voxelizaci\u00f3n de escenas con superficies difusas Trabajo Especial de Grado presentado ante la Ilustre Universidad Central de Venezuela Por el Bachiller Francisco Sans para optar al t\u00edtulo de Licenciado en Computaci\u00f3n Tutor: Prof. Esmitt Ram\u00edrez Caracas, 24 Septiembre de 2012 Universidad Central de Venezuela Facultad de Ciencias Escuela de Computaci\u00f3n Centro de Computaci\u00f3n Gr\u00e1fica ACTA DEL VEREDICTO Quienes suscriben, Miembros del Jurado designado por el Consejo de la Escuela de Computaci\u00f3n para examinar el Trabajo Especial de Grado, presentado por el Bachiller Fran- cisco Sans C.I.: 18.244.557, con el t\u00edtulo Iluminaci\u00f3n global en tiempo real basada en la voxelizaci\u00f3n de escenas con superficies difusas, a los fines de cumplir con el requisito legal para optar al t\u00edtulo de Licenciado en Computaci\u00f3n, dejan constancia de lo siguiente: Le\u00eddo el trabajo por cada uno de los Miembros del Jurado, se fij\u00f3 el d\u00eda 24 de Septiem- bre de 2012, a las 2:00 pm, para que su autor lo defendiera en forma p\u00fablica, en el Centro de Computaci\u00f3n Gr\u00e1fica, lo cual se realiz\u00f3 mediante una exposici\u00f3n oral de su contenido, y luego respondi\u00f3 satisfactoriamente a las preguntas que les fueron formuladas por el Jurado, todo ello conforme a lo dispuesto en la Ley de Universidades y dem\u00e1s normativas vigentes de la Universidad Central de Venezuela. Finalizada la defensa p\u00fablica del Trabajo Especial de Grado, el jurado decidi\u00f3 aprobarlo. En fe de lo cual se levanta la presente acta, en Caracas a los 24 d\u00edas del mes de Septiembre del a\u00f1o dos mil doce, dej\u00e1ndose tambi\u00e9n constancia de que actu\u00f3 como Coordinador del Jurado el Profesor Esmitt Ram\u00edrez. __________________ Prof. Esmitt Ram\u00edrez _______________ ___________________ Prof. Jaime Parada Prof. Walter Hern\u00e1ndez Resumen El c\u00e1lculo de la iluminaci\u00f3n global en tiempo real sigue siendo un problema no resuelto en el \u00e1rea de la computaci\u00f3n gr\u00e1fica. Actualmente se tiende al uso de discretizaciones y simplificaciones que permiten una aproximaci\u00f3n realista en un tiempo aceptable a la soluci\u00f3n de este problema. Una de las t\u00e9cnicas actuales que ofrece buenos resultados es la denominada Voxel-based Global Illumination. Esta t\u00e9cnica se basa en la discretizaci\u00f3n de una escena empleando un v\u00f3xel como estructura de datos en superficies difusas y as\u00ed poder calcular r\u00e1pidamente intersecciones rayo/v\u00f3xel, permitiendo la iluminaci\u00f3n en tiempo real cercana a un punto. En este trabajo se realizan modificaciones a la propuesta original, as\u00ed como detalles de implementaci\u00f3n para realizar pruebas y comparar resultados. Palabras claves: iluminaci\u00f3n global, voxelizaci\u00f3n de escenas, GPU, tiempo real, superficies difusas. III Tabla de Contenidos Introducci\u00f3n X 1. Iluminaci\u00f3n global 1 1.1. Efectos creados por la interacci\u00f3n de la luz . . . . . . . . . . . . . . . . . . . 2 1.2. Ecuaci\u00f3n de despliegue . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3 1.3. Funci\u00f3n de distribuci\u00f3n de reflectancia bidireccional . . . . . . . . . . . . . 5 1.4. Algoritmos de iluminaci\u00f3n global . . . . . . . . . . . . . . . . . . . . . . . 7 1.5. Iluminaci\u00f3n global en tiempo real . . . . . . . . . . . . . . . . . . . . . . . 9 2. Iluminaci\u00f3n global basada en v\u00f3xeles 12 2.1. Planteamiento del problema . . . . . . . . . . . . . . . . . . . . . . . . . . 12 2.1.1. Esquema propuesto . . . . . . . . . . . . . . . . . . . . . . . . . . . 13 2.2. Voxelizaci\u00f3n . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14 2.2.1. Basada en Slicemap . . . . . . . . . . . . . . . . . . . . . . . . . . . 15 2.2.2. Basada en el uso de texturas atlas . . . . . . . . . . . . . . . . . . . 18 2.2.3. Estructura de datos . . . . . . . . . . . . . . . . . . . . . . . . . . . 20 2.3. C\u00e1lculo de la Iluminaci\u00f3n indirecta . . . . . . . . . . . . . . . . . . . . . . . 20 2.3.1. Intersecci\u00f3n rayo/v\u00f3xel . . . . . . . . . . . . . . . . . . . . . . . . . 21 2.3.2. Iluminaci\u00f3n indirecta . . . . . . . . . . . . . . . . . . . . . . . . . . 23 2.4. Despliegue . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 25 3. Implementaci\u00f3n 26 3.1. Metodolog\u00eda . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 26 3.2. Diagrama de clases y estructuras de datos . . . . . . . . . . . . . . . . . . . 26 3.2.1. Clase FBOQuad . . . . . . . . . . . . . . . . . . . . . . . . . . . . 30 3.2.2. Clase Texture . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 30 3.2.3. Clase Shaders . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 30 3.2.4. Mediciones de tiempo . . . . . . . . . . . . . . . . . . . . . . . . . 31 3.2.5. Manejo de modelos . . . . . . . . . . . . . . . . . . . . . . . . . . . 31 3.2.6. Manejo de luces . . . . . . . . . . . . . . . . . . . . . . . . . . . . 32 3.2.7. Clase GBuffer . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 32 3.2.8. Voxelizaci\u00f3n de la escena . . . . . . . . . . . . . . . . . . . . . . . 32 3.2.9. Obtenci\u00f3n de la luz directa . . . . . . . . . . . . . . . . . . . . . . . 33 IV TABLA DE CONTENIDOS V 3.2.10. Obtenci\u00f3n de la luz indirecta . . . . . . . . . . . . . . . . . . . . . . 33 3.2.11. Clase Scene . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 33 3.2.12. Navegaci\u00f3n en la escena . . . . . . . . . . . . . . . . . . . . . . . . 34 3.2.13. Manejo de los men\u00fas . . . . . . . . . . . . . . . . . . . . . . . . . . 34 3.3. Algoritmo . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 34 3.4. Implementaci\u00f3n detallada en la GPU . . . . . . . . . . . . . . . . . . . . . . 36 3.4.1. Shaders multifuncionales . . . . . . . . . . . . . . . . . . . . . . . . 36 3.4.2. G-Buffer . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 38 3.4.3. Reflective Shadow Map . . . . . . . . . . . . . . . . . . . . . . . . . 39 3.4.4. Shadow map . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 41 3.4.5. Despliegue de texturas atlas . . . . . . . . . . . . . . . . . . . . . . 42 3.4.6. Proceso de voxelizaci\u00f3n . . . . . . . . . . . . . . . . . . . . . . . . 42 3.4.7. Iluminaci\u00f3n directa . . . . . . . . . . . . . . . . . . . . . . . . . . . 45 3.4.8. Iluminaci\u00f3n indirecta . . . . . . . . . . . . . . . . . . . . . . . . . . 47 3.4.9. Filtro para la iluminaci\u00f3n indirecta . . . . . . . . . . . . . . . . . . . 54 3.4.10. Combinaci\u00f3n de soluciones . . . . . . . . . . . . . . . . . . . . . . 56 4. Pruebas y resultados 59 4.1. Ambiente de pruebas . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 59 4.2. Voxelizaci\u00f3n . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 60 4.2.1. Tama\u00f1o del volumen . . . . . . . . . . . . . . . . . . . . . . . . . . 61 4.2.2. Tama\u00f1o de la textura atlas . . . . . . . . . . . . . . . . . . . . . . . 62 4.2.3. Comparaci\u00f3n del uso de texturas atlas y slicemap . . . . . . . . . . . 63 4.3. Iluminaci\u00f3n indirecta . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 65 4.4. Tama\u00f1o de la ventana . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 69 5. Conclusiones y trabajos futuros 70 Lista de figuras 1.1. Im\u00e1genes desplegadas con iluminaci\u00f3n local (arriba) y global (abajo). . . . . 2 1.2. Fotograf\u00eda de una escena con m\u00faltiples rebotes difusos y especulares, c\u00e1usti- cas y dispersi\u00f3n de la luz. Imagen tomada de [1]. . . . . . . . . . . . . . . . 3 1.3. La radiancia emitida desde el punto x es igual a la radiancia emitida L(x \u2192 \u0398) m\u00e1s la radiancia reflejada L(x\u2190 \u03a8). Imagen tomada de [2]. . . . . . . . 4 1.4. Tipos de superficie. Imagen tomada de [2]. . . . . . . . . . . . . . . . . . . . 6 1.5. C\u00e1lculo de la iluminaci\u00f3n usando el photon mapping. Imagen en [2]. . . . . . 8 1.6. Despliegue del modelo de Marko Dabrovic de la Catedral de Sibenik [3], donde 1.6(a) es inyectada con un conjunto de luces virtuales y 1.6(b) la cate- dral es iluminada con instant radiosity. . . . . . . . . . . . . . . . . . . . . . 8 2.1. Esquema de las etapas propuestas para el c\u00e1lculo de la iluminaci\u00f3n global. . . 13 2.2. Objeto con 2.2(a) su representaci\u00f3n poligonal y 2.2(b) v\u00f3xeles. . . . . . . . . 14 2.3. Representaci\u00f3n de un volumen con una textura 2D. . . . . . . . . . . . . . . 16 2.4. Ejemplo de una escena 2.4(a) mal voxelizada con Slicemap debido a superfi- cies perpendiculares a la c\u00e1mara de voxelizado 2.4(b). . . . . . . . . . . . . . 17 2.5. Ejemplo de una textura atlas (2.5(b)) correspondiente a un modelo 3D (2.5(a)). 18 2.6. Las coordenadas de mundo del objeto 2.6(a) son almacenados en una textura atlas 2.6(b). . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19 2.7. Proceso de voxelizaci\u00f3n de una escena. . . . . . . . . . . . . . . . . . . . . 19 2.8. Construcci\u00f3n de la jerarqu\u00eda mipmap en dos dimensiones. . . . . . . . . . . . 20 2.9. Recorrido de un rayo a trav\u00e9s de la jerarqu\u00eda mipmap. . . . . . . . . . . . . . 21 2.10. C\u00e1lculo de la luz indirecta en el \u00e1rea cercana. Imagen tomada de [4]. . . . . . 25 3.1. Diagrama de clases de la implementaci\u00f3n realizada. . . . . . . . . . . . . . . 30 3.2. Distribuci\u00f3n de los shaders (bordes de colores) en las diferentes etapas del algoritmo (bordes negros). . . . . . . . . . . . . . . . . . . . . . . . . . . . 35 3.3. Resultado de las diferentes etapas del algoritmo. . . . . . . . . . . . . . . . . 58 4.1. Escenarios de prueba. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 59 4.2. Tiempo en microsegundos de la creaci\u00f3n de la jerarqu\u00eda mipmap para dife- rentes resoluciones del volumen. . . . . . . . . . . . . . . . . . . . . . . . . 61 4.3. Voxelizaci\u00f3n de una escena con diferentes tama\u00f1os de textura atlas. . . . . . 63 4.4. Tiempo de voxelizaci\u00f3n de escenas en microsegundos. . . . . . . . . . . . . 64 VI LISTA DE FIGURAS VII 4.5. Voxelizaci\u00f3n de una escena mediante slicemap y texturas atlas, y su corres- pondiente contribuci\u00f3n al c\u00e1lculo de la iluminaci\u00f3n indirecta. . . . . . . . . . 65 4.6. Comparaci\u00f3n del uso del filtro para diferentes cantidades de rayos. . . . . . . 67 4.7. Comparaci\u00f3n del uso de diferentes longitudes del rayo en el c\u00e1lculo de la iluminaci\u00f3n indirecta. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 68 4.8. Cantidad de fps para diferentes tama\u00f1os del viewport. . . . . . . . . . . . . . 69 Lista de tablas 4.1. Escenas para la realizaci\u00f3n de pruebas. . . . . . . . . . . . . . . . . . . . . . 60 4.2. Especificaciones de las tarjetas de video. . . . . . . . . . . . . . . . . . . . . 60 4.3. V\u00e9rtices creados por diferentes resoluciones de texturas atlas. . . . . . . . . . 62 4.4. Comparaci\u00f3n de tiempos en microsegundos al agregar un objeto din\u00e1mico a la escena. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 65 4.5. Tiempos en microsegundos de la aplicaci\u00f3n del filtro en la iluminaci\u00f3n indi- recta. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 69 VIII Lista de c\u00f3digos 2.1. C\u00f3digo para obtener el punto de intersecci\u00f3n. . . . . . . . . . . . . . . . . . 22 3.1. Pase de v\u00e9rtices del vertex shader al fragment shader. . . . . . . . . . . . . . 36 3.2. Pase de v\u00e9rtices y coordenadas de textura del vertex shader al fragment shader. 36 3.3. Copia de la textura de prevoxelizaci\u00f3n a la textura de voxelizado (fragment shader). . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 37 3.4. Creaci\u00f3n de la m\u00e1scara de bits (fragment shader). . . . . . . . . . . . . . . . 37 3.5. Obtenci\u00f3n del G-Buffer (vertex shader). . . . . . . . . . . . . . . . . . . . . 38 3.6. Obtenci\u00f3n del G-Buffer (fragment shader). . . . . . . . . . . . . . . . . . . . 38 3.7. Obtenci\u00f3n del RSM (vertex shader). . . . . . . . . . . . . . . . . . . . . . . 39 3.8. Obtenci\u00f3n del RSM (fragment shader). . . . . . . . . . . . . . . . . . . . . . 40 3.9. Despliegue de las coordenadas de mundo a la textura atlas (vertex shader). . . 42 3.10. Despliegue de las coordenadas de mundo a la textura atlas (fragment shader). 42 3.11. Voxelizaci\u00f3n por medio del uso de slicemap (vertex shader). . . . . . . . . . 43 3.12. Codificaci\u00f3n del volumen (fragment shader). . . . . . . . . . . . . . . . . . 43 3.13. Voxelizaci\u00f3n a trav\u00e9s del uso de texturas atlas (vertex shader). . . . . . . . . 43 3.14. Creaci\u00f3n de la jerarqu\u00eda mipmap (fragment shader). . . . . . . . . . . . . . . 44 3.15. C\u00e1lculo de la iluminaci\u00f3n directa (fragment shader). . . . . . . . . . . . . . 45 3.16. M\u00e9todo principal para el c\u00e1lculo de la intersecci\u00f3n del rayo (fragment shader). 48 3.17. Intersecci\u00f3n del rayo con la jerarqu\u00eda. . . . . . . . . . . . . . . . . . . . . . 51 3.18. C\u00e1lculo de la m\u00e1scara de bits de la intersecci\u00f3n. . . . . . . . . . . . . . . . . 52 3.19. C\u00e1lculo de la luz indirecta (fragment shader). . . . . . . . . . . . . . . . . . 52 3.20. Combinaci\u00f3n de la oclusi\u00f3n direccional con la iluminaci\u00f3n indirecta (frag- ment shader). . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 54 3.21. Filtro para eliminar el ruido en la iluminaci\u00f3n indirecta (fragment shader). . . 55 3.22. Combinaci\u00f3n de la luz indirecta y la luz directa (fragment shader). . . . . . . 56 IX Introducci\u00f3n La computaci\u00f3n gr\u00e1fica es una rama de las ciencias de la computaci\u00f3n que se encarga del estudio, dise\u00f1o y modificaci\u00f3n de im\u00e1genes en la pantalla de un computador utilizando he- rramientas proporcionadas por diferentes ciencias como la f\u00edsica, la t\u00e9rmica, la geometr\u00eda, la \u00f3ptica, etc. Una de sus mayores \u00e1reas de desarrollo es la computaci\u00f3n gr\u00e1fica tridimensional, donde se trata de recrear escenas virtuales en 3D y alcanzar un alto realismo. El objetivo es crear escenas que sean visualmente cercanas a si estas escenas existieran en realidad. Estas escenas son utilizadas en la arquitectura, el cine, en los juegos de video, en la publicidad, en simulaciones de carro y vuelos de aviones, recreaciones de objetos que no han sido produci- dos, entre otros. Un factor fundamental para infundir realismo en una escena virtual es la simulaci\u00f3n de la iluminaci\u00f3n. Esta simulaci\u00f3n es una tarea computacionalmente costosa, ya que la obten- ci\u00f3n de un buen resultado visual puede requerir mucho tiempo de c\u00e1lculo. Debido a ello, la simulaci\u00f3n de la iluminaci\u00f3n sigue siendo un problema no resuelto completamente. Diversos estudios han procurado desarrollar t\u00e9cnicas para obtener un buen resultado visual en el menor tiempo posible. En el \u00e1rea de computaci\u00f3n gr\u00e1fica, se comenz\u00f3 calculando la iluminaci\u00f3n tomando s\u00f3lo la informaci\u00f3n de la fuente de luz y la superficie iluminada. Estos algoritmos s\u00f3lo toman en cuenta la informaci\u00f3n local a la superficie y son conocidos como algoritmos de iluminaci\u00f3n local. Por ello, \u00e9stos no consideran todos los posibles caminos de los rayos luminosos, por lo que se obvian efectos que son creados por la luz, restando realismo a la escena. Tambi\u00e9n existen los algoritmos de iluminaci\u00f3n global, los cuales tratan de simular la iluminaci\u00f3n de una escena, considerando la mayor cantidad posibles de efectos creados por la interacci\u00f3n de la luz. El uso de algoritmos de iluminaci\u00f3n global permite crear escenas con un alto nivel de realismo. Sin embargo, debido a su \u00e1mbito global y a lo complejo del modelo matem\u00e1tico que expresa el calculo de la iluminaci\u00f3n, estos algoritmos tardan mucho tiempo en calcularla. Al implementar un algoritmo de iluminaci\u00f3n global, se busca lograr un buen resultado visual en un tiempo aceptable. Sin embargo, es dif\u00edcil satisfacer ambos objetivos. A tal fin, es imprescindible conocer la gama de t\u00e9cnicas existentes para poder seleccionar aquella que m\u00e1s se adec\u00fae a la soluci\u00f3n esperada. De acuerdo a esto, se hace necesario desarrollar una apli- caci\u00f3n que permita calcular la iluminaci\u00f3n en un tiempo aceptable, aprovechando al m\u00e1ximo los avances tecnol\u00f3gicos m\u00e1s recientes. El presente documento aborda los principales m\u00e9todos creados para simular la ilumina- ci\u00f3n, y se centra la implementaci\u00f3n de la t\u00e9cnica propuesta por Thiedemann et al. [4], con X INTRODUCCI\u00d3N XI el fin de poder aplicar un algoritmo de iluminaci\u00f3n global y realizar pruebas sobre \u00e9ste. Para introducir esta t\u00e9cnica, en el cap\u00edtulo 1 se presentan los conceptos b\u00e1sicos relacionados a la iluminaci\u00f3n, as\u00ed como los primeros trabajos elaborados en esta \u00e1rea. La explicaci\u00f3n detallada de la soluci\u00f3n propuesta por Thiedemann et al. [4] se expone en el cap\u00edtulo 2. Luego, en el cap\u00edtulo 3 se describe la implementaci\u00f3n de esta soluci\u00f3n realizada para este trabajo especial de grado. Despu\u00e9s, en el cap\u00edtulo 4 se describen y analizan las pruebas realizadas sobre esta implementaci\u00f3n. Finalmente, se plantean las conclusiones en el cap\u00edtulo 5. Cap\u00edtulo 1 Iluminaci\u00f3n global Uno de los campos m\u00e1s importantes en el \u00e1rea de la computaci\u00f3n gr\u00e1fica es la creaci\u00f3n de im\u00e1genes realistas. Para crear este tipo de im\u00e1genes, se tiene una escena virtual vista desde una c\u00e1mara virtual, desde la cual se despliega una imagen que sea lo m\u00e1s parecido posible a si esta escena existiera en la realidad. Para ello, es necesario representar los objetos presentes en la escena y todos los fen\u00f3menos que se producen por la interacci\u00f3n de estos con la luz. La generaci\u00f3n de im\u00e1genes realistas tiene diversas utilidades: en la arquitectura (recrean- do los dise\u00f1os antes de que se construyan), en el cine (con efectos especiales), en los juegos de video, en la publicidad, en simulaciones de carros y vuelos de aviones, en la recreaci\u00f3n de objetos que todav\u00eda no han sido producidos, entre otros. Sin embargo, debido a las limi- taciones de hardware, la generaci\u00f3n de estas im\u00e1genes no siempre ha sido posible, ya que representar la interacci\u00f3n de la luz en una escena es muy costoso desde el punto de vista computacional [2]. En tiempos pasados, en el campo de la computaci\u00f3n gr\u00e1fica, la iluminaci\u00f3n se limitaba al trazado de rayos y puntos. Los primeros algoritmos de iluminaci\u00f3n consist\u00edan en asignar un color determinado seg\u00fan el \u00e1ngulo de incidencia de la luz sobre la superficie. Posteriormente Gouraud [5] y Phong [6] introdujeron sus modelos de iluminaci\u00f3n a la computaci\u00f3n gr\u00e1fica, pero \u00e9stos solo consideraban la informaci\u00f3n local de la superficie, sin tomar en cuenta las dem\u00e1s entidades presentes en la escena. A este tipo de t\u00e9cnicas que solo usan informaci\u00f3n local, se les conoce como t\u00e9cnicas de iluminaci\u00f3n local. Por otra parte, existen las denominadas t\u00e9cnicas de iluminaci\u00f3n global, las cuales toman en cuenta la interacci\u00f3n de la luz con todas las entidades de la escena. El objetivo de los algoritmos de la iluminaci\u00f3n global es el c\u00e1lculo del estado de la distribuci\u00f3n de la energ\u00eda luminosa en una escena en un momento determinado. Debido al \u00e1mbito global de estos al- goritmos, son computacionalmente costosos y su implementaci\u00f3n para tiempos interactivos es dif\u00edcil de alcanzar. En la figura 1.1 se puede apreciar una escena iluminada con ilumina- ci\u00f3n global (abajo) y local (arriba). A la derecha de la figura se puede observar los caminos luminosos que son tomados en cuenta para cada uno de los tipos de iluminaci\u00f3n. Para profundizar en los trabajos actuales en este campo de estudio, es necesario conocer sus bases. Primero se explicar\u00e1 los diferentes efectos que son importantes recrear por medio de la iluminaci\u00f3n global. Luego se expondr\u00e1 la ecuaci\u00f3n de despliegue que se utiliza para 1 CAP\u00cdTULO 1. ILUMINACI\u00d3N GLOBAL 2 modelar la interacci\u00f3n de la luz en una escena. Posteriormente, se estudiar\u00e1n los primeros m\u00e9todos existentes para recrear la iluminaci\u00f3n global, para luego estudiar los trabajos actua- les que permiten su c\u00e1lculo en tiempo real. Figura 1.1: Im\u00e1genes desplegadas con iluminaci\u00f3n local (arriba) y global (abajo). 1.1. Efectos creados por la interacci\u00f3n de la luz Debido a que la iluminaci\u00f3n global tiene como objetivo calcular la distribuci\u00f3n de la energ\u00eda de la luz en una escena, es importante aclarar los diversos efectos que produce la interacci\u00f3n de la luz con las superficies presentes en una escena. Los diferentes algoritmos propuestos en la actualidad tratan de recrear la mayor\u00eda de estos efectos, pero a mayor canti- dad de estos, es mayor el procesamiento requerido para calcularlos. En la figura 1.2 se muestran los efectos que generalmente se tratan de representar con un algoritmo de iluminaci\u00f3n global. La luz directa se refiere al rayo de luz que viaja direc- tamente desde una fuente de luz hasta una superficie, sin considerar otros posibles caminos. En cambio, la luz indirecta es la luz que ha sido rebotada, dispersada (scattering), reflejada o refractada desde una superficie antes de iluminar otro objeto. Esto se debe al cambio de la direcci\u00f3n de los rayos de la luz al incidir sobre una superficie. Los rebotes pueden causar efectos como el sangrado de color (color bleeding) o c\u00e1usticas. Adem\u00e1s, es importante recordar que la luz son part\u00edculas, por lo que un objeto podr\u00eda obstaculizar su paso normal. Cuando un rayo luminoso es obstaculizado en gran medida se crean las sombras. Sin embargo, tambi\u00e9n se pueden encontrar elementos en el ambiente (lla- mados medios participantes), a trav\u00e9s de los cuales el rayo luminoso es obstruido levemente y es distorsionado al pasar. CAP\u00cdTULO 1. ILUMINACI\u00d3N GLOBAL 3 Figura 1.2: Fotograf\u00eda de una escena con m\u00faltiples rebotes difusos y especulares, c\u00e1usticas y dispersi\u00f3n de la luz. Imagen tomada de [1]. 1.2. Ecuaci\u00f3n de despliegue Como se mencion\u00f3 anteriormente, el objetivo de la iluminaci\u00f3n global es calcular la dis- tribuci\u00f3n de la energ\u00eda de la luz en una escena para un momento dado. Debido a la alta complejidad de la interacci\u00f3n de la luz con los diferentes componentes de una escena, Kaji- ya [7] propone una ecuaci\u00f3n que permite representar estas interacciones de tal forma que sea factible su despliegue. Esta ecuaci\u00f3n describe el flujo de la radiaci\u00f3n a trav\u00e9s de un ambiente tridimensional. Philip Dutr\u00e9 et al. [2] plantean esta ecuaci\u00f3n en t\u00e9rminos radiom\u00e9tricos de la siguiente manera: L(x\u2192 \u0398) = Le(x\u2192 \u0398) + \u222b \u2126x fr(x,\u03a8\u2192 \u0398)L(x\u2190 \u03a8) cos(Nx,\u03a8)d\u03c9\u03a8 (1.1) Esta ecuaci\u00f3n esta expresada en t\u00e9rminos de radiancia, la cual indica la cantidad de ener- g\u00eda que es recibida en (o emitido desde) cierto punto en la superficie, por unidad de \u00e1ngulo s\u00f3lido y por unidad de \u00e1rea proyectada (watts/steradian \u00d7 m2). La radiancia saliente de un punto x en la direcci\u00f3n \u0398 (L(x\u2192 \u0398)) es igual a la radiancia emitida en el punto x, saliendo en la direcci\u00f3n \u0398 (Le(x \u2192 \u0398)), m\u00e1s toda la radiancia proveniente del hemisferio iluminado que es incidente en el punto x y que es reflejada en la direcci\u00f3n \u0398, ver figura 1.3. Esta es una integral sobre todo el hemisferio del punto x y la funci\u00f3n fr representa la funci\u00f3n de distribuci\u00f3n de reflectancia bidireccional (BRDF por sus siglas en ingl\u00e9s). La BRDF se en- carga de definir sobre la esfera visible la relaci\u00f3n existente entre la radiaci\u00f3n incidente en la direcci\u00f3n \u03a8 y la radiancia reflejada en la direcci\u00f3n \u0398. Todas las luces incidentes en el \u00e1ngulo \u0398 son sumadas en proporci\u00f3n al BRDF y al coseno del \u00e1ngulo incidente, en [2] se explica con mayor detalle este proceso. La ecuaci\u00f3n de despliegue es una integral llamada la ecuaci\u00f3n de Fredholm de segundo tipo, debido a su forma: la radiancia, que es el valor desconocido, aparece tanto en el lado CAP\u00cdTULO 1. ILUMINACI\u00d3N GLOBAL 4 derecho como el izquierdo de la ecuaci\u00f3n. Sin embargo, esta funci\u00f3n es expresada en t\u00e9rminos m\u00e1s simples por Kajiya [7] de la siguiente manera: Figura 1.3: La radiancia emitida desde el punto x es igual a la radiancia emitida L(x\u2192 \u0398) m\u00e1s la radiancia reflejada L(x\u2190 \u03a8). Imagen tomada de [2]. I(x, x\u2032) = g(x, x\u2032)[e(x, x\u2032) + \u222b S p(x, x\u2032, x\u2032\u2032)I(x\u2032, x\u2032\u2032)dx\u2032\u2032 ] (1.2) Donde: I(x, x\u2032) es la intensidad de luz que pasa desde el punto x\u2032 al punto x. g(x, x\u2032) es un t\u00e9rmino geom\u00e9trico. e(x, x\u2032) es la intensidad de luz emitida desde x\u2032 a x. p(x, x\u2032, x\u2032\u2032) es la intensidad de luz dispersada desde x\u2032\u2032 a x pasando por el punto x\u2032. Esta ecuaci\u00f3n representa el balance de la energ\u00eda transmitida de un punto de una superficie a otro punto. As\u00ed, se plantea que la intensidad de luz transportada desde un punto de una superficie a otro es la suma de la luz emitida y el total de luz dispersa hacia x desde todos los puntos de las superficies. Por lo mismo, pasa de tener una integral sobre el hemisferio a tener una integral sobre S = \u22c3 Si, la uni\u00f3n de todas las superficies. A pesar de lo complejo de la ecuaci\u00f3n, la misma no toma en cuenta todos los efectos crea- dos por la luz. Entre otras cosas, asume que las superficies est\u00e1n en el vac\u00edo, donde carecen de un medio participante; no toma en cuenta el tiempo que tarda la luz en ser transportada, y no considera efectos como fosforescencia o fluorescencia. Sin embargo, en su trabajo, Kaji- ya [7] propone extensiones para abarcar estos efectos. A pesar de estas carencias, la ecuaci\u00f3n representa una generalizaci\u00f3n para la mayor parte de los algoritmos existentes que se usan para el c\u00e1lculo de la iluminaci\u00f3n global. La resoluci\u00f3n de esta ecuaci\u00f3n representa un gran reto, a\u00fan con los computadores actua- les, especialmente en aplicaciones en tiempo real. Por lo tanto, ha sido un gran campo de estudio en los \u00faltimos a\u00f1os y se ha llegado a diversos m\u00e9todos que intentan resolverla. Todos los algoritmos utilizan como base de sus c\u00e1lculos la ecuaci\u00f3n propuesta Kajiya [7]. CAP\u00cdTULO 1. ILUMINACI\u00d3N GLOBAL 5 1.3. Funci\u00f3n de distribuci\u00f3n de reflectancia bidireccional La energ\u00eda emitida hacia una escena interact\u00faa con diferentes objetos, siendo transmitida o reflejada en su superficie. Parte de la energ\u00eda tambi\u00e9n puede ser absorbida o disipada en forma de calor. La propiedad de reflectancia de la superficie de un objeto determina la manera en que la luz interact\u00faa con el mismo y cambia su apariencia. De forma general, un rayo luminoso puede incidir en un punto p con una direcci\u00f3n \u03a8 y ser reflejado en un punto q en una direcci\u00f3n \u0398. La funci\u00f3n que define la relaci\u00f3n entre la radiancia incidente y la reflejada es llamada la funci\u00f3n de distribuci\u00f3n de reflectancia bidireccional con dispersi\u00f3n en la superficie (BSSRDF). Sin embargo, los algoritmos de iluminaci\u00f3n global generalmente no consideran la dispersi\u00f3n de las superficies, ya que resulta muy compleja de modelar. Por lo tanto, asumen que el rayo reflejado siempre parte desde el mismo punto de incidencia del rayo luminoso. Por ello, las propiedades de reflectancia de una superficie son descritas con la funci\u00f3n de distribuci\u00f3n de reflectancia bidireccional (BRDF). La BRDF en un punto x es definida como la proporci\u00f3n entre el diferencial de la radiancia reflejada en una direcci\u00f3n saliente \u0398 (dL(x \u2192 \u0398)) y el diferencial de la irradiancia incidente a trav\u00e9s del diferencial por unidad de \u00e1ngulo s\u00f3lido d\u03c9\u03a8 (dE(x \u2190 \u03a8)). La irradiancia es el total de energ\u00eda incidente en una superficie, por unidad de \u00e1rea de la superficie. De esta manera, la BRDF se puede expresar como: fr(x,\u03a8\u2192 \u0398) = dL(x\u2192 \u0398) dE(x\u2190 \u03a8) (1.3) Los algoritmos de iluminaci\u00f3n global generalmente usan modelos emp\u00edricos para repre- sentar la BRDF. Dependiendo de la naturaleza de la BRDF, el material de un objeto puede parecer una superficie difusa, especular o brillosa. La BRDF puede simplificarse dependiendo de la superficie a modelar. Superficies difusas Son superficies que reflejan la luz de manera uniforme en todas las direcciones posibles, como puede observarse en la figura 1.4(a). Por lo tanto, su valor de BRDF es constante para todos los valores de \u0398 y \u03a8. Para un observador, un punto en una superficie difusa se ve igual desde todas las direcciones posibles. De esta manera, la BRDF de una superficie difusa ideal cumple la siguiente ecuaci\u00f3n: fr(x,\u03a8\u2192 \u0398) = \u03c1d \u03c0 (1.4) La reflectancia \u03c1d representa la cantidad de energ\u00eda incidente que es reflejada de la super- ficie. Este valor var\u00eda entre 0 y 1. CAP\u00cdTULO 1. ILUMINACI\u00d3N GLOBAL 6 (a) Difusas perfectas (b) Especulares perfectas (c) Brillosas Figura 1.4: Tipos de superficie. Imagen tomada de [2]. Superficies especulares Las superficies especulares perfectas son aquellas que reflejan y refractan la luz en una direcci\u00f3n espec\u00edfica. En la figura 1.4(b) se encuentra un ejemplo de estas superficies. El rayo reflejado se puede conseguir de la siguiente manera: R = 2(N \u00b7\u03a8)N \u2212\u03a8 (1.5) Donde \u03a8 es la direcci\u00f3n de la luz incidente, N es la normal de la superficie y R es el rayo reflejado. Esta ecuaci\u00f3n es derivada de la ley de reflexi\u00f3n, en la cual se establece que la normal de la superficie posee el mismo \u00e1ngulo con la direcci\u00f3n del rayo incidente y la direcci\u00f3n del rayo reflejado. Por otra parte, el rayo refractado es obtenido con la ley de Snell. En esta ley se considera la siguiente igualdad: \u03b71 sin \u03b81 = \u03b72 sin \u03b82 (1.6) Donde \u03b81 y \u03b82 son los \u00e1ngulos entre el rayo incidente y el transmitido con la normal de la superficie, y \u03b71 y \u03b72 son los \u00edndices refractivos del medio incidente y el saliente respectiva- mente. Con el uso de esta igualdad, el rayo refractado T es calculado de la siguiente manera: T = \u2212 \u03b71 \u03b72 \u03a8 +N( \u03b71 \u03b72 (N \u00b7\u03a8)\u2212 \u221a 1\u2212 \u03b71 \u03b72 2 (1\u2212 (N \u00b7\u03a8)2)) (1.7) Estas ecuaciones para el c\u00e1lculo de los rayos son solo v\u00e1lidas para superficies especulares perfectas, las cuales no son f\u00e1ciles de encontrar en el mundo real. Superficies brillosas Generalmente las superficies en la naturaleza no son puramente especulares ni puramente difusas, sino que exhiben una combinaci\u00f3n de los dos comportamientos, como se muestra en la figura 1.4(c). Estas superficies son llamadas superficies brillosas y son dif\u00edciles de modelar computacionalmente. CAP\u00cdTULO 1. ILUMINACI\u00d3N GLOBAL 7 1.4. Algoritmos de iluminaci\u00f3n global Haciendo uso de la ecuaci\u00f3n de despliegue presentada anteriormente, diferentes algorit- mos se han propuesto para tratar de resolver el problema de la iluminaci\u00f3n global. En esta secci\u00f3n se presentar\u00e1n los primeros trabajos que buscan una soluci\u00f3n a este problema. Trazado de rayos El trazado de rayos (ray tracing) fue uno de los primeros esfuerzos para lograr la ilumina- ci\u00f3n global, introducida por Whitted [8]. En su trabajo se describe una extensi\u00f3n al algoritmo de lanzado de rayos (ray casting) para poder determinar la visibilidad de las superficies e incluir el efecto de refracci\u00f3n y reflecci\u00f3n de superficies especulares perfectas. La t\u00e9cnica original presenta una alta recursividad, por lo que termina siendo ineficiente. Sin embargo, se producen im\u00e1genes realistas, por lo que se han realizado grandes esfuerzos para acelerarlo. Entre las diversas variantes propuestas encontramos: el trazado de rayos dis- tribuido propuesto por Cook et al. [9], el trabajo de Kajiya [7] sobre el trazado de caminos, el trazado de rayos inverso de Arvo [10], el trazado de rayos bidireccional [11] y el transporte de luz de metr\u00f3polis [12] propuestos por Veach y Guibas, entre otros. Radiosidad La t\u00e9cnica de radiosidad (radiosity) fue propuesta por Goral et al. [13] para resolver la interacci\u00f3n de la luz para superficies difusas. Por lo tanto, solo resuelve parcialmente el pro- blema de la iluminaci\u00f3n global. Su idea principal es calcular el promedio de radiosidad Bi en cada elemento de superficie o parche i para una escena tridimensional. Esta t\u00e9cnica presenta la ventaja de que una vez realizado el c\u00e1lculo de la iluminaci\u00f3n, es posible el despliegue de manera interactiva, ya que no depende del punto de visi\u00f3n. Sin embargo, se limita a escenas y luces est\u00e1ticas. Adem\u00e1s, solo representa la interacci\u00f3n con superficies difusas y no da el aporte especular, restando as\u00ed realismo a la escena. Cach\u00e9 de irradiancia Debido a que el ray tracing original es lento, Ward et al. [14] presentan una mejora para el c\u00e1lculo de la iluminaci\u00f3n difusa indirecta de las escenas, conocida como cach\u00e9 de irradiancia (irradiance caching). La idea principal consiste en mantener almacenada la irradiaci\u00f3n de diferentes puntos de la escena calculados anteriormente, bas\u00e1ndose en que la radiaci\u00f3n en superficies difusas var\u00eda de manera suave. Mapeado de fotones El mapeado de fotones (photon mapping) fue propuesto por Jensen [15\u201317]. Consiste en trazar rayos desde la luz y desde el punto de vista. Esta t\u00e9cnica hace uso del almacenamiento de la radiaci\u00f3n calculada a trav\u00e9s de los rayos emitidos desde la luz. En la primera pasada se disparan fotones desde la luz y la cantidad de radiancia que emiten es almacenada en una CAP\u00cdTULO 1. ILUMINACI\u00d3N GLOBAL 8 estructura llamada el mapa de fotones [18]. En la segunda pasada se despliega la imagen utilizando la informaci\u00f3n almacenada. En la figura 1.5 se observa el uso del mapeado de fotones para el c\u00e1lculo de la iluminaci\u00f3n. El procesos de toma de muestras en el mapa de fotones se realiza con el segundo rebote del rayo. Sin embargo, se puede crear un mapa de c\u00e1usticas tomando muestras en el primer rebote. Diferentes mapas conllevan diferentes formas de tomar muestras. Figura 1.5: C\u00e1lculo de la iluminaci\u00f3n usando el photon mapping. Imagen en [2]. Radiosity instant\u00e1neo En 1997, Keller [19] propone la t\u00e9cnica de radiosity instant\u00e1neo (instant radiosity), como un algoritmo de dos pasadas. La idea consiste en reemplazar la luz difusa indirecta por luz difusa directa proveniente desde un punto de luz llamado punto de luz virtual (virtual light points, VPL). Para ello, se trazan rayos desde la fuente de luz y se colocan luces virtuales en el punto de intersecci\u00f3n. Eventualmente se puede permitir la dispersi\u00f3n especular para colocar m\u00e1s luces virtuales a partir de la primera luz virtual, como se observa en la figura 1.6. (a) (b) Figura 1.6: Despliegue del modelo de Marko Dabrovic de la Catedral de Sibenik [3], donde 1.6(a) es inyectada con un conjunto de luces virtuales y 1.6(b) la catedral es iluminada con instant radiosity. CAP\u00cdTULO 1. ILUMINACI\u00d3N GLOBAL 9 Cortes-de-luz Walter et. al [20, 21] proponen la t\u00e9cnica de Cortes-de-luz (Lightcuts), para el despliegue de efectos complejos como los son: una gran cantidad de luces, desenfoque por movimiento, desenfoque por distancia y presencia de medios participantes. En [20] se propone representar las luces a trav\u00e9s de un \u00e1rbol, de tal manera que estas puedan ser unidas en clusters. De esta forma, quedar\u00e1n las fuentes de luz en las hojas y en los nodos internos quedar\u00e1n representaciones promediadas de las mismas. Utilizando este \u00e1rbol, no se necesita evaluar todas las luces, sino un corte del \u00e1rbol tal que no se exceda de un error preestablecido. Estas propuestas solo resuelven parcialmente el problema de la iluminaci\u00f3n global. Si se realizan demasiadas simplificaciones, se obtiene una soluci\u00f3n poco realista en un tiempo aceptable; si no se realizan simplificaciones, se obtiene una soluci\u00f3n realista, pero en un tiem- po excesivo. Actualmente, con los avances en computaci\u00f3n, se han realizado propuestas para el c\u00e1lculo de la iluminaci\u00f3n tratando de mejorar los trabajos pasados y obteniendo mejores resultados. Generalmente se trata de obtener una soluci\u00f3n visualmente aceptable en tiempos interactivos. En la siguiente secci\u00f3n se expondr\u00e1n las investigaciones actuales en el c\u00e1lculo de la iluminaci\u00f3n global. 1.5. Iluminaci\u00f3n global en tiempo real A pesar de los grandes avances en computaci\u00f3n en los \u00faltimos a\u00f1os, el c\u00e1lculo de la ilu- minaci\u00f3n global en tiempo real continua siendo un gran reto. Sin embargo, debido a su gran importancia, se han realizado diversas investigaciones que tratan de obtener una soluci\u00f3n vi- sualmente aceptable, en el menor tiempo posible. Esto se debe a que actualmente se reconoce que en la mayor\u00eda de los casos no es necesario calcular una soluci\u00f3n exacta para crear un efecto convincente. Adem\u00e1s, la mayor parte de las investigaciones actuales tienden al uso de la GPU. La unidad de procesamiento gr\u00e1fico o GPU (acr\u00f3nimo del ingl\u00e9s graphics processing unit) es un coprocesador dedicado al procesamiento de gr\u00e1ficos u operaciones de coma flo- tante, para aligerar la carga de trabajo del procesador central como en los juegos de video o aplicaciones 3D interactivas. De esta forma, mientras gran parte de lo relacionado con los gr\u00e1ficos se procesa en la GPU, la unidad central de procesamiento (CPU) puede dedicarse a otro tipo de c\u00e1lculos (como la inteligencia artificial o los c\u00e1lculos mec\u00e1nicos en el caso de los juegos de video). Seg\u00fan Kaplayan y Dachsbacher [22] las t\u00e9cnicas actuales de iluminaci\u00f3n global en tiempo real pueden clasificarse de la siguiente manera: M\u00e9todos cl\u00e1sicos Dadas las mejoras actuales de hardware, m\u00e9todos cl\u00e1sicos como raytracing [23] y radio- sity [24], han sido mejorados para poder alcanzar as\u00ed desempe\u00f1os interactivos. Sin embargo, CAP\u00cdTULO 1. ILUMINACI\u00d3N GLOBAL 10 estas mejoras representan grandes restricciones o el uso de grandes cantidades de poder de computaci\u00f3n, por lo que no son la mejor opci\u00f3n para aplicaciones en tiempo real. Iluminaci\u00f3n precalculada Esta es una de las t\u00e9cnicas m\u00e1s usadas especialmente en video juegos, como Halo 3 [25] o Dragon Age II [26]. Esta consiste en realizar el prec\u00e1lculo de la iluminaci\u00f3n, incluyendo informaci\u00f3n de visibilidad, lo que conlleva la restricci\u00f3n del uso de escenas est\u00e1ticas o semi- est\u00e1ticas [27] [28]. M\u00e9todos en espacio de imagen El espacio de imagen es un sistema de coordenadas 2D que corresponde a coordenadas f\u00edsicas de la pantalla. Estas t\u00e9cnicas hacen uso de la GPU para el c\u00e1lculo de la iluminaci\u00f3n en el espacio de imagen [29] [30], y s\u00f3lo trabajan en \u00e9ste espacio, por lo que ignoran objetos o luces que se encuentran fuera de \u00e9ste espacio. As\u00ed, crean una gran cantidad de artefactos y es necesario un post-procesamiento para disminuirlos. Dachsbacher y Stamminger [31] proponen una t\u00e9cnica eficiente basada en el uso de reflec- tive shadow maps (RSM). Los RSM utilizan la idea de los mapas de sombras para capturar puntos iluminados de forma directa, y as\u00ed convertir cada p\u00edxel en peque\u00f1os puntos de luz. Otra de las t\u00e9cnicas con m\u00e1s auge a sido el c\u00e1lculo de oclusi\u00f3n ambiental en espacio de imagen [32] [33]. M\u00e9todos basados en instant radiosity Haciendo uso del instant radiosity [19], es posible calcular la iluminaci\u00f3n de una escena a trav\u00e9s de VPL. Con el uso del RSM [31], se pueden calcular VPL para el primer rebote de luz indirecta, por lo que esta t\u00e9cnica ha cobrado gran inter\u00e9s en el c\u00e1lculo de la iluminaci\u00f3n global durante los \u00faltimos a\u00f1os [34] [35] [36] [37]. Una de las principales desventajas de estas t\u00e9cnicas es que es necesario un gran n\u00famero de VPL para solventar los artefactos en la imagen final. M\u00e9todos basado en modelos discretos Consiste en la discretizaci\u00f3n de los t\u00e9rminos de radiaci\u00f3n de una escena, de tal manera que estos puedan ser guardados en un mallado tridimensional que la represente. La luz inter- act\u00faa con elementos vecinos del volumen, reduciendo el c\u00e1lculo por interacci\u00f3n a un \u00e1mbito local [38] [22] [39] [40]. Son principalmente empleados para modelar diversos medios parti- cipantes. M\u00e9todos de aproximaciones geom\u00e9tricas Uno de los mayores aspectos a tomar en cuenta cuando se quiere calcular la iluminaci\u00f3n global, es la complejidad y el dinamismo de la escena. El uso de una descripci\u00f3n poligonal de CAP\u00cdTULO 1. ILUMINACI\u00d3N GLOBAL 11 una escena generalmente consume mucho tiempo. Por lo tanto, su discretizaci\u00f3n en elementos m\u00e1s simples puede agilizar el c\u00e1lculo del transporte de la luz. Esta vertiente se basa en la idea de calcular la iluminaci\u00f3n global en objetos at\u00f3micos pre- calculados, usualmente usando discos, esferas [41] o surfels [42] [43]. Debido al incremento del poder de procesamiento de la GPU, est\u00e1s t\u00e9cnicas han cobrado importancia. Sin embar- go, la representaci\u00f3n de las escenas en estos elementos at\u00f3micos puede llegar a ser costosa y dif\u00edcil de calcular. Una de las vertientes actuales es el uso de la discretizaci\u00f3n de escenas empleando v\u00f3xeles para el c\u00e1lculo de la iluminaci\u00f3n global, ya sea con el uso de v\u00f3xeles para la representaci\u00f3n de la geometr\u00eda de la escena [44] [45] [46] o de grids para la dispersi\u00f3n de la luz en el ambiente [38] [22] [45]. Uno de los trabajos m\u00e1s recientes en esta \u00e1rea es el realizado por Thiedemann et al. [4], donde se introduce una nueva t\u00e9cnica basada en el uso de texturas atlas para obtener la voxelizaci\u00f3n de la escena, adem\u00e1s de proponerse pruebas de intersecci\u00f3n rayo/v\u00f3xel. Estas pruebas permiten el c\u00e1lculo de la iluminaci\u00f3n de un solo rebote de la luz en un \u00e1rea cercana en tiempo real. Cap\u00edtulo 2 Iluminaci\u00f3n global basada en v\u00f3xeles En este cap\u00edtulo, se expondr\u00e1n las diferentes ideas expuestas en el trabajo de Thiedemann et al. [4] y como estas ideas son implementadas en este trabajo especial de grado. A continua- ci\u00f3n, se expondr\u00e1 el planteamiento del problema y se presentar\u00e1 un esquema del algoritmo propuesto, resaltando cada uno de los pasos necesarios para obtener la iluminaci\u00f3n global. 2.1. Planteamiento del problema Como se mencion\u00f3 en el cap\u00edtulo anterior, el objetivo de los algoritmos de la iluminaci\u00f3n global es el c\u00e1lculo del estado de la distribuci\u00f3n de la energ\u00eda luminosa en una escena en un momento determinado. Dada la complejidad de la interacci\u00f3n de la luz con la escena, es necesario realizar simplificaciones para obtener una aproximaci\u00f3n de la iluminaci\u00f3n global en tiempos interactivos. En este trabajo se hace necesario realizar una aplicaci\u00f3n que permita el c\u00e1lculo de la iluminaci\u00f3n global en tiempos interactivos. Para ello, se plantea el uso de la GPU para la aceleraci\u00f3n del proceso completo; y la t\u00e9cnica de iluminaci\u00f3n basada en v\u00f3xeles. Esta t\u00e9cni- ca obtiene resultados visuales de alta calidad as\u00ed como tiempos interactivos adecuados para aplicaciones en tiempo real. Una de las t\u00e9cnicas m\u00e1s recientes para el c\u00e1lculo de la iluminaci\u00f3n global es la pro- puesta por Thiedemann et al. [4]. En esta propuesta, se utiliza la discretizaci\u00f3n de la escena por medio de la voxelizaci\u00f3n, pasando de una representaci\u00f3n poligonal a v\u00f3xeles. Para ello, Thiedemann et al. proponen una nueva t\u00e9cnica de voxelizado a trav\u00e9s de texturas atlas. Una textura atlas es una representaci\u00f3n plana de un objeto, que generalmente es utilizada para su texturizado. El c\u00e1lculo de la luz indirecta se realiza haciendo uso de los v\u00f3xeles, utilizando una t\u00e9cnica parecida a las t\u00e9cnicas del c\u00e1lculo de la iluminaci\u00f3n en espacio de imagen. Para simplificar los c\u00e1lculos solo se considera un rebote de la luz indirecta, ya que seg\u00fan Tabe- llion et al. [47] un solo rebote es suficiente para introducir veracidad visual en la imagen. La escena es proyectada desde el punto de vista de la c\u00e1mara y para cada uno de los p\u00edxeles de la imagen un rayo es lanzado hacia la escena. Para calcular la luz indirecta en el primer punto de intersecci\u00f3n, se lanzan N rayos a partir de ese punto hacia la escena y se calcula su 12 CAP\u00cdTULO 2. ILUMINACI\u00d3N GLOBAL BASADA EN V\u00d3XELES 13 intersecci\u00f3n utilizando la representaci\u00f3n voxelizada de la escena. De esta manera, la soluci\u00f3n de la iluminaci\u00f3n global carece de los defectos presentes en la t\u00e9cnicas de espacio de imagen, ya que tanto oclusores como emisores de luz que no son vistos en el espacio de imagen, son considerados a trav\u00e9s de los v\u00f3xeles. Adem\u00e1s, Thiedemann et al. [4] proponen una t\u00e9cnica para acelerar el c\u00e1lculo de la intersecci\u00f3n rayo/v\u00f3xel. En esta t\u00e9cnica, mientras m\u00e1s corto se mantenga el rayo, m\u00e1s r\u00e1pido ser\u00e1 el c\u00e1lculo de la intersecci\u00f3n. Por ello, manteniendo la longitud del rayo peque\u00f1a se puede obtener una soluci\u00f3n a la iluminaci\u00f3n global en tiempos interactivos. Utilizando las ideas expuestas por Thiedemann et al. [4], se realiz\u00f3 una implementaci\u00f3n de un algoritmo de iluminaci\u00f3n global, en la cual se permite interactuar con la escena y mo- dificar los diferentes par\u00e1metros del algoritmo. Con ello, se pretende realizar pruebas sobre el mismo para poder hacer mediciones sobre los resultados obtenidos. 2.1.1. Esquema propuesto Etapa 1 Etapa 2 Voxelizar la escena Crear la Jerarqu\u00eda mipmap Etapa 3 Calcular iluminaci\u00f3n directa Calcular iluminaci\u00f3n indirecta Etapa final Combinar soluciones de iluminaci\u00f3n (luz directa + luz indirecta) Desplegar escena final Calcular Shadowmap Calcular G-Buffer Calcular Reflective Shadow Map Figura 2.1: Esquema de las etapas propuestas para el c\u00e1lculo de la iluminaci\u00f3n global. Para lograr el c\u00e1lculo de la iluminaci\u00f3n global bas\u00e1ndose en el trabajo de Thiedemann et al. [4], se siguen las etapas mostradas en la imagen 2.1. La soluci\u00f3n final se obtiene de combinar la contribuci\u00f3n de la luz directa y la luz indirecta. Para la obtenci\u00f3n de la luz directa es necesario calcular la contribuci\u00f3n directa de cada una de las luces. Adem\u00e1s, para crear un efecto m\u00e1s realista se agregan las sombras que cada una de las luces crea sobre la escena, por lo que es necesario el uso del shadow maps. En el caso de la luz indirecta es un proceso m\u00e1s complejo. Primeramente se necesita voxelizar la escena utilizando alguna de las t\u00e9cnicas propuestas: slicemap o texturas atlas. Una vez obtenida la escena voxelizada se puede crear una jerarqu\u00eda mipmap, la cual es una estructura de datos con la que se aceleran los c\u00e1lculos. Al mismo tiempo, se obtiene un reflective shadow map para cada una de las CAP\u00cdTULO 2. ILUMINACI\u00d3N GLOBAL BASADA EN V\u00d3XELES 14 luces y un G-Buffer para la escena, el cual contiene un conjunto de buffers intermedios que almacenan informaci\u00f3n sobre la escena para ser usada posteriormente. Una vez obtenida la escena voxelizada, el G-Buffer y los RSM se procede al c\u00e1lculo de la iluminaci\u00f3n indirecta de la manera propuesta por Thiedemann et al. [4] y combinandola con la iluminaci\u00f3n directa se obtiene la iluminaci\u00f3n global. Cada uno de estos procesos son explicados con mayor detalle a lo largo de este cap\u00edtulo. Primeramente se expondr\u00e1 lo que es la voxelizaci\u00f3n, explicando las t\u00e9cnicas a utilizar en este trabajo, la forma de almacenar una escena voxelizada y como crear una jerarqu\u00eda mipmap a partir de esta representaci\u00f3n. Luego se detallar\u00e1 el m\u00e9todo de intersecci\u00f3n rayo/voxel pro- puesto por Thiedemann et al. [4] y se mostrar\u00e1 como se utiliza para obtener la iluminaci\u00f3n indirecta. Por \u00faltimo, se explicar\u00e1 como se obtiene la iluminaci\u00f3n directa y como se combina con la iluminaci\u00f3n indirecta para crear la iluminaci\u00f3n global. 2.2. Voxelizaci\u00f3n Las escenas se dise\u00f1an con mayor complejidad geom\u00e9trica cada vez. Mientras m\u00e1s com- plejidad exista, la interacci\u00f3n con una escena y la realizaci\u00f3n de c\u00e1lculos sobre la misma, se vuelve un proceso m\u00e1s costoso. Por ello, es de gran inter\u00e9s encontrar una representaci\u00f3n alternativa de la escena, como lo es el uso de v\u00f3xeles, lo cual requiere utilizar la voxelizaci\u00f3n. La voxelizaci\u00f3n de escenas es el proceso mediante el cual se transforma la representaci\u00f3n de una escena compuesta de entidades geom\u00e9tricas, en un grid tridimensional conformado por v\u00f3xeles. Cada celda del grid codifica informaci\u00f3n espec\u00edfica acerca de la escena. En la figura 2.2 podemos observar un objeto con su representaci\u00f3n poligonal 2.2(a) y su represen- taci\u00f3n con v\u00f3xeles 2.2(b). (a) (b) Figura 2.2: Objeto con 2.2(a) su representaci\u00f3n poligonal y 2.2(b) v\u00f3xeles. Dependiendo de la informaci\u00f3n que necesite ser almacenada, se tienen varios tipos de CAP\u00cdTULO 2. ILUMINACI\u00d3N GLOBAL BASADA EN V\u00d3XELES 15 voxelizaci\u00f3n. La binaria, que solo se encarga de codificar la presencia o la ausencia de geo- metr\u00eda en el v\u00f3xel, y la multivalor, que puede almacenar m\u00e1s informaci\u00f3n como las normales o coeficientes de materiales. Por otro lado, la voxelizaci\u00f3n tambi\u00e9n puede dividirse en voxeli- zaci\u00f3n de superficies, si solo toma en cuenta las superficies de los objetos; o en voxelizaci\u00f3n s\u00f3lida, si tambi\u00e9n toma en cuenta su interior. Por mucho tiempo la voxelizaci\u00f3n fue una tarea costosa, generalmente realizada como un preprocesamiento. Sin embargo, la utilizaci\u00f3n del hardware gr\u00e1fico moderno, ha permitido realizar la voxelizaci\u00f3n de escenas en tiempos interactivos. La idea es utilizar la funcionalidad de rasterizaci\u00f3n1 presente en el hardware gr\u00e1fico para acelerar la voxelizaci\u00f3n. Esto se debe a que la rasterizaci\u00f3n y la voxelizaci\u00f3n son procesos similares. En el proceso est\u00e1ndar de rasterizaci\u00f3n, los tri\u00e1ngulos son convertidos en un frame buffer 2D. Solo los fragmentos m\u00e1s cercanos son almacenados en el frame buffer. Sin embargo, la voxelizaci\u00f3n es un proceso de rasterizaci\u00f3n 3D, por lo que es requerido un espacio discreto de v\u00f3xeles. Haciendo uso de la GPU, existen diferentes maneras de voxelizar una escena. El primer enfoque fue propuesto por Fang et al. [48], con los algoritmos de cortes (slicing). Su algorit- mo consiste en usar diversas configuraciones del z-near y del z-far de una c\u00e1mara ortogonal para capturar diferentes cortes de la geometr\u00eda de una escena. Usando la idea de slicing, Cra- ne et al. [49] proponen una t\u00e9cnica donde intersectan todos los tri\u00e1ngulos de la escena con cada uno de los planos del volumen, para as\u00ed llenar todas las capas. Posteriormente, Passalis et al. [50] y Li et al. [51] propusieron un m\u00e9todo llamado pelado-por-capas (Depth-peeling). En esta t\u00e9cnica la escena se va pelando capa por capa, y se va almacenando cada una de las capas en el volumen. Por \u00faltimo, est\u00e1n las t\u00e9cnicas que utilizan rasterizadores personaliza- dos. Fueron propuestas por Dong et al. [52] y Eisemann et al. [53], en donde se utiliza la profundidad de los fragmentos para codificar el volumen. Actualmente, se poseen diversas t\u00e9cnicas que permiten voxelizar una escena en muy poco tiempo. En este trabajo, interesa el uso la voxelizaci\u00f3n de superficies, ya que solo se considera la interacci\u00f3n de la luz con la superficie de los objetos. Adem\u00e1s, para simplificar los c\u00e1lculos, se utiliza una voxelizaci\u00f3n binaria. Se implementan dos t\u00e9cnicas de voxelizado: mapa de cortes (Slicemap) [53] y la voxelizaci\u00f3n utilizando texturas atlas [4]. 2.2.1. Basada en Slicemap Es una t\u00e9cnica propuesta por Eiseman y D\u00e9coret [53], en donde se utilizan los shaders 2 para crear el volumen. Se basa en el uso del hardware gr\u00e1fico, ya que la vista de despliegue puede definir el grid del volumen impl\u00edcitamente, y porque para cada fragmento se encuentra la intersecci\u00f3n del mismo con el grid. 1La rasterizaci\u00f3n es el proceso por el cual una imagen descrita en un formato gr\u00e1fico vectorial se convierte en un conjunto de p\u00edxeles o puntos para ser desplegados en un medio de salida digital, como una pantalla de computadora, una impresora electr\u00f3nica o una imagen de mapa de bits 2Los shaders son programas que reemplazan ciertas etapas del pipeline gr\u00e1fico de la GPU. Los programas que m\u00e1s se utilizan son el de v\u00e9rtices (vertex shader), el de fragmentos (fragment shader) y el de geometr\u00edas (geometry shader). CAP\u00cdTULO 2. ILUMINACI\u00d3N GLOBAL BASADA EN V\u00d3XELES 16 Codificaci\u00f3n del volumen La idea m\u00e1s b\u00e1sica para codificar un volumen con v\u00f3xeles bi- narios es el uso de una matriz tridimensional, donde cada posici\u00f3n indique la presencia de geometr\u00eda o no. Sin embargo, es mucho m\u00e1s eficiente el uso de una textura 2D para el mis- mo prop\u00f3sito. El alto y el ancho de la textura definen el alto y el ancho del volumen, y la profundidad es codificada con los bits de los canales RGBA de la textura. La manera m\u00e1s eficiente de almacenar un volumen en una textura 2D, es haciendo uso de shaders y colocando el volumen como objetivo de despliegue. Para ello, se define una c\u00e1mara de la escena de tal forma que el frustum 3 envuelva el \u00e1rea a ser voxelizada. Se puede utilizar tanto una c\u00e1mara perspectiva como una ortogonal. El viewport a utilizar debe corresponder con el alto y el ancho del volumen (w\u00d7h). Para la profundidad es posible utilizar una textura de tipo GL_RGBA32UI , las cuales utilizan 32 bits por canal, obteniendo en cada texel una columna de 128 celdas. Una vez escogida la c\u00e1mara y el viewport, se obtiene un volumen de dimensiones w \u00d7 h\u00d7 128 donde cada bit de la textura 2D representa informaci\u00f3n, como se observa en la figura 2.3. Cada bit ser\u00e1 utilizado para codificar si una primitiva intersecta esa celda o no. Figura 2.3: Representaci\u00f3n de un volumen con una textura 2D. Creaci\u00f3n del volumen Para generar el volumen se despliega la escena en una textura uti- lizando un fragment shader. La textura necesita estar inicializada en 0 y se requiere colocar la c\u00e1mara para que envuelva la escena. Adem\u00e1s, se debe preparar el pipeline gr\u00e1fico. Una textura debe ser colocada como objetivo de despliegue y se debe colocar la operaci\u00f3n de OR l\u00f3gico para la mezcla de colores: glLogicOp(GL_OR); glEnable(GL_COLOR_LOGIC_OP); 3Frustum es una porci\u00f3n de una figura geom\u00e9trica (e.g. pir\u00e1mide) comprendida entre dos planos paralelos. Las aplicaciones de despliegue gr\u00e1fico utilizan esta figura para calcular la parte del escenario virtual que ve la c\u00e1mara virtual. CAP\u00cdTULO 2. ILUMINACI\u00d3N GLOBAL BASADA EN V\u00d3XELES 17 Para cada primitiva es necesario determinar con cuales v\u00f3xeles intersecta y colocar el bit de la textura correspondiente a esa celda en 1. El rasterizado de la primitiva crear\u00e1 un fragmento por cada columna que se intersecte. En el fragment shader se tiene la informaci\u00f3n de la profundidad y con el mismo se calcula una m\u00e1scara de bits, en donde todos los bits son 0 excepto el correspondiente al corte intersectado, el cual se colocar\u00e1 en 1. El valor de profundidad est\u00e1 mapeado en los valores [0,1]. Este valor es usado para realizar una b\u00fasqueda en una textura 1D, la cual contendr\u00e1 las m\u00e1scaras de bits correspondientes para cada uno de los 128 valores de profundidad posible. Usar esta textura es \u00fatil, ya que los valores de cada una de las m\u00e1scaras son independientes del volumen y pueden ser calculados una sola vez. Adem\u00e1s, el acceso a una textura es m\u00e1s r\u00e1pido que crear la m\u00e1scara de bits. El valor de profundidad del v\u00e9rtice que se encuentra disponible en el fragment shader no representa una distribuci\u00f3n uniforme en coordenadas de mundo. Por lo tanto, se realiza una transformaci\u00f3n que toma en consideraci\u00f3n la distancia real de los v\u00e9rtices a la c\u00e1mara. Estas distancias son transferidas al fragment shader como coordenadas de textura, las cuales ser\u00e1n interpoladas, obteniendo el valor correcto de profundidad z en el rango [\u2212zn, zf ]. Este valor es mapeado de manera uniforme usando: z\u2032 = z + zn zn+ zf (2.1) (a) (b) Figura 2.4: Ejemplo de una escena 2.4(a) mal voxelizada con Slicemap debido a superficies perpendiculares a la c\u00e1mara de voxelizado 2.4(b). Esta t\u00e9cnica solo necesita desplegar la escena una vez por ciclo, por lo que se realiza en tiempo despreciable. Sin embargo, como depende del proceso de rasterizado, superficies que son perpendiculares a la c\u00e1mara de voxelizado solo crean un fragmento por columna, por lo que se podr\u00eda perder mucha informaci\u00f3n. Eso se puede observar en la figura 2.4. Para solventar este problema Thiedemann et al. [4] proponen una t\u00e9cnica de voxelizado por medio de texturas atlas, la cual se explicar\u00e1 a continuaci\u00f3n. CAP\u00cdTULO 2. ILUMINACI\u00d3N GLOBAL BASADA EN V\u00d3XELES 18 2.2.2. Basada en el uso de texturas atlas Esta t\u00e9cnica fue propuesta por Thiedemann et al. [4] como un enfoque novedoso para la voxelizaci\u00f3n de escenas. Dicho enfoque se centra en el almacenamiento de superficies de objetos, pudiendo ser de forma binaria o multivalor. En la forma binaria se utilizan los bits de los canales RGBA de una textura 2D para la codificaci\u00f3n de los v\u00f3xeles, de la misma manera en que se realiza en slicemap. Este m\u00e9todo funciona para cualquier tipo de modelos, ya sean est\u00e1ticos o din\u00e1micos, siempre y cuando puedan ser almacenados en una textura atlas y que sea posible generar una correspondencia apropiada. Una textura atlas es una imagen que contiene muchas im\u00e1genes m\u00e1s peque\u00f1as, cada una de las cuales es una textura de una parte de un modelo, o bien texturas de modelos diferentes. Estas peque\u00f1as texturas pueden ser desplegadas modificando las coordenadas UV del objeto en el atlas, b\u00e1sicamente indic\u00e1ndole que parte de la imagen corresponde a su textura. En la figura 2.5 se observa como una textura atlas (parte 2.5(b)) es mapeada a un objeto para su despliegue (parte 2.5(a)). (a) (b) Figura 2.5: Ejemplo de una textura atlas (2.5(b)) correspondiente a un modelo 3D (2.5(a)). Para realizar la voxelizaci\u00f3n, primero se necesita desplegar la escena en una o varias texturas atlas por cada objeto. Para ello, se coloca la textura como objetivo de despliegue y se pasan las coordenadas de textura atlas como coordenadas de textura al vertex shader. All\u00ed se normalizan estas coordenadas al espacio [\u22121, 1]2 y se utilizan como la posici\u00f3n del v\u00e9rtice. Adem\u00e1s, el vertex shader pasa la posici\u00f3n en el espacio de mundo al fragment shader, el cual solo se encargar\u00e1 de desplegar esta posici\u00f3n en la textura atlas como un color. En la figura 2.6 se observa como las coordenadas de mundo de un objeto (parte 2.6(a)) son almacenadas en una textura atlas (parte 2.6(b)). Generalmente este mapeado dejar\u00e1 huecos, por lo que se necesita marcar esas entradas como inv\u00e1lidas. Una manera de hacerlo es crear un vertex buffer object con cada una de las posiciones v\u00e1lidas de la textura, el cual solo necesita ser creado una vez. Por cada texel v\u00e1lido en la textura atlas se crea un v\u00e9rtice. Al crear el volumen, se despliega cada uno de los v\u00e9rtices almacenados en el vertex buffer object. La coordenada del v\u00e9rtice es utilizada para extraer de la textura atlas su correspon- diente posici\u00f3n en el espacio de mundo. Es necesario transformar esta posici\u00f3n al sistema de CAP\u00cdTULO 2. ILUMINACI\u00d3N GLOBAL BASADA EN V\u00d3XELES 19 (a) (b) Figura 2.6: Las coordenadas de mundo del objeto 2.6(a) son almacenados en una textura atlas 2.6(b). coordenadas definido por la c\u00e1mara de voxelizaci\u00f3n. Posteriormente, se realiza un proceso similar al propuesto en la t\u00e9cnica de Slicemap para introducir este v\u00e9rtice en el grid. En la figura 2.7 se observa c\u00f3mo la escena es transformada en una textura atlas que contiene las coordenadas de mundo, para posteriormente ser insertada en el grid. Figura 2.7: Proceso de voxelizaci\u00f3n de una escena. Debido a que los objetos son desplegados en una textura atlas antes de ser voxelizados, est\u00e1 t\u00e9cnica carece de los problemas que presentaba slicemap con superficies perpendiculares a la c\u00e1mara de voxelizaci\u00f3n. Sin embargo, se necesita desplegar cada uno de los objetos en una o varias texturas, y posteriormente procesar cada una de esas texturas para llevarse al grid. CAP\u00cdTULO 2. ILUMINACI\u00d3N GLOBAL BASADA EN V\u00d3XELES 20 Con el uso de cualquiera de las dos t\u00e9cnicas, si existe una escena con objetos din\u00e1micos y est\u00e1ticos, es posible aplicar una pre voxelizaci\u00f3n de todas la partes est\u00e1ticas. De esta manera, en tiempo de ejecuci\u00f3n solo ser\u00e1 necesario voxelizar los objetos din\u00e1micos y combinar sus v\u00f3xeles con los v\u00f3xeles precalculados para los objetos est\u00e1ticos. Adem\u00e1s, es posible crear una jerarqu\u00eda de mipmap a partir del grid almacenado en una textura 2D, de tal forma que pueda acelerarse los c\u00e1lculos realizados sobre \u00e9ste. 2.2.3. Estructura de datos Para poder acelerar los c\u00e1lculos sobre el volumen, Thiedemann et al. [4] proponen el uso de una jerarqu\u00eda, utilizando una idea similar a la propuesta por Forest et al. [54]. Se aprovecha la representaci\u00f3n del volumen por medio de una textura 2D para emplear una jerarqu\u00eda de mipmaps [55]. Los mipmaps son colecciones de im\u00e1genes m\u00e1s peque\u00f1as, que acompa\u00f1an a una textura principal para aumentar la velocidad de despliegue y reducir sus artefactos. Cada imagen del mipmap representa una versi\u00f3n reducida de la textura principal, cuyas dimensiones se van disminuyendo a la mitad hasta obtener una textura de 1 \u00d7 1 p\u00edxeles. As\u00ed, es posible obtener diversas resoluciones de una escena voxelizada en una textura 2D, donde el nuevo nivel es construido utilizando operaciones de OR l\u00f3gico en los mapas de bits de niveles anteriores. Debido a que cada p\u00edxel siempre posee la misma resoluci\u00f3n sin importar su nivel en la jerarqu\u00eda, la profundidad del volumen siempre mantendr\u00e1 la misma resoluci\u00f3n (en la figura 2.8 se ejemplifica la construcci\u00f3n de esta jerarqu\u00eda). Figura 2.8: Construcci\u00f3n de la jerarqu\u00eda mipmap en dos dimensiones. En la siguiente secci\u00f3n se explicar\u00e1 el uso de la representaci\u00f3n de la escena a trav\u00e9s de v\u00f3xeles para el c\u00e1lculo de la iluminaci\u00f3n indirecta. 2.3. C\u00e1lculo de la Iluminaci\u00f3n indirecta Para obtener la iluminaci\u00f3n indirecta es necesario poder lanzar rayos a trav\u00e9s de la es- cena y calcular sus intersecciones con las mismas. Por ello, Thiedemann et al. [4] proponen una prueba de visibilidad entre dos puntos y una prueba para el calculo de la intersecci\u00f3n, CAP\u00cdTULO 2. ILUMINACI\u00d3N GLOBAL BASADA EN V\u00d3XELES 21 haciendo uso de la representaci\u00f3n de la escena en una textura 2D con una jearqu\u00eda mipmap para acelerar los c\u00e1lculos. 2.3.1. Intersecci\u00f3n rayo/v\u00f3xel Visibilidad entre dos puntos en el espacio Con el objetivo de poder trazar un rayo a lo largo de la jerarqu\u00eda mipmap, es necesario transformar el rayo en coordenadas de dispositivo normalizadas (normal device coordinates, NDC). Esto quiere decir que las dimensiones del volumen se colocar\u00e1n en el espacio [0, 1]3, y el rayo tambi\u00e9n se transformar\u00e1 para quedar dentro de estas coordenadas. Una vez obtenidas las NDC del rayo, se proyecta el origen del rayo en el nivel de la jerarqu\u00eda correspondiente, seleccionando el texel apropiado. Una caja envolvente o bounding box es generada para ese texel en NDC y se calcula la intersecci\u00f3n del rayo con esta caja. Debido a que un texel siempre mantiene la resoluci\u00f3n m\u00e1xima de profundidad, es posible crear una m\u00e1scara de bits para el rayo que represente los v\u00f3xeles que son intersectados en la columna de bits correspondientes al texel. Para ello, se debe calcular el punto de entrada y el punto de salida del rayo con la caja envolvente. Una vez obtenidos estos dos valores de profundidad es posible obtener una m\u00e1scara de bits del rayo, la cual tendr\u00e1 todos los bits en 1 entre el punto de entrada y el punto de salida del rayo. Esta m\u00e1scara puede ser obtenida a partir de una textura 2D precalculada. Figura 2.9: Recorrido de un rayo a trav\u00e9s de la jerarqu\u00eda mipmap. Posteriormente se usa la m\u00e1scara del rayo obtenida y la m\u00e1scara de bits almacenadas en el texel, para determinar si hubo intersecci\u00f3n. Para ello, se realiza una operaci\u00f3n AND entre las dos m\u00e1scaras. Si el resultado obtenido es 0, no hubo intersecci\u00f3n, por lo que el origen del rayo es trasladado hasta el punto de salida del rayo de la caja envolvente y se incrementa un nivel en la jerarqu\u00eda para realizar la prueba otra vez con el rayo trasladado. Si CAP\u00cdTULO 2. ILUMINACI\u00d3N GLOBAL BASADA EN V\u00d3XELES 22 ocurri\u00f3 una intersecci\u00f3n, es necesario decrementar un nivel en la jerarqu\u00eda para comprobar si la intersecci\u00f3n sigue presente a una mayor resoluci\u00f3n del volumen. Es necesario alcanzar el nivel con mayor resoluci\u00f3n de la jerarqu\u00eda mipmap para asegurar que hubo una intersecci\u00f3n. El algoritmo se detiene si hubo intersecci\u00f3n o si la longitud del rayo es despreciable. En la figura 2.9 se muestra un ejemplo del recorrido de un rayo en la jerarqu\u00eda en dos dimensiones. En las columnas se muestra de arriba hacia abajo: el rayo en azul y la caja en- volvente correspondiente al texel activo en naranja; el nivel actual de la jerarqu\u00eda; las m\u00e1scaras de bits del nivel de la jerarqu\u00eda actual y el texel activo; la m\u00e1scara de bits de la intersecci\u00f3n del rayo con la caja envolvente en el nivel de la jerarqu\u00eda actual; y los bits intersectados de la m\u00e1scara de bits del rayo y la del texel actual. Con esta prueba se determina la visibilidad entre dos puntos, pero es necesario realizar ciertos c\u00e1lculos adicionales para poder conocer las coordenadas del primer punto de intersec- ci\u00f3n del rayo. Intersecci\u00f3n del rayo Con la prueba anterior se determina la visibilidad entre dos puntos, pero se obtienen todas las intersecciones del rayo para un texel en la m\u00e1xima resoluci\u00f3n del volumen. Para deter- minar las coordenadas de mundo del primer punto de intersecci\u00f3n, es necesario calcular el primer bit encendido del texel y transformar sus coordenadas NDC a coordenadas de mundo. Detallando en la implementaci\u00f3n, se tiene como entrada una m\u00e1scara de bits que indica todas las intersecciones a lo largo del rayo con los elementos de la escena. Si el producto punto de la direcci\u00f3n del rayo con la direcci\u00f3n de voxelizaci\u00f3n es mayor a 0, se debe buscar el bit m\u00e1s significativo. Para ello, se utiliza un logaritmo base 2 sobre la m\u00e1scara de bits. En caso de que el producto punto sea menor a 0, se realiza la operaci\u00f3n X AND NOT (X \u2212 1), donde X es uno de los canales de la m\u00e1scara de bits. Luego de esto, se aplica un logaritmo base 2 para obtener el bit menos significativo. Este \u00faltimo caso puede observarse en el c\u00f3digo 2.1. vec3 currentTNear; //vector que contiene la posici\u00f3n del texel int x = 0; int bitPosition = 0; //Se busca el bit m\u00e1s lejano en la direcci\u00f3n de la voxelizaci\u00f3n //Se itera sobre cada uno de los canales rgba de la m\u00e1scara de bits de la intersecci\u00f3n (Bitmask) for(int v = 3; (x == 0) && (v >= 0); v--) { x = int(Bitmask[v]); if(x != 0) { //Si x != 0 hay un bit encendido en el canal, por lo que es el primer punto de intersecci\u00f3n int pos32 = int(log2(float(x & ~(x-1)))+0.5); bitPosition = (3-v)*32 + pos32; } CAP\u00cdTULO 2. ILUMINACI\u00d3N GLOBAL BASADA EN V\u00d3XELES 23 } //Obtener la posici\u00f3n de la intersecci\u00f3n en coordenadas NDC [0,1]^3 currentTNear.z = (float(127.0 - bitPosition))/128.0; //Transformar de coordenadas NDC a coordenadas de mundo HitPos = UnitToWorldCoordMatrix * vec4(currentTNear,1.0); C\u00f3digo 2.1: C\u00f3digo para obtener el punto de intersecci\u00f3n. Una vez obtenido este bit es necesario transformarlo a coordenadas de mundo para co- nocer la posici\u00f3n de la intersecci\u00f3n. El bit obtenido representar\u00e1 la profundidad y el texel de donde se obtuvo la m\u00e1scara de bits representar\u00e1 las otras dos coordenadas. Primeramente el valor de profundidad est\u00e1 entre los valores [0, 127], que representa la resoluci\u00f3n de pro- fundidad del volumen, por lo que es necesario transformar este valor a NDC. Se realiza un proceso similar con el alto y el ancho del volumen. Una vez obtenidas las coordenadas de la intersecci\u00f3n en NDC se procede a transformarlas a coordenadas de mundo, por medio de la inversa de la matriz de transformaci\u00f3n usada para voxelizar. 2.3.2. Iluminaci\u00f3n indirecta El c\u00e1lculo de la iluminaci\u00f3n global en tiempo real se logra utilizando una t\u00e9cnica parecida a las t\u00e9cnicas de espacio de imagen. Primero, se despliega la escena y para cada p\u00edxel de la imagen final se obtiene el valor de la iluminaci\u00f3n directa e indirecta. Para lograr tiempos interactivos es necesario reducir el c\u00e1lculo a un \u00e1rea cercana al punto de recepci\u00f3n. Esto se debe a que mientras m\u00e1s corto se mantenga el rayo, m\u00e1s r\u00e1pido se realiza la prueba de intersecci\u00f3n. Para el desarrollo de esta t\u00e9cnica, se requiere obtener el reflective shadow map (RSM) [31] y un G-buffer. La idea de un RSM est\u00e1 basada en que un solo rebote de luz indirecta es causado por superficies que son visibles desde el punto de luz, por lo que son visibles en el shadow map. Para generar el RSM se usa el mismo procedimiento que genera un shadow map, donde la escena es desplegada desde la posici\u00f3n de la luz, pero se utilizan m\u00faltiples objetivos de despliegue. Adem\u00e1s de guardar los valores de profundidad, se genera un buffer de vectores normales, de coordenadas de espacio de mundo, y de la energ\u00eda reflejada. Se necesita crear un RSM para cada una de las luces presentes en la escena. El G-buffer sigue la misma idea del RSM pero se despliega desde el punto de vista de la c\u00e1mara. De esta manera se obtienen buffers intermedios, donde se almacenar\u00e1 informaci\u00f3n que se utiliza para el despliegue final. Luego de obtenido los RSMs y el G-buffer, se procede al c\u00e1lculo de la luz indirecta en cada uno de los p\u00edxeles de la imagen final. Para ello, se hace uso de una versi\u00f3n reducida de la ecuaci\u00f3n de despliegue propuesta por Philip Dutr\u00e9 et al. [2] (ecuaci\u00f3n 1.1). Si se considera que las superficies de los objetos no emiten radiancia por ellas mismas, la ecuaci\u00f3n quedar\u00eda de la siguiente manera: L(x\u2192 \u0398) = \u222b \u2126x fr(x,\u03a8\u2192 \u0398)L(x\u2190 \u03a8) cos(Nx,\u03a8)d\u03c9\u03a8 (2.2) CAP\u00cdTULO 2. ILUMINACI\u00d3N GLOBAL BASADA EN V\u00d3XELES 24 Thiedemann et al. [4] proponen usar la integraci\u00f3n de Monte Carlo para simplificar la ecuaci\u00f3n de la siguiente manera: L(x\u2192 \u0398) \u2248 1 N N\u2211 i=1 fr(x,\u03a8i \u2192 \u0398)L\u0303(x\u2190 \u03a8i) cos(Nx,\u03a8i) p(\u03a8i) (2.3) donde p(\u03a8i) es una funci\u00f3n de densidad de probabilidad arbitraria y \u03a8i son las N di- recciones de los rayos generadas por la funci\u00f3n p. L\u0303 es la radiancia entrante aproximada, usando la escena voxelizada. Adem\u00e1s, como se utilizan superficies difusas, la BRDF puede sustituirse por \u03c1(x) \u03c0 , por lo que la ecuaci\u00f3n puede expresarse como: L(x) \u2248 \u03c1(x) \u03c0 N N\u2211 i=1 L\u0303(x\u2190 \u03a8i) cos(Nx,\u03a8i) p(\u03a8i) (2.4) Algoritmo 1 Primera intersecci\u00f3n del rayo. 1: procedure OBTENERLUZINDIRECTA 2: for cada rayo a lanzar do 3: LanzarRayo() . Calcular intersecciones para cada p\u00edxel en la imagen 4: for cada luz en la escena do 5: CalculoIluminacion() . Calcular la iluminaci\u00f3n en cada intersecci\u00f3n 6: end for 7: CombinarSolucion() . Combinar la contribuci\u00f3n con los rayos anteriores 8: end for 9: end procedure Con esta ecuaci\u00f3n simplificada, la luz indirecta se calcula promediando el resultado del trazado de N rayos desde cada uno de los p\u00edxeles del G-buffer (el cual contiene la posici\u00f3n en coordenadas de mundo vista por la c\u00e1mara) con una distancia m\u00e1xima r. Para acelerar los c\u00e1lculos se realizan m\u00faltiples pasadas, con una pasada por rayo como se expresa en el algoritmo 1. Para cada rayo trazado, se calcula el primer punto de intersecci\u00f3n y se obtiene la radiancia directa en el v\u00f3xel intersectado. Para ello, se realiza una proyecci\u00f3n de ese v\u00f3xel en el RSM, el cual contendr\u00e1 la informaci\u00f3n correspondiente al valor de radiancia directa en ese p\u00edxel. Esta radiancia solo ser\u00e1 v\u00e1lida si la distancia de la posici\u00f3n de la intersecci\u00f3n y la posici\u00f3n almacenada en el RSM es menor a un cierto umbral \ufffd. Si esta condici\u00f3n no se cumple, ese punto se encuentra en sombra. Thiedemann et al. [4] proponen que el umbral \ufffd sea ajustado a la discretizaci\u00f3n de la voxelizaci\u00f3n \u03c5, el tama\u00f1o del p\u00edxel s en el RSM, la proyecci\u00f3n perspectiva y la orientaci\u00f3n de la normal \u03b1. Esto conlleva a que \ufffd = max(\u03c5, s cos\u03b1 \u00b7 z Znear ). El proceso de proyecci\u00f3n del punto del v\u00f3xel en el RSM es necesario realizarlo para cada una de las luces en la escena, por lo que a mayor cantidad de luces m\u00e1s costosa es la soluci\u00f3n. Esta t\u00e9cnica permite el c\u00e1lculo de la luz indirecta de un solo rebote en un radio r. Manteniendo los valores de r peque\u00f1os, permite el c\u00e1lculo en tiempo real. En la figura 2.10 se muestra c\u00f3mo se realiza el c\u00e1lculo de la luz indirecta en el \u00e1rea cercana a un punto x. Para esto, se trazan diversos rayos en el hemisferio de x. Para cada CAP\u00cdTULO 2. ILUMINACI\u00d3N GLOBAL BASADA EN V\u00d3XELES 25 rayo es necesario obtener su punto de intersecci\u00f3n y proyectarlo en el RSM para calcular la luz directa. En este caso, las intersecciones son A y B. En el caso de A, su distancia con la posici\u00f3n del p\u00edxel en el RSM es menor al umbral \ufffd, por lo que su valor es tomado. En cambio, la posici\u00f3n de B difiere de la posici\u00f3n almacenada en el RSM, lo que significa que el punto se encuentra en sombra. Si ninguna intersecci\u00f3n es encontrada, se puede obtener un valor opcional del ambiente (punto C). Figura 2.10: C\u00e1lculo de la luz indirecta en el \u00e1rea cercana. Imagen tomada de [4]. 2.4. Despliegue Con los pasos expuestos anteriormente, se logra obtener la contribuci\u00f3n de la luz indirecta para la imagen final. Sin embargo, es necesario mezclarla con la luz directa. Para obtener la luz directa se debe considerar la contribuci\u00f3n de cada una de las luces. Con el uso del mismo G-buffer que se utiliz\u00f3 para la luz indirecta, se calcula la luz directa en cada uno de los p\u00edxeles de la imagen, considerando la sombra por medio del shadow map. De esta manera, la obtenci\u00f3n de la iluminaci\u00f3n global es resumida en el algoritmo 2. Algoritmo 2 Primera intersecci\u00f3n del rayo. 1: procedure ILUMINACIONGLOBAL 2: ObtenerGBuffer() 3: ObtenerRSM() . En este paso tambi\u00e9n se obtiene el shadow map 4: ObtenerLuzIndirecta() 5: ObtenerLuzDirecta() 6: CombinarSoluciones() . Luz directa m\u00e1s luz indirecta 7: end procedure Cap\u00edtulo 3 Implementaci\u00f3n En este cap\u00edtulo se expondr\u00e1 como se realiz\u00f3 la implementaci\u00f3n de las ideas expuestas en el trabajo de Thiedemann et al. [4] sobre iluminaci\u00f3n global en tiempo real. Primero se explicar\u00e1n las herramientas de hardware y software utilizadas para la implementaci\u00f3n. Luego se expondr\u00e1 un diagrama de clases y se detallar\u00e1n las clases m\u00e1s importantes. Posteriormente, se mostrar\u00e1 la importancia de los shaders en la implementaci\u00f3n, para finalmente profundizar en el detalle de la implementaci\u00f3n de los shaders. 3.1. Metodolog\u00eda El desarrollo de la implementaci\u00f3n se basa en el paradigma de la programaci\u00f3n orientada a objetos. El hardware requerido para su ejecuci\u00f3n consisti\u00f3 en una PC convencional con una tarjeta gr\u00e1fica con soporte a GLSL con versi\u00f3n 3.30. Por otro lado, se utiliz\u00f3 el siguiente software para el desarrollo: Windows 7 como sistema operativo. Microsoft Visual Studio 2010 como ambiente de trabajo. Ant Tweak Bar [56] en su versi\u00f3n 1.15 para la interfaz gr\u00e1fica dentro de la aplicaci\u00f3n. OpenGL en su versi\u00f3n 3.3. Open Asset Import Library [57] en su versi\u00f3n 3.0 para la carga de la escena y los modelos. 3.2. Diagrama de clases y estructuras de datos En la figura 3.1 se muestra un diagrama de clases del programa, con sus respectivos m\u00e9todos y atributos. En esta secci\u00f3n se explicar\u00e1 en detalle las principales clases. 26 CAP\u00cdTULO 3. IMPLEMENTACI\u00d3N 27 CAP\u00cdTULO 3. IMPLEMENTACI\u00d3N 28 CAP\u00cdTULO 3. IMPLEMENTACI\u00d3N 29 CAP\u00cdTULO 3. IMPLEMENTACI\u00d3N 30 Figura 3.1: Diagrama de clases de la implementaci\u00f3n realizada. 3.2.1. Clase FBOQuad FBOQuad es una clase que sigue el patr\u00f3n singleton, lo cual solo permite la creaci\u00f3n de una sola instancia para la ejecuci\u00f3n del programa. En ella se define un cuadrado de di- mensiones [\u22121, 1]2 almacenado en un vertex buffer object. Tiene los m\u00e9todos necesarios para preparar la tarjeta de video para su preparaci\u00f3n (StartUp), su despliegue (OnlyDraw) y su culminaci\u00f3n (Stop). La idea de esta clase es usarse en combinaci\u00f3n con un shader para des- plegar un cuadrado que ocupe toda la ventana y as\u00ed poder crear un fragmento por cada p\u00edxel de la misma. 3.2.2. Clase Texture Esta clase tiene los m\u00e9todos necesario para la creaci\u00f3n y carga de una textura 2D. Los m\u00e9todos CreateEmptyTexture2DClampToBorder y CreateEmptyTexture2D permiten la crea- ci\u00f3n de una textura en blanco, o pas\u00e1ndoles informaci\u00f3n, con la posibilidad de cambiar la mayor\u00eda de los valores de entrada en la declaraci\u00f3n de una textura en OpenGL. Adem\u00e1s, el m\u00e9todo LoadTexture carga una textura desde un archivo de entrada. La clase elimina toda la informaci\u00f3n de la texturas excepto el identificador creado por OpenGL, por lo que la textu- ra s\u00f3lo queda almacenada en la tarjeta de video. Las clases que contengan una instancia de Texture pueden acceder al identificador de la textura por medio de GetTextId. 3.2.3. Clase Shaders La clase Shaders permite la creaci\u00f3n, carga y compilaci\u00f3n de un fragment y un vertex shader. Adem\u00e1s, permite la activaci\u00f3n y desactivaci\u00f3n del shader por medio de los m\u00e9todos Enable y Disable, y la modificaci\u00f3n de variables uniformes al poder tener acceso al programa CAP\u00cdTULO 3. IMPLEMENTACI\u00d3N 31 por el atributo m_p. Tambi\u00e9n permite vincular ubicaciones para atributos de los shaders. Tanto Shaders como Textures son las clases m\u00e1s utilizadas en el programa. 3.2.4. Mediciones de tiempo Se define la clase Time para medir el tiempo y TimeManager como un coordinador. En la clase Time los m\u00e9todos Begin y End definen el fragmento de c\u00f3digo en el cual se va a medir el tiempo. El tiempo se va acumulando para posteriormente ser promediado con el m\u00e9todo GetAverage. Debido a que la mayor parte del algoritmo esta pensado para funcionar en la GPU, las mediciones de tiempo se realizan con consultas OpenGL, a trav\u00e9s de la variables GL_TIME_ELAPSED. Por otro lado, la clase TimeManager se encargar\u00e1 de coordinar varias instancias de la clase Time, de manera que puedan medirse diferentes partes del algoritmo. Con el m\u00e9todo PrintResults() se totalizan los tiempos y se escriben en disco en un archivo de salida. 3.2.5. Manejo de modelos Estas clases sirven para la carga y el despliegue de modelos. Las clases principales son Object y DynamicObject, aunque se utilizan otras estructuras auxiliares. DynamicObject La clase DynamicObject sirve para la carga y despliegue de modelos en formato MD2. Debido a su peculiar formato de almacenamiento, es necesario la creaci\u00f3n de unas subclases para su importaci\u00f3n. Se utiliza md2_model_t para la carga del modelo, clase que a su vez usa instancias de md2_header_t para describir las cabecera, md2_vertex_t para los v\u00e9rtices, md2_skin_t para los nombres de las texturas, md2_texCoord_t para las coordenadas de tex- turas, md2_triangle_t para los tri\u00e1ngulos y md2_frame_t para los frames. Una vez importado el modelo con el m\u00e9todo Import, se cambia la estructura de datos por una matriz de Vertex (finalObject), la cual se encargar\u00e1 de almacenar los frames. Vertex almacena por cada v\u00e9rtice las coordenadas de mundo, el vector normal y las coordenadas de textura. Adem\u00e1s, mientras se transforma la estructura del modelo, se realizan las transformaciones sobre los v\u00e9rtices. Una caja envolvente del model es creada haciendo uso de la clase BoundingBox. El objeto se despliega mediante el uso de un vertex buffer object, con el m\u00e9todo Draw. Debido a que es un objeto din\u00e1mico se necesita del m\u00e9todo Animate para llevar el tiempo entre frames y UpdateVBO para interpolar los v\u00e9rtices y actualizar el vertex buffer object. La clase DynamicObject tambi\u00e9n posee dos instancias de Texture: pText para el almacenamiento de la textura del modelo y m_texTextureAtlas para almacenar la textura atlas. Es posible modificar la resoluci\u00f3n de la textura atlas a trav\u00e9s del m\u00e9todo SetTextureAtlasResolution. CAP\u00cdTULO 3. IMPLEMENTACI\u00d3N 32 Object La clase Object se utiliza para cargar y desplegar modelos en formato OBJ. Se utili- za la librer\u00eda Open Asset Import Library para importar el modelo y posteriormente su es- tructura de datos es transformada. El modelo es almacenado en el arreglo m_vVertex, que contiene instancias de la clase Vertex2. Debido a que el modelo puede dividirse en varios grupos categorizados por material, se utiliza el vector m_vMeshes con instancias de la clase Mesh para dividir los grupos, el vector m_vMaterial para almacenar los materiales y el vec- tor m_pArrayTexture para almacenar las texturas de cada grupo. Tambi\u00e9n posee una textura atlas (m_texTextureAtlas), a la cual se le puede cambiar la resoluci\u00f3n. Se utiliza el m\u00e9todo DrawGC para poder dibujar el modelo por medio de un vertex buffer object. 3.2.6. Manejo de luces En la clase Light se poseen las propiedades y los m\u00e9todos para el manejo de una luz focal. Por ello, se definen las propiedades posici\u00f3n (m_vPosition) , direcci\u00f3n (m_svSpotDIrection), color difuso (m_vDiffuse), \u00e1ngulo de apertura (m_ fSpotCosCutoff ) y las variables de atenua- ci\u00f3n (m_ fSpotExponent, m_ fConstantAttenuation, m_ fLinearAttenuation y m_ fQuadrati- cAttenuation). Para poder modificar los atributos se crean los m\u00e9todos get y set para cada uno de ellos. Dado la necesidad de crear un reflective shadow map y un shadow map por luz, la clase Light contiene los m\u00e9todos necesarios para generarlos. Para ello, es necesario un FrameBuffer Object, las instancias de la clase Shaders (sh y m_pshShadow) y las texturas para almacenar los resultados (m_texCoord, m_texFlux, m_texNormals y m_texShadowMap). Las texturas son accesibles a trav\u00e9s de m\u00e9todos get. Adem\u00e1s, es posible cambiar la resoluci\u00f3n de estos buffer con el m\u00e9todo SetResolution. 3.2.7. Clase GBuffer Esta clase est\u00e1 dise\u00f1ada para crear los buffers temporales necesarios por el G-Buffer. De manera similar a la clase Light, se tiene un FrameBuffer Object, la instancia de la clase Sha- ders (m_shGbuffer) y las texturas para almacenar los resultados (m_texCoord, m_texMaterial y m_texNormals). Estas texturas son accedidas a trav\u00e9s de m\u00e9todos gets. Por otro lado, la re- soluci\u00f3n de los buffers depende del tama\u00f1o de la ventana del programa, por lo que es posible modificarlos con el m\u00e9todo SetResolution. 3.2.8. Voxelizaci\u00f3n de la escena Se define la clase VoxelGrid con el fin de contener un FrameBuffer Object y la textura m_ TextVoxelGrid, con lo cual se almacena la escena voxelizada. Tambi\u00e9n permite hacer una prevoxelizaci\u00f3n, la cual almacena la escena prevoxelizada en la textura auxiliar m_ TextPre- VoxelizeDataTA si se utiliza el m\u00e9todo de texturas atlas, o la textura m_ TextPreVoxelizeData CAP\u00cdTULO 3. IMPLEMENTACI\u00d3N 33 si se utiliza slicemap. Para poder copiar la textura prevoxelizada en la textura a utilizar, se usa la instancia de la clase Shaders m_shCopyTexture. Tambi\u00e9n, se define el m\u00e9todo GetMipmap para obtener la jerarqu\u00eda mipmap de la tex- tura que contiene la escena voxelizada. Para ello, necesita la instancia de la clase Shaders m_shMipMap y una instancia de la clase FBOQuad para desplegar un cuadrado que abarque toda el \u00e1rea de despliegue. Adem\u00e1s, con el m\u00e9todo DrawVoxelGrid se permite el despliegue de la escena por me- dio de v\u00f3xeles. Dado que los v\u00f3xeles pueden representarse como cubos, se tiene una clase m_pCube que define un cubo para desplegar por medio de vertex buffer objects. El m\u00e9todo recorre la textura que contiene la escena y despliega un cubo por cada bit encendido. El tama\u00f1o de las texturas presentes en esta clase puede ser modificado a trav\u00e9s del m\u00e9todo SetResolution, y es independiente del tama\u00f1o de la ventana. 3.2.9. Obtenci\u00f3n de la luz directa La clase DirectLighting se encarga de obtener la iluminaci\u00f3n directa de la escena por medio del m\u00e9todo GetDirectLighting. Utiliza la informaci\u00f3n almacenada por el G-Buffer en vez de desplegar la escena otra vez. Por ello, tiene la misma resoluci\u00f3n que la ventana del programa y utiliza una instancia de FBOQuad para desplegar un cuadrado que ocupe toda la ventana. El c\u00e1lculo de la iluminaci\u00f3n se realiza con un shader definido en la variable m_pshDL. Una vez calculada la iluminaci\u00f3n es posible obtener la textura resultado a trav\u00e9s del m\u00e9todo GetDirectIlumination. 3.2.10. Obtenci\u00f3n de la luz indirecta La estructuras necesarias para la obtenci\u00f3n de la luz indirecta est\u00e1n definidas en la clase IndirectLighting. Se definen las texturas m_ pHitPos, m_ pIndirectlighting y m_ pDirectio- nalOclution para la obtenci\u00f3n de la iluminaci\u00f3n. Posteriormente, la clase permite aplicar un filtro a la soluci\u00f3n, por lo que se utiliza la textura auxiliar m_pFilter. Todas las texturas tie- nen la misma resoluci\u00f3n que la ventana principal del programa. Debido a que se necesita realizar c\u00e1lculos sobre todos los p\u00edxeles de la imagen, se utiliza una instancia de la clase FBOQuad. Todos los c\u00e1lculo son realizados a trav\u00e9s de la GPU, por lo que es necesario el uso de instancias de la clase Shaders y el uso de un FrameBuffer Object. 3.2.11. Clase Scene Esta es la clase principal, ya que se encarga de manejar todas las dem\u00e1s clases del progra- ma. Contiene instancias de las clases UserConf, Camera, lightStructure, TimeManager, Sha- ders, Object, DynamicObject, GBuffer, Light, VoxelGrid, DirectLighting e Indirectlighting. Tambi\u00e9n posee una instancia de la clase Bitmask, la cual se encarga de crear unas texturas auxiliares que servir\u00e1n de entrada a otras clases. La idea de la clase Scene es enmascarar todos los m\u00e9todos de las clases anteriores por los m\u00e9todos presentes en Scene, as\u00ed el m\u00e9todo principal del programa s\u00f3lo contendr\u00e1 una instancia de Scene. CAP\u00cdTULO 3. IMPLEMENTACI\u00d3N 34 La clase define arreglos que contienen a los objetos (m_pvDynamicObj y m_pvObj) y esta encargado de crear las texturas atlas de los mismos. Para ello, necesita el uso de shaders. Posteriormente se encarga de crear un FrameBuffer Object que contiene todos los v\u00e9rtices v\u00e1lidos de una textura atlas. Adem\u00e1s, a trav\u00e9s del m\u00e9todo GetDerreferedShading, la clase Scene se encarga de combi- nar y desplegar la soluci\u00f3n final. 3.2.12. Navegaci\u00f3n en la escena La navegaci\u00f3n dentro de la escena es manejada por la clase Camera. En ella se definen los 3 vectores principales para poder definir una c\u00e1mara con OpenGL: el vector posici\u00f3n (m_pPosition), el vector up (m_pUpVector) y el vector de direcci\u00f3n (m_pView). Con estos 3 vectores es posible construir una matriz de transformaciones que es necesaria para varias etapas del algoritmo, por lo que es posible obtenerla con el m\u00e9todo GetLookAt. Para mover la c\u00e1mara en la escena con el teclado se utilizan los m\u00e9todos MoveCame- ra, MoveCamera2 y MoveCameraVertical. Para el mouse se usan los m\u00e9todos RotateView y SetViewByMouse. 3.2.13. Manejo de los men\u00fas Estas clases sirven como estructuras de datos para manejar las diferentes entradas de usuario presentes en los men\u00fas de Ant Tweak Bar. Las dos clases que son utilizadas con este prop\u00f3sito son lightStructure y UserConf. UserConf contiene los campos necesario para permitirle manejar al usuario diferentes par\u00e1metros del programa, como la resoluci\u00f3n de los buffers intermedios, par\u00e1metros del rayo, par\u00e1metros del filtro, activaci\u00f3n de diferentes caracter\u00edsticas, entre otros. Por otro lado, lightStructure contiene todas las propiedades de la luz, de tal forma que el usuario pueda cambiarlas y estas sean transmitidas a una instancia de la clase Light. 3.3. Algoritmo Los procesos m\u00e1s importantes del programa fueron realizados para trabajar en la GPU mediante el uso de shaders. Por ello, para estudiar con mayor detalle cada uno de los pasos es necesario analizar cada unos los programas del GPU. En la imagen 3.2 podemos observar los fragment shaders (con extensi\u00f3n .frag) y los vertex shaders (con extensi\u00f3n.vert) utilizados en el programa. Para poder almacenar los resultados del uso de los shaders y evitar el despliegue de estos por pantalla, se hizo uso de los FrameBuffer Objects. Estos son mecanismos que permiten el despliegue de im\u00e1genes a FrameBuffers diferentes al FrameBuffer por defecto de OpenGL. Adem\u00e1s, estos permiten desplegar directamente a una textura e incluso utilizar m\u00faltiples ob- jetivos de despliegue, para ser mostrados en varias texturas simult\u00e1neamente. Para simplificar su uso, se crean varios FrameBuffer Object, donde para cada uno se configuran las texturas CAP\u00cdTULO 3. IMPLEMENTACI\u00d3N 35 Etapa 1 Calcular Shadowmap Calcular G-Buffer Calcular Reflective Shadow Map Etapa 2 Voxelizar la escena Crear Jerarqu\u00eda mipmap Etapa 3 Calcular iluminaci\u00f3n directa Calcular iluminaci\u00f3n indirecta Etapa final Combinar soluciones de iluminaci\u00f3n (luz directa + luz indirecta) Desplegar escena final JustVert.vert Simple.frag VertTextCoord.vert ClampToZero.frag VertTextCoord.vert CopyTexture.frag JustVert.vert CreateBitmaskRay.frag VertTextCoord.vert DirectIlumination.frag VertTextCoord.vert IndirectIlumination.frag VertTextCoord.vert FilterUpSampling.frag VertTextCoord.vert FinalIlumination.frag GBuffer.vert GBuffer.frag VertTextCoord.vert HitPosition.frag VertTextCoord.vert MipMap.frag RSM.vert RSM.frag TextureAtlas.vert TextureAtlas.frag VoxNormal.vert VoxNormal.frag VoxTextureAtlas.vert VoxTextureAtlas.frag Preprocesamiento Figura 3.2: Distribuci\u00f3n de los shaders (bordes de colores) en las diferentes etapas del algoritmo (bordes negros). a utilizar como blancos de despliegue. Adem\u00e1s, es necesario indicar a OpenGL cual es el tama\u00f1o de la ventana que se va a desplegar, por lo que es necesario cambiar el tama\u00f1o del viewport cada vez que se va a utilizar un FrameBuffer Object diferente. Cada FrameBuffer Object creado en el programa esta ligado con alguna etapa del mismo, existiendo uno o m\u00e1s programas de shaders asociado a cada uno. Para cada shader en esta aplicaci\u00f3n se tiene un vertex shader y un fragment shader. Como se utiliza GLSL en su versi\u00f3n 3.30, es necesario enviar las matrices de transformaci\u00f3n a los shaders por medio de variables uniformes, ya que OpenGL no las env\u00eda de manera directa. Es necesario realizar lo mismo para las propiedades de las luces y para las propiedades de los v\u00e9rtices. En la siguiente secci\u00f3n se explicar\u00e1 detalladamente la funci\u00f3n de cada uno de los shaders en las diferentes etapas del programa. CAP\u00cdTULO 3. IMPLEMENTACI\u00d3N 36 3.4. Implementaci\u00f3n detallada en la GPU En estas secci\u00f3n se detallar\u00e1 en los shaders realizados para esta implementaci\u00f3n. 3.4.1. Shaders multifuncionales Pase de v\u00e9rtices uniform mat4 ModelViewProjectionMatrix; in vec4 glVertex; out vec2 pos; void main(){ gl_Position = ModelViewProjectionMatrix * glVertex; pos = glVertex.xy; } C\u00f3digo 3.1: Pase de v\u00e9rtices del vertex shader al fragment shader. El vertex shader mostrado en el c\u00f3digo 3.1 solo tiene como entrada la posici\u00f3n de un v\u00e9rtice en espacio de objeto y lo env\u00eda al fragment shader. Adem\u00e1s, multiplica la posici\u00f3n del v\u00e9rtice por la matriz de transformaciones para colocarlo en la posici\u00f3n correcta en el espacio de imagen. Pase de v\u00e9rtices y de coordenadas de textura uniform mat4 ModelViewProjectionMatrix; in vec4 glVertex; in vec2 glTexCoord; out vec2 TextCoord; out vec4 pos; void main(){ gl_Position = ModelViewProjectionMatrix * glVertex; TextCoord = glTexCoord; pos = gl_Position; } C\u00f3digo 3.2: Pase de v\u00e9rtices y coordenadas de textura del vertex shader al fragment shader. En el c\u00f3digo 3.2 se recibe como entrada la posici\u00f3n de un v\u00e9rtice en espacio de objeto y su correspondiente coordenada de textura. La posici\u00f3n es multiplicada por la matriz de transformaciones para luego ser enviada al fragment shader, al igual que la coordenada de textura. A pesar de su simplicidad, este es uno de los vertex shaders m\u00e1s utilizados en el programa. CAP\u00cdTULO 3. IMPLEMENTACI\u00d3N 37 Copia de una textura uniform usampler2D PreVoxelizedTexture; in vec2 TextCoord; in vec4 pos; /*El fragment shader escribe informaci\u00f3n en uno o m\u00e1s framebuffers. Cuando se tiene varias salidas, el valor de \"location\" indica cual es el framebuffer de salida correspondiente a esa variable*/ layout(location = 0) out uvec4 FragColor; void main(){ FragColor = texture2D(PreVoxelizedTexture, TextCoord); } C\u00f3digo 3.3: Copia de la textura de prevoxelizaci\u00f3n a la textura de voxelizado (fragment shader). El fragment shader mostrado en el c\u00f3digo 3.3 sirve para copiar una textura de entrada (PreVoxelizedTexture) a una textura colocada como blanco de despliegue (FragColor). Est\u00e1 asociada al vertex shader que se muestra en el c\u00f3digo 3.2. Como entrada se recibe las coor- denadas de textura que estar\u00e1 asociado a un cuadrado de dimensiones [\u22121, 1]2, para poder obtener cada una de las coordenadas de la textura de entrada. Se utiliza para copiar la infor- maci\u00f3n de una escena prevoxelizada almacenada en una textura, a la textura a utilizar en la voxelizaci\u00f3n. Creaci\u00f3n de la textura de m\u00e1scara de rayos uniform usampler1D BitmaskXOR; in vec2 pos; layout(location = 0) out uvec4 FragColor; void main(){ FragColor = texelFetch1D(BitmaskXOR,int((pos.x + 1.0) / 2.0 * 128),0) ^ texelFetch1D(BitmaskXOR,int((pos.y + 1.0) / 2.0 * 128 + 1),0); } C\u00f3digo 3.4: Creaci\u00f3n de la m\u00e1scara de bits (fragment shader). Para la creaci\u00f3n de las texturas que contienen las m\u00e1scaras de bits de una dimensi\u00f3n se puede utiliza la CPU. Sin embargo, para acelerar el c\u00e1lculo en la creaci\u00f3n de la textura 2D se utiliza el fragment shader mostrado en el c\u00f3digo 3.4. Se utiliza en conjunto con el vertex sha- der presentado en el c\u00f3digo 3.1. Para poder tomar muestras sobre la textura 1D se despliega un cuadrado cuyas coordenadas est\u00e1n entre [-1,1] y posteriormente son transformadas en el espacio [0,127]. Se utiliza la funci\u00f3n texelFetch1D para tomar las muestras en la textura con valores enteros. CAP\u00cdTULO 3. IMPLEMENTACI\u00d3N 38 3.4.2. G-Buffer Para crear el G-Buffer es necesario utilizar m\u00faltiples objetivos de despliegue con el fin de almacenar las coordenadas de mundo de los objetos, los vectores normales y el valor de la BRDF, para cada uno de los fragmentos que son visibles desde el punto de vista de la c\u00e1mara. Por lo tanto, es necesario enviar al vertex shader mostrado en el c\u00f3digo 3.5 las coordenadas de objeto, los vectores normales y las coordenadas de textura de cada uno de los v\u00e9rtices. Adem\u00e1s, es necesario poder manejar las diferentes matrices de transformaciones. Cada una de estas coordenadas debe ser transformada antes de ser enviadas al fragment shader. Los vectores normales son multiplicados por la matriz glNormalMatrix, la cual es equivalente a la traspuesta de la inversa de la matriz de modelos (glModelMatrix); las coor- denadas de texturas no son transformadas y la posici\u00f3n es multiplicada por la matriz de modelos para modificar las coordenadas a espacio de mundo. in vec4 glVertex; in vec2 glTexCoord; in vec3 glNormal; uniform mat3 glNormalMatrix; uniform mat4 glModelViewProjectionMatrix; uniform mat4 glModelMatrix; out vec3 vNormal; out vec4 vecPos; out vec2 TextureCoord; void main(){ vNormal = glNormalMatrix * glNormal; vecPos = glModelMatrix * glVertex; TextureCoord = glTexCoord; gl_Position = glModelViewProjectionMatrix * glVertex; } C\u00f3digo 3.5: Obtenci\u00f3n del G-Buffer (vertex shader). Una vez que los datos son enviados al fragment shader que se muestra en el c\u00f3digo 3.6, cada uno de los valores son almacenados en la textura correspondiente. Las coordenadas de mundo son desplegadas sin ning\u00fan procesamiento. Para los vectores normales es necesario normalizarlos antes de poder almacenarlos. El material de los objetos son enviados a trav\u00e9s de una variable uniforme (mat_diffuse) y se divide entre \u03c0 para obtener la BRDF en ese fragmento. Adem\u00e1s, se puede agregar el valor de la textura del objeto si se posee. #define PI 3.14159265359 uniform vec4 mat_diffuse; //Propiedad difusa del material uniform bool useTexture; //Indica si se usa textura o no uniform sampler2D text; //Textura del objeto in vec3 vNormal; CAP\u00cdTULO 3. IMPLEMENTACI\u00d3N 39 in vec4 vecPos; in vec2 TextureCoord; layout(location = 0) out vec4 WorldPosition; layout(location = 1) out vec4 Normals; layout(location = 2) out vec4 Material; void main(){ vec4 n = vec4(normalize(vNormal),0.0); WorldPosition = vecPos; //Buffer de coordenadas de mundo Normals = n; //Buffer de vectores normales vec3 texval = (useTexture)? pow(texture2D(text,TextureCoord.xy).rgb, vec3(2.2)) : vec3(1.0); //Buffer del material Material.rgb = mat_diffuse.rgb / 3.14159265359 * texval; } C\u00f3digo 3.6: Obtenci\u00f3n del G-Buffer (fragment shader). 3.4.3. Reflective Shadow Map El RSM mantiene la misma idea del G-Buffer, salvo que la escena es desplegada desde la posici\u00f3n de la luz en la direcci\u00f3n de la luz, por medio de la matriz glModelViewProjection- Matrix. Aqu\u00ed se almacenar\u00e1n las coordenadas de mundo, los vectores normales y la energ\u00eda recibida en cada uno de los puntos visibles desde la luz. Cada luz tiene asociado un RSM. El viewport de la escena debe ser configurado seg\u00fan el tama\u00f1o de la resoluci\u00f3n del RSM. En el vertex shader, mostrado en el c\u00f3digo 3.7, se recibe como entrada las coordenadas de objeto, las coordenadas de textura y los vectores normales de cada v\u00e9rtice. Adem\u00e1s, se debe poseer la posici\u00f3n de la luz para poder realizar los c\u00e1lculos de iluminaci\u00f3n posteriores. Al fragment shader se le env\u00edan los vectores normales, las coordenadas de mundo, las coor- denadas de textura del objeto y el vector de direcci\u00f3n de la luz en coordenadas de mundo. La posici\u00f3n del v\u00e9rtice se transforma para verse desde el punto de vista de la luz. in vec4 glVertex; in vec2 glTexCoord; in vec3 glNormal; uniform mat3 glNormalMatrix; uniform mat4 glModelViewProjectionMatrix; uniform mat4 glModelMatrix; //Posici\u00f3n de la luz uniform vec4 light_pos; out vec3 vNormal; CAP\u00cdTULO 3. IMPLEMENTACI\u00d3N 40 out vec4 vecPos; out vec3 light_dir; out vec2 TextureCoord; void main(){ vNormal = glNormalMatrix * glNormal; vecPos = glModelMatrix * glVertex; //Direcci\u00f3n de la luz en espacio de mundo light_dir = light_pos.xyz - vecPos.xyz; TextureCoord = glTexCoord; gl_Position = glModelViewProjectionMatrix * glVertex; } C\u00f3digo 3.7: Obtenci\u00f3n del RSM (vertex shader). El fragment shader que se muestra en el c\u00f3digo 3.8 se encarga de desplegar los vectores normales, las coordenadas de mundo y lo valores de iluminaci\u00f3n. Para poder calcular los valores de iluminaci\u00f3n, es necesario tener los valores de las diferentes propiedades de la luz, por lo que son enviados al shader como variables uniformes. #define PI 3.14159265359 uniform vec4 mat_diffuse; //Propiedad difusa del material uniform vec4 light_diffuse; //Color de la luz uniform vec3 light_spotDirection; //Direcci\u00f3n uniform float light_spotCosCutoff;//\u00c1ngulo de corte uniform float light_spotExponent; //Exponente uniform float light_spotConstant; //Atenuaci\u00f3n constante uniform float light_spotLinear; //Atenuaci\u00f3n linear uniform float light_spotQuadratic;//Atenuaci\u00f3n cuadr\u00e1tica uniform sampler2D text; uniform bool useTexture; in vec3 vNormal; in vec4 vecPos; in vec2 TextureCoord; in vec3 light_dir; layout(location = 0) out vec4 WorldPosition; layout(location = 1) out vec3 Normals; layout(location = 2) out vec4 Flux; void main(){ vec3 n = normalize(vNormal); //Buffer de coordenadas de mundo WorldPosition = vec4(vecPos.xyz,abs(vecPos.z)); Normals = n; //Buffer de vectores normales float dist = length(light_dir); vec3 lightVec = light_dir / dist; float NdotL = max(dot(n,lightVec),0.0); CAP\u00cdTULO 3. IMPLEMENTACI\u00d3N 41 if(NdotL > 0.0){ float SpotEffect = dot(normalize(light_spotDirection), -lightVec); if (SpotEffect > light_spotCosCutoff){ SpotEffect = pow(SpotEffect, light_spotExponent); float att = SpotEffect / (light_spotConstant + light_spotLinear * dist + light_spotQuadratic * dist * dist); vec4 texval = (useTexture)? pow(texture2D(text,TextureCoord.xy). rgba,vec4(2.2)) : vec4(1.0); vec4 material = mat_diffuse / PI * texval; Flux = att * ( material * light_diffuse * NdotL); } } } C\u00f3digo 3.8: Obtenci\u00f3n del RSM (fragment shader). La iluminaci\u00f3n directa en la escena proviene de luces focales. Estas luces tienen la pro- piedad de que los rayos luminosos se encuentran restringidos a un cono. Las luces focales poseen una posici\u00f3n, una direcci\u00f3n (light_ spotDirection) y un \u00e1ngulo de apertura (light_ spotCosCutoff ). Adem\u00e1s, posee un porcentaje de decadencia de la intensidad de la luz desde el centro hasta los bordes del cono. La atenuaci\u00f3n de la luz es calculada utilizando la siguiente ecuaci\u00f3n: SpotEffect = (\u2212lightV ec \u00b7 light_spotDirection) (3.1) att = SpotEffect light_spotConstant+ light_spotLinear \u00d7 dist+ light_spotQuadratic\u00d7 dist2 (3.2) Debido a que solo se utilizan superficies difusas, la contribuci\u00f3n de la luz se calcula tomando en cuenta la propiedad difusa de la superficie (material), la componente difusa de la luz (light_ diffuse) y el producto punto de la normal de la superficie con la direcci\u00f3n de la luz (NdotL). Lo anterior puede resumirse en la siguiente ecuaci\u00f3n: Flux = att\u00d7 (material \u00d7 light_diffuse\u00d7NdotL) (3.3) 3.4.4. Shadow map La creaci\u00f3n del shadow map es semejante al del RSM. La escena es proyectada desde la posici\u00f3n de la luz, pero solo los valores de profundidad son almacenados en una textura de profundidad, cuya componente esGL_DEPTH_COMPONENT . El FrameBuffer Object asociado a este shader no desplegar\u00e1 color en ninguna textura. Para cada luz en la escena est\u00e1 asociado un shadow map. CAP\u00cdTULO 3. IMPLEMENTACI\u00d3N 42 3.4.5. Despliegue de texturas atlas Este shader es utilizado para desplegar las coordenadas de mundo de un objeto en su co- rrespondiente coordenada de textura atlas, para posteriormente ser voxelizado. Para la crea- ci\u00f3n de las texturas atlas es necesario colocar el viewport del tama\u00f1o de la resoluci\u00f3n de las texturas atlas. Este valor es colocado dependiendo de la resoluci\u00f3n necesaria para el objeto que se est\u00e1 procesando. El proceso de creaci\u00f3n de texturas atlas se realiza para cada uno de los objetos de la escena. Para el despliegue de la textura atlas, el vertex shader que se muestra en el c\u00f3digo 3.9 debe tener como entrada las coordenadas de textura atlas del objeto y las coordenadas de espacio de objeto del objeto. Para poder hacer el despliegue de manera correcta, se env\u00eda al fragment shader las coordenadas de mundo del v\u00e9rtice y se coloca como posici\u00f3n del mismo las coordenadas de textura transformada al espacio [-1,1]. uniform mat4 glModelViewMatrix; in vec4 glVertex; in vec2 glTexCoord; out vec3 vecPos; void main(){ vecPos = (glModelViewMatrix * glVertex).xyz; gl_Position = vec4((glTexCoord * 2.0) - vec2(1.0), 1.0 ,1.0); } C\u00f3digo 3.9: Despliegue de las coordenadas de mundo a la textura atlas (vertex shader). Una vez en el frament shader presentado en el c\u00f3digo 3.10, la posici\u00f3n en coordenadas de mundo del v\u00e9rtice recibidas como entrada, se colocan como color del fragmento. in vec3 vecPos; layout(location = 0) out vec4 FragColor; void main(){ FragColor = vec4(vecPos,1.0); } C\u00f3digo 3.10: Despliegue de las coordenadas de mundo a la textura atlas (fragment shader). De esta manera, se obtendr\u00e1 una imagen en donde cada p\u00edxel tendr\u00e1 como color las coor- denadas de mundo del objeto asignadas seg\u00fan la textura atlas. 3.4.6. Proceso de voxelizaci\u00f3n Mediante slicemap Para realizar la voxelizaci\u00f3n por medio de slicemap los objetos son desplegados normal- mente y posteriormente los fragmentos son codificados en el volumen. El viewport debe ser CAP\u00cdTULO 3. IMPLEMENTACI\u00d3N 43 configurado para que contenga todo el volumen, esto es, del tama\u00f1o de la resoluci\u00f3n del vo- lumen. En el vertex shader mostrado en el c\u00f3digo 3.11 se tiene como entrada solamente la coordenada de objeto del v\u00e9rtice y por medio de la matriz viewProjMatrixVoxelCam la coor- denada es transformada a espacio del volumen. El valor de profundidad Z es transformado para distribuirlo uniformemente en el volumen. uniform mat4 viewProjMatrixVoxelCam; in vec4 glVertex; out float Z; void main(){ gl_Position = viewProjMatrixVoxelCam * glVertex; //Se transforma la coordenada Z al espacio [0,1] Z = gl_Position.z * 0.5 + 0.5; } C\u00f3digo 3.11: Voxelizaci\u00f3n por medio del uso de slicemap (vertex shader). Posteriormente, en el fragment shader presentado en el c\u00f3digo 3.12 cada fragmento crea- do activa un bit del volumen en la posici\u00f3n correspondiente. Para ello, se busca la m\u00e1scara de bits correspondiente en la textura bitmask, utilizando el valor de profundidad adecuado. En esta textura estar\u00e1n almacenadas todas las m\u00e1scaras que contienen todos los valores en 0 excepto el correspondiente al valor de profundidad. uniform usampler1D bitmask; in float Z; layout(location = 0) out uvec4 FragColor; void main(){ FragColor = texture(bitmask,Z); } C\u00f3digo 3.12: Codificaci\u00f3n del volumen (fragment shader). Mediante texturas atlas uniform mat4 viewProjMatrixVoxelCam; uniform int res; uniform sampler2D TextureAtlas; in vec2 glVertex; out float Z; void main(){ CAP\u00cdTULO 3. IMPLEMENTACI\u00d3N 44 //Se obtiene la coordenada de mundo de la textura vec3 WorldCoord = texelFetch2D(TextureAtlas, ivec2(glVertex.xy * res) ,0).rgb; //Se transforma la coordenada de mundo al espacio del volumen gl_Position = viewProjMatrixVoxelCam * vec4(WorldCoord,1.0); //Se transforma la coordenada Z al espacio [0,1] Z = gl_Position.z * 0.5 + 0.5; } C\u00f3digo 3.13: Voxelizaci\u00f3n a trav\u00e9s del uso de texturas atlas (vertex shader). Esta voxelizaci\u00f3n funciona de manera similar al slicemap, la \u00fanica diferencia es que en el fragment shader mostrado en el c\u00f3digo 3.13 las coordenadas de mundo son obtenidas a trav\u00e9s de la textura atlas TextureAtlas. Para ello, se debe desplegarse un v\u00e9rtice por cada p\u00edxel v\u00e1lido de la textura, cuya coordenada sirve para obtener muestras sobre la textura usando texelFetch2D. Posteriormente se realizan los mismos pasos utilizados en slicemap. Creaci\u00f3n de la jerarqu\u00eda mipmap uniform usampler2D voxelTexture; //Textura con el volumen uniform int level; //Del nivel de la jerarqu\u00eda que se va a leer uniform float inverseTexSize; // (1.0 / Resoluci\u00f3n de la jerarqu\u00eda) in vec2 TextCoord; in vec4 pos; layout(location = 0) out uvec4 FragColor; void main(){ //Se calculan las coordenadas de los vecinos vec2 offset1 = vec2(inverseTexSize, 0.0); //Derecha vec2 offset2 = vec2(0.0, inverseTexSize); //Arriba vec2 offset3 = vec2(inverseTexSize, inverseTexSize); //Arriba y derecha vec2 coord = TextCoord - vec2(inverseTexSize/2.0, inverseTexSize/2.0); /*Se obtiene el valor de textura de los vecinos en el nivel correspondiente*/ uvec4 val1 = texture2DLod(voxelTexture, coord, level); uvec4 val2 = texture2DLod(voxelTexture, coord+offset1, level); uvec4 val3 = texture2DLod(voxelTexture, coord+offset2, level); uvec4 val4 = texture2DLod(voxelTexture, coord+offset3, level); //Se realiza la operaci\u00f3n l\u00f3gica Or entre los 4 valores FragColor = val1 | val2 | val3 | val4; } C\u00f3digo 3.14: Creaci\u00f3n de la jerarqu\u00eda mipmap (fragment shader). Cuando la escena voxelizada es obtenida por medio de slicemap o de las texturas atlas, el volumen es almacenado en una textura 2D (voxelTexture). Para crear la jerarqu\u00eda mipmap a CAP\u00cdTULO 3. IMPLEMENTACI\u00d3N 45 partir de esta textura se utiliza el fragment shader que se muestra en c\u00f3digo 3.14. Se utiliza en conjunto con el vertex shader del c\u00f3digo 3.2. La textura original representar\u00e1 el nivel 0 de la jerarqu\u00eda y dada una resoluci\u00f3n X del volumen se tendr\u00e1n Y = log2(X) niveles en la jerarqu\u00eda. En cada nivel de la jerarqu\u00eda es necesario utilizar el shader para crear el nivel siguiente. Por ejemplo, para calcular el nivel i de la jerarqu\u00eda, a la variable level se le asigna i- 1 para acceder al nivel anterior, y el shader despliega informaci\u00f3n en el nivel i de la jerarqu\u00eda. Para ello, se obtiene el valor de 4 p\u00edxeles en el nivel anterior utilizando texture2DLod, y por medio de la operaci\u00f3n OR l\u00f3gico se obtiene el valor del p\u00edxel en el nivel actual. 3.4.7. Iluminaci\u00f3n directa Para el c\u00e1lculo de la luz directa se utiliza el fragment shader mostrado en el c\u00f3digo 3.15, en conjunto con el vertex shader presente en el c\u00f3digo 3.2. La iluminaci\u00f3n directa se calcula desde el punto de vista de la c\u00e1mara, por lo que puede utilizarse la informaci\u00f3n almacenada en el G-Buffer, en vez de desplegar toda la escena otra vez. Por ello, se utilizar\u00e1n las texturas que almacenan las coordenadas de mundo (position), los vectores normales (normal) y la BRDF de las superficies (material). Como se va a calcular la iluminaci\u00f3n, se deben enviar las propiedades de la luz a trav\u00e9s de variables de tipo uniformes al shader, adem\u00e1s de enviar el shadow map como una textura (ShadowMap). Con la coordenada de textura enviada al fragment shader se obtienen los valores correctos a trav\u00e9s de las texturas del G-Buffer, almacenando las coordenadas de mundo en vposition, el vector normal en vnormal y el valor de la BRDF de la superficie en vmaterial. Con estos valores es posible calcular la contribuci\u00f3n de la luz directa en este p\u00edxel de manera similar a como se calcula la iluminaci\u00f3n para el RSM. Para el c\u00e1lculo de las sombras es necesario proyectar la coordenada de mundo al espacio del RSM, ya que el shadow map se encuentra en este espacio. Por ello, la matriz de trans- formaciones del RSM es enviada al shader en la variable glRSMReprojectMatrix. Debido a la baja resoluci\u00f3n de las sombras en el RSM, se hace uso del filtro propuesto por Bunnell y Pellacini [58]. En este filtro se obtienen los valores de sombra de 16 valores alrededor del p\u00edxel y se promedian sus contribuciones, logrando el efecto de una sombra suave. Debido a que la escena puede poseer varias luces, se hace uso de este shader para su- mar las contribuciones de las luces en la textura final. Para cada uno de los despliegues se modifican los valores uniformes de las propiedades de la luz. in vec4 vecPos; //Coordenadas de mundo in vec2 TextCoord; //Coordenadas de textura //G-buffers uniform sampler2D position; //Posici\u00f3n uniform sampler2D normal; //Normal uniform sampler2D material; //BRDF uniform sampler2DShadow ShadowMap; uniform vec2 texmapscale; CAP\u00cdTULO 3. IMPLEMENTACI\u00d3N 46 uniform mat4 glRSMReprojectMatrix; //Propiedades de la luz uniform vec3 lightPos; //Posici\u00f3n uniform vec3 lightColor; //Color uniform vec3 lightDirection; //Direcci\u00f3n uniform float lightCosCutoff; //\u00c1ngulo de corte uniform float lightExponent; //Exponente uniform float lightConstant; //Atenuaci\u00f3n constante uniform float lightLinear; //Atenuaci\u00f3n linear uniform float lightQuadratic; //Atenuaci\u00f3n cuadr\u00e1tica uniform bool softShadow; //Calidad de la sombra layout(location = 0) out vec4 DirectLight; float offset_lookup(vec4 loc, vec2 offset){ return textureProj(ShadowMap, vec4(loc.xy + offset * texmapscale * loc.w, loc.z - 0.01, loc.w)); } void main(){ DirectLight = vec4(0.0); vec3 vposition = texture2D(position,TextCoord).rgb; vec3 vnormal = texture2D(normal,TextCoord).rgb; vec3 vmaterial = texture2D(material,TextCoord).rgb; if(vposition.z < 100.0){ DirectLight = vec4(0.0,0.0,0.0,0.0); vec3 light_dir = lightPos - vposition; float dist = length(light_dir); light_dir = light_dir/dist; float NdotL = max(dot(vnormal,light_dir),0.0); if(NdotL > 0.0){ float SpotEffect = dot(normalize(lightDirection), -light_dir); if (SpotEffect >= lightCosCutoff){ SpotEffect = pow(SpotEffect, lightExponent); float att = SpotEffect / (lightConstant + lightLinear * dist + lightQuadratic * dist * dist); DirectLight = vec4(att * (vmaterial * lightColor * NdotL),1.0); } } vec4 shadowProjectedCoord = glRSMReprojectMatrix * vec4(vposition ,1.0); float shadow = 1.0; CAP\u00cdTULO 3. IMPLEMENTACI\u00d3N 47 if(shadowProjectedCoord.w > 0.0){ //Se obtienen muestras de la sombra shadow = 0.0; float x, y; float limit = (softShadow)?1.5:0.0; int num = 0; for (y = -limit; y <= limit; y += 1.0){ for (x = -limit; x <= limit; x += 1.0){ shadow += offset_lookup(shadowProjectedCoord, vec2(x, y)); ++num; } } shadow /= num; } DirectLight.rgb *= shadow; } } C\u00f3digo 3.15: C\u00e1lculo de la iluminaci\u00f3n directa (fragment shader). 3.4.8. Iluminaci\u00f3n indirecta C\u00e1lculo de la intersecci\u00f3n del rayo Para realizar el c\u00e1lculo de la iluminaci\u00f3n indirecta es necesario lanzar un rayo por cada p\u00edxel de la imagen final y calcular su intersecci\u00f3n con la escena voxelizada. En el c\u00f3digo 3.16 se muestra el m\u00e9todo principal del fragment shader que se encarga de calcular la intersec- ci\u00f3n. Primero, se extrae el origen del rayo de las coordenadas de mundo almacenadas en el G-Buffer. Luego, la direcci\u00f3n del rayo se calcula tomando muestras en el hemisferio de la superficie. El origen es desplazado en direcci\u00f3n de la normal para evitar que intersecte con la misma geometr\u00eda. Una vez calculado el origen y la direcci\u00f3n del rayo, se calcula el punto final del rayo, el cual depender\u00e1 de la longitud establecida. Para poder recorrer el volumen es necesario transformar las coordenadas del rayo a NDC, lo cual se realiza por medio de la matriz WordlToNDCMatrix. Para poder ir avanzando en la direcci\u00f3n del rayo se utlizan las variables TNear y a TFar, y cuando TNear sea mayor TFar la longitud restante del rayo ser\u00e1 0. Una vez que se tiene preparado el rayo se procede a realizar el recorrido a trav\u00e9s del volumen. Las condiciones de parada del recorrido son que la longitud del rayo se acabe, se encuentre una intersecci\u00f3n o se haga un n\u00famero determinado de pruebas de intersecci\u00f3n (steps). Para cada iteraci\u00f3n el rayo es proyectado sobre el volumen, calculando el p\u00edxel del volumen en el que se encuentra el origen. En este p\u00edxel se puede crear una caja envolvente que contenga la columna de bits de ese p\u00edxel. Con esta caja se puede calcular un valor de salida y uno de entrada del rayo en la caja. Posteriormente con estos valores es posible calcular la intersecci\u00f3n del rayo con los valores que est\u00e1n contenidos en el p\u00edxel. Si se encuentra CAP\u00cdTULO 3. IMPLEMENTACI\u00d3N 48 una intersecci\u00f3n, se necesita verificar si tambi\u00e9n la hay en un nivel menor de la jerarqu\u00eda. Solamente se considera que hay intersecci\u00f3n si esta se encuentra en el nivel 0 de la jerarqu\u00eda. En caso que no haya intersecci\u00f3n, se debe avanzar el rayo con el punto de salida de la caja envolvente del p\u00edxel calculado anteriormente, actualizando el TNear y se incrementa un nivel en la jerarqu\u00eda. Este avance del rayo se realiza con un desplazamiento para evitar errores de punto flotante. #define PI 3.14159265359 in vec4 vecPos; in vec2 TextCoord; uniform usampler2D allBitMasks; //Textura con todas las m\u00e1scaras de bit uniform usampler2D Voxel; //Textura que almacena el volumen //G-Buffers uniform sampler2D positionGBuffer; //Posici\u00f3n uniform sampler2D normalGBuffer; //Normal uniform sampler2D random; //Una textura aleatoria uniform mat4 WordlToNDCMatrix; //Coordenadas de mundo a NDC uniform mat4 UnitToWorldCoordMatrix;//NDC a coordenadas de mundo uniform int max_lvl; //Nivel m\u00e1ximo de la jerarqu\u00eda uniform int steps; //N\u00famero de pasos uniform float ray_lenght; //Longitud del rayo uniform vec3 VoxelizeDirection; //Direcci\u00f3n de la voxelizaci\u00f3n uniform float VoxelDiagonal; //Tama\u00f1o de la diagonal de un v\u00f3xel uniform vec2 SamplingSequence[128]; //Arreglo con muestras uniform int ray_number; //El n\u00famero del rayo uniform float contribution; //Contribuci\u00f3n del rayo uniform float NormalOffset; //Desplazamiento del rayo con la normal uniform float RayOffsetStart; //Desplazamiento del comienzo del rayo //Definici\u00f3n del rayo vec3 dir; vec3 origin; layout(location = 0) out vec3 Hit; layout(location = 1) out vec3 directionalOclusion; void main(){ vec4 Position = texture2D(positionGBuffer,TextCoord); Hit = vec3(0.0,0.0,100.0); directionalOclusion = vec3(0); if(Position.z < 100.0){ vec3 normal = texture2D(normalGBuffer,TextCoord).xyz; normal = normalize(normal); //Se generan 2 vectores ortogonales con la normal vec3 R = vec3(0.0,0.0,1.0); CAP\u00cdTULO 3. IMPLEMENTACI\u00d3N 49 if(abs(normal.x) < 0.001 && abs(normal.y) < 0.001) R = vec3(0.0,1.0,0.0); vec3 T = normalize(cross(normal,R)); vec3 B = cross(T,normal); //Se obtiene un valor aleatorio de la textura vec2 ran = texelFetch2D(random, ivec2(mod(ivec2((TextCoord.st)*1024), ivec2(16))), 0).rg; float r1 = fract(SamplingSequence[ray_number].x + ran.x); float r2 = fract(SamplingSequence[ray_number].y + ran.y); //Se obtiene un valor aletorio en el hemisferio float r = 2 * PI * r2; float sq2 = sqrt(r1); float x = cos(r) * sq2; float y = sin(r) * sq2; float z = sqrt(max(0.0, 1.0 - x*x - y*y)); //Se proyecta ese punto en la direcci\u00f3n de la normal vec3 ray = normalize(x*B + y*T + z*normal); //Desplazamiento para prevenir el auto sombreado //Se mueve el rayo al menos el tama\u00f1o de la diagonal del v\u00f3xel float soffset = RayOffsetStart * VoxelDiagonal / dot(ray, normal); if(soffset <= ray_lenght){ //Se construye el origen y el final del rayo origin = Position.xyz + NormalOffset * normal + ray * soffset; vec3 end = Position.xyz + NormalOffset * normal + ray * ray_lenght; //Solo se procede si el rayo tiene una longitud aceptable if(distance(origin,end) > VoxelDiagonal*1.5){ //Transformar las coordenadas a NDC origin = (WordlToNDCMatrix * origin).xyz; dir = (WordlToNDCMatrix * end).xyz - origin; //Un peque\u00f1o desplazamiento para el recorrido de la jerarqu\u00eda float offset = (0.25 / (1 << (max_lvl -1))) / length(dir); float TNear = 0.0, TFar; //Se calcula la intersecci\u00f3n del rayo en el m\u00e1ximo nivel if(!IntersectBox(vec3(0.0),vec3(1.0),TFar)) TFar = 1.0; bool intersection = false; uvec4 Bitmask = uvec4(0.0); //Colocar el origen actual con el origen del rayo vec3 currentTNear = origin; float currentTFar; int lvl = min(3 , max_lvl - 2); CAP\u00cdTULO 3. IMPLEMENTACI\u00d3N 50 //Se calcula la intersecci\u00f3n del rayo con el volumen for(int i=0; (i < steps) && (TNear <= TFar) && (!intersection); ++i ){ currentTFar = 1.0; if(IntersectWithVolume(lvl, currentTNear, currentTFar, Bitmask) ){ //Si hay intersecci\u00f3n se debe probar si hay intersecci\u00f3n un //nivel menor de la jerarqu\u00eda. Solo ocurre intersecci\u00f3n si //hay intersecci\u00f3n en el nivel 0 de la jerarqu\u00eda intersection = (lvl == 0); -- lvl; }else{ //Si no hay intersecci\u00f3n el rayo es trasladado y se avanza //al nivel anterior TNear = currentTFar + offset; currentTNear = origin + TNear * dir; ++ lvl; } } //Si hay intersecci\u00f3n se calcula cual fue el bit intersectado if(intersection){ CalculatePosition(bitPosition) //Se obtiene la posici\u00f3n del hit en NDC, para luego //transformarla a coordenadas de mundo y almacenar //el resultado currentTNear.z = (float(127.0 - bitPosition) + 0.5)/128.0; Hit = (UnitToWorldCoordMatrix * vec4(currentTNear,1.0)).rgb; } //Se calcula la oclusi\u00f3n direccional vec3 senderRadiance = vec3(0.2); float occlusionStrength = 1.1; float receiverGeometricTerm = max(0.0, dot(ray, normal)); float visibility = 1.0 - (intersection ? occlusionStrength: 0.0); directionalOclusion = contribution * visibility * receiverGeometricTerm * senderRadiance; } } } } C\u00f3digo 3.16: M\u00e9todo principal para el c\u00e1lculo de la intersecci\u00f3n del rayo (fragment shader). En el c\u00f3digo 3.17 se muestra el m\u00e9todo IntersectWithVolume, el cual se encarga de pro- yectar el rayo en la jerarqu\u00eda y calcular la caja envolvente del p\u00edxel. Primeramente se debe calcular el p\u00edxel activo de la jerarqu\u00eda. Como el rayo se encuentra en coordenadas NDC, esto se realiza multiplicando su posici\u00f3n actual (posTNear) por el alto y el ancho del volumen en el nivel actual de la jerarqu\u00eda. Posteriormente, se obtiene la caja envolvente dividiendo la CAP\u00cdTULO 3. IMPLEMENTACI\u00d3N 51 coordenada del p\u00edxel entre el alto y el ancho de volumen en el nivel actual. El valor de entrada del rayo con la caja envolvente est\u00e1 definido por posTNear.z y el valor de salida es almacena- do en zFar, despu\u00e9s de ser calculado el valor de tFar con el m\u00e9todo IntersectBoxOnlyTFar. Con el valor de salida y entrada del rayo en la caja, se obtiene la m\u00e1scara de bits del rayo, tomando una muestra de la textura 2D allBitMasks. Esta textura tiene ya precalculado todas las m\u00e1scaras posibles dado un valor de entrada y un valor de salida. Esta m\u00e1scara es pasada junto con la coordenada del p\u00edxel y el nivel de la jerarqu\u00eda actual, al m\u00e9todo intersectBits. bool IntersectWithVolume(in int level, in vec3 posTNear, inout float tFar , out uvec4 intersectionBitmask){ //Calcula las coordenadas del rayo en p\u00edxeles float res = float(1 << (max_lvl - 1 - level)); ivec2 pixelCoord = ivec2(posTNear.xy * res); vec2 voxelWH = vec2(1.0) / res; //Se calcula el AABB perteneciente a la posici\u00f3n del p\u00edxel vec2 box_min = pixelCoord * voxelWH; //Se computa la intersecci\u00f3n con la caja envolvente tFar = IntersectBoxOnlyTFar( vec3(box_min, 0.0), vec3(box_min + voxelWH, 1.0)); //Se calcula la salida del rayo con la caja envolvente float zFar = tFar*dir.z + origin.z ; /*Con la entrada y la salida de la caja envolvente se calcula una m\u00e1scara de bits con 1\u2019s entre estos dos valores y 0\u2019s los dem\u00e1s bits, y se verifica si intersecta con la columna de bits del volumen*/ return intersectBits( texture2D(allBitMasks, vec2(min(posTNear.z, zFar), max(posTNear.z, zFar))), pixelCoord, level, intersectionBitmask); } C\u00f3digo 3.17: Intersecci\u00f3n del rayo con la jerarqu\u00eda. El m\u00e9todo intersectBits mostrado en el c\u00f3digo 3.18 toma como entrada la m\u00e1scara de bits del rayo y procede a calcular la m\u00e1scara de bits del p\u00edxel, obteniendo el valor del volumen (Voxel) y en el p\u00edxel requerido (texel), en el nivel actual de la jerarqu\u00eda (level). Luego procede a realizar la operaci\u00f3n l\u00f3gica AND entre estas dos m\u00e1scaras y proceder\u00e1 a almacenar el valor en la variable intersectionBitmask. Si el valor de intersectionBitmask es diferente de 0 significa que hubo intersecci\u00f3n. El m\u00e9todo IntersectWithVolume posteriormente se encargar\u00e1 de notificar al m\u00e9todo principal si hubo intersecci\u00f3n o no. El valor presente en la variable intersectionBitmask es almacenado en el m\u00e9todo principal en la variable bitPosition, y con \u00e9l se procede a calcular el primer bit encendido de la manera mostrada en el c\u00f3digo 2.1 en el cap\u00edtulo 2. De esta manera, se obtiene el valor de profundidad de la intersecci\u00f3n. Transformando el valor almacenado en currentTNear de coordenadas NDC CAP\u00cdTULO 3. IMPLEMENTACI\u00d3N 52 a coordenadas de mundo, se obtiene el punto de la intersecci\u00f3n del rayo en coordenadas de mundo y se despliega en la textura Hit. bool intersectBits(in uvec4 bitRay, in ivec2 texel, in int level, out uvec4 intersectionBitmask){ intersectionBitmask = (bitRay & texelFetch2D(Voxel, texel, level)); return (intersectionBitmask != uvec4(0)); } C\u00f3digo 3.18: C\u00e1lculo de la m\u00e1scara de bits de la intersecci\u00f3n. Adicionalmente, se calcula la oclusi\u00f3n direccional. La oclusi\u00f3n direccional fue propuesta por Ritschel et al. [59] y representa un complemento a la soluci\u00f3n de la iluminaci\u00f3n global. Para el c\u00e1lculo de este valor se lanzan rayos alrededor del hemisferio de una superficie, si el rayo no intersecta con geometr\u00eda se toma un valor proveniente del ambiente (senderRa- diance). En caso de que haya intersecci\u00f3n, el valor tender\u00e1 a oscurecer el p\u00edxel. La prueba de intersecci\u00f3n realizada anteriormente se puede aprovechar para calcular este valor. De esta manera, superficies que no reciban luz indirecta de ningun rayo, podr\u00e1n ser iluminadas por la luz ambiental. Obtenci\u00f3n del valor de iluminaci\u00f3n Una vez obtenido el punto de intersecci\u00f3n del rayo con el shader anterior, se procede a proyectar ese punto en el RSM, mediante el uso de la matriz RSMMatrix, para calcular la iluminaci\u00f3n indirecta. Este proceso se realiza con el fragment shader mostrado en el c\u00f3digo 3.19. La textura HitBuffer almacena todas las intersecciones de los rayos para cada uno de los p\u00edxeles de la imagen. Con ella es posible obtener el punto proyectado en el RSM y es almace- nado en la variable coord. Con esta variable se obtiene el vector normal, las coordenadas de mundo y el color de los buffers creados por el RSM. Por otro lado, RayOriginBuffer es la tex- tura obtenida con las coordenadas de mundo del G-Buffer, las cuales representan el origen del rayo. Una vez obtenida esta informaci\u00f3n, se determina si el punto de intersecci\u00f3n realmente es visible desde la luz, utilizando el umbral que se explic\u00f3 en el cap\u00edtulo 2, en la secci\u00f3n 2.3.2. Si el punto de intersecci\u00f3n es visible desde la luz, se coloca el valor de iluminaci\u00f3n del RSM como la iluminaci\u00f3n directa para este punto. in vec4 vecPos; //Coordenadas de mundo del fragmento in vec2 TextCoord; //Coordenadas de textura del fragmento //Textura que almacena el final del rayo uniform sampler2D HitBuffer; //Textura que almacena el origen del rayo uniform sampler2D RayOriginBuffer; //Buffers del RSM uniform sampler2D positionRSM; //Posici\u00f3n uniform sampler2D normalRSM; //Normal CAP\u00cdTULO 3. IMPLEMENTACI\u00d3N 53 uniform sampler2D colorRSM; //Color //Matriz para reproyectar el punto hacia el espacio visto por el RSM uniform mat4 RSMMatrix; uniform float voxelDiagonal; uniform float pixel_sideDivzNear; uniform float contribution; //Contribuci\u00f3n de la luz indirecta uniform vec3 lightDir; //Direcci\u00f3n de la luz uniform float thresholdFactor; layout(location = 0) out vec4 FragColor; void main(){ //Obtenci\u00f3n de origen del rayo vec3 rayOrigin = texture2D(RayOriginBuffer,TextCoord).xyz; //Obtenci\u00f3n del final del rayo vec3 rayEnd = texture2D(HitBuffer,TextCoord).xyz; //Obtenci\u00f3n de la direcci\u00f3n del rayo vec3 raydir = normalize(rayOrigin - rayEnd); //Proyectar el final del rayo en el espacio del RSM vec4 coord = RSMMatrix * vec4(rayEnd,1.0); //Coordenadas de mundo del final del rayo en el RSM vec4 position = texture2DProj(positionRSM, coord); //Vector normal en la posici\u00f3n final del rayo en el RSM vec3 normal = texture2DProj(normalRSM, coord).xyz; //Iluminaci\u00f3n directa en la posici\u00f3n final del rayo en el RSM vec4 color = texture2DProj(colorRSM, coord); float lightZ = position.w; float pixelSide = pixel_sideDivzNear * lightZ; float front_face = dot(normal, raydir); float cosAlpha = max(dot(normal, lightDir),0.001); /*El umbral de comparaci\u00f3n de la distancia entre el final del rayo y la posici\u00f3n del RSM debe ser ajustada a la discretizaci\u00f3n de la voxelizaci\u00f3n (definida por el tama\u00f1o de la diagonal del voxel), el tama\u00f1o de un p\u00edxel en el RSM y la orientaci\u00f3n de la superficie */ if( rayEnd.z < 100.0 && /*Si hay una intersecci\u00f3n*/ color.z < 100.0 && /*Si el material es v\u00e1lido en esa posici\u00f3n*/ coord.w > 0.0 && /*Si el final del rayo es proyectado al RSM*/ front_face >= 0.0 && /*Si la superficie es una cara frontal*/ distance(rayEnd,position.xyz) < min( 4.0 * voxelDiagonal, max( voxelDiagonal,pixelSide/cosAlpha)) * thresholdFactor){ CAP\u00cdTULO 3. IMPLEMENTACI\u00d3N 54 FragColor = contribution * color; }else{ FragColor = vec4(0.0); } } C\u00f3digo 3.19: C\u00e1lculo de la luz indirecta (fragment shader). Este shader, en conjunto con el shader para el c\u00e1lculo de la intersecci\u00f3n del rayo mostrado en el c\u00f3digo 3.16, deben utilizarse para cada uno de los rayos que deban lanzarse en una pasada hacia la escena. Por ello, el n\u00famero de rayos y el viewport de la imagen final son factores que inciden en el desempe\u00f1o del algoritmo. Combinaci\u00f3n de la oclusi\u00f3n direccional Cuando se obtuvo el valor de iluminaci\u00f3n indirecta se almacen\u00f3 los valores de la oclusi\u00f3n direccional en una textura diferente. Por lo tanto, se necesitan sumar estos valores con los va- lores de la iluminaci\u00f3n indirecta. El fragment shader mostrado en el c\u00f3digo 3.20, en conjunto con el vertex shader presentado en el c\u00f3digo 3.2, se encargan de realizar esta tarea. Para ello, se coloca como objetivo de despliegue la textura que contiene la iluminaci\u00f3n indirecta y se debe preparar el pipeline gr\u00e1fico para poder mezclar los valores de oclusi\u00f3n direccional (di- rectionalOclution), con los ya presentes en la textura objetivo IndirectIlumination. Debido a que los valores de oclusi\u00f3n direccional pueden ser negativos en presencia de una fuerte oclusi\u00f3n, es necesario transformar los valores negativos a 0. //Textura con los valores de oclusi\u00f3n direccional uniform sampler2D directionalOclution; in vec4 vecPos; //Coordenadas de mundo del fragmento in vec2 TextCoord; //Coordenadas de textura del fragmento layout(location = 0) out vec3 IndirectIlumination; void main(){ IndirectIlumination = max(vec3(0.0),texture(directionalOclution, TextCoord).rgb); } C\u00f3digo 3.20: Combinaci\u00f3n de la oclusi\u00f3n direccional con la iluminaci\u00f3n indirecta (fragment shader). 3.4.9. Filtro para la iluminaci\u00f3n indirecta Debido a que la iluminaci\u00f3n indirecta se calcula en espacio de imagen y con un n\u00famero limitado de rayos, la soluci\u00f3n resultante posee mucho ruido. Para poder eliminar este ruido es necesario la aplicaci\u00f3n de un filtro. En el fragment shader mostrado en el c\u00f3digo 3.21, se CAP\u00cdTULO 3. IMPLEMENTACI\u00d3N 55 aplica el filtro espacial presentado por Herzog et al. [60]. Este filtro es usado para interpolar valores de p\u00edxeles cercanos, tomando en cuenta las coordenadas de mundo y los vectores nor- males que est\u00e1n almacenados en el G-Buffer. De esta manera, la contribuci\u00f3n de los valores es dependiente de la cercan\u00eda de los p\u00edxeles en espacio de mundo y de la orientaci\u00f3n de las superficies. El valor filtrado h(i) para un p\u00edxel i puede ser calculado de la siguiente manera: h(i) = 1\u2211 \u03c9s \u2211 j\ufffdN{i} \u03c9s(i, j) \u00b7 l(j) (3.4) Donde N{i} son los vecinos alrededor de i, j es el \u00edndice del p\u00edxel vecino y \u03c9s(i, j) es la contribuci\u00f3n del p\u00edxel i al p\u00edxel j dependiente de la geometr\u00eda. Esta contribuci\u00f3n puede ser calculada de la siguiente manera: \u03c9s(i, j) = n(max(0, 1\u2212 (\u2212\u2192ni \u00b7 \u2212\u2192nj))2, \u03c32n)\u00d7 d(|zi \u2212 zj| 2, \u03c32z)\u00d7 k(i, j) (3.5) Este peso tiene un factor dependiente de la orientaci\u00f3n n, uno dependiente de la distancia d y uno dependiente de el espacio de imagen k. Los valores de \u03c32n y de \u03c3 2 z son dependientes de la escena. Para n, d y k se utiliza el siguiente kernel: g(x, \u03c3) = max(\ufffd, 1\u2212 ( x2 \u03c3 ))3 (3.6) En este fragment shader se aplica esta ecuaci\u00f3n con el fin de poder eliminar el ruido en la textura de la iluminaci\u00f3n indirecta (inputText), con lo que puede utilizarse una menor cantidad de rayos obteniendo un resultado aceptable. uniform sampler2D inputText; //Textura con iluminaci\u00f3n indirecta uniform sampler2D normal; //Vectores normales G-Buffer uniform sampler2D position; //Coordenadas de mundo G-Buffer uniform float normalTolerance; //Tolerancia de la normal al cuadrado uniform float distanceTolerance;//Tolerancia de la distancia al cuadrado uniform int radius; //Radio del filtro uniform float pixelDiagonal; uniform vec2 sampleDisplacement; in vec4 vecPos; //Coordenadas de mundo del v\u00e9rtice in vec2 TextCoord; //Coordenadas de textura del v\u00e9rtice layout(location = 0) out vec3 indirLight; float kernel(in float x, in float rho){ float aux = max(0.01,1.0 - (x * x / rho)); return aux * aux * aux; } float k(in float dist){ float aux = max(0.01,1.0 - (dist / pixelDiagonal)); return aux * aux * aux; } CAP\u00cdTULO 3. IMPLEMENTACI\u00d3N 56 void main(){ vec2 textcoord = TextCoord; vec3 actualposition = texture(position,textcoord).rgb; if(actualposition.z < 100.0){ vec3 actualnormal = texture(normal,textcoord).rgb; float weight; vec3 totalWeight = vec3(0.0); float sumWeight = 0.0; vec2 sampleCoord; for(int i = -radius;i <= radius; ++i){ sampleCoord = textcoord + i * sampleDisplacement; weight = kernel(max(0.0,1.0 - dot(actualnormal, texture(normal, sampleCoord).rgb)),normalTolerance) * kernel(distance(actualposition, texture(position, sampleCoord ).rgb),distanceTolerance) * k(i); sumWeight += weight; totalWeight += weight * texture(inputText,sampleCoord).rgb; } if(sumWeight > 0.0) indirLight = totalWeight / sumWeight; } } C\u00f3digo 3.21: Filtro para eliminar el ruido en la iluminaci\u00f3n indirecta (fragment shader). 3.4.10. Combinaci\u00f3n de soluciones Una vez obtenidas tanto la iluminaci\u00f3n directa como la iluminaci\u00f3n indirecta, sus co- rrespondientes texturas son utilizadas para obtener la soluci\u00f3n final. La combinaci\u00f3n de las soluciones se realiza con el fragment shader mostrado en el c\u00f3digo 3.22, en combinaci\u00f3n con el vertex shader que se muestra en el c\u00f3digo 3.2. El shader recibe como entradas las texturas de coordenadas de mundo y de la BRDF del G-Buffer, adem\u00e1s de las texturas con contienen la iluminaci\u00f3n directa y la iluminaci\u00f3n indirecta. Se busca la coordenada de mundo, vista desde el p\u00edxel haciendo uso del G-Buffer. Si la posici\u00f3n es v\u00e1lida, se procede a sumar la luz indirecta y la luz directa. Ambos valores son multiplicados por un factor de contribuci\u00f3n y la luz indirecta es multiplicada por la BRDF de la superficie vista desde el p\u00edxel. Finalmen- te, el resultado es codificado con un operador de correcci\u00f3n gama, el cual resaltar\u00e1 m\u00e1s las superficies iluminadas de la escena. in vec4 vecPos; //Coordenadas de mundo in vec2 TextCoord; //Coordenadas de textura uniform sampler2D position; //Coordenadas de mundo del G-Buffer uniform sampler2D material; //BRDF del G-Buffer CAP\u00cdTULO 3. IMPLEMENTACI\u00d3N 57 uniform sampler2D IIlu; //Texturas con iluminaci\u00f3n indirecta uniform sampler2D DIlu; //Texturas con iluminaci\u00f3n directa uniform float dlcont; uniform float idlcont; uniform bool addDirect; uniform bool addIndirect; layout(location = 0) out vec3 FinalResult; void main() { vec3 vposition = texture(position,TextCoord).rgb; vec3 vmaterial = texture(material,TextCoord).rgb; if(vposition.z < 100.0){ FinalResult = vec3(0.0); if(addDirect){ //Se suma la luz directa FinalResult += dlcont * texture(DIlu,TextCoord).rgb; } if(addIndirect){ //Se coloca la luz indirecta //Luz indirecta = contribuci\u00f3n indirecta * BRDF difusa FinalResult += idlcont * max(vec3(0.00001), texture(IIlu, TextCoord).rgb * vmaterial); } //Correcci\u00f3n gama para colocar la imagen m\u00e1s brillante FinalResult = pow(FinalResult, vec3(1.0/2.0)); } } C\u00f3digo 3.22: Combinaci\u00f3n de la luz indirecta y la luz directa (fragment shader). En la figura 3.3 se muestran algunas de las texturas resultado m\u00e1s importantes en las diferentes etapas del algoritmo. Para la etapa 1 se muestra el G-Buffer con sus coordenadas de mundo, vectores normales y las BRDF de la superficie. Adem\u00e1s, se encuentra el shadow map y el reflective shadow map con sus coordenadas de mundo, vectores normales y la iluminaci\u00f3n directa. En la etapa 2 se observan las texturas atlas de la escena (izquierda) y la textura con la escena voxelizada (derecha). Las texturas creadas para el c\u00e1lculo de la luz directa (derecha) y la luz indirecta (izquierda) son mostradas en la etapa 3. Para la luz indirecta se muestra el buffer de intersecci\u00f3n de los \u00faltimos rayos lanzados, la oclusi\u00f3n direccional, y la luz indirecta ya combinada con la oclusi\u00f3n direccional y filtrada. Por \u00faltimo, en la etapa 4 se observa el resultado final al combinar la contribuci\u00f3n de la luz directa y la luz indirecta. CAP\u00cdTULO 3. IMPLEMENTACI\u00d3N 58 Figura 3.3: Resultado de las diferentes etapas del algoritmo. Cap\u00edtulo 4 Pruebas y resultados En este cap\u00edtulo se analizar\u00e1n los resultados obtenidos al aplicar diferentes pruebas en la implementaci\u00f3n del algoritmo realizada para este trabajo especial de grado. Debido a que la implementaci\u00f3n esta orientada mayormente al uso de la GPU para realizar los c\u00e1lculos, las mediciones de tiempo se efect\u00faan en tiempos de la GPU y no de la CPU. Primero se de- tallar\u00e1n las escenas y los ambientes utilizados para realizar las pruebas. Luego se estudiar\u00e1n diferentes factores que afectan la voxelizaci\u00f3n, como lo son el tama\u00f1o del volumen, el tama\u00f1o de las texturas atlas y la comparaci\u00f3n del uso de las texturas atlas y slicemap. Posteriormente, se estudiar\u00e1n diferentes factores que afectan el rendimiento del c\u00e1lculo de la iluminaci\u00f3n in- directa. Finalmente, se analizar\u00e1 el desempe\u00f1o de la implementaci\u00f3n para diferentes tama\u00f1os de la ventana. 4.1. Ambiente de pruebas Una escena contiene dos tipos de objetos: los din\u00e1micos y los est\u00e1ticos. Los est\u00e1ticos son cargado en la aplicaci\u00f3n como modelos en formato OBJ, representando la estructura b\u00e1sica de la escena. Los din\u00e1micos son cargados como modelos en formato MD2. Para la prueba de la implementaci\u00f3n, se dise\u00f1\u00f3 3 escenas de diferentes tama\u00f1o: peque\u00f1a (figura 4.1(a)), mediana (figura 4.1(b)) y grande (figura 4.1(c)). (a) Caja de colores (b) Catedral de Sibenik (c) Sponza de Crytek Figura 4.1: Escenarios de prueba. 59 CAP\u00cdTULO 4. PRUEBAS Y RESULTADOS 60 En la tabla 4.1 se muestra el nombre, los modelos contenidos, la cantidad de v\u00e9rtices y la cantidad de tri\u00e1ngulos de la escenas dise\u00f1adas. El sponza de Crytek [61], debido a su gran cantidad de geometr\u00eda, fue divido en dos partes: la estructura del edificio y los objetos dentro del mismo. En la tabla solo se toma en cuenta los modelos en formato OBJ, ya que poseen mayor cantidad de geometr\u00eda y un nivel de detalle m\u00e1s alto que los objetos din\u00e1micos. Los objetos din\u00e1micos pueden ser agregados a cualquiera de la escenas. Nombre Modelos Nro. de V\u00e9rtices Nro. deTri\u00e1ngulos Escena peque\u00f1a (E1) Caja de colores 38 32 Escena mediana (E2) Catedral de Sibenik 79.116 79.851 Escena grande (E3) Sponza de Crytek: Estructura 60.094 112.257 Objetos 83.438 147.333 Tabla 4.1: Escenas para la realizaci\u00f3n de pruebas. Las pruebas se realizaron en 2 ambientes diferentes. En ambos se utiliz\u00f3 una PC conven- cional con las siguientes especificaciones: Windows 7 de 64 bits, procesador Intel Core i3 de 3 GHz y OpenGL versi\u00f3n 3.3. La diferencia entre los ambientes es la tarjeta de video. En el ambiente 1 (A1) se utiliz\u00f3 una Nvidia GeForce GTS 450, mientras que en el ambiente 2 (A2) se us\u00f3 una Nvidia GeForce GTX 470. En la tabla 4.2, se pueden observar las especificaciones de algunas caracter\u00edsticas importantes de ambas tarjetas. Nvidia GeForce GTS 450 Nvidia GeForce GTX 470 Reloj del n\u00facleo 783 MHz 607 MHz Reloj de la memoria 1804 MHz 1674 MHz Ancho de banda de la memoria 57.728 GB/sec 133.92 GB/sec Taza de relleno de p\u00edxeles 12528 MPixels/sec 24280 MPixels/sec Taza de relleno de texturas 25056 MTexels/sec 33992 MTexels/sec Tabla 4.2: Especificaciones de las tarjetas de video. 4.2. Voxelizaci\u00f3n La voxelizaci\u00f3n es una de las etapas principales para la obtenci\u00f3n de la iluminaci\u00f3n glo- bal. Aunque este proceso puede ser realizado en tiempos interactivos, hay varios factores a tomar en cuenta para un buen resultado visual en el menor tiempo posible. En esta secci\u00f3n se estudiar\u00e1 primero la importancia del tama\u00f1o del volumen. Luego, se expondr\u00e1 la relaci\u00f3n entre el tama\u00f1o de la textura atlas y el tama\u00f1o del volumen. Finalmente, se comparar\u00e1 el uso de la voxelizaci\u00f3n por medio de texturas atlas y por medio de slicemap. CAP\u00cdTULO 4. PRUEBAS Y RESULTADOS 61 4.2.1. Tama\u00f1o del volumen El tama\u00f1o del volumen afectar\u00e1 a la resoluci\u00f3n de la escena voxelizada. Un mayor tama- \u00f1o implica una mayor resoluci\u00f3n, pero es m\u00e1s costoso de crear la jerarqu\u00eda mipmap y crea mayor cantidad de niveles con los cuales intersectar el rayo. Por ello, hay que mantener un ta- ma\u00f1o del volumen que posea una representaci\u00f3n aceptable de la escena y no afecte en mayor medida la calidad y el tiempo necesario para el c\u00e1lculo de la iluminaci\u00f3n indirecta. Debido a que el volumen es almacenado mediante una textura 2D, hay ciertas restric- ciones en su tama\u00f1o. Para su creaci\u00f3n es necesario utilizar la tarjeta de video, por lo que el alto y el ancho del volumen est\u00e1n limitados por el m\u00e1ximo tama\u00f1o del viewport. En cuanto a la profundidad, esta limitada al uso de una textura con componentes GL_RGBA32UI , la cual permite 32 bits por canal para un total de 128 bits. Por ello, la resoluci\u00f3n del volumen depende es del alto y del ancho. El tiempo de voxelizaci\u00f3n no depende del tama\u00f1o del volumen. El \u00fanico proceso que es afectado por el tama\u00f1o del volumen es la creaci\u00f3n de la jerarqu\u00eda mipmap. En la figura 4.2 se observa un gr\u00e1fico del tiempo en microsegundos que tarda en realizarse la creaci\u00f3n de la jerarqu\u00eda para diferentes resoluciones del volumen. Como puede observarse, a medida que se aumenta la resoluci\u00f3n, el tiempo tiende a aumentar. Al llegar a la resoluci\u00f3n 1024 \u00d7 1024 \u00d7 128 p\u00edxeles el incremento de tiempo es considerable. Para todos los casos, en el A1 se presentan mejores tiempos. Esto se debe a que para crear la jerarqu\u00eda mipmap se realizan cuatro operaciones l\u00f3gicas por cada p\u00edxel en cada uno de los niveles de la jerarqu\u00eda. Estas operaciones son at\u00f3micas y se realizan en menor tiempo en el A1 debido principalmente a que tiene un reloj de n\u00facleo m\u00e1s r\u00e1pido que el A2. Figura 4.2: Tiempo en microsegundos de la creaci\u00f3n de la jerarqu\u00eda mipmap para diferentes resoluciones del volumen. CAP\u00cdTULO 4. PRUEBAS Y RESULTADOS 62 Con estos tiempos podemos observar que es recomendable utilizar una resoluci\u00f3n de los vol\u00famenes entre 128 \u00d7 128 \u00d7 128 p\u00edxeles y 512 \u00d7 512 \u00d7 128 p\u00edxeles. Aunque la resoluci\u00f3n de 64\u00d764\u00d7128 p\u00edxeles tambi\u00e9n presenta buenos tiempos, contiene una representaci\u00f3n de la escena muy discretizada y esto no es conveniente para el c\u00e1lculo de la iluminaci\u00f3n. Sin em- bargo, si se utiliza la voxelizaci\u00f3n por texturas atlas, una alta resoluci\u00f3n del volumen implica la utilizaci\u00f3n de una alta resoluci\u00f3n de la textura atlas, lo cual es costoso computacionalmen- te. Debido a lo anterior expuesto, a partir de ahora se utilizar\u00e1 un volumen de dimensiones 128 \u00d7 128 \u00d7 128 p\u00edxeles en las pruebas, para mantener una representaci\u00f3n de la escena cuadrada y que utilize poco tiempo para la creaci\u00f3n de la jerarqu\u00eda. 4.2.2. Tama\u00f1o de la textura atlas El tama\u00f1o del volumen representar\u00e1 la resoluci\u00f3n de la escena voxelizada. Sin embargo, a mayor cantidad de v\u00f3xeles, se necesita un mayor tama\u00f1o de textura atlas para poder hacer una buena correspondencia entre la geometr\u00eda y el volumen. Debe existir una correspondencia de uno a uno desde el texel de la textura atlas a un v\u00f3xel. En la tabla 4.3 se muestra la cantidad de v\u00e9rtices creados por diferentes resoluciones de textura atlas. La cantidad de v\u00e9rtices var\u00eda poco entre una escena y otra, ya que no depende de la complejidad de la escena sino de la correspondencia con la textura atlas. Sin embargo, el n\u00famero de v\u00e9rtices de una resoluci\u00f3n es aproximadamente cuatro veces mayor a la cantidad de v\u00e9rtices de la resoluci\u00f3n anterior. Resoluci\u00f3n en p\u00edxeles Escena 1282 2562 5122 E1 15.956 63.831 253.917 E2 16.346 65.346 260.847 E3 15.808 64.127 256.573 Tabla 4.3: V\u00e9rtices creados por diferentes resoluciones de texturas atlas. A pesar de la cantidad de v\u00e9rtices creados, es necesario tener una buena resoluci\u00f3n que permita representar la escena de forma correcta. En la figura 4.3 se observa como la E1 (figura 4.3(a)) es voxelizada mediante el uso de diferentes resoluciones de textura atlas. En la figura 4.3(b) se observa que una textura atlas de dimensiones 1282 p\u00edxeles no es suficiente para representar correctamente la escena. Con una resoluci\u00f3n de 5122 p\u00edxeles, en la figura 4.3(d) se observa una buena correspondencia. Colocar una mayor resoluci\u00f3n a la textura atlas solo lograr\u00eda que varios texels correspondan con un mismo v\u00f3xel, desplegando as\u00ed v\u00e9rtices innecesariamente y afectando el desempe\u00f1o de la aplicaci\u00f3n. Una resoluci\u00f3n de 5122 p\u00edxeles para la textura atlas se considera adecuada para la mayor\u00eda de las escenas. Sin embargo, dependiendo del \u00e1rea ocupada por las superficies en la textura atlas, este valor puede cambiar. Superficies que ocupen mucho espacio en la escena y est\u00e9n CAP\u00cdTULO 4. PRUEBAS Y RESULTADOS 63 (a) Escena con textura atlas (b) Resoluci\u00f3n 1282 (c) Resoluci\u00f3n 2562 (d) Resoluci\u00f3n 5122 Figura 4.3: Voxelizaci\u00f3n de una escena con diferentes tama\u00f1os de textura atlas. representadas en espacios muy peque\u00f1os en la textura atlas, necesitan de una textura atlas con una resoluci\u00f3n mayor. En el caso de objetos que ocupen muy poco espacio dentro del volumen, se puede utilizar una resoluci\u00f3n mucho menor, ya que la cantidad de v\u00f3xeles que ocupa es muy peque\u00f1a. No obstante, esto ocasionar\u00e1 que la superficie del objeto se represente de una manera muy discretizada en el volumen. 4.2.3. Comparaci\u00f3n del uso de texturas atlas y slicemap Tanto el uso de las texturas atlas como el slicemap logran la voxelizaci\u00f3n de la escena en tiempo real. Sin embargo, difieren en calidad visual y en tiempo. En la figura 4.4 se observa un gr\u00e1fico con mediciones de tiempo en microsegundos, en las que se compara el uso de las texturas atlas y el slicemap. Todas las pruebas se realizaron con vol\u00famenes de resoluci\u00f3n 1283 p\u00edxeles y texturas atlas de resoluci\u00f3n 5122 p\u00edxeles. En ambos m\u00e9todos, se observa que mientras sea mayor la complejidad de la geometr\u00eda, mayor es el tiempo de voxelizaci\u00f3n. La \u00fanica excepci\u00f3n a esto es las texturas atlas del A2 en la E2, comparado con la texturas atlas del A2 en la E1. Por otro lado, para todas las escenas y todos los ambientes es posible observar que voxelizar por medio de las texturas atlas consume m\u00e1s tiempo que por medio del slicemap. Esto se debe a que el slicemap despliega directamente la geometr\u00eda al volumen, mientras que las texturas atlas necesitan desplegar la geometr\u00eda a las texturas atlas y luego desplegar estas al volumen. Sin embargo, para la mayor\u00eda de las escenas el tiempo adicional que se necesita para voxelizar con esta t\u00e9cnica no es excesivo. En el peor de los casos (E3) la diferencia es de 5 microsegundos, pero esto se debe a que en esta escena hay dos objetos, cada uno con sus respectivas texturas atlas. Para CAP\u00cdTULO 4. PRUEBAS Y RESULTADOS 64 Figura 4.4: Tiempo de voxelizaci\u00f3n de escenas en microsegundos. la mayor\u00eda de las mediciones se observa que el A1 presenta mejores tiempos que el A2. A partir del an\u00e1lisis anterior se puede apreciar que hay poca diferencia en cuanto al tiempo de voxelizaci\u00f3n entre el slicemap y la textura atlas. Sin embargo, en la figura 4.5 se muestra la E2 voxelizada con texturas atlas 4.5(a) y con slicemap 4.5(c). Utilizando slicemap se pierde mucha informaci\u00f3n en la voxelizaci\u00f3n, lo que ocasiona errores al calcular la iluminaci\u00f3n indirecta 4.5(d), a diferencia de la voxelizaci\u00f3n mediante texturas atlas 4.5(b). Por ello, es recomendable utilizar siempre texturas atlas. Todas los an\u00e1lisis sobre los tiempos de voxelizaci\u00f3n se realizaron utilizando solo mode- los en formato OBJ, los cuales representan la parte est\u00e1tica de la escena. En la tabla 4.4 se observa la variaci\u00f3n de tiempo de voxelizaci\u00f3n presente en la E1 al agregar un solo modelo en formato MD2, utilizando texturas atlas. Debido a que este modelo ocupa un espacio pe- que\u00f1o dentro del volumen, se utiliz\u00f3 una textura atlas de resoluci\u00f3n 1282, la cual es suficiente para representar al modelo de forma voxelizada. Por ello, el agregar un objeto din\u00e1mico a la escena, se genera poco retraso en el tiempo de voxelizaci\u00f3n. Como se observa en la tabla, un objeto din\u00e1mico en el A1 genera un aumento de tiempo cerca del 5 %, mientras que agregarlo al A2 solo representa un aumento del 1 %. En ambos casos se observa que el A1 voxeliza m\u00e1s r\u00e1pido que el A2. El uso de la voxelizaci\u00f3n de la escena para hacer el c\u00e1lculo de la iluminaci\u00f3n, no repre- senta un gran costo de tiempo en el desarrollo del algoritmo. Como se observa en el gr\u00e1fico de la figura 4.4, la escena m\u00e1s grande (E3) consume menos de 10 microsegundos para ser voxelizada. Esto representa un tiempo aceptable. Sin embargo, como se mencion\u00f3 en los cap\u00edtulos 2 y 3, se puede utilizar una prevoxelizaci\u00f3n de la escena, en la cual los objetos est\u00e1- ticos son voxelizados una sola vez y posteriormente solo se voxelizan los objetos din\u00e1micos. CAP\u00cdTULO 4. PRUEBAS Y RESULTADOS 65 (a) Voxelizaci\u00f3n textura atlas (b) Iluminaci\u00f3n indirecta (c) Voxelizaci\u00f3n slicemap (d) Iluminaci\u00f3n indirecta Figura 4.5: Voxelizaci\u00f3n de una escena mediante slicemap y texturas atlas, y su correspondiente contribuci\u00f3n al c\u00e1lculo de la iluminaci\u00f3n indirecta. Ambiente Sin MD2 Con MD2 A1 2,58 \u00b5s 2,70 \u00b5s A2 2,67 \u00b5s 2,71 \u00b5s Tabla 4.4: Comparaci\u00f3n de tiempos en microsegundos al agregar un objeto din\u00e1mico a la escena. De esta manera, los tiempos de voxelizaci\u00f3n disminuyen, permitiendo realizar el c\u00e1lculo de la iluminaci\u00f3n inidrecta de manera m\u00e1s r\u00e1pida. 4.3. Iluminaci\u00f3n indirecta El c\u00e1lculo de la iluminaci\u00f3n indirecta es la etapa del algoritmo que consume m\u00e1s tiempo. Esto depende de muchos factores como el n\u00famero de rayos, el n\u00famero de pasos permitidos para encontrar una intersecci\u00f3n, el tama\u00f1o de la ventana, la longitud del rayo, entre otros. La importancia del tama\u00f1o de la ventana se estudiar\u00e1 en la siguiente secci\u00f3n y todas las pruebas en este cap\u00edtulo ser\u00e1n realizada con una ventada de 1024\u00d7 680 p\u00edxeles. CAP\u00cdTULO 4. PRUEBAS Y RESULTADOS 66 En cuanto al n\u00famero de pasos (variable step mencionada en la secci\u00f3n 3.4.8 del cap\u00edtulo 3) para encontrar una intersecci\u00f3n, a trav\u00e9s de pruebas visuales se determin\u00f3 que 16 pasos es un valor que crea una soluci\u00f3n aceptable para las escenas de prueba. Un aumento de este valor conlleva un aumento en el tiempo necesario para calcular la intersecci\u00f3n y tambi\u00e9n es dependiente del n\u00famero de rayos. Como los rayos son lanzados para cada uno de los p\u00edxeles de la imagen, al aumentar la cantidad de rayos se disminuye el desempe\u00f1o de la implementaci\u00f3n. En la figura 4.6 puede observarse como el uso de diferentes cantidades de rayos y del filtro afectan el resultado visual de la iluminaci\u00f3n indirecta. La cantidad de rayos utilizados en esta prueba fueron escogidos emp\u00edricamente. Se puede observar que el uso de 12 (4.6(a), 13 fps), 24 (4.6(c), 7,4 fps) y 128 (4.6(e), 1,5 fps) rayos es insuficiente para crear una soluci\u00f3n de iluminaci\u00f3n indirecta sin ruido. Por ello, se hace el uso del filtro mostrado en la secci\u00f3n 3.4.9 del cap\u00edtulo 3, con el cual se elimina de manera eficiente el ruido en las im\u00e1genes de 12 (4.6(b), 10 fps), 24 (4.6(d), 6,3 fps) y 128 (4.6(f), 1,46 fps) rayos. La cantidad de frames por segundo1 mostrados fueron medidos en el A1. Se puede apreciar que hay poca diferencia visual entre las im\u00e1genes, por lo que utilizar 12 rayos con filtro es suficiente para crear una imagen visualmente aceptable en un tiempo aceptable. Por lo tanto, las pruebas en esta secci\u00f3n se realizar\u00e1n con 12 rayos y con 16 pasos para encontrar la intersecci\u00f3n. Una vez fijado el n\u00famero de rayos y el n\u00famero de pasos para encontrar la intersecci\u00f3n, es importante estudiar como afecta la longitud del rayo en el desempe\u00f1o de la aplicaci\u00f3n. En la figura 4.7 podemos observar dos gr\u00e1ficos, en los que se muestra el tiempo en microsegundos de utilizar diferentes longitudes del rayo en cada una de las escenas de prueba. La longitud del rayo est\u00e1 medida en porcentaje de la longitud del lado m\u00e1s grande de la caja envolvente de la escena. A medida que el porcentaje es m\u00e1s grande, el tiempo para el c\u00e1lculo de la iluminaci\u00f3n indirecta es mayor para todas las escenas y para todos los ambientes. Sin embargo, solo en la E1 hay aumentos considerables del tiempo al aumentar la longitud. Esto se debe a que en la E2 y E3, con una longitud corta del rayo basta para calcular la mayor parte de las intersecciones desde el punto de vista en el cual se realizaron las pruebas, por lo que un aumento de la longitud del rayo permite encontrar pocas intersecciones m\u00e1s. Para todos los casos, los tiempos obtenidos por el A2 (figura 4.7(b)) son notoriamente menores a los tiempos obtenidos por el A1 (figura 4.7(a)), aunque la velocidad del reloj del n\u00facleo y de la memoria sean mayores en el A1. Esto se debe a que el c\u00e1lculo de la iluminaci\u00f3n se realiza en espacio de imagen accediendo a varias texturas, por lo que el A2 con un ancho de banda de la memoria, una taza de relleno de p\u00edxeles y una taza de relleno de texturas m\u00e1s r\u00e1pido, realiza este c\u00e1lculo m\u00e1s r\u00e1pido. Adem\u00e1s, en el A2 la mayor\u00eda de los tiempos obtenidos en la E3 son menores a los tiempos obtenidos en la E2, a pesar de que la E3 es m\u00e1s compleja. Esto se debe a que el c\u00e1lculo de la iluminaci\u00f3n indirecta no es dependiente de la complejidad geom\u00e9trica de la escena, sino de la representaci\u00f3n de la misma en el volumen. En una escena abierta con objetos lejanos unos de otros, el recorrido del rayo consume mayor tiempo que en una escena donde los objetos se encuentran cercanos, como es el caso de la E3. 1Frames por segundo o fps es la medida de frecuencia a la cual un reproductor de im\u00e1genes genera distintos frames. En una aplicaci\u00f3n gr\u00e1fica es ideal producir im\u00e1genes a 60 fps. CAP\u00cdTULO 4. PRUEBAS Y RESULTADOS 67 (a) 12 rayos (b) 12 rayos filtrados (c) 24 rayos (d) 24 rayos filtrados (e) 128 rayos (f) 128 rayos filtrados Figura 4.6: Comparaci\u00f3n del uso del filtro para diferentes cantidades de rayos. A pesar que el filtro elimina de manera considerable el ruido de la iluminaci\u00f3n indirecta, consume una gran cantidad de tiempo. En la tabla 4.5 se puede apreciar el tiempo en micro- segundos necesario para realizar el filtro de una imagen. El tiempo necesario por el A2 es mucho menor al tiempo necesario por el A1. Para ambos ambientes y seg\u00fan los gr\u00e1ficos mos- trados en la figura 4.7, el tiempo del filtrado de la imagen representa entre aproximadamente 40 % (los tiempos m\u00e1s cortos) y 15 % (los tiempos m\u00e1s grandes) del tiempo total del c\u00e1lculo CAP\u00cdTULO 4. PRUEBAS Y RESULTADOS 68 (a) Ambiente 1 (b) Ambiente 2 Figura 4.7: Comparaci\u00f3n del uso de diferentes longitudes del rayo en el c\u00e1lculo de la iluminaci\u00f3n indirecta. CAP\u00cdTULO 4. PRUEBAS Y RESULTADOS 69 de la iluminaci\u00f3n indirecta. A pesar de que el uso del filtro es costoso, su uso ofrece mejores resultados que aumentar el n\u00famero de rayos. Ambiente Tiempo A1 180,72 \u00b5s A2 47,28 \u00b5s Tabla 4.5: Tiempos en microsegundos de la aplicaci\u00f3n del filtro en la iluminaci\u00f3n indirecta. 4.4. Tama\u00f1o de la ventana Dado que la implementaci\u00f3n del algoritmo trabaja mayormente en el espacio de imagen, cambios en el tama\u00f1o de la ventana de despliegue afectan el desempe\u00f1o de la aplicaci\u00f3n. Procesos como el c\u00e1lculo del G-Buffer, la iluminaci\u00f3n directa y en especial la iluminaci\u00f3n indirecta dependen de la cantidad de p\u00edxeles de la imagen. En la figura 4.8, se observa un gr\u00e1fico que indica la cantidad de frames por segundo para diferentes tama\u00f1os del viewport. A medida que el tama\u00f1o de la ventana va aumentando, la cantidad de frames por segundo va disminuyendo gradualmente. Para todos los tama\u00f1os el A2 presenta un mejor rendimiento al mostrado por el A1, incluso la menor cantidad de frames por segundos mostrado en A2 (mayor tama\u00f1o de ventana), es igual a la mayor cantidad de frames por segundo mostrado por A1 (menor tama\u00f1o de la ventana). Figura 4.8: Cantidad de fps para diferentes tama\u00f1os del viewport. Cap\u00edtulo 5 Conclusiones y trabajos futuros En este trabajo se implement\u00f3 un algoritmo de iluminaci\u00f3n global bas\u00e1ndose en las ideas propuestas por Thiedemann et al. [4]. Esta implementaci\u00f3n fue desarrollada para hacer la mayor parte de sus c\u00e1lculos con el uso de la GPU. Adem\u00e1s, para permitir la interactividad y la prueba de la misma, se realiz\u00f3 de manera que los par\u00e1metros puedan ser modificado. A trav\u00e9s de pruebas sobre esta implementaci\u00f3n se logr\u00f3 determinar que la voxelizaci\u00f3n por medio de texturas atlas obtiene una mejor representaci\u00f3n de la escena y es una mejor opci\u00f3n que voxelizar por medio de slicemap, a pesar de que consuma mayor tiempo de pro- cesamiento y espacio en memoria. La elecci\u00f3n de un tama\u00f1o adecuado para el volumen y las texturas atlas es dependiente de la escena y el hardware. Es dependiente de la escena, ya que una escena con mucha geometr\u00eda y detalle puede requerir de una mayor resoluci\u00f3n del volumen y de texturas atlas para ser representada correctamente. Tambi\u00e9n dependen del hardware, ya que un tama\u00f1o considerable puede saturar la memoria de la GPU. Por otro lado, se logr\u00f3 determinar a trav\u00e9s de las pruebas que el n\u00famero de rayos, la longitud de los mismos y el tama\u00f1o de la ventana son factores que influyen de manera significativa en el desempe\u00f1o del algoritmo, as\u00ed como el uso de un filtro es crucial para poder obtener una soluci\u00f3n de ilu- minaci\u00f3n indirecta sin ruidos en tiempo real. Debido a que las pruebas fueron realizadas con diferentes tarjetas de video, se pudo apreciar que una tarjeta de video m\u00e1s novedosa tiene la capacidad de acelerar de manera significativa este algoritmo. Aunque esta t\u00e9cnica de iluminaci\u00f3n global permite el c\u00e1lculo en tiempos interactivos, presenta algunas simplificaciones que pueden restar realismo a la imagen final. Primero, solo toma en cuenta superficies difusas, obviando la contribuci\u00f3n especular. Adem\u00e1s, solo con- sidera un solo rebote de la luz, por lo que simplifica caminos de la luz que pueden a\u00f1adir iluminaci\u00f3n a la escena. Aunque se hace uso del volumen para el c\u00e1lculo de la luz indirec- ta, muchos otros c\u00e1lculos se realizan en espacio de imagen y este algoritmo posee algunos de los defectos que otros algoritmos de espacio de imagen tambi\u00e9n poseen. A pesar de ello, es posible lograr buenos resultados visuales en un tiempo aceptable y se puede integrar con alguna otra herramienta. Como trabajo futuro se plantea el uso de una voxelizaci\u00f3n m\u00e1s novedosa como la pro- puesta por Fei et al. [62] y un filtro para la iluminaci\u00f3n indirecta m\u00e1s novedoso como el propuesto por Chen et al [63]. Tambi\u00e9n, es importante estudiar la influencia en tiempo y ca- 70 CAP\u00cdTULO 5. CONCLUSIONES Y TRABAJOS FUTUROS 71 lidad visual, de la variaci\u00f3n de la cantidad de pasos para buscar una intersecci\u00f3n. Adem\u00e1s, se recomienda comparar el uso de tarjetas de videos m\u00e1s novedosas (actualmente disponibles en el mercado), esperando as\u00ed un aumento de la velocidad de procesamiento de la iluminaci\u00f3n. Bibliograf\u00eda [1] T. Ritschel, C. Dachsbacher, T. Grosch, y J. Kautz, \u201cThe state of the art in interactive global illumination,\u201d Computer Graphics Forum, vol. 31, pp. 160\u2013188, Febrero 2012. [2] P. Dutr\u00e9, K. Bala, P. Bekaert, y P. Shirley, Advance Global Illumination. A K Peters, Ltd., 2006. [3] M. Dabrovic. (2001) Sibenik cathedral. [En l\u00ednea]. Disponible en: http://hdri.cgtechniques.com/ sibenik2/ [4] S. Thiedemann, N. Henrich, T. Grosch, y S. M\u00fcller, \u201cVoxel-based global illumination,\u201d en I3D \u201911 Symposium on Interactive 3D Graphics and Games. ACM, 2011, pp. 103\u2013110. [5] Gouraud, \u201cContinuous shading of curved surfaces,\u201d IEEE Transactions on Computers, vol. 20, pp. 623\u2013629, Junio 1971. [6] B. T. Phong, \u201cIllumination for computer generated pictures,\u201d Communications of the ACM, vol. 18, pp. 311\u2013317, Junio 1975. [7] J. Kajiya, \u201cThe rendering equation,\u201d ACM SIGGRAPH Computer Graphics, vol. 20, pp. 143\u2013150, 1986. [8] T. Whitted, \u201cAn improved illumination model for shaded display,\u201d ACM SIGGRAPH Computer Graphics, vol. 13, pp. 343\u2013349, 1979. [9] R. Cook, T. Porter, y L. Carpenter, \u201cDistributed ray tracing,\u201d ACM SIGGRAPH Compu- ter Graphics, vol. 18, pp. 137\u2013145, Julio 1984. [10] J. Arvo, \u201cBackward ray tracing,\u201d en ACM SIGGRAPH \u201986 Course Notes - Developments in Ray Tracing, 1986, pp. 259\u2013263. [11] E. Veach y L. Guibas, \u201cBidirectional estimators for light transport,\u201d en Fifth Eurograp- hics Workshop on Rendering. Darmstadt, 1994, pp. 147\u2013162. [12] \u2014\u2014, \u201cMetropolis light transport,\u201d en SIGGRAPH \u201997 Proceedings of the 24th annual conference on Computer graphics and interactive techniques. ACM, 1997, pp. 65\u201376. 72 BIBLIOGRAF\u00cdA 73 [13] C. Goral, K. Torrance, D. Greenberg, y B. Battaile, \u201cModeling the interaction of light between diffuse surfaces,\u201d ACM SIGGRAPH Computer Graphics, vol. 18, pp. 213\u2013222, Julio 1984. [14] G. Ward, F. Rubinstein, y R. D. Clear, \u201cA ray tracing solution for diffuse interreflection,\u201d ACM SIGGRAPH Computer Graphics, vol. 22, pp. 85\u201392, Julio 1988. [15] H. W. Jensen y N. J. Christensen, \u201cPhoton maps in bidirectional monte carlo ray tracing of complex objects,\u201d Computers and Graphics, vol. 19, pp. 215\u2013224, 1995. [16] H. W. Jensen, \u201cGlobal illumination using photon maps,\u201d en Proceedings of the euro- graphics workshop on Rendering techniques \u201996. Springer-Verlag, 1996, pp. 21\u201330. [17] \u2014\u2014, \u201cRendering caustics on non-lambertian surfaces,\u201d en GI \u201996 Proceedings of the conference on Graphics interface \u201996. Canadian Information Processing Society, 1996, pp. 116\u2013121. [18] \u2014\u2014, Realistic Image Synthesis Using Photon Mapping. A. K. Peters, Ltd., 2009. [19] A. Keller, \u201cInstant radiosity,\u201d en SIGGRAPH \u201997 Proceedings of the 24th annual confe- rence on Computer graphics and interactive techniques. ACM Press/Addison-Wesley, 1997, pp. 49\u201356. [20] B. Walter, S. Fernandez, A. Arbree, K. Bala, M. Donikian, y D. P. Greenberg, \u201cLight- cuts: A scalable approach to illumination,\u201d ACM Transactions on Graphics (TOG) - Proceedings of ACM SIGGRAPH 2005, vol. 24, pp. 1098\u20131107, Julio 2005. [21] B. Walter, A. Arbree, K. Bala, y D. P. Greenberg, \u201cMultidimensional lightcuts,\u201d ACM Transactions on Graphics (TOG) - Proceedings of ACM SIGGRAPH 2006, vol. 25, pp. 1081\u20131088, Julio 2006. [22] A. Kaplanyan y C. Dachsbacher, \u201cCascaded light propagation volumes for real-time indirect illumination,\u201d en I3D \u201910 Proceedings of the 2010 ACM SIGGRAPH symposium on Interactive 3D Graphics and Games. ACM, 2010, pp. 99\u2013107. [23] R. Wang, R. Wang, K. Zhou, M. Pan, y H. Bao, \u201cAn efficient gpu-based approach for interactive global illumination,\u201d ACM Transactions on Graphics (TOG) - Proceedings of ACM SIGGRAPH 2009, vol. 28, pp. 1\u20138, Agosto 2009. [24] Z. Dong, J. Kautz, C. Theobalt, y H.-P. Seidel, \u201cInteractive global illumination using implicit visibility,\u201d en PG \u201907 Proceedings of the 15th Pacific Conference on Computer Graphics and Applications. IEEE Computer Society, 2007, pp. 77\u201386. [25] Bungie. (2007) Halo 3. [En l\u00ednea]. Disponible en: http://halo.xbox.com/en-us/intel /titles/halo3 [26] BioWare. (2011) Dragon Age II. [En l\u00ednea]. Disponible en: http://dragonage.bioware .com BIBLIOGRAF\u00cdA 74 [27] P.-P. Sloan, J. Kautz, y J. Snyder, \u201cPrecomputed radiance transfer for real-time rende- ring in dynamic, low-frequency lighting environments,\u201d ACM Transactions on Graphics (TOG) - Proceedings of ACM SIGGRAPH 2002, vol. 21, pp. 527\u2013536, 2002. [28] H. Chen y X. Liu, \u201cLighting and material in halo 3,\u201d en SIGGRAPH \u201908 ACM SIG- GRAPH 2008 classes. ACM, 2008, pp. 1\u201322. [29] T. Ritschel, T. Engelhardt, T. Grosch, H.-P. Seidel, J. Kautz, y C. Dachsbacher, \u201cMicro- rendering for scalable, parallel final gathering,\u201d ACM Transactions on Graphics (TOG) - Proceedings of ACM SIGGRAPH Asia 2009, vol. 28, Diciembre 2009. [30] M. McGuire y D. Luebke, \u201cHardware-accelerated global illumination by image space photon mapping,\u201d en HPG \u201909 Proceedings of the Conference on High Performance Graphics 2009. ACM, 2009, pp. 77\u201389. [31] C. Dachsbacher y M. Stamminger, \u201cReflective shadow maps,\u201d en I3D \u201905 Proceedings of the 2005 symposium on Interactive 3D graphics and games. ACM, 2005, pp. 203\u2013 231. [32] M. Mittring, \u201cFinding next gen: Cryengine 2,\u201d en SIGGRAPH \u201907 ACM SIGGRAPH 2007 courses. ACM, 2007, pp. 97\u2013121. [33] T. Ritschel, T. Grosch, y H.-P. Seidel, \u201cApproximating dynamic global illumination in image space,\u201d en I3D \u201909 Proceedings of the 2009 symposium on Interactive 3D grap- hics and games. ACM, 2009, pp. 75\u201382. [34] C. Dachsbacher y M. Stamminger, \u201cSplatting indirect illumination,\u201d en I3D \u201906 Procee- dings of the 2006 symposium on Interactive 3D graphics and games. ACM, 2006, pp. 93\u2013100. [35] G. Nichols y C. Wyman, \u201cMultiresolution splatting for indirect illumination,\u201d en I3D \u201909 Proceedings of the 2009 symposium on Interactive 3D graphics and games. ACM, 2009, pp. 83\u201390. [36] T. Ritschel, T. Grosch, M. H. Kim, H.-P. Seidel, C. Dachsbacher, y J. Kautz, \u201cImper- fect shadow maps for efficient computation of indirect illumination,\u201d ACM Transactions on Graphics (TOG) - Proceedings of ACM SIGGRAPH Asia 2008, vol. 27, Diciembre 2008. [37] G. Nichols, J. Shopf, y C. Wyman, \u201cHierarchical image-space radiosity for interactive global illumination,\u201d Computer Graphics Forum, vol. 28, pp. 1141\u20131149, 2009. [38] A. Kaplanyan, \u201cLight propagation volumes in cryengine 3,\u201d en ACM SIGGRAPH 2009 Courses - Advances in Real-Time Rendering in 3D Graphics and Games Course, 2009. [39] R. Fattal, \u201cParticipating media illumination using light propagation maps,\u201d ACM Tran- sactions on Graphics (TOG), vol. 28, Enero 2009. BIBLIOGRAF\u00cdA 75 [40] R. Geist, K. Rasche, J. Westall, y R. Schalkoff, \u201cLattice-boltzmann lighting,\u201d en Rende- ring Techniques 2004 Proceedings of the Eurographics Symposium on Rendering, 2004, pp. 355\u2013362. [41] P.-P. Sloan, N. Govindaraju, D. Nowrouzezahrai, y J. Snyder, \u201cImage-based proxy ac- cumulation for real-time soft global illumination,\u201d en PG \u201907 Proceedings of the 15th Pacific Conference on Computer Graphics and Applications. IEEE Computer Society, 2007, pp. 97\u2013105. [42] C. Dachsbacher, M. Stamminger, G. Drettakis, y F. Durand, \u201cImplicit visibility and antiradiance for interactive global illumination,\u201d ACM Transactions on Graphics (TOG) - Proceedings of ACM SIGGRAPH 2007, vol. 26, Julio 2007. [43] A. Evans, \u201cFast approximations for global illumination on dynamic scenes,\u201d en SIG- GRAPH \u201906 ACM SIGGRAPH 2006 Courses. ACM, 2006, pp. 153\u2013171. [44] P. Mavridis y G. Papaioannou, \u201cGlobal illumination using imperfect volumes,\u201d en GRAPP \u201911: Proceedings of the international conference on computer graphics theory and applications, 2011. [45] G. Greger, P. Shirley, P. Hubbard, y D. Greenberg, \u201cThe irradiance volume,\u201d IEEE Com- puter Graphics and Applications, vol. 18, pp. 32\u201343, Marzo 1998. [46] C. Crassin, F. Neyret, M. Sainz, S. Green, y E. Eisemann, \u201cInteractive indirect illumi- nation using voxel cone tracing,\u201d en Pacific Graphics 2011, vol. 30. The Eurographics Association and Blackwell Publishing Ltd., 2011. [47] E. Tabellion y A. Lamorlette, \u201cAn approximate global illumination system for com- puter generated films,\u201d ACM Transactions on Graphics (TOG) - Proceedings of ACM SIGGRAPH 2004, vol. 23, pp. 469\u2013476, Agosto 2004. [48] S. Fang y H. Chen, \u201cHardware accelerated voxelization,\u201d Computers and Graphics 24, 2000. [49] K. Crane, I. Llamas, y S. Tariq, \u201cReal-time simulation and rendering of 3d fluids,\u201d GPU Gems 3: Programming Techniques for High-Performance Graphics and General- Purpose Computation, pp. 633\u2013675, 2007. [50] G. Passalis, T. Theoharis, G. Toderici, y I. Kakadiaris, \u201cGeneral voxelization algorithm with scalable gpu implementation,\u201d Journal of Graphics, GPU and Game Tools, vol. 12, pp. 61\u201371, Enero 2007. [51] W. Li, Z. Fan, X. Wei, y A. Kaufman, \u201cFlow simulation with complex boundaries,\u201d GPU Gems 2: Programming Techniques for High-Performance Graphics and General- Purpose Computation, 2005. BIBLIOGRAF\u00cdA 76 [52] Z. Dong, W. Chen, H. Bao, H. Zhang, y Q. Peng, \u201cReal-time voxelization for complex polygonal models,\u201d en PG \u201904 Proceedings of the Computer Graphics and Applications, 12th Pacific Conference. IEEE Computer Society, 2004, pp. 43\u201350. [53] E. Eisemann y X. D\u00e9coret, \u201cFast scene voxelization and applications,\u201d en I3D \u201906 Pro- ceedings of the 2006 symposium on Interactive 3D graphics and games. ACM, 2006, pp. 71\u201378. [54] V. Forest, L. Barthe, y M. Paulin, \u201cReal-time hierarchical binary-scene voxelization,\u201d Journal of Graphics, Gpu, and Game Tools, vol. 14, pp. 21\u201334, 2009. [55] D. Shreiner, OpenGL Programming Guide: The Official Guide to Learning OpenGL, Versions 3.0 and 3.1. Addison-Wesley Professional, 2009. [56] Anttweakbar. [En l\u00ednea]. Disponible en: http://www.antisphere.com/Wiki /tools:anttweakbar [57] Open asset import library. [En l\u00ednea]. Disponible en: http://assimp.sourceforge.net/ [58] M. Bunnell y F. Pellacini, \u201cShadow map antialiasing,\u201d GPU Gems, p. Cap\u00edtulo 11, 2003. [59] T. Ritschel, T. Grosch, y H.-P. Seidel, \u201cApproximating dynamic global illumination in image space,\u201d en I3D \u201909 Proceedings of the 2009 symposium on Interactive 3D grap- hics and games. ACM, 2009, pp. 75\u201382. [60] R. Herzog, E. Eisemann, K. Myszkowski, y H.-P. Seidel, \u201cSpatio-temporal upsampling on the gpu,\u201d en I3D \u201910 Proceedings of the 2010 ACM SIGGRAPH symposium on In- teractive 3D Graphics and Games. ACM, 2010, pp. 91\u201398. [61] Crytek sponza. [En l\u00ednea]. Disponible en: http://www.crytek.com/cryengine/cryengine3 /downloads [62] Y. Fei, B. Wang, y J. Chen, \u201cPoint-tessellated voxelization,\u201d en GI \u201912 Graphics Interace Conference. Canadian Information Processing Society Toronto, Ont., 2012, pp. 9\u201318. [63] Y.-C. Chen, S. I. E. Lei, y C.-F. Chang, \u201cSpatio-temporal filtering of indirect lighting for interactive global illumination,\u201d Computer Graphics Forum, vol. 31, pp. 189\u2013201, Febrero 2012. [64] M. Cohen y D. Greenberg, \u201cThe hemi-cube: a radiosity solution for complex environ- ments,\u201d ACM SIGGRAPH Computer Graphics, vol. 19, pp. 31\u201340, Julio 1985. [65] M. Cohen, S. E. Chen, J. Wallace, y D. Greenberg, \u201cA progressive refinement approach to fast radiosity image generation,\u201d ACM SIGGRAPH Computer Graphics, vol. 22, pp. 75\u201384, Agosto 1988. [66] E. Eisemann y X. D\u00e9coret, \u201cSingle-pass gpu solid voxelization and applications,\u201d In GI \u201908: Proceedings of Graphics Interface 2008, vol. 322, pp. 73\u201380, 2008. BIBLIOGRAF\u00cdA 77 [67] C. Everitt, \u201cInteractive order-independent transparency,\u201d NVIDIA Corporation, Rep. Tec., 2001. [68] E. Lafortune y Y. Willems, \u201cA theoretical framework for physically based rendering,\u201d Computer Graphics Forum, vol. 13, pp. 97\u2013107, Mayo 1994. [69] N. Metropolis, A. W. Rosenbluth, M. N. Rosenbluth, H. Teller, y E. Teller, \u201cEquations of state calculations by fast computing machines,\u201d Journal of Chemical Physics, vol. 21, pp. 1087\u20131092, 1953. [70] B.-T. Phong y F. C. Crow, \u201cImproved rendition of polygonal models of curved surfaces,\u201d en Proceedings of the 2nd USA-Japan Computer Conference, 1975. [71] E. Sparrow, \u201cA new and simpler formulation for radiative angle factors,\u201d Transactions of the ASME, Journal of Heat Transfer, vol. 85, pp. 81\u201388, 1963. [72] E. Sparrow y R. Cess, \u201cRadiation heat transfer,\u201d en Thermal and Fluids Engineering. Hemisphere Publishing Corporation, 1978. [73] M. Zwicker y M. Pauly, \u201cEditorial: Point-based computer graphics,\u201d ACM Computer Graphics, vol. 28, pp. 799\u2013800, Diciembre 2004.", "document_id": 539586}]}]}