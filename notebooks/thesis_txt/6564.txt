Universidad Central de Venezuela Facultad de Ciencias Escuela de Computación Centro de Investigación en Sistemas de Información DESARROLLO DE UNA SOLUCIÓN DE GESTIÓN DE PROCESOS DE NEGOCIO, PARA LA COORDINACIÓN DE TAREAS Y NOTIFICACIONES ENTRE LOS MÓDULOS DEL ARCHIVO WEB DE VENEZUELA. Trabajo Especial de Grado presentado ante la Ilustre Universidad Central de Venezuela por las Br. Alejandra Guadalupe Matos Lagonell. Br. María Andreina Da Silva Cabral. para optar al título de Licenciado en Computación Tutores: Profa. Mercy Ospina. Prof. Franky Uzcátegui Caracas, Octubre del 2017 II Agradecimientos Primero que nada le doy gracias a Dios y a la Virgen de Guadalupe, por estar siempre ayudándome en todo los aspectos de mi vida, por permitirme vivir a plenitud y por bendecirme con cada una de las personas que pone en mi camino, gracias por sus bondades y el infinito amor que me han dado. A mi mamá Yrma y mis hermanas Carolina y Marisela. Gracias por el infinito apoyo a lo largo de esta etapa, por siempre estar ahí en cada paso que he ido dando, por querer lo mejor para mi persona y por mantenernos siempre unidas, son mi más grande inspiración. A mi abuela, por cada una de las bendiciones que me da desde el cielo y por enseñarme que todo lo debemos hacer bien y con mucho amor. A todos mis familiares en general, que siempre me han apoyado, y han sido ejemplo para que desee ser mejor cada día. A mis amigos Clayton, Felymar, Jorge, Leonardo y Luisana por ser esos amigos incondicionales que la vida nos regala, gracias por siempre estar ahí, por todos los increibles momentos que hemos compartidos juntos y por el apoyo que me han dado en los momentos difíciles. A todos los profesores que me apoyaron y confiaron en mi, gracias por su apoyo. A la Universidad Central de Venezuela, por todas las experiencias que recibí de mi amada universidad, gracias por seguir formando al talento de este país, a pesar de las circunstancia. A Andreina, a tí que te conocí como una simple compañera de clases y hoy eres la mejor amiga que jamás hubiera imaginado tener, MIL GRACIAS por todos los momentos que hemos compartido juntas, por reirnos hasta que no podamos más y por tu incondicional apoyo, gracias por tu valiosa y linda amistad. Alejandra Matos. III Agradecimientos IV Primeramente a Dios y San Miguel Arcángel por bendecirme y permitirme llegar hasta donde estoy hoy, porque hicieron realidad este sueño tan anhelado. Gracias por estar siempre conmigo, guiando mis pasos e iluminando mi camino. A mis padres, por ser grandes ejemplos de perseverancia, dedicación y trabajo duro, por hacerme la persona que soy. Gracias a ambos por siempre defenderme, apoyarme, impulsarme y demostrarme que todo se puede. Gracias por estar conmigo en cada paso de mi vida, por lo consejos, su paciencia y todo el amor que me dan. Los amo. A mi tío José Antonio Cabral Pereira y a mi bisabuela Agustina Da Silva, por ser mis ángeles en el cielo, por acompañarme todos los días y brindarme consuelo siempre que lo necesite. A mis hermanos, Antonio y Angel, porque no se que haría sin ustedes. Gracias por siempre apoyarme y darme su cariño incondicional. A mis abuelos, por siempre estar a mi lado, iluminándome con su cariño. Gracias por enseñarme que trabajando duro todo se puede. A mi mejor amiga, por compartir conmigo esta travesía, llena de risas y locura. Gracias Alejandra, por cada uno de los momentos compartidos, por ser una amiga incondicional y apoyarme todos los días. A la ilustre Universidad Central de Venezuela y la Facultad de Ciencias, por todo el conocimiento, principios y valores que me inculcaron. A todos mis familiares y amigos,por brindarme todo su apoyo. María Andreina Da Silva. A Dios, por ser nuestra fortaleza en los momentos de debilidad y por permitirnos cumplir esta meta tan anhelada. A cada uno de los profesores que fueron parte de nuestra formación académica como profesional. A nuestros amigos Clayton, Jorge y Leonardo por su apoyo sincero y por cada uno de los momentos tan valiosos que compartimos juntos a lo largo de la carrera, gracias por su gran amistad. Y a todos los que de una forma u otra ayudaron a la realización de este Trabajo Especial de Grado. Alejandra Matos & María Andreina Da Silva. Este Trabajo esta dedicado a mi mamá y mis hermanas que me han enseñado que todo lo que uno se propone se puede lograr, siempre que se luche por ello. A mi abuelita que siempre me ha acompañado desde el cielo, esto es para ustedes, las amo. Alejandra Matos. Este trabajo esta dedicado mis padres, Teresa y Antonio, por ser mi motor para salir adelante, por enseñarme que con perseverancia puedes alcanzar todas tus metas y sueños. A quien siempre me ha acompañado y guiado, el compañero silencioso que me entendió mejor que nadie, mi tío José Antonio Cabral Pereira, este trabajo también es para ti por sostenerme cuando más lo necesitaba. María Da Silva. A todos los fallecidos en las protestas de este año, a quienes tuvieron pérdidas irreparables, a quienes luchan día a día por reconstruir este hermoso país, para todos los que en algún momento hayan aceptado la decepción finita, recuerden que nunca se debe perder la esperanza infinita, esto es para ustedes. Alejandra Matos & María Da Silva. V Resumen DESARROLLO DE UNA SOLUCIÓN DE GESTIÓN DE PROCESOS DE NEGOCIO, PARA LA COORDINACIÓN DE TAREAS Y NOTIFICACIONES ENTRE LOS MÓDULOS DEL ARCHIVO WEB DE VENEZUELA. Autores: Alejandra Guadalupe Matos Lagonell. María Andreina Da Silva Cabral. Tutores: Profa. Mercy Ospina. Prof. Franky Uzcátegui. Fecha: 06 de Octubre de 2017. El patrimonio cultural ha sido definido por la UNESCO como todo aquello que es rele- vante para la historia de una sociedad, comunidad o pueblo y que forma parte de sus tradiciones y educación, con la evolución tecnológica cada vez hay nuevas formas de re- presentación de este patrimonio, tal como el patrimonio digital definido como aquel que ha sido originado de manera digital y abarca recursos como páginas Web, bases de datos, libros digitales, material multimedia, grabaciones, programas informáticos, entre otros. En particular el patrimonio publicado en la web cambia de manera muy dinámica, por lo que para su preservación, se ha impulsado el desarrollo de sistemas de información conocidos como Archivos Web, cuyo objetivo principal es archivar, de manera histórica, conjuntos seleccionados de páginas, o sitios Web, y sus documentos mediante la repli- cación y/o migración de su formato original a otra representación. Actualmente se está desarrollando un prototipo de Archivo Web en la Escuela de Computación de la Facultad de Ciencias de la Universidad Central de Venezuela, para sitios Web en Venezuela. Está iniciativa de preservación Web capta los contenidos a preservar a través de un rastreador (o crawler) llamado Heritrix, el cual además genera una gran cantidad de metadatos, a partir de los rastreos realizados y que no son accesibles de manera directa; por otra par- te este sistema se ha ido desarrollando en módulos que ejecutan actividades específicas dentro del proceso de preservación, pero cuya comunicación se ha establecido de manera muy básica a través de scripts que ejecuta el sistema, pero que limita la orquestación de sus tareas. El presente Trabajo Especial de Grado tiene como finalidad la implementación de un proceso, que permita la orquestación de los módulos del Prototipo de Archivo Web y I RESUMEN la visualización de las distintas alertas y notificaciones asociadas a los rastreos generados en el subproceso de adquisición de contenidos, haciendo uso de la Gestión de Procesos de Negocios (BPM), bajo una adaptación del método de ciclo de vida BPM propuesto por (Smith & Fingar, 2003), el cual contempla las fases de descubrimiento, modelado, ejecu- ción, despliegue, monitoreo y optimización, para la extracción de los datos se utilizó la librería Pyinotify(Python), para el almacenamiento de dichos datos, se utilizó MySQL y para la orquestación se utilizó la herramienta Bonita BPM. El uso coordinado del enfo- que metodológico para la Gestión de Procesos de Negocio y la plataforma BPM señalada, ofrecen como resultado, una aplicación que orquesta la comunicación entre los módulos del Prototipo de Archivo Web, y las demás actividades del subproceso de adquisición a través de la información obtenida de los rastreos realizados de forma automática y que maneja las notificaciones de alertas y cambios en el momento oportuno. Palabras Claves: Archivo Web,rastreo, Heritrix, Preservación Web, Gestión de Procesos de Negocio, Logs, Alertas, Bonita BPM. II ÍNDICE GENERAL Resumen I Introducción X 1. Problema de Investigación 1 1.1. Planteamiento del Problema . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1 1.2. Objetivos . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5 1.2.1. Objetivo General . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5 1.2.2. Objetivos Específicos . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5 1.3. Alcance . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5 2. Marco Conceptual 6 2.1. Patrimonio Digital . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7 2.2. Preservación Web . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8 2.3. Archivos Web . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10 2.4. Módulo de Adquisición . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12 2.5. Módulo de Almacenamiento . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14 2.5.1. Archivos WARC . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15 2.6. Módulo de Indexación y Búsqueda . . . . . . . . . . . . . . . . . . . . . . . . . 18 2.7. Herramienta de Rastreo . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19 2.7.1. Tipos de Rastreo . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19 2.7.2. Heritrix . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20 2.7.2.1. Arquitectura . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20 2.7.2.2. Principales Características de Heritrix . . . . . . . . . . . . . 23 2.7.2.3. Salidas de Heritrix . . . . . . . . . . . . . . . . . . . . . . . . . 24 2.7.2.4. Registros de Heritrix . . . . . . . . . . . . . . . . . . . . . . . . 28 2.7.2.5. Limitaciones de Heritrix . . . . . . . . . . . . . . . . . . . . . 31 2.8. Sistema de Información . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 31 2.8.1. Actividades que realizan los sistemas de información . . . . . . . . . 32 2.8.2. Tipos de Sistemas de Información . . . . . . . . . . . . . . . . . . . . . 33 2.8.2.1. Sistemas de Soporte a Ejecutivos . . . . . . . . . . . . . . . . 33 2.8.2.2. Sistema de Soporte de Decisiones . . . . . . . . . . . . . . . . 34 2.8.2.3. Sistemas de Información Gerencial . . . . . . . . . . . . . . . 34 III ÍNDICE GENERAL 2.8.2.4. Sistemas de Trabajo de Conocimiento y Sistemas de Au- tomatización de la Oficina . . . . . . . . . . . . . . . . . . . . 34 2.8.2.5. Sistemas de Procesamiento de Transacciones . . . . . . . . . 35 2.9. Base de Datos . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 35 2.9.1. Definición . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 35 2.9.2. Modelos de Base de datos . . . . . . . . . . . . . . . . . . . . . . . . . . 35 2.9.2.1. Base de Datos Relacionales . . . . . . . . . . . . . . . . . . . 36 2.9.3. Sistemas Gestores de Bases de Datos . . . . . . . . . . . . . . . . . . . . 36 2.9.3.1. Objetivos de los SGBD . . . . . . . . . . . . . . . . . . . . . . 36 2.9.3.2. Ventajas de los SGBD . . . . . . . . . . . . . . . . . . . . . . . 37 2.9.3.3. Ventajas de los SGBD . . . . . . . . . . . . . . . . . . . . . . . 38 2.9.4. MySQL . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 38 2.9.4.1. Características de MySQL . . . . . . . . . . . . . . . . . . . . . 39 2.10.Procesos de Negocio . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 40 2.10.1. Componentes de un Proceso de Negocio . . . . . . . . . . . . . . . . . 43 2.10.2. Principales Tipos de Procesos de Negocio . . . . . . . . . . . . . . . . . 43 2.11.Gestión de Procesos de Negocio (BPM, Business Process Management) . . . 44 2.11.1. Sistemas de Gestión de Procesos de Negocio (BPMS, Business Pro- cess Management Systems) . . . . . . . . . . . . . . . . . . . . . . . . . 45 2.11.2. Modelo y Notación de Procesos de Negocios (BPMN, Business Pro- cess Model and Notation) . . . . . . . . . . . . . . . . . . . . . . . . . . 46 2.11.3. Elementos de BPMN . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 47 2.11.4. Lenguaje de Ejecución de Procesos de Negocios (BPLE, Business Process Execution Language) . . . . . . . . . . . . . . . . . . . . . . . . 51 2.11.5. Beneficios de una Herramienta BPMS en una Organización . . . . . . 52 2.11.6. Bonita BPM . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 53 2.11.6.1. Funciones de la Plataforma Bonita BPM . . . . . . . . . . . . 53 2.11.6.2. Versiones . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 54 2.11.6.3. Elementos propios de Bonita BPM . . . . . . . . . . . . . . . 55 2.11.6.4. Módulos de Bonita BPM . . . . . . . . . . . . . . . . . . . . . 57 2.12.Servicios Web . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 59 2.12.1. Características de los Servicios Web . . . . . . . . . . . . . . . . . . . . 59 2.12.2. Ventajas y Desventajas de los Servicios Web . . . . . . . . . . . . . . . 59 2.13.Lenguaje de Programación . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 60 2.13.1. Tipos de Lenguajes de Programaión . . . . . . . . . . . . . . . . . . . . 60 2.13.2. Lenguajes interpretados . . . . . . . . . . . . . . . . . . . . . . . . . . . 61 2.14.Python . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 61 2.14.1. Módulos . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 62 3. Marco Metodológico 63 3.1. Metodologías de Desarrollo . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 63 3.2. Ciclo de Vida BPM . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 64 3.2.1. Descubrimiento . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 64 IV ÍNDICE GENERAL 3.2.2. Modelado . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 65 3.2.3. Despliegue . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 65 3.2.4. Ejecución . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 66 3.2.5. Monitoreo . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 66 3.2.6. Optimización . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 66 4. Marco Aplicativo 67 4.1. Definición de Requerimientos . . . . . . . . . . . . . . . . . . . . . . . . . . . . 67 4.2. Diseño Técnico . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 68 4.3. Herramientas Tecnológicas . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 69 4.3.1. Bonita BPM . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 69 4.3.2. Servicios Web . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 71 4.3.3. Python . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 71 4.3.4. MySQL . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 72 4.4. Etapas del Proyecto . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 72 4.4.1. Descubrimiento . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 72 4.4.2. Modelado . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 76 4.4.2.1. Subproceso: Notificaciones . . . . . . . . . . . . . . . . . . . . 83 4.4.2.2. Subproceso: Archivo Web de Venezuela . . . . . . . . . . . . 87 4.4.3. Despliegue . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 101 4.4.4. Ejecución . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 104 4.4.4.1. Rastreo Ejecutado Genera una Advertencia . . . . . . . . . . 104 4.4.4.2. Rastreo Ejecutado Finaliza con un Error . . . . . . . . . . . . 106 4.4.4.3. Rastreo Ejecutado Finalizado . . . . . . . . . . . . . . . . . . 108 4.4.4.4. Rastreo Ejecutado No Finalizado . . . . . . . . . . . . . . . . 110 4.4.5. Pruebas Funcionales y No Funcionales . . . . . . . . . . . . . . . . . . 113 Conclusiones y Recomendaciones 121 Bibliografía 123 V ÍNDICE DE FIGURAS 1.1. Arquitectura del Prototipo de Archivo Web. . . . . . . . . . . . . . . . . . . . . 4 2.1. Actividades para la Preservación Web. . . . . . . . . . . . . . . . . . . . . . . . 9 2.2. Mapa Conceptual de Preservación de Sitios Web en Archivos Web. . . . . . 11 2.3. Arquitectura del Prototipo de Arhivo Web. . . . . . . . . . . . . . . . . . . . . . 11 2.4. Archivado del lado del Cliente. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13 2.5. Formato Registro WAC. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15 2.6. Archivado con Servidor Web. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17 2.7. Arquitectura de Heritrix. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 21 2.8. Información almacenada en el archivo heritrix-out.log . . . . . . . . . . . . . 24 2.9. Información almacenada en el archivo crawl-report.txt . . . . . . . . . . . . . 25 2.10.Información almacenada en el archivo hosts-report.txt . . . . . . . . . . . . . 25 2.11.Información almacenada en el archivo mimetype-report.txt . . . . . . . . . . 25 2.12.Información almacenada en el archivo responsecode-report.txt . . . . . . . . 26 2.13.Información almacenada en el archivo seeds-report.txt . . . . . . . . . . . . . 26 2.14.Información almacenada en el archivo source-report.txt . . . . . . . . . . . . 26 2.15.Configuración del Reemplazo de DiskSpaceMonitor. . . . . . . . . . . . . . . . 27 2.16.Plantilla predeterminada del prefijo. . . . . . . . . . . . . . . . . . . . . . . . . 28 2.17.Diagrama de Actividades Básicas de los Sistemas de Informacción. . . . . . . 32 2.18.Pirámide de los Diferentes Tipos de Sistemas de Información. . . . . . . . . . 33 2.19.Representación Básica de un Proceso. . . . . . . . . . . . . . . . . . . . . . . . . 40 2.20.Representación Esquemática de un Proceso de Negocio. . . . . . . . . . . . . 42 2.21.Esquema del Motor Bonita. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 57 2.22.Interfaz de Bonita Studio. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 58 3.1. Ciclo de vida BPM. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 64 4.1. Arquitectura del Prototipo de Archivo Web, añadiendo las modificaciones necesarias. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 69 4.2. Pool y Lane, Bonita BPM. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 70 4.3. Eventos Inicio y Fin, Bonita BPM. . . . . . . . . . . . . . . . . . . . . . . . . . . 70 4.4. Compuerta XOR, Bonita BPM. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 70 4.5. Lanzar y , Capturar Enlace, Bonita BPM. . . . . . . . . . . . . . . . . . . . . . . 71 4.6. Actividad de Llamada propia de Bonita BPM. . . . . . . . . . . . . . . . . . . . 71 VI ÍNDICE DE FIGURAS 4.7. Temporizador, Bonita BPM. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 71 4.8. Estructura de la Base de Datos para el control de los logs generados por los rastreos en Heritrix. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 77 4.9. Subproceso Notificaciones . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 83 4.10.Tarea de Servicio: Enviar Correo de Notificación . . . . . . . . . . . . . . . . . 84 4.11.Configuración de Usuario y Contraseña del Correo Electrónico del Remitente 84 4.12.Configuración de los destinatarios de correo electrónico y remitente . . . . . 84 4.13.Asunto y Mensaje del Correo a Enviar . . . . . . . . . . . . . . . . . . . . . . . 85 4.14.Asignación de Asunto del Mensaje . . . . . . . . . . . . . . . . . . . . . . . . . . 86 4.15.Asignación del Cuerpo del Mensaje . . . . . . . . . . . . . . . . . . . . . . . . . 86 4.16.Subproceso Archivo Web de Venezuela . . . . . . . . . . . . . . . . . . . . . . . 87 4.17.Subproceso: Archivo Web de Venezuela, control de nuevos rastreos . . . . . 88 4.18.Tarea de Servicio: Ejecutando nuevos rastreo . . . . . . . . . . . . . . . . . . . 89 4.19.Consulta a la Base de Datos: Comprobar si existen Nuevos Rastreos . . . . . 89 4.20.Tarea de Servicio: Guardar Lanzamiento en la Base de Datos . . . . . . . . . 89 4.21.Update a la Base de Datos: Estado Visitado . . . . . . . . . . . . . . . . . . . . 90 4.22.Tarea de Servicio: Obtener Datos del Lanzamiento del Rastreo . . . . . . . . 90 4.23.Consulta a la Base de Datos: Obtener datos básicos del Lanzamiento . . . . 90 4.24.Subproceso: Archivo Web de Venezuela, iniciado nuevo rastreo . . . . . . . . 91 4.25.Actividad de Llamada: Notificar Lanzamiento de un Nuevo Rastreo. . . . . . 92 4.26.Actividad de Llamada: Datos enviados por lanzamiento de un nuevo rastreo 92 4.27.Tarea de Servicio: Estado actual del Rastreo . . . . . . . . . . . . . . . . . . . . 92 4.28.Consulta a la Base de Datos: Nuevo estado en un rastreo . . . . . . . . . . . . 93 4.29.Tarea de Servicio:Guardar Estado en la Base de Datos . . . . . . . . . . . . . 93 4.30.Update a la Base de Datos: Nuevo estado en un rastreo . . . . . . . . . . . . . 93 4.31.Tarea de Servicio:Obtener Datos del Estado Actual del Rastreo . . . . . . . . 93 4.32.Consulta a la Base de Datos: Datos Básicos del Nuevo estado . . . . . . . . . 94 4.33.Subproceso: Archivo Web de Venezuela, Tipos de estados y acciones a tomar 94 4.34.Actividad de Llamada: Notificar Advertencia. . . . . . . . . . . . . . . . . . . . 95 4.35.Actividad de Llamada: Datos enviados por una advertencia . . . . . . . . . . 95 4.36.Actividad de Llamada: Notificar Error. . . . . . . . . . . . . . . . . . . . . . . . 96 4.37.Actividad de Llamada: Datos enviados por un error . . . . . . . . . . . . . . . 96 4.38.Tarea de Servicio:Obtener Datos de Identificación . . . . . . . . . . . . . . . . 96 4.39.Consulta a la Base de Datos: Datos de Identificación de un rastreo finaliza- do o en ejecución . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 96 4.40.Subproceso: Archivo Web de Venezuela, Rastreos en Ejecución y Códigos de Estado . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 97 4.41.Actividad de Llamada: Notificar Rastreo En Ejecución. . . . . . . . . . . . . . 98 4.42.Actividad de Llamada: Datos enviados por un rastreo en ejecución . . . . . . 98 4.43.Tarea de Servicio:Generando Código de Estado del Rastreo . . . . . . . . . . 98 4.44.Consulta a la Base de Datos: Datos de Identificación del código de estado final . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 99 4.45.Tarea de Servicio:Obtener Información del Estado Final del Rastreo . . . . . 99 VII ÍNDICE DE FIGURAS 4.46.Consulta a la Base de Datos: Datos Básicos de un código de estado . . . . . 99 4.47.Tarea de Servicio:Obtener estado del rastreo . . . . . . . . . . . . . . . . . . . 99 4.48.Consulta a la Base de Datos: Estado de rastreo y fechas del rastreo finalizado100 4.49.Subproceso: Archivo Web de Venezuela, Rastreos Finalizados . . . . . . . . . 100 4.50.Actividad de Llamada: Notificar Finalización Exitosa. . . . . . . . . . . . . . . 100 4.51.Actividad de Llamada: Datos enviados por rastreo finalizado exitosamente . 101 4.52.Actividad de Llamada: Notificar Finalización Fallida. . . . . . . . . . . . . . . 101 4.53.Actividad de Llamada: Datos enviados por un finalizado fallidamente . . . . 101 4.54.Compilar Proceso. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 102 4.55.Selección de Procesos a Compilar . . . . . . . . . . . . . . . . . . . . . . . . . . 102 4.56.Finalizando Compilación . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 103 4.57.Vista Proceso Notificaciones . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 103 4.58.Vista Proceso Archivo Web de Venezuela . . . . . . . . . . . . . . . . . . . . . . 103 4.59.Procesos Habilitados para el usuario de la organización . . . . . . . . . . . . 104 4.60.Heritrix: Job FUNDACREDESA . . . . . . . . . . . . . . . . . . . . . . . . . . . . 105 4.61.Heritrix: Archivo ’job.log’, FUNDACREDESA . . . . . . . . . . . . . . . . . . . . 105 4.62.Notificaciones: Heritrix emitió una Advertencia . . . . . . . . . . . . . . . . . . 106 4.63.Heritrix: Job FUNDACREDESA . . . . . . . . . . . . . . . . . . . . . . . . . . . . 106 4.64.Heritrix: Archivo ’job.log’, FUNDACREDESA . . . . . . . . . . . . . . . . . . . . 107 4.65.Notificaciones: Heritrix informa de un Error . . . . . . . . . . . . . . . . . . . . 107 4.66.Heritrix: Job CIDA . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 108 4.67.Heritrix: Archivo ’job.log’, CIDA . . . . . . . . . . . . . . . . . . . . . . . . . . . 109 4.68.Heritrix: Archivo ’seeds-report.txt’, CIDA . . . . . . . . . . . . . . . . . . . . . . 109 4.69.Notificaciones: Nuevo Rastreo . . . . . . . . . . . . . . . . . . . . . . . . . . . . 109 4.70.Notificaciones: Rastreo en Ejecución . . . . . . . . . . . . . . . . . . . . . . . . 110 4.71.Notificaciones: Rastreo Finalizado . . . . . . . . . . . . . . . . . . . . . . . . . . 110 4.72.Heritrix: Job INZIT . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 111 4.73.Heritrix: Archivo ’job.log’, INZIT . . . . . . . . . . . . . . . . . . . . . . . . . . . 111 4.74.Heritrix: Archivo ’seeds-report.txt’, INZIT . . . . . . . . . . . . . . . . . . . . . 111 4.75.Notificaciones: Nuevo Rastreo . . . . . . . . . . . . . . . . . . . . . . . . . . . . 112 4.76.Notificaciones: Rastreo No Finalizado . . . . . . . . . . . . . . . . . . . . . . . . 112 VIII ÍNDICE DE TABLAS 1.1. Usuarios de un Archivo Web. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2 2.1. Campos que conforman el registro crawl.log. . . . . . . . . . . . . . . . . . . . 28 2.2. Campos que conforman el registro crawl.log. . . . . . . . . . . . . . . . . . . . 30 2.3. Representación Básica de un Proceso. . . . . . . . . . . . . . . . . . . . . . . . . 40 2.4. Elementos Básicos del Modelado . . . . . . . . . . . . . . . . . . . . . . . . . . . 49 2.5. Cuadro Comparativo: BPMS’s Open Source. . . . . . . . . . . . . . . . . . . . 51 2.6. Elementos BPMN Propios de Bonita BPM. . . . . . . . . . . . . . . . . . . . . . 55 4.1. Flujo Diseñado en la Fase de Descubrimiento. . . . . . . . . . . . . . . . . . . . 75 IX Introducción La herencia cultural de una comunidad son sus creencias, su costumbres, doctrinas, son los bienes culturales que la historia le ha legado a una nación las cuales se transmite de generación a generación, a esto se le denomina patrimonio cultural, es la herencia recibida de los antepasados, y que viene a ser el testimonio de su existencia, de su visión de mundo, de sus formas de vida y de su manera de ser, y es también el legado que se deja a las generaciones futuras. Este patrimonio puede ser tanto tangible (objetos arqueológicos, artísticos, religiosos, entre otros) como intangible (costumbres, tradiciones, conocimiento científico, entre otros), y es dentro de éste último, que se encuentra el patrimonio digital, el cual está en formato digital y abarca bases de datos, libros digitales, sitios Web, material multimedia, entre otros. La problemática del patrimonio digital, específicamente del patrimonio Web, es la fa- cilidad con la que puede perderse, sea por modificaciones o eliminación del mismo, ya que no es autopreservable, no obstante, debido a que actualmente la información pública disponible en la Web es mayor que la información difundida en cualquier otro medio de comunicación, se han desarrollado mecanismos para conservar los recursos digitales que están en la web. A las actividades asociadas a este proceso de conservación, se les ha dado el nombre de preservación web y, como su principal objetivo, busca almacenar la infor- mación web relevante para cualquier rama del saber en un lugar alterno, a su localidad actual, de manera segura. La acción de preservar la web implica muchas cosas y entre ellas están, seleccionar un conjunto de contenidos web (páginas web), esto se hace por la razón de que es inviable preservar toda la web, por lo tanto hay que decidir cuáles son los contenidos a preservar, luego de esto hay que realizar la adquisición de dicho contenido de manera periódica, lo que se busca con esto es poder capturar posibles cambios en el contenido de la web, esto se debe a que los contenidos web son de naturaleza dinámica por lo que tienden a cambiar con el tiempo. En las últimas décadas, a nivel mundial, se han ido implementando iniciativas para realizar la actividad de preservación de la web. Para poder realizar esta tarea se crearon los sistemas para la Preservación Web los cuales se denominan Archivos Web, los cua- les permiten preservar este contenido y mantenerlo de manera histórica, en ambientes seguros e independientes a los servidores originales en los cuales están almacenados. El proceso de preservar la Web ha sido llevado a cabo de manera paulatina, por medio del desarrollo de iniciativas de preservación, que surgen, del interés de cada país en preservar X INTRODUCCIÓN su patrimonio digital, siendo cada vez más los países desarrollando iniciativas para dicho fin. Es por esto que un conjunto de iniciativas se han agrupado, formando el “Consorcio Internacional para la Preservación del Internet” (IIPC, por sus siglas en inglés), encargado de definir estándares y buenas prácticas para la creación y administración de los Archivos Web, con el objetivo de crear en un futuro, un repositorio universal. Actualmente en la Universidad Central de Venezuela, se está desarrollando un prototipo de Archivo Web como una iniciativa, que busca preservar los sitios web del país, el cual cuenta con los módulos de adquisición, almacenamiento e indexación y búsqueda, y que se encuentra funcionando en un servidor para poder rastrear y preservar distintos sitios Web. Estos rastreos, son realizados por Heritrix, que es un rastreador Web, open-source, que por defecto almacena los recursos Web que rastrea en un archivo WARC y toda la información concerniente a la ejecución de dichos rastreos es almacenada en distintos archivos logs y de reporte; información que no está siendo aprovechada y que podría ser de gran utilidad, para facilitar la comunicación entre los distintos módulos del Archivo Web y posibilitar el manejo de alertas y/o notificaciones en caso de cambios contundentes o incidencias. Es por lo antes mencionado, que este Trabajo Especial de Grado (TEG) propone estudiar la información almacenada por Heritrix en sus logs y reportes, para desarrollar un solución de Gestión de Procesos de Negocio (BPM), que permita orquestar los módulos del Archivo Web de Venezuela permitiendo la comunicación entre ellos y facilitando la visualización y gestión de distintas notificaciones relevantes para el control de los rastreos. En el capítulo I, se plantea formalmente el problema a abarcar, dando un contexto completo y justificado, además se definen el alcance y los objetivos de este trabajo. En el Capítulo II, se definen todos los conceptos necesarios para poder desarrollar la solución al problema presentado en el capítulo anterior y las técnicas necesarias que ayu- darán a alcanzar los objetivos. En el Capítulo III, se explica la metodología a utilizar para el desarrollo del traba- jo. En el Capítulo IV, se explica formalmente el desarrollo de la aplicación, siguiendo las actividades planteadas en la metodología, y se expone el producto final. Para finalizar, se ofrecen las Conclusiones alcanzadas y algunas propuestas para posibles trabajos futu- ros. XI 1 Problema de Investigación En este capítulo se esboza el problema a resolver, se explica cuál es el planteamiento del problema en el contexto actual, se especifican los objetivos, la justificación y por último el alcance definido para este Trabajo Especial de Grado. 1.1. Planteamiento del Problema En las culturas modernas la información digital es de gran relevancia e interés; ya que representa un formato de contenido relativamente fácil de generar, conservar y usar. Con el uso del Internet la información publicada en formato digital, más específicamente, las páginas Web, puede ser accedida y utilizada ampliamente para diversos propósitos. El inconveniente, es que la información publicada en la Web es efímera, es decir, se elimina o diversifica constantemente. Existen una serie de estudios que documentan la naturale- za efímera de los recursos Web, algunos de estos se centran en la disponibilidad de los recursos y otros miden las tasas de cambio en los contenidos, estos demuestran que la vida media de una página Web (período durante el cual la mitad de las páginas cambia- ran o desaparecerán) está entre 50 y 100 días, y muestran cómo este tipo de cambio está relacionado con el tamaño y la ubicación del contenido. Es gracias a esta caducidad que se ha vuelto necesario preservar contenidos Web, de allí surge la preservación Web, la cual es un conjunto de técnicas, herramientas, estruc- turas y de metodologías que permiten que la información digital en formato Web pueda permanecer y seguir usándose a mediano y largo plazo. 1 CAPÍTULO 1. PROBLEMA DE INVESTIGACIÓN Actualmente está en desarrollo un prototipo de Archivo Web en la Escuela de Compu- tación de la Facultad de Ciencias de la Universidad Central de Venezuela, el cual cuenta con los siguientes módulos: Módulo de adquisición: Módulo encargado de: • Suscripción de sitios Web. • Establecer una frecuencia de adquisición. • Programación periódica de rastreo. Módulo de Indexación y Almacenamiento: Este módulo permite: • Almacenar los contenidos adquiridos de los sitios suscritos, en formato WARC, utilizando un clúster Hadoop, donde se pueden almacenar grandes volúmenes de datos. • Indexar las versiones de dichos sitios de acuerdo a su fecha de adquisición. Módulo de Acceso: Módulo encargado de: • Búsquedas de contenido por URL o palabra clave. • Generación de índices, para la búsqueda de contenido. • Búsquedas por colección. • Seleccionar versión de un sitio Web. • Desplegar versión para su navegación. • Registro de usuarios, manejo de historias de búsqueda y favoritos. Este sistema está dirigido a diferentes usuarios o actores, los cuales son aquellos entes que interactúan con el Archivo Web. A continuación, en la Tabla 1.1 se definen los usuarios para el Prototipo de Archivo Web. Tabla 1.1: Usuarios de un Archivo Web. Nombre Descripción Suscriptor Rol desempeñado por las personas o los sistemas cliente, que proporcionan la información a ser conservada. Toman decisiones para incluir o excluir elementos (semillas –puntos de entrada de los sitios web a preservar–) o grupos de elementos (colecciones –conjuntos de semillas clasificados por tema–) en cada etapa del flujo, desde la adquisición hasta el almacenamiento. Tienen la responsabilidad de cumplir la política de selección. 2 CAPÍTULO 1. PROBLEMA DE INVESTIGACIÓN Usuario Final Rol desempeñado por las personas o los sistemas cliente, que interactúan con los servicios del Archivo para encontrar y adquirir información conservada de interés y estadísticas acerca de las métricas recolectadas Director Rol responsable del manejo de los componentes funcionales, análisis de riesgos y costos, y definición de las políticas del Archivo a un nivel superior, así como de la coordinación entre administradores y suscriptores. Administrador Rol desempeñado por técnicos u operadores de rastreo, que controlan el flujo de trabajo y su operación diaria. Su tarea es desarrollar, construir, mantener y controlar el flujo de trabajo del Archivo. Fuente: Fuente: Un Marco de Referencia para la Implementación de Archivos Web. (Ospina Torres, 2014) En la Figura 1.1 se puede observar la arquitectura del prototipo de Archivos Web de Venezuela. Las tareas de rastreo son llevadas a cabo por Heritrix, rastreador Web, diseñado espe- cíficamente para el rastreo de contenido web a través de Internet. Heritrix, almacena la información concerniente a los distintos rastreos en un conjunto bien definido de archivos logs y de reporte, donde registra cada uno de los estados que puede atravesar un rastreo, incluyendo cualquier advertencia o error que pueda producirse. A pesar, de que toda está información se encuentra disponible en Heritrix,no es accesible, de manera directa, por los usuarios quienes no pueden aprovechar estos metadatos de manera efectiva y así po- der conocer el desempeño del sistema; ya que no existe una herramienta que realice la acción de notificar en que estado se encuentra algún rastreo. Claramente, sin está infor- mación, la detección de errores o fallas puede no llevarse a cabo en el momento indicado, generando problemas de sincronización entre los distintos módulos y algunas incidencias descritas a continuación: Si un rastreo es iniciado, no existe ninguna forma de notificar que dicho rastreo se está llevando a cabo. Si Heritrix detecta la posibilidad de que ocurra una falla o error, la almacena como una advertencia en sus logs, pero no notifica este evento de ninguna otra forma, por lo que podría pasar desapercibida y que no se tomen las medidas pertinentes a tiempo. En caso de que un rastreo falle, no se dispone de ninguna herramienta que se en- cargue de notificar, de manera inmediata, lo que ocurrió; ya que Heritrix se limita 3 CAPÍTULO 1. PROBLEMA DE INVESTIGACIÓN Figura 1.1: Arquitectura del Prototipo de Archivo Web. Fuente: Implementación del módulo de indexación y búsqueda para el prototipo de Archivo Web Venezuela para la búsqueda de los contenidos bajo el formato WARC. (Montero & Pérez, 2016). a registrar el error en archivos logs y terminar el rastreo correspondiente de forma inmediata. Otro inconveniente que se presenta con la falla de un rastreo o con una finalización no exitosa del mismo, es que no es posible volver a iniciar su ejecución de manera automática, sino que debe ser detectado e iniciado manualmente. No obstante, el inconveniente más relevante presente en el prototipo de Archivo Web, es la falta de comunicación efectiva y coherente entre las distintas actividades de lo módulos de adquisición, almacenamiento e indexación y búsqueda. Por todo lo anterior, se necesita encontrar una manera eficiente de automatizar todo el ciclo de vida, reglas y servicios de negocio de los rastreos llevados a cabo por Heritrix para el Prototipo de Archivo Web, para poder solventar las excepciones y orquestar los recursos; ya que todas estas incidencias indican la necesidad de utilizar tecnologías encargadas de orquestar los procesos con los sistemas colaboradores y otros entes externos; con el uso de un lenguaje de programación común y fácil de usar, a través de una herramienta de modelado que permita que los actores involucrados en el negocio describan y documenten fácilmente sus procesos garantizando el buen funcionamiento de todos los módulos. 4 CAPÍTULO 1. PROBLEMA DE INVESTIGACIÓN 1.2. Objetivos 1.2.1. Objetivo General Desarrollar una solución basada en Gestión de Procesos de Negocio (BPM), que permita la visualización y solución de excepciones y la orquestación los Módulos del Archivo Web de Venezuela. 1.2.2. Objetivos Específicos Comprender la información acerca de los estándares, la ejecución y archivos de salida de Heritrix. Establecer las estrategias de adquisición adecuadas para el análisis e interpretación de archivos logs y reportes generados por Heritrix. Diseñar una base de datos de control que sirva para el almacenamiento de la infor- mación generada en tiempo de ejecución por Heritrix. Definir las reglas de negocio asociadas al proceso de notificación de rastreos. Modelar el proceso de rastreo del Archivo Web de Venezuela a través de la herra- mienta Bonita BPM, utilizando el estándar BPMN 2.0. Realizar pruebas funcionales, no funcionales. 1.3. Alcance En este trabajo se busca implementar una solución de Gestión de Procesos de Negocio como parte del Prototipo de Archivo Web de Venezuela, donde se pueden visualizar las distintas notificaciones y alertas que puedan surgir durante los rastreos de sitios web, realizados por Heritrix. Se provee además la orquestación entre los módulos del Archivo Web, permitiendo la comunicación entre ellos, la gestión y/o monitoreo del sistema, automatización y optimi- zación de alertas, buscando así eliminar algunas tareas manuales y evitar la redundancia de actividades. Se especifican los métodos de extracción y almacenamiento de los metadatos obtenidos en sus archivos logs y reportes de Heritrix, así como también se desarrollo un solución de Gestión de Procesos de Negocio, utilizando como núcleo el motor de ejecución de Bonita BPM, que se encarga de gestionar el proceso, las tareas, los usuarios, eventos, entre otros. 5 2 Marco Conceptual A continuación en este capítulo se explicará cada uno de los conceptos básicos para entender el contexto relacionado a este Trabajo Especial de Grado. En primer lugar el pa- trimonio digital, seguido la preservación Web, incluyendo la definición de Archivo Web, los módulos de adquisición, almacenamiento e indexación, búsqueda que conforman el archivo Web y el archivo WARC. Tercero se define la herramienta de rastreo HERITRIX, incluyendo su arquitectura, sus principales características, sus tipos de salidas, los regis- tros y las limitaciones que esta herramienta tiene. En cuarto lugar se tratan los Sistemas de Información, las actividades que estos realizan y los tipos de Sistema de Información que existen. Para el quinto lugar se define la Base de Datos, cuáles son los modelos de Base de Datos, los Sistemas Gestores de Base de Datos (SMBD), los objetivos y ventajas que estos tienen y para finalizar esta sección MySQL y las características de este SMBD. Luego se tratan los Procesos de Negocio, los componentes que lo conforman y los tipos de Proceso de Negocio que hay actualmente. Para la Gestión de Procesos de Negocio (BPM) se explican los sistemas (BPMS) , los modelos y notación (BPMN), el lenguaje (BPLE), los elementos de BPMN y los beneficios de una herramienta BPMS. Para la herramienra Boni- ta BPM se explica cuáles son sus funciones ,las versiones que posee, los elementos propios de esta herramienta y en que consiste cada uno de sus módulos ( Bonita Engine, Bonita Studio y Bonita User Experience). Para la comunicación con los módulos del archivo web es necesario conocer el concepto de Servicios web, ya que mediante estos se realizaran las conexiones, para esta sección se explica en que consisten, cuáles son sus características y las ventajas y desventajas que estos pueden tener. Para finalizar este capítulo se tratan los lenguajes de programación, los tipos de lenguajes, los lenguajes interpretados y Python, ya que este último es un lenguaje interpretado con la explicación en la que se tratan en 6 CAPÍTULO 2. MARCO CONCEPTUAL que consisten tres módulos que son usados en el capítulo IV. 2.1. Patrimonio Digital Actualmente gozamos de una cantidad incalculable de métodos digitales que nos per- miten almacenar todo tipo de información, el problema existente es que las tecnologías avanzan demasiado rápido, lo que conlleva a que la gran parte de estos formatos, so- portes digitales, software y hardware queden obsoletos en poco tiempo, sumando a todo ello la incompatibilidad de los nuevos sistemas con los antiguos. Este hecho aviva una gran necesidad en la sociedad: no perder la información almacenada durante años. El principio de la preservación en los documentos digitales se fundamenta en mantener la información a largo plazo y posibilitar el acceso a ella desde lugares remotos. El patrimonio digital fue reconocido por la Organización de las Naciones Unidas para la Educación, la Ciencia y la Cultura (UNESCO) en su Conferencia General en el año 2003, donde se definió que el Patrimonio Digital consiste en recursos únicos que son fruto del saber o la expresión de los seres humanos. Comprende recursos de carácter cultural, educativo, científico o administrativo e información técnica, jurídica, médica y de otras clases, que se generan directamente en formato digital o se convierten a éste a partir de material analógico ya existente. Los productos “de origen digital” no existen en otro formato que el electrónico. El patrimonio cultural fue clasificado como tangible, siendo éste los objetos arqueo- lógicos, históricos, artísticos, etnográficos, tecnológicos, religiosos y aquellos de origen artesanal o folclórico, que constituyen colecciones importantes para las ciencias, la histo- ria del arte y la conservación de la diversidad cultural del país, como los monumentos, conjuntos de construcciones y sitios con valor histórico, estético arqueológico, científi- co, etnológico y antropológico, o como patrimonio intangible, es decir, las expresiones y prácticas culturales, constituido por la poesía, los ritos, los modos de vida, la medicina tradicional, la religiosidad popular, las tecnologías tradicionales, entre otros elementos, de cada país. La idea de patrimonio se ha extendido a categorías que van más allá de los sectores artísticos, las cuales también tienen un gran valor para la humanidad, una perspectiva moderna del patrimonio es aquella que no solo toma en cuenta las memorias pasadas sino también los testimonios presentes, lo cuales se almacenan cada vez más en for- mato digital. Estos objetos digitales pueden ser textos, bases de datos, imágenes fijas o en movimiento, grabaciones sonoras, material gráfico, programas informáticos o páginas Web. Las tecnologías que se utilizan para crear y aprovechar el patrimonio digital poseen numerosas ventajas que explican que hayan sido adoptadas tan rápidamente en muchas partes del mundo. No obstante, existen graves problemas para mantener utilizable y dis- 7 CAPÍTULO 2. MARCO CONCEPTUAL ponible el emergente patrimonio digital. Los medios que se emplean para guardarlo y almacenarlo son inestables y la tecnología necesaria para tener acceso a él es superada rápida y constantemente por otras nuevas. Cuando las tecnologías caducan, con ellas se pierde también el acceso al patrimonio digital que permitían. Sin embargo, los problemas asociados a la preservación digital no son únicamente de carácter técnico, sino que también tienen dimensiones sociales y de organización, es por ello que surge el interés de la UNESCO, pues su razón de ser, es en parte fomentar y permitir la preservación y el disfrute del patrimonio cultural, científico e informativo de los pueblos del mundo, y difícilmente podía ignorar el crecimiento y la vulnerabilidad del patrimonio digital. Por ello, la UNESCO ha elaborado una estrategia para promover la preservación digital, que se estructura en torno a las siguientes premisas: Un amplio proceso de consultas con los gobiernos, responsables de la formulación de políticas, productores de información, instituciones y expertos encargados del patrimonio, fabricantes de programas informáticos y organismos de normalización. La difusión de directrices técnicas. La ejecución de proyectos piloto. La preparación de un proyecto de carta para la preservación del patrimonio digital, que se someterá a la aprobación de la Conferencia General en su 32ª reunión. Para la UNESCO la preservación digital debe tener las siguientes características: Ser accesible a todo público. Garantizar la protección de información delicada o de carácter privado. Disponer de un marco jurídico y técnico que proteja su autenticidad. La facilidad que brinda Internet para la publicación, ofrece una fuente única de con- tenido cultural, sin embargo, como se mencionó anteriormente, la rápida obsolescencia de este contenido, así como la inestabilidad del Internet ponen en riesgo todo el testi- monio acumulado en formato HTML, de ahí es que surge la preservación Web, la cual se explicará en la sección 2.2. 2.2. Preservación Web Según la UNESCO (2003), gran parte de la enorme cantidad de información que se produce en el mundo es de origen digital y existe una gran variedad de formatos: textos, bases de datos, imágenes, audios, videos, programas informáticos, páginas Web, entre otros. Para las instituciones culturales que tienen a su cargo la recolección y preservación del patrimonio cultural, definir qué elementos deben mantenerse para las generaciones 8 CAPÍTULO 2. MARCO CONCEPTUAL futuras y como debe ser llevada a cabo su selección y conservación, se está volviendo un problema apremiante. Hoy en día la información digital producida, en prácticamente todas las áreas de las actividades humanas, y concebida para ser consultada utilizando computadoras, podría perderse si no se elaboran técnicas y políticas específicas para su conservación. Los métodos tradicionales de preservación no pueden aplicarse tal cual, al material digital, porque las “publicaciones” de la red comúnmente utilizan datos almacenados en varios servidores, ubicados en diferentes partes del mundo. Otro problema que se plantea, es el volumen mismo de los datos, pues se estima que en Internet existen mil millones de páginas, cuya duración de vida media es muy corta. Es, precisamente por estos problemas, que se hace imperiosa la necesidad de preservar la información digital. La preservación Web, como parte de la preservación digital, tiene como objetivo con- servar conjuntos seleccionados de páginas del Internet las cuales deben ser mantenidas completas, es decir, acompañadas de los formatos de archivos, imágenes, gráficas, y as- pecto visual, y ser almacenadas en un ambiente seguro, para luego hacerlas accesibles a los usuarios del Internet. El Instituto Internacional de Projeciologia e Conscienciologia (IIPC), ha definido cuatro (4) actividades para la preservación Web, las cuales se pueden visualizar en la Figura 2.1 a continuación. Figura 2.1: Actividades para la Preservación Web. Fuente: (Ospina, Martinez, Kabchi, & León, 2014). Ospina, Martinez, Kabchi & Leon (2014), describen estas actividades de la siguiente manera: La selección permite limitar el ámbito del archivo, pudiendo preservar contenidos locales o de un tipo en particular, como, por ejemplo, contenidos de un país o edu- cativos solamente. La adquisición logra que se puedan almacenar los cambios generados sobre los con- tenidos que se preservan a través del tiempo. El almacenamiento requiere estrategias que permitan preservar grandes volúme- nes de información (del orden de los Terabytes), millones de archivos y diferentes formatos. Para este fin, se han desarrollado formatos de archivos contenedores es- pecíficos, cuyo objetivo principal es superar la limitación de los sistemas de archivos propios de los sistemas operativos donde se alojan los Archivos Web, en la sección 2.3 se abarca todo el concepto de Archivo Web y como esta estructurado este. 9 CAPÍTULO 2. MARCO CONCEPTUAL El acceso o recuperación de los contenidos está estrechamente ligado a la forma en que se encuentran almacenados, pero debido a la naturaleza hipertextual y multi- media de la Web, se espera que el usuario final pueda acceder a este contenido de manera similar a cuando lo hace en los servidores originales. 2.3. Archivos Web Conociendo la importancia de preservar la Web, muchos países han dedicado esfuer- zos considerables en crear iniciativas para preservar la misma, aunque algunas de estas iniciativas ya se han ido planteando en ampliar un poco más el dominio o alcance, dando a surgir el concepto de Archivo Web. Los Archivos Web son sistemas de información que surgen para archivar, de manera histórica, documentos que están publicados en la web, considerados parte del patrimonio digital de las naciones. Se puede definir un documento web como un documento basado en el lenguaje de marcas HTML (HiperText Markup Lenguage), también llamado página web, y los demás archivos asociados en su composición como imágenes, videos, hojas de estilo, scripts, entre otros, que puede ser localizado a través de un URL y que, normal- mente, forma parte de un sitio Web. (Ospina Torres M. H., 2014) Los Archivos Web tienen como objetivo preservar conjuntos seleccionados de páginas o sitios web, y sus documentos mediante su replicación y/o migración de su formato original a otra representación. Los sitios replicados son mantenidos completos, es decir, acompañados de los archivos, imágenes, gráficas y aspecto visual, y son almacenados en servidores de preservación en un ambiente seguro. (Masanés, 2006). En la Figura 2.2 se muestra como sería la preservación de sitios Web en los Archivos Web. En la Figura 2.3, se puede observar la arquitectura del prototipo para Archivo Web, en donde pueden diferenciarse los siguientes tres módulos: El módulo de adquisición: es el encargado de obtener de manera frecuente una copia de los documentos web que conforman los sitios web seleccionados. La adqui- sición logra que se puedan almacenar los cambios generados sobre los contenidos que se preservan a través del tiempo El módulo de gestión de almacenamiento: este módulo va almacenar de forma histórica las versiones de los sitios web adquiridos y generar un índice para su bús- queda. El módulo de indexación y búsqueda: consiente en recuperar las versiones de los sitios web almacenados mediante la utilización de un índice. Los módulos antes mencionado son tratados en detalle en las secciones 2.4, 2.5 y 2.6 respectivamente. 10 CAPÍTULO 2. MARCO CONCEPTUAL Figura 2.2: Mapa Conceptual de Preservación de Sitios Web en Archivos Web. Fuente: (Ospina, Martinez, Kabchi, & León, 2014). Figura 2.3: Arquitectura del Prototipo de Arhivo Web. Fuente: (Ospina, Martinez, Kabchi, & León, 2014). 11 CAPÍTULO 2. MARCO CONCEPTUAL 2.4. Módulo de Adquisición El término adquisición designa los diferentes medios técnicos utilizados para obtener el contenido a ser preservado, la captura del contenido se puede hacer tanto en línea como fuera de línea (se obtienen los archivos directamente del servidor), muchas veces se necesita más de un enfoque para obtener el contenido, es por ello que existen varios métodos de adquisición. (Sánchez & Milano, 2014) Existen tres tipos de métodos de adquisición, principalmente porque el proceso de re- colección se puede hacer de forma remota como cliente, cerca de la salida del servidor o por acceso directo a los archivos del servidor. La primera opción se hace con archivos rastreadores o copia del sitio Web, que es derivada y adaptada de la tecnología de los motores de búsqueda y proporcionan una herramienta poderosa para la captura desde la posición del cliente. En el prototipo de archivo web desarrollado fue utilizado el archivado del lado del cliente (Garcia & Rivero, 2013), el término “archivado del lado del cliente” es usado para este módulo ya que el rastreador es, para el servidor web, un cliente como cualquier otro. Dependiendo de la arquitectura “backend” del servidor Web y el nivel de interacción con el cliente, los rastreadores pueden capturar la página Web completa, o algunas partes de ella. La parte restante fuera del alcance de los rastreadores ha sido llamada "Web profunda.o "Web oculta.en la terminología de los motores de búsqueda. Este es el principal método de adquisición tanto por su simplicidad, como por su esca- labilidad y adaptación a un entorno cliente-servidor. Los rastreadores se adaptan a lo que es la forma habitual de acceder a la Web. Esto permite el archivado de cualquier sitio que sea accesible libremente ya sea en la web abierta, o en intranets o extranets, siempre y cuando el rastreador obtenga la autorización correspondiente. Este método no sólo adopta la misma posición de usuarios normales de la Web, sino que también imita su forma de interacción con los servidores. Los rastreadores comienzan desde las páginas semillas, las analizan, extraen los enlaces y buscan los documentos enlazados. A continuación, reitera este proceso con los documentos traídos y sigue el procedimien- to siempre que haya vínculos a explorar, entonces encuentran más documentos dentro del alcance definido. Este proceso es necesario, debido a que el protocolo HTTP no pro- porciona un comando que devuelva la lista completa de los documentos disponibles en el servidor, a diferencia, por ejemplo, de FTP. Cada página tiene, por lo tanto, que ser "descu- bierta"por extracción de enlaces desde otras páginas. En la Figura 2.4 se puede distinguir como sería el archivado del lado del cliente. La tecnología de rastreo ha sido desarrollada originalmente para fines de indexación. Su aplicación para el archivado Web, a pesar de la reutilización de gran parte de los aspec- tos originales existen varios cambios. El primero, es que los rastreadores para archivado 12 CAPÍTULO 2. MARCO CONCEPTUAL Figura 2.4: Archivado del lado del Cliente. Fuente: Garcia & Rivero, 2013 tratarán de buscar todos los archivos, independientemente de su formato para archivar una versión completa de los sitios, al contrario de los rastreadores de motores de búsque- da que suelen buscar sólo los archivos que pueden indexar. Por ejemplo, los rastreadores de los motores de búsqueda, a menudo ignoran los grandes archivos de vídeo y aplica- ción. Descargar este tipo de archivos puede hacer una diferencia significativa en términos de tiempo y ancho de banda necesarios para el rastreo de sitios enteros. El segundo aspecto está relacionado con la gestión temporal de los rastreos. Para evitar la sobrecarga de los servidores Web, en los rastreadores se establece un retardo fijo entre dos peticiones, por lo general de varios segundos, o un retardo que depende del tiempo de respuesta del servido. Esto significa que una captura Web puede durar varios minutos en el mejor caso, o varias horas o días algunas veces. Este retraso plantea un problema de la consistencia temporal de la captura del sitio, que puede sufrir cambios durante el tiempo que está siendo capturado. Si la página de índice se modifica durante la captura, por ejemplo, su versión archivada no será compatible con la más reciente que enlazaba las últimas páginas archivadas. Este es un asunto de los rastreadores de archivado porque se supone que el rastreo debe proporcionar el contenido y no solo la dirección al contenido. Los rastreadores de los motores de búsqueda sólo se utilizan para señalar páginas en vivo en la Web lo que significa que el contexto del hipertexto para ellos es el que disponga el servidor original. Por el contrario, los rastreadores de archivado tienen que capturar el contenido en su conjunto, con o sin su coherencia interna, siendo el único contexto para la navegación y la interpretación. 13 CAPÍTULO 2. MARCO CONCEPTUAL Esto tiene consecuencias de largo alcance en lo que respecta a la política de rastreo. Como la cortesía con los servidores siempre ha sido un cuello de botella para el ras- treo, los rastreadores han estado utilizando prioridad de rastreo principalmente en am- plitud (breadth-first), con algunas variantes principalmente destinadas a rastrear las "me- jores"primeras páginas. Pero esta estrategia de planificación de rastreo tiene el inconveniente de aumentar la discrepancia temporal de los rastreadores a nivel de sitio. Así, se ha propuesto adoptar para rastreadores de archivado una prioridad de primer sitio. Pero, para rastreos a gran escala aún es necesario optimizar la eficiencia de rastreo para asegurar que los recursos se utilicen a su máxima capacidad. Dado el retardo entre las solicitudes, y los recursos disponibles para rastrear, se tiene que encontrar el número óptimo de sitios para iniciar y al mismo tiempo asegurar que la frecuencia de solicitud será establecida por las normas de cortesía, sin retardos innecesa- rios entre las solicitudes. Hay límites a lo que puede lograrse con este método. La mayoría de los problemas ocurren durante la extracción de enlace y algunos durante la recuperación a través de la interfaz HTTP. Los primeros pueden ser causados por el hecho de que los URI extraídos están mal formados o usen parámetros complejos, por la dificultad para analizar los URI de secuencias de comandos, código ejecutable o código HTLM. Otros pueden ser causados por redirecciones, negociación de contenidos, autorizaciones, respuestas lentas, tamaño extremo, conexiones TCP anómalas, respuestas no válidas del servidor, entre otros. 2.5. Módulo de Almacenamiento Hacer una copia de un sitio Web es una tarea compleja, que implica volver a crear un sistema de información que será accesible para los usuarios. Además, en un archivo Web no se almacena una, sino varias copias del mismo sitio Web, cada una considerada una versión asociada a una variable temporal. Lo ideal sería que cada versión del sitio Web dentro del archivo fuera isomorfo al ori- ginal en el momento de la captura (misma estructura jerárquica, nombres de archivos, mecanismos de enlaces, formato) pero este casi nunca es el caso. Esta es la razón por la cual los responsables de los Archivos Web han adoptado di- ferentes estrategias de almacenamiento, las cuales pueden afectar el direccionamiento, los mecanismos de enlace y los formatos, así como del objeto mismo de su representa- ción. La estrategia adoptada para el archivo Web desarrollado fue la de archivado con servi- dor Web (Garcia & Rivero, 2015), el cual evita las limitaciones en cuanto al tamaño del 14 CAPÍTULO 2. MARCO CONCEPTUAL Sistema de Archivo, lo que es crucial para la preservación Web a gran escala. El reque- rimiento principal es lograr la escalabilidad horizontal a fin de poder expandir todo el sistema de almacenamiento, agregando en este caso un módulo para poder indexar y re- cuperar los datos almacenados a través de SolrCloud (el contenido es indexado pasándole una palabra clave, el URL la versión y el WARC donde está contenido) y Hadoop (donde se almacenan los archivos WARC de manera distribuida en los Nodos de Datos) permi- tiendo manejar gran volumen de información con un resultado aceptable de respuesta en caso de que se requiera. Para el almacenamiento de estos contenidos se usa el formato de almacenamiento WARC que será descrito en detalle en la siguiente sección. 2.5.1. Archivos WARC De acuerdo a la ISO 28500 (2009), el formato WARC (Web ARChive) es un contenedor de archivos, que permite concatenar múltiples registros de recursos (objetos de datos), cada uno compuesto de un set de cabeceras de texto simple y un bloque de datos arbitrario en un archivo largo. En la Figura 2.5, se muestra el formato de un registro WARC perteneciente a un archivo WARC. Figura 2.5: Formato Registro WAC. Fuente: ISO 28500, 2009. Un archivo de formato WARC es una concatenación de una o más registros WARC. Por 15 CAPÍTULO 2. MARCO CONCEPTUAL lo general la primera colección describe las que le siguen. El contenido de una colección es usualmente el resultado de la adquisición de páginas Web, imágenes, información de redi- reccionamiento URL, resultados de búsqueda de nombres a través del protocolo DNS, ar- chivos únicos o material sintetizado (metadatos, contenido transformado). Una colección WARC consiste de una cabecera seguida de un bloque de contenido. (ISO, 2009) Todos los registros WARC tiene un tipo. Actualmente hay ocho tipos propuestos exis- tentes, que se explican a continuación (ISO, 2009): Warcinfo:una colección de este tipo describe las colecciones que le siguen hasta el final del archivo o hasta la siguiente colección del tipo warcinfo. Típicamente aparece al inicio de cada archivo WARC y usualmente contiene información acerca de la cosecha que generó las siguientes colecciones. Response: una colección del tipo response debería contener una esquematización completa y específica de la respuesta del servidor incluyendo la información del protocolo de red. Resource: una colección calificada como un recurso puede contener, por ejemplo, un archivo adquirido directamente de un repositorio localmente accesible o el re- sultado de una búsqueda en la red donde el protocolo de información ha sido des- cartado. Request:una colección del tipo request debería contener una esquematización com- pleta y específica de la petición al servidor incluyendo la información del protocolo de red. Metadata:es una colección creada para describir, explicar o acompañar a otra co- lección. Esta colección siempre debe referirse a otra sea de contenido original o versionado. Revisit:este tipo describe la acción de volver a visitar el contenido previamente archivado y puede incluir un cuerpo de contenido abreviado que tiene que estar enlazado a alguna colección previa. Esto se utiliza en lugar del tipo response o del tipo request para indicar que el contenido visitado era un documento completo o un duplicado de un material previamente almacenado. Conversion:una colección de conversion contiene una versión alternativa del con- tenido de otra colección que se creó como resultado del proceso de archivado. Cada transformación de una versión alternativa debe ser independiente de su versión original. Continuation:los bloques de colecciones de este tipo deben estar concatenados a su correspondiente colección anterior (de otros archivos WARC) para crear la colección original de tamaño completo. Este es utilizado cuando una colección hace que el WARC exceda el tamaño límite deseado y debe ser separado en segmentos. Un archivo WARC registra una secuencia de documentos web cosechados, cada página 16 CAPÍTULO 2. MARCO CONCEPTUAL está precedida por un encabezado que describe brevemente el contenido de cosecha y su longitud. En la Figura 2.6, se puede observar que con el Archivado con Servidor Web el sitio original se rastrea y las respuestas se almacenan sin cambios en el contenedor WARC. Lo que permite evadir el mapeo del archivo del sistema para la asignación de nombres por convenio y el cambio de la estructura del enlace. El acceso requiere que un Servidor Web obtenga lo que esté almacenado en los contenedores y los envía como una respuesta al usuario final, permitiendo que la navegación por el sitio web se pueda hacer tal cual como fue rastreado. Figura 2.6: Archivado con Servidor Web. Fuente: Ospina M. , 2014 La principal ventaja de la utilización de contenedores WARC es la posibilidad de superar la limitación del sistema de archivos de almacenamiento en términos de tamaño ya que se almacenan menos archivos individuales en el sistema de archivo. La desventaja de este enfoque se basa en que es imposible el acceso directo a los archi- vos almacenados. Son necesarias dos capas extra de aplicación para acceder al contenido: un sistema de índice para archivos WARC y un servidor Web. Estas dos capas no son muy complejas, pero requieren la ejecución de un ambiente de acceso, que puede ser difícil de configurar y mantener en organizaciones pequeñas. Este método es apropiado para la preservación Web a mediana y gran escala, así como para los pequeños archivos que se ocupan de la autenticidad del contenido preserva- 17 CAPÍTULO 2. MARCO CONCEPTUAL do. Como estos métodos almacenan las respuestas del servidor original, como llega del cliente, sin ningún tipo de transformación, en realidad ofrece más fidelidad que los otros métodos. 2.6. Módulo de Indexación y Búsqueda Una vez que el contenido ha sido almacenado, el Archivo Web debe proveer el acceso del mismo a los interesados. El catalogar no es una solución muy práctica para proveer acceso a un Archivo Web. Cabe destacar que la mayoría de los usuarios de la Web suelen encontrar el contenido y obtener el acceso a los sitios Web mediante el uso de herramientas de búsquedas dispo- nibles. (Lamarca Lapuente, 2013) En un reporte realizado por el proyecto MINERVA se concluyó que se debe contar con indexación automática para el descubrimiento de información de sitios Web y los conte- nidos de los mismos. El texto completo de todos los materiales de texto debe ser indexado de forma periódica y buscar por usuarios. Además, no se debería invertir en el proceso de catalogación a menos que se trate de sitios Web de particular importancia para los usuarios o el sistema. Hay que resaltar que el uso de índices disminuye los tiempos de búsqueda y facili- ta el proceso de búsqueda dentro del repositorio. Una indexación basada en un archivo Web será acumulativa y dependerá de la política de recolección que se tenga y se ten- drá una referencia de todos los documentos que se han cosechado y almacenado en el archivo. La indexación en el Archivo Web desarrollado esta implementada en la plataforma de Búsqueda SolrCloud, permitiendo la búsqueda por palabras claves en el contenido y búsquedas por URL(Montero Hernández Pérez Laya, 2016). En este módulo se pueden distinguir dos etapas: Etapa de Indexación: Una vez que todos los archivos Warc’s son obtenidos del clúster Hadoop, se almacenan de forma temporal, para analizar y extraer las palabras claves de los contenidos en los HTML almacenado en los Warc’s, y posteriormente ser indexado en SolrCloud pasándole la palabra clave, el URL, la versión y el WARC donde está contenido. Etapa de Búsqueda: Dado una palabra clave se realiza el proceso de consulta en SorlCloud, donde este retorna un JSON con los resultados donde la palabra clave. 18 CAPÍTULO 2. MARCO CONCEPTUAL 2.7. Herramienta de Rastreo Un rastreador (o crawler) es un software que busca en la Web de forma metódica y cuyo objetivo es recolectar información actualizada y descargarla en algún repositorio de datos. Son importantes, por ejemplo, para minería de datos o aplicaciones que indexan archivos. Un rastreador mantiene una lista inicial de URLs que va a revisar. En esta lista los URLs son priorizados y mantenidos. El rastreador toma uno de los URL de la lista, descarga la página, extrae cualquier otro enlace que esta contenga y coloca los nuevos URLs en la lista. Este proceso se repite hasta que el rastreador decide cuando detenerse. Para esta sección se tomará en cuenta el rastreador Heritrix. En el proceso de preservación Web, se hace uso de herramientas de rastreo para realizar la adquisición, almacenamiento y resguardo de la información. 2.7.1. Tipos de Rastreo Broad crawling: Largos rastreos que consumen gran ancho de banda, el número de páginas y sitios recogidos son tan importantes como el grado de cobertura para cada sitio, esto es que tan completa será la página recogida. Por lo general la co- bertura de cada sitio se limita con el fin de rastrear un mayor número de sitios, en esta negociación se pierden sitios Web completos a favor de conseguir una mayor cobertura de la World Wide Web. Focusedcrawling: Rastreos pequeños y medianos (por lo general menos de 10 mi- llones de documentos únicos), la idea de este tipo de rastreo es hacer una cobertura completa a algunos sitios o tema de interés, esto se puede hacer de una variedad de maneras. Continuouscrawling: Tradicionalmente los rastreadores persiguen una instantánea de los recursos de interés, cada URI se descarga una sola vez, en cambio en el rastreo continuo se vuelven a buscar las paginas rastreadas anteriormente con el propósito de buscar cambios, así como de descubrir nuevas URIs, esto limita severamente la velocidad con la que la frontera puede crecer ya que el rastreador debe dividir su tiempo entre los reprocesamientos de las URis ya cosechadas y las nuevas. Experimental crawling: Esta categoría engloba los rastreos atípicos que pueden ser llevados a cabo para experimentar nuevas técnicas, protocolos, orden en que los recursos son rastreados, entre otros. 19 CAPÍTULO 2. MARCO CONCEPTUAL 2.7.2. Heritrix Heritrix es un rastreador de archivos web a través de Internet. Su licencia es open- source y está escrito completamente en JAVA. Su interfaz de configuración es accesible usando un navegador Web, haciéndolo muy versátil y cómodo de usar, aunque también puede ser lanzando desde línea de comandos. El Internet Archive, primer archivo web conocido, comenzó el desarrollo de Heritrix a principios de 2003, con la intención de desarrollar un rastreador con el propósito específico del archivado de sitios Web, al ser código open-source se fomenta la colaboración y el desarrollo con entes similares que necesiten servicio de rastreo. Se escogió java como lenguaje de implementación, por ser un lenguaje de alto nivel orientado a objetos que ofrece soporte para el diseño modular, para así formar compo- nentes ampliables y/o sustituibles, otros factores de peso que favorecieron la elección de java es el gran conjunto de librerías de código abierto con las que cuenta el lenguaje, así como la gran comunidad de desarrolladores que posee. 2.7.2.1. Arquitectura Heritrix fue diseñado como un Framework de rastreo genérico donde diversos compo- nentes intercambiables pueden ser conectados. Los rastreos son configurables, para ello se eligen y configuran un conjunto de componentes específicos y se ponen en funcionamien- to, la ejecución de un rastreo repite el siguiente proceso recursivamente (este proceso es común en todos los rastreadores Web). 1. Elegir un URI de entre todas las programadas. 2. Buscar el URI. 3. Analizar o archivar los resultados. 4. Seleccionar los URI descubiertos que sean de interés, y sumarlos a los ya programa- dos. 5. Se termina el procesamiento de la URI actual y se repite el proceso. Los 3 componentes principales de Heritrix son: Alcance(Scope): determina si cierta URI esta fuera o dentro de las reglas de rastreo, el alcance incluye las semillas: URI que se usan para iniciar el rastreo, el alcance también interviene en la selección de URis mencionadas en el paso 4 del proceso de rastreo. Frontera(Frontier): Es el responsable de seleccionar el siguiente URI a ser proce- sado, además de llevar un registro de la URI cosechadas y otro de las URI que ya han sido procesadas. 20 CAPÍTULO 2. MARCO CONCEPTUAL Cadena de procesamiento(ProcessorChains): Incluye procesadores modulares que realizan tareas específicas en cada URI, esto incluye; búsqueda del URI, análisis de los resultados devueltos y pase de URIs descubiertas a la frontera. En la Figura 2.7, se aprecia la Arquitectua del rastreador Heritrix. A continuación, se detallarán los aspectos más importantes de esta arquitectura, resal- tando los componentes principales y sus funcionalidades. Empezando con la Web Admi- nistrativeConsole, la cual puede ser puede ser vista como una aplicación independiente (standalone), su funcionalidad es la de permitir elegir los componentes de un rastreo y especificar los parámetros de un Crawlorder, con la ella es posible ver el estado del rastreo actual, logs y generar reportes. Un rastreo es iniciado cuando el CrawlController aprueba la Crawlorder, el CrawlCon- trollercrea una instancia de todos los módulos necesarios para el rastreo, la Web Admi- nistrativeConsolecontrola realiza el rastreo a través del CrawlController. Figura 2.7: Arquitectura de Heritrix. Fuente: Garcia & Rivero. , 2014 El CrawlOrder contiene suficiente información para crear el ámbito de aplicación. Datos tales como: el alcance, la semilla con la cual el Frontier iniciará el rastreo e información de qué hacer con las URI’s que sean descubiertas posteriormente. El Frontier es el responsable de ordenar los URI’s a ser visitados, así como de asegurarse que las URI’s no sean revisadas innecesariamente y moderar las visitas que el rastreador 21 CAPÍTULO 2. MARCO CONCEPTUAL hace a cualquier sitio remoto. Se consiguen estos objetivos mediante el mantenimiento de una serie de colas internas de URI’s para ser visitados y una lista de todos los URI’s que ya han sido visitados o encolados, por defecto el Frontier tiene una implementación de búsqueda en anchura, esto determina las políticas para seleccionar las URI’s a procesar, con una opción de preferiblemente terminar el rastreo de los sitios en progreso antes de iniciar con nuevos sitios. Otras implementaciones de Frontier son posibles. El rastreador Heritrix es multiproceso, por lo que puede llevar muchos rastreos en pa- ralelo. Cada subproceso de trabajo se denomina ToeThread y mientras se mantiene un rastreo activo cada ToeThread recorre los pasos que corresponden al proceso genérico de rastreo descrito anteriormente. El número de ToeThread ejecutándose en un rastreo se puede ajustar para lograr el máximo rendimiento con los recursos locales. El número de ToeThread por lo general oscila en el rango de los cientos. Cada URI es representada por una instancia de CrawlURI, se empaqueta la URI con información adicional recogida durante el proceso de rastreo, los componentes del siste- ma comunican su progreso y la salida a través de CrawlURI, que lleva los resultados de procesamientos anteriores, para ser revisados posteriormente y finalmente el CrawlURI regresa a la frontera para influir en futuros reintentos o programación de rastreos. El ServerCache contiene datos persistentes acerca de los servidores a través de CrawlU- RI. Contiene cualquier número de entidades CrawlServer recogiendo información como direcciones IP, política de exclusión de robots, capacidad de respuesta histórica y estadís- ticas de rastreos del host. La funcionalidad global de un rastreador con respecto a una URI programada es en gran parte especificada por la serie de procesadores configurados para ejecutarse, cada proce- sador a su vez realiza sus tareas marcando el estado del CrawlURI y retornando, las tareas realizadas varían en función del tipo de URI, historia o el contenido recuperado. Los procesadores se agrupan en cinco cadenas: 1. Procesadores en el PrefetchChain reciben el CrawlURI antes de resolver cualquier actividad de red o de ir a buscar la URI, Por lo general cada procesador demora, reordena o veta la tramitación posterior de una CrawlURI, por ejemplo, para ase- gurar que las políticas de exclusión de robots se captan y son consideradas antes de que la URI sea procesada. 2. Procesadores en el FetchChain, la actividad de red intenta adquirir el recurso que se refiere a un CrawlURI, es el caso típico de una transacción HTTP, un procesador de búsqueda llenará la demanda y respuesta en el buffer de la CrawlURI o indicará cualquier condición de error que impida que el buffer sea llenado. 3. Procesadores en el ExtractChain realizan seguimiento al procesamiento de un Craw- lURI que busca las URIs ya finalizadas, extrayendo característica de interés, por lo 22 CAPÍTULO 2. MARCO CONCEPTUAL general estos son nuevos URIs que también pueden ser elegibles para ser visitados, En este paso las URIs solo se descubren, no se evalúan. 4. Procesadores en el WriteChain almacenan el resultado del rastreo para almacena- miento permanente. El rastreador estándar simplemente escribe los datos en el for- mato de archivos de Internet, conocidos como archivos ARC, sin embargo, terceros han creado procesadores que escriben los datos en otros formatos o indexan los resultados del rastreo. 5. Procesadores en el PostProcessChain realiza el mantenimiento final de las acciones de rastreo en el CrawlURI como las pruebas descubiertas. 2.7.2.2. Principales Características de Heritrix La versión 3.0 de Heritrix ofrece las siguientes características: Posibilidad de ejecutar varios trabajos de rastreo simultáneamente. El único límite en el número de trabajos de rastreo que se pueden ejecutar simultáneamente es la memoria asignada a Heritrix. Archivo de configuración XML único basado en el framework Spring. Este archivo reemplaza order.xml y otros archivos de configuración de Heritrix 1.x. Posibilidad de navegar y modificar los "beans"de Spring configurados a través de un navegadores. Extensibilidad mejorada a través del framework Spring. Por ejemplo, las anulacio- nes de dominios se pueden establecer en un nivel de grano muy fino. Consola de control de usuario más segura. HTTPS se utiliza para acceder y mani- pular la consola de control de usuario. Mayor escalabilidad. Anteriormente, los rastreos con valores de semillas grandes (decenas o cientos de millones) podrían intentar utilizar más memoria que la asig- nada a Heritrix. Esto causaría la falla total del rastreador. Mayor flexibilidad al modificar un rastreo en ejecución. La ejecución de rastreos se puede modificar mediante el Explorador o mediante el Directorio de acciones. Introducción de colas paralelas. Al rastrear sitios específicos que pueden manejar grandes cantidades de tráfico, la opción de colas paralelas puede utilizarse para abrir muchas conexiones de rastreo simultáneas a un solo sitio. Una consola de secuencias de comandos que acepta la entrada de secuencias de comandos en varios formatos, como AppleScript y ECMAScript. Las secuencias de comandos se pueden utilizar para acceder y manipular los componentes básicos de Heritrix de forma programática. 23 CAPÍTULO 2. MARCO CONCEPTUAL 2.7.2.3. Salidas de Heritrix Además de los registros, se generan los siguientes archivos: surts.dump: Este archivo contiene la SURTs forma de los URI de semillas. Donde SURT significa Trial-friendly URI Reordering Transform, y es una transformación aplicada a URIs que hace que su representación de izquierda a derecha coincida mejor con la jerarquía natural de nombres de dominio. negativo-surts.dump: Este archivo contiene la forma SURT de URIs que se deben excluir del rastreo. heritrix-out.log: Este archivo captura la salida a estándar y error estándar. La mayor parte de la salida consiste en excepciones de bajo nivel e información de registro. Este archivo se crea en el mismo directorio que el archivo Heritrix jar. No está aso- ciado a ningún trabajo, pero contiene la salida de todos los trabajos ejecutados por el rastreador. A continuación en la Figura 2.8 se muestra la salida de este archivo: Figura 2.8: Información almacenada en el archivo heritrix-out.log Fuente: https://webarchive.jira.com crawl-report.txt: Este archivo contiene métricas útiles sobre trabajos completados. El informe es creado por el StatisticsTrackerbean. Este archivo se escribe al final del rastreo. A continuación en la Figura 2.9 se muestra la salida de este archivo: 24 CAPÍTULO 2. MARCO CONCEPTUAL Figura 2.9: Información almacenada en el archivo crawl-report.txt Fuente: https://webarchive.jira.com hosts-report.txt: Este archivo contiene una descripción general de los hosts que se rastrearon. También muestra el número de documentos rastreados y los bytes descargados por host. Este archivo es creado por el StatisticsTrackerbean y se escribe al final del rastreo. A continuación en la Figura 2.10 se muestra la salida de este archivo: Figura 2.10: Información almacenada en el archivo hosts-report.txt Fuente: https://webarchive.jira.com mimetype-report.txt: Este archivo contiene un informe que muestra el número de documentos descargados por tipo de mime. Además, se muestra la cantidad de datos descargados por tipo de mime. Este archivo es creado por el StatisticsTrackerbean y se escribe al final del rastreo. A continuación en la Figura 2.11 se muestra el resultado de este informe: Figura 2.11: Información almacenada en el archivo mimetype-report.txt Fuente: https://webarchive.jira.com 25 CAPÍTULO 2. MARCO CONCEPTUAL procesadores-report.txt: Este archivo contiene el informe de procesadores. El in- forme de los procesadores muestra la actividad de cada procesador Heritrix. Para obtener más información sobre los procesadores, consulte Transformación de cade- nas . Se escribe al final del rastreo. responsecode-report.txt: ste archivo contiene un informe que muestra el número de documentos descargados por código de estado. Sólo cubre códigos exitosos. Para ver los códigos de error, consulte el crawl.logarchivo. Este archivo es creado por el StatisticsTrackerbean y se escribe al final del rastreo. A continuación en la Figura 2.12 se muestra el resultado de este informe: Figura 2.12: Información almacenada en el archivo responsecode-report.txt Fuente: https://webarchive.jira.com seeds-report.txt: Este archivo contiene el estado de rastreo de cada semilla. Este archivo es creado por el StatisticsTrackerbean y se escribe al final del rastreo. A continuación en la Figura 2.13 se muestra el resultado de este informe: Figura 2.13: Información almacenada en el archivo seeds-report.txt Fuente: https://webarchive.jira.com frontier-summary-report.txt Este informe contiene un desglose de la actividad de la frontera en una base por hilo. Para cada subproceso en ejecución, se puede exa- minar el estado de la cola de frontera. source-report.txt: Este informe contiene una línea de pedido para cada host, que incluye la semilla desde la que se alcanzó el host. A continuación en la Figura 2.14 se muestra una muestra de este informe: Figura 2.14: Información almacenada en el archivo source-report.txt Fuente: https://webarchive.jira.com 26 CAPÍTULO 2. MARCO CONCEPTUAL La sourceTagSeedspropiedad del TextSeedModulebean debe establecerse en true para que se genere este informe. threads-report.txt: Este informe contiene la lista de subprocesos que estaban acti- vos al final del rastreo. También hay información detallada sobre cada hilo. Archivos WARC:Suponiendo que esté utilizando el escritor WARC que viene con Heritrix, se generará una serie de archivos WARC que contienen contenido ras- treado. Puede especificar la ubicación de almacenamiento de los archivos WARC estableciendo el directoryvalor del WARCWriterProcessorbean. Los archivos WARC se nombran utilizando la siguiente convención: [prefijo] [marca de hora de 12 dígitos] [serie rellenada a 5 dígitos] [nombre de host del rastreador] .warc.gz El WARCWriterProcessorcontiene el prefixajuste. Por defecto es IAH. Los archivos WARC con un .opensufijo están en proceso de ser escritos por Heritrix. Puede haber múltiples WARCs abiertas en un momento dado. Los archivos WARC con un .invalidsufijo indican problemas al escribir en el archi- vo. Esto puede ser el resultado de un disco defectuoso o un disco completamente utilizado. En un problema de E / S, Heritrix cierra el archivo WARC problemático y le da un .invalidsufijo. Estos archivos deben ser comprobados para la coherencia. A partir de Heritrix 3.1, el bean "LowDiskPauseProcessor"ha sido reemplazado por el "DiskSpaceMonitor"bean. Al escribir archivos WARC, DiskSpaceMonitor comprue- ba el espacio disponible en las rutas configuradas y si el espacio libre ha caído por debajo del umbral definido, el rastreo se pausará. En el ejemplo siguiente, /warcsse controla la ruta . Si el nivel de espacio libre cae por debajo de 500 MB, los ras- treos que escriben en el /warcsdirectorio se pausan. En la Figura 2.15 se muestra la configuración del reemplazo por "DiskSpaceMonitor"bean. Figura 2.15: Configuración del Reemplazo de DiskSpaceMonitor. Fuente: https://webarchive.jira.com A partir de Heritrix 3.1, la convención de nomenclatura para los archivos WARC ha cambiado. En lugar de especificar la fórmula para la denominación ARC / WARC en código y usar un ’prefijo’y ’sufijo’, se puede usar una plantilla con interpolación variable. El ’prefijo’configurado sigue siendo una variable disponible, así como otras propiedades útiles de máquina local, rastreo y escritura. La plantilla predeterminada es la que se muestra en la Figura 2.16 : 27 CAPÍTULO 2. MARCO CONCEPTUAL Figura 2.16: Plantilla predeterminada del prefijo. Fuente: https://webarchive.jira.com 2.7.2.4. Registros de Heritrix Cada trabajo de rastreo tiene su propio conjunto de archivos de registro. Los registros se encuentran en el directorio "logs", que existe bajo el directorio de un trabajo específico. Las propiedades de registro pueden establecerse modificando el archivo logging.properties que se encuentra en el directorio ./conf. Los tipos de registro son: alerts.log: Este registro contiene alertas que indican problemas con un rastreo. crawl.log: Cada URI que Heritrix intente obtener provocará que se escriba una línea de registro en el crawl.logarchivo. En la Tabla 2.1 se puede apreciar cuáles son los campos que conforman este registro y una breve explicación de cada uno de ellos. Tabla 2.1: Campos que conforman el registro crawl.log. Nombre del campo Descripción Timestamp La marca de tiempo en formato ISO8601, en milisegundos de resolución. El tiempo es el instante de registro. Fetch Status Code Normalmente este es el código de respuesta HTTP, pero también puede ser un número negativo si el procesamiento de URI se finalizó inesperadamente. Document Size El tamaño del documento descargado en bytes. Para HTTP, este es el tamaño del contenido solamente. El tamaño excluye los encabezados de respuesta HTTP. Para DNS, el campo de tamaño es el tamaño total de la respuesta DNS. Downloaded URI Se ha descargado el URI del documento. 28 CAPÍTULO 2. MARCO CONCEPTUAL Discovery Path Los códigos de ruta de acceso (ruta de descubrimiento) que muestran el rastro de descargas que conducen al URI descargado. A partir de Heritrix 3.1, la longitud de la ruta de descubrimiento se ha limitado a los últimos 50 tipos de salto. Esta mejora disminuye el tamaño del registro y limita el uso de memoria. Los códigos de breadcrumb son los siguientes: • R: Redireccionar • E: Empotrar • X: Incorporación especulativa (agresiva / extracción de vínculo JavaScript) • L: Enlazar • P: Prerrequisito (como para DNS o robots.txt antes de otro URI) Referrer El URI que precede inmediatamente al URI descargado. Este es el referente. Tanto el camino de descubrimiento como el referente estarán vacíos para los URI de semillas. Mime Type El tipo de mime del documento descargado. Worker Thread ID El identificador del hilo de trabajo que descargó el documento. Fetch Timestamp La marca de tiempo en el formato de sólo dígitos condensadosen el RFC2550 / ARC que indica cuándo se inició la búsqueda de red. Si es apropiado, la duración de milisegundos de la búsqueda se añade a la marca de tiempo con un carácter -çomo separador. SHA1 Digest El SHA1 digiere sólo el contenido (los encabezados no se digieren). Source Tag La etiqueta de origen heredada por el URI, si está habilitado el etiquetado de origen. Annotations Si se ha establecido una anotación, se mostrará. Las anotaciones posibles incluyen: el número de veces que se intentó el URI, el literal "lenTrunc"si la descarga fue truncanted debido a los límites de tamaño configurados excedentes, el "timeTrunc"literal si la descarga se truncó debido a los límites de tiempo configurados o midFetchTrunc si un filtro midfetch determina que la descarga debe estar truncada. warc El nombre del archivo WARC / ARC al que está escrito el contenido rastreado. Este valor sólo se escribirá si la propiedad logExtraInfo del bean loggerModule se establece en true. Esta información registrada se escribirá en formato JSON . Fuente: Elaboración Propia. progress-statistics.log: Este registro está escrito por el bean StatisticsTracker. A intervalos configurables, una línea de registro que detalla el progreso del rastreo se escribe en este archivo. En la Tabla 2.2 se describen los campos que conforman a este registro. 29 CAPÍTULO 2. MARCO CONCEPTUAL Tabla 2.2: Campos que conforman el registro crawl.log. Nombre del campo Descripción timestamp Timestamp en formato ISO8601 que indica cuándo se escribió la línea de registro. discovered Normalmente este es el código de respuesta HTTP, pero también puede Número de URIs descubiertos hasta la fecha. queued Número de URIs actualmente en cola. downloaded Número de URI descargados hasta la fecha. doc/s(avg) Número de documentos descargados por segundo desde la última instantánea. El valor entre paréntesis se mide desde el inicio del arrastre. KB/s(avg) Cantidad en kilobytes descargados por segundo desde la última instantánea. El valor entre paréntesis se mide desde el inicio del arrastre. dl-failures Número de URI que Heritrix no ha podido descargar. busy-thread Número de hilos de punta ocupados procesando un URI. mem-use-KB Cantidad de memoria utilizada por Java Virtual Machine. heap-size-KB El tamaño de montón actual de la máquina virtual de Java. congestion La relación de congestión es una estimación aproximada de cuánta capacidad inicial, como un múltiplo de la capacidad actual, sería necesaria para rastrear la carga de trabajo actual a la tasa máxima disponible dada la configuración de cortesía. Este valor se calcula comparando el número de colas internas que están progresando con las que están esperando que un hilo esté disponible. max-depth El tamaño de la cola Frontier con el mayor número de URIs en cola. avg-depth El tamaño promedio de todas las colas Frontier. Fuente: Elaboración Propia. runtime-errors.log: Este registro captura excepciones inesperadas y errores que se producen durante el rastreo. Algunos pueden deberse a limitaciones de hardware (fuera de la memoria, aunque ese error puede ocurrir sin ser escrito en este registro), pero la mayoría se debe probablemente a errores de software, ya sea en el núcleo de Heritrix, pero más probablemente en una de sus clases conectables. uri-errors.log: Este registro almacena los errores que resultaron de intentos de búsqueda de URI. Normalmente la causa es URIs inexistente. Normalmente, es- te registro sólo es de interés para los usuarios avanzados que intentan explicar el comportamiento de rastreo inesperado. frontier.recover.gz: El frontier.recover.gzarchivo es un diario comprimido de even- tos Frontier. Se puede utilizar para restaurar la frontera después de un accidente. 30 CAPÍTULO 2. MARCO CONCEPTUAL 2.7.2.5. Limitaciones de Heritrix Las principales limitaciones actuales para tener en cuenta son: Toda la edición de configuración de pre-lanzamiento se realiza a través de los ar- chivos en el disco o el editor de archivos sin formato de textarea de la interfaz de usuario de la web. Los cambios de configuración o la reconfiguración realizada durante un rastreo in- corporado o en ejecución se realizan directamente en el estado del objeto del rastreo activo y no se reflejan automáticamente en la configuración para lanzamientos fu- turos. Cuando se relanza un trabajo, los registros anteriores se renombran a un lado, con nuevos nombres basados en el tiempo de lanzamiento nuevo. Cuando se generan informes de tareas (en la solicitud de vista o al final del rastreo), se sobreescriben los informes anteriores. 2.8. Sistema de Información Para comprender que es un sistema de información, es necesario definir primero algu- nos conceptos. Se define sistema como un conjunto de partes coordinadas y en interacción para alcanzar un conjunto de objetivos (Johansen, 2004). La clave está en las relaciones entre las diversas partes del mismo; puede existir un conjunto de objetos, pero si estos no se encuentran relacionados entre sí, no constituyen un sistema. Por otra parte, información se define como un conjunto de datos procesados, que tie- nen un significado (relevancia, propósito y contexto), y que por lo tanto son de utilidad para quien debe tomar decisiones, al disminuir su incertidumbre (Davenport y Prusak, 1998). Por lo tanto, la información son datos acerca de algún evento, que organizados y procesados en un contexto obtienen un significado, cuyo propósito es incrementar el conocimiento acerca algo. Luego de haber definido los términos anteriores, se pueden definir técnicamente los sistemas de información como un conjunto de componentes interrelacionados que re- colectan (o recuperan), procesan, almacenan y distribuyen información para apoyar los procesos de toma de decisiones y de control en una organización. Los sistemas de información contienen información sobre personas, lugares y cosas importantes dentro de la organización, o en el entorno que la rodea. 31 CAPÍTULO 2. MARCO CONCEPTUAL 2.8.1. Actividades que realizan los sistemas de información En la Figura 2.17 se puede observar el diagrama de actividades básicas de los Sistemas de información. Figura 2.17: Diagrama de Actividades Básicas de los Sistemas de Informacción. Fuente: http://aulavirtual.tecnologicocomfenalcovirtual.edu.co/aulavirtual/mod/book/ Peralta (2008) señala que los sistemas de información realizan cuatro (4) actividades básicas, las cuales permiten a las organizaciones analizar problemas, controlar operacio- nes y apoyar a la toma de decisiones, estas son: Entrada de información: los sistemas de información toman los datos que necesi- tan para procesar la información. Estos datos pueden ser obtenidos de forma manual o automática. Las entradas manuales son proporcionadas de forma directa por los usuarios que utilizan los sistemas, mientras que las automáticas provienen o son recolectados de otros sistemas. Almacenamiento de la información: es una de las capacidades más importantes que tiene un computador y es aprovechada por los sistemas ya que permite recupe- rar información guardada en procesos anteriores. Procesamiento de información: es la capacidad que tienen los sistemas para rea- lizar cálculos siguiendo una serie de operaciones previamente establecidas. Estos cálculos se realizan con los datos introducidos en los sistemas, datos almacenados o bien la combinación de ambos. Esta actividad de los sistemas es la que transfor- ma los datos en información, la cual es utilizada por las organizaciones como apoyo fundamental en el proceso de toma de decisiones, realizando proyecciones a partir de los datos obtenidos. Salida de información: se refiere a la capacidad de los sistemas para mostrar la información obtenida al mundo exterior. La salida de los sistemas puede servir de 32 CAPÍTULO 2. MARCO CONCEPTUAL entrada a otros sistemas o a ellos mismos, lo que se conoce como retroalimentación. 2.8.2. Tipos de Sistemas de Información Según Kendall y Kendall (2011), los sistemas de información se desarrollan para dis- tintos fines, dependiendo de las necesidades de los usuarios humanos y la empresa. En la Figura 2.18 se muestran la variedad de sistemas de información que pueden desarrollar los analistas, indicando que el nivel operacional de la organización (el más bajo) cuenta con apoye(soporte) de los sistemas de procesamiento de transacciones(TPS), mientras que el nivel estratégico de decisiones semiestructuradas y no estructuradas (el más alto) cuenta con soporte de los sistemas de soporte a Ejecutivos (ESS). Figura 2.18: Pirámide de los Diferentes Tipos de Sistemas de Información. Fuente: http://pertutatis.cat/la-piramide-de-los-diferentes-tipos-de-sistemas-de-informacion/ 2.8.2.1. Sistemas de Soporte a Ejecutivos Cuando los ejecutivos recurren a la computadora, por lo general lo hacen en busca de métodos que los auxilien en la toma de decisiones de nivel estratégico. Los sistemas de apoyo a ejecutivos (ESS, Executive Support Systems) ayudan a estos últimos a organizar sus actividades relacionadas con el entorno externo mediante herramientas gráficas y de comunicaciones, que por lo general se encuentran en salas de juntas o en oficinas cor- porativas personales. A pesar de que los ESS dependen de la información producida por los TPS y los MIS, ayudan a los usuarios a resolver problemas de toma de decisiones no 33 CAPÍTULO 2. MARCO CONCEPTUAL estructuradas, que no tienen una aplicación específica, mediante la creación de un en- torno que contribuye a pensar en problemas estratégicos de una manera bien informada. Los ESS amplían y apoyan las capacidades de los ejecutivos al darles la posibilidad de comprender sus entornos. 2.8.2.2. Sistema de Soporte de Decisiones Los sistemas de soporte de decisiones (DSS, Decisión Support Systems) constituyen una clase de alto nivel de sistemas de información computarizada. Los DSS coinciden con los sistemas de información gerencial en que ambos dependen de una Base de Datos para abastecerse de datos. Sin embargo, difieren en que el DSS pone énfasis en el apoyo a la toma de decisiones en todas sus fases, aunque la decisión definitiva es responsabilidad exclusiva del encargado de tomarla. Los sistemas de apoyo a la toma de decisiones se ajustan más al gusto de la persona o grupo que los utiliza que a los sistemas de informa- ción gerencial tradicionales. En ocasiones se hace referencia a ellos como sistemas que se enfocan en la inteligencia de negocios. 2.8.2.3. Sistemas de Información Gerencial Los sistemas de información gerencial (MIS, Management Information Systems) no reemplazan a los sistemas de procesamiento de transacciones, más bien, incluyen el pro- cesamiento de transacciones. Los MIS son sistemas de información computarizados cuyo propósito es contribuir a la correcta interacción entre los usuarios y las computadoras. Debido a que requieren que los usuarios, el software (los programas de cómputo) y el hardware (las computadoras, impresoras, etc.), funcionen de manera coordinada, los sis- temas de información gerencial dan apoyo a un espectro de tareas organizacionales mu- cho más amplio que los sistemas de procesamiento de transacciones, como el análisis y la toma de decisiones. Los sistemas de información gerencial producen información que se emplea en la toma de decisiones. 2.8.2.4. Sistemas de Trabajo de Conocimiento y Sistemas de Automatización de la Oficina Existen dos clases de sistemas en el nivel del conocimiento de una organización. Los sistemas de automatización de la oficina (OAS, Office Automation Systems) apoyan a los trabajadores de datos, quienes por lo general no generan conocimientos nuevos, sino más bien analizan la información con el propósito de transformar los datos o manipularlos de alguna manera antes de compartirlos o, en su caso, distribuirlos formalmente con el resto de la organización y en ocasiones más allá de ésta. Entre los componentes más comunes 34 CAPÍTULO 2. MARCO CONCEPTUAL de un OAS están el procesamiento de texto, las hojas de cálculo, la autoedición, la calen- darización electrónica y las comunicaciones mediante correo de voz, correo electrónico y videoconferencia. Los sistemas de trabajo del conocimiento (KWS, Knowledge Work Sys- tems) sirven de apoyo a los trabajadores profesionales, como los científicos, ingenieros y médicos, en sus esfuerzos de creación de nuevo conocimiento y dan a éstos la posibilidad de compartirlo con sus organizaciones o con la sociedad. 2.8.2.5. Sistemas de Procesamiento de Transacciones Los sistemas de procesamiento de transacciones (TPS, Transaction Processing Systems) son sistemas de información computarizada creados para procesar grandes cantidades de datos relacionadas con transacciones rutinarias de negocios, como las nóminas y los inventarios. Un TPS elimina el fastidio que representa la realización de transacciones operativas necesarias y reduce el tiempo que una vez fue requerido para llevarlas a cabo de manera manual, aunque los usuarios aún tienen que capturar datos en los sistemas computarizados. Los sistemas de procesamiento de transacciones expanden los límites de la organización dado que le permiten interactuar con entornos externos. 2.9. Base de Datos 2.9.1. Definición Di Vasta & Díaz (2001) definen una Base de Datos (BD) como un repositorio centra- lizado de datos lógicamente relacionados, que permite almacenar y organizar hechos o eventos y restituirlos a demanda de él, o los usuarios para producir información. Esto quiere decir que una Base de Datos se puede ver como una colección (finita) de datos que están organizados y estructurados siguiendo un modelo de información el cual refleja los datos y las relaciones entre ellos. 2.9.2. Modelos de Base de datos Son una colección de herramientas conceptuales para describir los datos, sus relacio- nes, su semántica y las restricciones de consistencia. Los modelos de datos ofrecen un modo de describir el diseño de las bases de datos en los niveles físico, lógico y de visitas. (Silberschatz, A y Korth, H y Sudarshan, S. 2006) Entre algunos de estos modelos de BD se encuentra las Bases de Datos Relacionales, descritas a continuación. 35 CAPÍTULO 2. MARCO CONCEPTUAL 2.9.2.1. Base de Datos Relacionales El modelo relacional usa una colección de tablas para representar tanto los datos como sus relaciones. Cada tabla tiene varias columnas, y cada columna tiene un nombre úni- co. El modelo relacional es un ejemplo de un modelo basado en registros. Los modelos basados en registros se denominan así porque la Base de Datos se estructura en regis- tros de formato fijo de varios tipos cada tabla contiene registros de un tipo dado. Cada tipo de registro define un número fijo de campos, o atributos. Las columnas de la tabla corresponden con los atributos del tipo de registro. El modelo de datos relacional es el modelo de datos más ampliamente usado, y una gran mayoría de sistemas de bases de datos actuales se basan en el modelo relacional. Estas usan un conjunto de tablas para representar tanto los datos como las relaciones entre ellos. (Silberschatz, A y Korth, H y Sudarshan, S. 2006) 2.9.3. Sistemas Gestores de Bases de Datos Un sistema gestor de bases de datos (SGBD) consiste en una colección de datos inter- relacionados y un conjunto de programas para acceder a dichos datos. La colección de datos, normalmente denominada Base de Datos, contiene información relevante para una empresa. Según De Miguel, Piattini y Marcos (2002), los SGBD se pueden definir como el con- junto de programas, procedimientos, lenguajes, entre otros, que suministran, tanto a los usuarios no informáticos como a los analistas, programadores o administradores, los me- dios necesarios para describir, recuperar y manipular los datos almacenados en la base, manteniendo su integridad, confidencialidad y seguridad. El objetivo principal de un SGBD es proporcionar una forma de almacenar y recuperar la información de una Base de Datos de manera que sea tanto práctica como eficiente. Los sistemas de bases de datos se diseñan para gestionar grandes cantidades de informa- ción. La gestión de los datos implica tanto la definición de estructuras para almacenar la información como la provisión de mecanismos para la manipulación de la información. Además, los sistemas de bases de datos deben proporcionar la fiabilidad de la informa- ción almacenada, a pesar de las caídas del sistema o los intentos de acceso sin autoriza- ción. 2.9.3.1. Objetivos de los SGBD De acuerdo con Simón y Mata (2010), los objetivos principales de un SGBD son: Permitir el acceso concurrente: El SGBD, debe actualizar y mantener la consis- tencia de los datos de forma cuando haya un acceso concurrente sobre los mismos 36 CAPÍTULO 2. MARCO CONCEPTUAL por parte de varios usuarios. Recuperar información: El SGBD debe proveer un mecanismo capaz de recupe- rar la BD en el caso de que ocurra alguna falla. El SGBD, debe dejar en cualquier circunstancia un estado consistente en la BD. Seguridad: Debe garantizar que solo los usuarios autorizados, tengan acceso a la data o parte de ella, así como también que tipo de privilegios tendrán sobre los datos mismos. Integridad y redundancia de datos: Se refiere a la calidad de los datos, el SGBD debe proporcionar medios necesarios para garantizar que los datos cumplan con ciertas reglas para que estos mantengan su consistencia y validez. Abstracción de la información: la BD contienen un gran volumen de información, los SMBD ocultan a los usuarios los detalles acerca del almacenamiento físico de los datos. 2.9.3.2. Ventajas de los SGBD Simón y Mata (2010), exponen algunas ventajas de los SGBD: Proveen facilidades para la manipulación de grandes volúmenes de datos. Simplifi- can la programación de chequeos de consistencia. Manejando las políticas de respaldo adecuadas, garantizan que los cambios de la base serán siempre consistentes sin importar si hay errores en el disco, o hay muchos usuarios accediendo simultáneamente a los mismos datos, o se ejecutaron progra- mas que no terminaron su trabajo correctamente, etc. Permiten realizar modificaciones en la organización de los datos, con un impacto mínimo en el código de los programas. Permiten implementar un manejo centralizado de la seguridad de la información (acceso a usuarios autorizados), protección de información, de modificaciones, in- clusiones, consulta. Las facilidades anteriores bajan drásticamente los tiempos de desarrollo y aumentan la calidad del sistema desarrollado si son bien explotados por los desarrolladores. Usualmente, proveen interfaces y lenguajes de consulta que simplifican la recupe- ración de los datos. 37 CAPÍTULO 2. MARCO CONCEPTUAL 2.9.3.3. Ventajas de los SGBD Simón y Mata (2010), explican no solo las ventajas de los SGBD sino también las des- ventajas, a continuación, se enuncian algunas: Recursos: Por lo general este tipo de software son de gran tamaño, ya que la com- plejidad del mismo y la gran cantidad de funciones que estos realizan, consumen un espacio considerable de memoria para ejecutarse y espacio en disco para su correcta instalación. Estos aspectos, son de vital importancia para que el software tenga un buen desempeño y no se degrade el rendimiento del sistema. Conocimiento previo: Para aprovechar al máximo las prestaciones que brindan los SMBD, es necesario, tener un conocimiento previo de los mismos, de lo contrario, se estará desaprovechando un gran número de funcionalidades que puedan ser de gran utilidad para las tareas a realizar, provocado así, gastos en costos y tiempos de operaciones. Costos: Algunos SMBD pueden llegar a ser bastantes costosos, así como también el hardware adicional necesario para el mismo. A continuación, se presentarán MySQL, PostgreSQL, Microsoft SQL Server y Oracle como ejemplos SGBD existentes actualmente: 2.9.4. MySQL MySQL fue inicialmente desarrollado por MySQL AB (empresa fundada por David Ax- mark, Allan Larsson y Michael Widenius). MySQL A.B. fue adquirida por Sun Microsys- tems en 2008, y ésta a su vez fue comprada por Oracle Corporation en 2010, la cual ya era dueña desde 2005 de Innobase Oy, empresa finlandesa desarrolladora del motor InnoDB para MySQL. MySQL es un SGDB para bases de datos relacionales multihilo y destaca por su gran adaptación a diferentes entornos de desarrollo, permitiendo su interactuación con los len- guajes de programación más utilizados como PHP, Perl, Java, entre otros, y su integración en distintos sistemas operativos MySQL es el SGDB de código abierto más conocido, y de- bido su gran desempeño, confiabilidad y fácil uso, se ha convertido en la opción principal para el desarrollo de aplicaciones web. Existen muchos tipos de bases de datos, desde un simple archivo hasta sistemas rela- cionales orientados a objetos. MySQL, como Base de Datos relacional, utiliza multiples tablas para almacenar y organizar la información. MySQL funciona sobre múltiples plataformas, Oracle provee el código fuente de MySQL Community Edition y versiones compiladas para diferentes sistemas operativos, aunque el 38 CAPÍTULO 2. MARCO CONCEPTUAL rendimiento de MySQL se encuentra optimizado para sistemas GNU/Linux, con pequeñas diferencias de rendimiento entre las diferentes distribuciones . 2.9.4.1. Características de MySQL Inicialmente, MySQL carecía de elementos considerados esenciales en las bases de da- tos relacionales, tales como integridad referencial y transacciones. A pesar de ello, atrajo a los desarrolladores de páginas web con contenido dinámico, justamente por su simpli- cidad. Poco a poco los elementos de los que carecía MySQL están siendo incorporados tanto por desarrollos internos, como por desarrolladores de software libre. Entre las caracterís- ticas disponibles en las últimas versiones se puede destacar: Amplio subconjunto del lenguaje SQL. Algunas extensiones son incluidas igualmen- te. Disponibilidad en gran cantidad de plataformas y sistemas. Posibilidad de selección de mecanismos de almacenamiento que ofrecen diferentes velocidades de operación, soporte físico, capacidad, distribución geográfica, tran- sacciones. Transacciones y claves foráneas. Conectividad segura. Replicación. Búsqueda e indexación de campos de texto. Uso de multihilos mediante hilos del kernel. Usa tablas en disco b-tree para búsquedas rápidas con compresión de índice. Completo soporte para operadores y funciones en cláusulas select y where. Completo soporte para cláusulas group by y order by, soporte de funciones de agru- pación. Seguridad: ofrece un sistema de contraseñas y privilegios seguro mediante verifi- cación basada en el host y el tráfico de contraseñas está cifrado al conectarse a un servidor. Soporta gran cantidad de datos. MySQL Server tiene bases de datos de hasta 50 millones de registros. Se permiten hasta 64 índices por tabla (32 antes de MySQL 4.1.2). Cada índice puede consistir desde 1 hasta 16 columnas o partes de columnas. El máximo ancho 39 CAPÍTULO 2. MARCO CONCEPTUAL de límite son 1000 bytes. MySQL contiene su propio paquete de pruebas de rendimiento proporcionado con el código fuente de la distribución de MySQL. 2.10. Procesos de Negocio Thompson, R.J y Redstone, L (2002) definen un proceso como una serie de actividades interconectadas en busca de un propósito. En un contexto de negocios, el propósito de los procesos será proveer a sus clientes internos con sus requerimientos de una manera oportuna. Las entradas y salidas de un proceso normalmente son bastante directas en identificar. Las entradas son aquello necesario en un proceso como “materia prima”, o en el caso de que el proceso sea un servicio, el detonante que inicia el proceso siguiente. Las salidas son el producto o servicio que los procesos producen. Los controles y recursos son un poco más complicados, ya que varían según el tipo del ambiente de negocio (Vásquez, 2007). En la Tabla 2.3, se muestra algunos tipos de procesos con sus características, propósito y rama en que se desenvuelven. Figura 2.19: Representación Básica de un Proceso. Fuente: Thompson & Redstone, 2002. Tabla 2.3: Representación Básica de un Proceso. Tipos de procesos: Industriales De Información De Negoicio Foco COSAS DATOS RELACIONES 40 CAPÍTULO 2. MARCO CONCEPTUAL Popósito Transformar y ensamblar materiales y componentes en otros componentes y productos finales, usando recursos. Procesar y transmitir datos estructurados y no estructurados, y conocimiento. Alcanzar las condiciones que satisfacen las necesidades de los participantes, clientes o usuarios. Características Tradiciones de la ingeniería industrial. Tradiciones de la ingeniería informática. Basados en estructuras de comunicación y coordinación humanas encontradas Acciones Ensamblar, Transformar, Transportar, Almacenar e Inspeccionar. Envíar, Invocar, Grabar, Recuperar, Consultar y Clasificar Solicitar, Prometer, Ofrecer, Rechazar, Proponer, Cancelar y Medir. Fuente: Elaboración Propia. Las organizaciones comenzaron a darse cuenta que es necesario e importante replan- tear sus negocios y orientarlos hacia los procesos, sin importar el área que se trate, aplicar nuevos criterios de valor de las operaciones y hacia los clientes, por lo que se puede decir que “Los procesos de negocio pueden ser vistos como un recetario para hacer funcionar un negocio y alcanzar las metas definidas en la estrategia de negocio de la empresa.” Un proceso de negocio se puede definir como una secuencia de actividades relacio- nadas en un orden especifico, con el objetivo de agregar valor a los productos de una organización. Además, es un conjunto estructurado de tareas relacionadas que contribu- yen colectivamente a lograr los objetivos de negocio. Cada proceso de negocio tiene sus entradas, funciones y salidas. Las entradas son requisitos que deben tenerse antes de que una función pueda ser aplicada. Cuando una función es aplicada a las entradas de un método, tendremos ciertas salidas resultantes. Un proceso de negocio puede ser parte de un proceso mayor que lo abarque o bien puede incluir otros procesos de negocio que deban ser incluidos en su función. En este contexto un proceso de negocio puede ser visto a varios niveles y granularidad. Para aplicar los procesos se deben tener claras las tareas, una estructura jerárquica y una tendencia a la interacción y comunicación vertical, son la manera más común de mejorar el desempeño de los sistemas de trabajos ya que podemos cambiar los procesos de negocio cambiando, eliminando o agregando pasos al proceso o también cambiando los métodos de cómo se usan estos pasos. 41 CAPÍTULO 2. MARCO CONCEPTUAL Los Procesos de Negocio (BP) son un recurso importante para el desempeño y la sub- sistencia de la competitividad en las empresas. Para representar procesos de negocio, en los últimos años se han mejorado lenguajes y han aparecido nuevas notaciones. En la Figura 2.20 se muestra la representación de un proceso de negocio por medio de un esquema. Figura 2.20: Representación Esquemática de un Proceso de Negocio. Fuente: Barrera, 2007 El objetivo principal de las empresas es conseguir agilidad y ventaja competitiva, sien- do capaz de adaptarse a los continuos cambios que se producen en el mercado en el que operan. Estos cambios suponen siempre una modificación de los procesos de la organiza- ción. Los procesos de negocios son las formas particulares en que las organizaciones coor- dinan y organizan las actividades de trabajo, la información y los conocimientos, para producir un bien o servicio valioso. La problemática está en que los procesos de negocio del mundo real se expanden por diferentes organizaciones, departamentos, sistemas y aplicaciones. Los procesos de negocio tienen las siguientes características: Complejos. Dinámicos. Distribuidos y particularizados. Duración prolongada (pueden durar incluso meses o años). A veces automatizados, aunque sea parcialmente. Dependen de la inteligencia y el juicio de las personas (características que los hacen muy subjetivos). Difíciles de visualizar. 42 CAPÍTULO 2. MARCO CONCEPTUAL Los procesos de negocios son la manera más común de mejorar el desempeño de los sistemas de trabajos ya que podemos cambiar los procesos de negocios cambiando, elimi- nando o agregando pasos al proceso o también cambiando los métodos de cómo se usan estos pasos. Aparecen, por lo tanto, nuevas necesidades de capturar, modelar, ejecutar y monitorizar los procesos de negocio. Las nuevas tecnologías de la información permiten que los Proceso de Negocio sean automatizados, monitoreados, gestionados y optimizados. Esta nueva rama de la tecno- logía se la suele conocer como la Gestión de Procesos de Negocio o BPM por sus siglas en ingles. El modelo del proceso de negocio es el componente fundamental de BPM, porque este modelo (o flujo) es el que de cierta forma se ejecuta en el motor de BPM. 2.10.1. Componentes de un Proceso de Negocio Actividades: son las tareas que debe hacer una persona (tarea interactiva, human task), o debe hacer un sistema (servicio, o system task) dentro del proceso de ne- gocio. Por ejemplo: “Revisar Antecedentes Financieros” (actividad interactiva), o “Imprimir Contrato” (servicio de un sistema). Roles y Usuarios: son los responsables de ejecutar las tareas interactivas. Por ejem- plo: un “Ejecutivo” de un Banco. Objeto de Negocio: es la información o documento que fluye a través del proceso de negocio. Por ejemplo: la “Solicitud de Crédito”, o el “Crédito de Consumo” (en que se transforma la solicitud), o la “Ficha del Cliente”. Decisiones: criterios para tomar distintas opciones en los procesos, distintas direc- ciones en el flujo. Subproceso: otro proceso interno, es parte un proceso de mayor nivel que tiene su propia meta, propietario, entradas y salidas. 2.10.2. Principales Tipos de Procesos de Negocio Procesos estratégicos: estos procesos dan orientación al negocio. Por ejemplo, "Pla- nificar estrategia", .Establecer objetivos y metas". Procesos Centrales: estos procesos dan el valor al cliente, son la parte principal del negocio. Por ejemplo, “Repartir mercancías”. Procesos de Soporte: estos procesos dan soporte a los procesos centrales. Por ejem- plo, “contabilidad”, “Servicio técnico”. 43 CAPÍTULO 2. MARCO CONCEPTUAL El modelado de procesos es usado para capturar, documentar y rediseñar procesos de negocio, facilitando el acercamiento y el acuerdo con los clientes, mejora la motivación de los empleados y existe una mayor facilidad para responder a cambios en el contexto. Para aplicar los procesos se deben tener claras las tareas, una estructura jerárquica y una tendencia a la interacción y comunicación vertical. 2.11. Gestión de Procesos de Negocio (BPM, Business Pro- cess Management) La Gestión de Procesos de Negocio es la traducción del término Businnes Process Ma- nagement (BPM) y se refiere a la disciplina empresarial que tiene como objetivo mejorar la eficiencia a través de la gestión sistemática de los procesos de negocio. Se trata de una estrategia para la gestión y mejora de la ejecución del negocio a través de la continua optimización de los procesos de negocio en un ciclo cerrado de modelado, ejecución y medición. BPM modela, simula, ejecuta, gestiona, monitoriza y optimiza los procesos de negocio. Según Giga (Vollmer et al., 2004) "La gerencia de proceso del negocio se refiere a dise- ñar, ejecutar y optimizar los procesos funcionales del negocio a través de toda la organiza- ción incorporando los sistemas, a los procesos y a la gente". Forrester (Harris et al., 2003) definen BPM como ïntegración caracterizada por flujo de trabajo orquestado, orientado a aplicaciones a través de usos internos múltiples y/o entre los socios externos". La Gestión de Procesos de Negocio permite a las empresas mejorar su eficiencia y adap- tarse con rapidez y flexibilidad a un mundo en contaste cambio. BPM tiene como objetivo principal la implementación de una mejora continua en las organizaciones. Mediante BPM se persigue el modelado de las actividades de negocio para lograr una mejor administra- ción, automatización y optimización. A través del modelado de las actividades y procesos se logra un mejor entendimiento del negocio y muchas veces esto presenta la oportuni- dad de mejorarlos. La automatización de los procesos reduce errores, asegurando que los mismos se comporten siempre de la misma manera y dando elementos que permitan visualizar el estado de los mismos. La administración de los procesos nos permite asegu- rarnos de que los mismos estén ejecutándose eficientemente y obtener información que luego puede ser usada para mejorarlos. Es a través de la información que se obtiene de la ejecución diaria de los procesos que se puede identificar posibles ineficiencias en los mismos y de esta forma optimizarlos. Para lograr estos objetivos y adherirse al paradigma BPM se han desarrollado sistemas o suites que automatizan la administración de procesos de negocio proporcionando he- rramientas para modelar, integrar, medir y optimizar procesos de negocio. A estas herra- mientas se le denominan Sistemas de Gestión de Procesos de Negocio (BPMS – Business Process Management Systems). 44 CAPÍTULO 2. MARCO CONCEPTUAL 2.11.1. Sistemas de Gestión de Procesos de Negocio (BPMS, Business Process Management Systems) BPMS (Business Process Management Systems) son aquellas aplicaciones mediante las cuales se puede implementar una estrategia de Tecnología de Información orientada a la automatización de los procesos claves de las distintas organizaciones que operan en los distintos segmentos del mercado. Es decir, un BPMS es la herramienta en la cual se diseñan, modelan y ejecutan los procesos de negocios. De esta forma, BPMS es una categoría estratégica dentro del mercado de desarrollo de software, que explota la infraestructura middleware IT, permitiendo a las corporaciones unir sus tecnologías ya implementadas, con las personas y con los procesos que partici- pan en el desarrollo del negocio diario. Esta capacidad de operar automáticamente los procesos de negocios reduce drásticamente los costos relacionados. Van de Putte (2001) establece que los objetivos de los BPMS son: Implementar cambios en las reglas y objetivos del negocio. Medir la efectividad de esos cambios. Separar el qué y cómo, independencia de administración de recursos y procesos. Definir, cambiar e implementar los procesos de negocios de manera consistente. Para soportar esta estrategia es necesario contar con un conjunto de herramientas que den el soporte necesario para cumplir con el ciclo de vida de BPM, estas herramientas son las siguientes: Modelador Gráfico de Procesos: (Business Modeler) permite modelar los procesos de negocio, simular su ejecución, definir métricas para el monitoreo, y exportar a Lenguaje de Ejecución de Procesos de Negocio. Ambiente Integración y Desarrollo: (Integration Developer) es la herramienta que permite implementar los procesos, y servicios. Esta herramienta permite integrar las pantallas (para interacción de un participante), y los servicios (interacción con sistemas legados). Servidor de Procesos de Negocio: (Process Server) es el motor que permite eje- cutar los procesos de negocio, aquí se ejecutan las Aplicaciones Compuestas (flujos BPM), los Workflows tradicionales, y la Orquestación de Servicios (procesos com- puestos solo por servicios). Este servidor también es el encargado de generar los datos de las métricas, y de monitoreo. Permite intervenir los procesos en tiempo real: balancear carga, cambiar flujo de negocio, y realizar acciones correctivas (se- gún reglas de negocio). Monitor de Actividades de Negocio: (BAM, Business Activity Monitor) esta es una aplicación de administración que permite gestionar los procesos y servicios, 45 CAPÍTULO 2. MARCO CONCEPTUAL gráficamente se pueden ver indicadores de performance, y Acuerdos de Nivel de Servicios (SLA -Service Level Agreements). Se puede además definir alertas y trig- gers de acuerdo a eventos de negocio que sucedan en el proceso. También puede proveer datos reales a los modelos (Business Modeler) para ajustar las simulaciones (y lograr mejoramiento continuo). 2.11.2. Modelo y Notación de Procesos de Negocios (BPMN, Business Process Model and Notation) BPMN es un estándar de la Business Process Management Initiative (BPMI), organismo que ha sido absorbido por la OMG, cuyo objetivo principal según la BPMI (2006) “propor- cionar una notación fácilmente comprensible por todos los usuarios del negocio, desde los analistas, los desarrolladores técnicos, hasta aquellos que monitorizarán y gestionarán los procesos”. Otros objetivos importantes que se plantea esta especificación son: Crear puentes entre el diseño de los procesos de negocio y la implementación del proceso. Que los lenguajes basados en XML para describir procesos (como BPEL) tengan notación gráfica. Es importante tener en cuenta que BPMN abarca únicamente los procesos de negocio, lo que significa que otro tipo de modelos relacionados (estructura de la organización, recursos, modelados de datos, estrategias, reglas de negocio, etc.) quedan fuera de la especificación. Los modelos BPMN se expresan gráficamente mediante diagramas, estos diagramas constan de una serie de elementos que nos van a permitir diferenciar claramente las tres secciones (o submodelos) básicos que existen en un modelo BPMN. Estas secciones son: Procesos de negocio privados (internos): Los procesos de negocio privados o inter- nos son los que, dentro de una organización específica, han sido tradicionalmente llamados Diagramas de Flujo de Trabajo o Workflow. (Pérez, 2007). Procesos abstractos (públicos): Sirven para representar las interacciones existentes entre un proceso de negocio privado y, o bien otro proceso de negocio o bien un participante del proceso. En este tipo de procesos únicamente se incluyen aquellas actividades que se usan para comunicar un proceso privado con el exterior, así como las correspondientes estructuras de control de flujo (Pérez, 2007). Procesos de colaboración (globales): Sirven para mostrar la interacción entre dis- tintas entidades de negocio. Estas interacciones son definidas como secuencias de actividades que representan el intercambio de mensaje entre las distintas entida- des. La colaboración se entiende como la comunicación entre dos o más procesos 46 CAPÍTULO 2. MARCO CONCEPTUAL (Pérez, 2007). 2.11.3. Elementos de BPMN Cabe destacar que uno de los motores para el desarrollo de BPMN es crear un meca- nismo simple y comprensible para crear modelos de procesos de negocio, mientras que al mismo tiempo es capaz de manejar la complejidad inherente de los procesos de nego- cio. El enfoque adoptado para manejar estos dos requisitos contradictorios fue organizar aspectos gráficos de la notación en categorías específicas. Esto proporciona un pequeño conjunto de categorías de notación para que el lector de un diagrama BPMN pueda re- conocer fácilmente los tipos básicos de elementos y comprender el diagrama. Las cinco categorías básicas de elementos son: Objetos de flujo. Datos. Conexión de objetos. Swimlanes o canales. Artefactos. Los objetos de flujo son los elementos gráficos principales para definir el comporta- miento de un proceso de negocio. Hay tres objetos de flujo, los cuales son: Eventos. Actividades. Puertas de enlace. Los datos se representan con los cuatro elementos: Objetos de datos. Entradas de datos Salidas de datos. Tiendas de datos. Hay cuatro formas de conectar los objetos de flujo entre sí u otra información: Flujos de secuencia. Flujos de mensajes. Asociaciones. Asociaciones de datos. 47 CAPÍTULO 2. MARCO CONCEPTUAL Hay dos formas de agrupar los elementos primarios de modelado a través de "Swimla- nes:" Área funcional o Pool. Carril o Lane. A continuación, se presenta en la Tabla 2.4 algunos de los elementos de BPMN más importantes: 48 CAPÍTULO 2. MARCO CONCEPTUAL Tabla 2.4: Elementos Básicos del Modelado Tipo Descripción Imagen Evento Un evento es algo que ocurre durante el curso de un proceso o una coreografía. Estos even- tos afectan el flujo del modelo y suelen te- ner una causa (desencadenante) o un impacto (Resultado). Los eventos son círculos con cen- tros abiertos para permitir que los marcadores internos diferencien diferentes Disparadores o Resultados. Actividad Una actividad es un término genérico para el trabajo que la empresa realiza en un proceso. Una actividad puede ser atómica o no atómi- ca (compuesto). Los tipos de Actividades que forman parte de un modelo de proceso son: Subproceso y tarea, que son rectángulos re- dondeados. Las actividades se utilizan tanto en Procesos estándar como en Coreografías. Decisión Se utiliza para controlar la divergencia y la convergencia de los flujos de secuencia en un proceso y en una coreografía. Por lo tanto, de- terminará ramificación, bifurcación, fusión y unión de rutas. Los marcadores internos indi- carán el tipo de control de comportamiento. Flujo de secuencia Se utiliza un flujo de secuencia para mostrar el orden en que las actividades se realizarán en un proceso y en una coreografía. Flujo de mensaje Se utiliza un flujo de mensajes para mostrar el flujo de mensajes entre dos participantes que están preparados para enviarlos y recibirlos. En BPMN, dos áreas funcionales separadas en un Diagrama de Colaboración representarán a los dos Participantes. 49 CAPÍTULO 2. MARCO CONCEPTUAL Asociación Una asociación se utiliza para vincular infor- mación y artefactos con elementos gráficos BPMN. Anotaciones y otros artefactos pueden asociarse con los elementos gráficos. Una pun- ta de flecha en la Asociación indica una direc- ción de flujo, cuando corresponda. Área Funcional o Pool Un área funcional es la representación grá- fica de un participante en una colaboración. También actúa como un "swimlane o canales 2 un contenedor gráfico para dividir un conjun- to de Actividades de otras áreas funcionales. Un área funcional puede tener detalles inter- nos en la forma del proceso que se ejecutará o puede no tener detalles internos, es decir, puede ser una çaja negra". Carril o Lane Un carril es una subpartición dentro de un proceso, a veces dentro de un área funcional y se extenderá en todo el proceso, ya sea verti- cal u horizontalmente. Los carriles se utilizan para organizar y clasificar las actividades. Objeto de datos Los Objetos de Datos proporcionan informa- ción sobre qué Actividades requieren que se realicen y / o qué producen. Los Objetos de datos pueden representar un objeto singular o una colección de objetos. La entrada de da- tos y la salida de datos proporcionan la misma información para los procesos. Anotación Las anotaciones son un mecanismo para que un modelador proporcione información de texto adicional para el lector de un Diagrama BPMN. Fuente: Elaboración Propia. 50 CAPÍTULO 2. MARCO CONCEPTUAL 2.11.4. Lenguaje de Ejecución de Procesos de Negocios (BPLE, Busi- ness Process Execution Language) Es un lenguaje basado en XML diseñado para compartir tareas en ambientes distribui- dos, incluso a través de múltiples organizaciones, usando una combinación de servicios Web. Escrito por desarrolladores de BEA Systems, IBM y Microsoft, BPEL combina y subs- tituye IBM’s WebServices Flow Language (WSFL) y la especificación Microsoft’s XLANG. (BPEL es también conocido como BPELWS o BPEL4WS). Usando BPEL, un programador describe formalmente un Proceso del Negocio que ocurre a través de la Web de tal for- ma que cualquier entidad pueda realizar unos o más pasos en el proceso de la misma manera. A continuación en la Tabla 2.5 se observa el cuadro comparativo entre las diferentes herramientas BPMS Open Source. Tabla 2.5: Cuadro Comparativo: BPMS’s Open Source. Herramienta Versión Actual Estándares Licencia Tecnología base BonitaSoft 7.5.4 BPMN 2.0 XPDL GPL v2 Java Intalio 7.5.0 BPMN 2.0 orientada a SOA GPL + licencia de Intalio Java JBPM 6.5.0 BPMN 2.0 orientada a SOA Apace License 2.0 Java ProcessMaker 3.0 BPMN 2.0 Orientada a SOA AGPLv3 PHP Activiti 5.23 BPMN 2.0 Apache License 2.0 Java Fuente: Elaboración Propia. La razón por la que se decidió el uso de la herramienta Bonita BPM fue debido a su alto nivel de documentación y por su activa comunidad. Bonita BPM provee las funcionalida- des y características necesarias para llevar a cabo la implementación del proceso, como lo son: UI Designer, para la creación de páginas y formularios de interacción. Conectores. Fácil integración con las diferentes aplicaciones de una organización a través de la arquitectura orientada a servicios (SOA). 51 CAPÍTULO 2. MARCO CONCEPTUAL 2.11.5. Beneficios de una Herramienta BPMS en una Organización Rodríguez (s.f.), en su artículo ¿BPMS Ahora?, señala que las suites BPM ofrecen a las organizaciones los siguientes beneficios: Facilitan la orquestación tanto de tareas humanas como de sistemas en un mismo proceso a la vez que permiten utilizar las aplicaciones existentes en la organización. Proporcionan al usuario un entorno de trabajo intuitivo mediante el uso de portal de tareas que combina capacidades de Monitorización de Actividades de Negocio (BAM). Permiten adaptarse a las necesidades del mercado y manejar excepciones, de una forma ágil, modificando tanto las reglas de negocio como los procesos en tiempo real. Identifican cuellos de botella en los procesos mediante la combinación de simula- ción y monitoreo, permitiendo realizar acciones correctivas a tiempo y optimizar los procesos. Aseguran la consistencia en las tareas rutinarias de la organización. La visualización de los procesos facilita a los usuarios la identificación de tareas inter-departamentales o inter-organizacionales y un mayor compromiso con la actividad al conocer la im- plicación de su trabajo (roles de usuario). Identifican las mejores prácticas y verifican el cumplimiento de las políticas de la empresa. Pueden reasignar actividades, flujos de información o modificar un pro- ceso iniciado adaptando reglas de negocio en tiempo real. BPM es la evolución del concepto de gestión y reingeniería de procesos que fue ini- cialmente desarrollado a principios de los años noventa. Hoy en día BPM representa la convergencia de metodologías gerenciales y prácticas tecnológicas alrededor de la Geren- cia por Procesos. La Gerencia de Procesos de Negocio permite estandarizar el flujo de actividades del negocio, permitiendo la ganancia de puntos en la productividad y la eficiencia. Las solu- ciones de BPM también sirven para medir, analizar y mejorar la Gerencia de los Procesos de Negocio y análisis financiero de una empresa. La razón por la que se decidió el uso de la herramienta Bonita BPM fue debido a su alto nivel de documentación y por su activa comunidad. Bonita BPM provee las funciona- lidades y características necesarias para llevar a cabo la implementación del proceso de control de acceso, como lo son: UI Designer, para la creación de páginas y formularios de interacción. Conectores. 52 CAPÍTULO 2. MARCO CONCEPTUAL Fácil integración con las diferentes aplicaciones de una organización a través de la arquitectura orientada a servicios (SOA). Puede manejar un alto volumen de usuarios. 2.11.6. Bonita BPM Bonita BPM es el primer editor y líder de soluciones BPM (Business Process Manage- ment) en software libre. Es una empresa de software creada en el 2009 por Miguel Valdés Faura, Charles Charles Souillard y Rodrigue Le Gall, fundadores del proyecto de código abierto Bonita. Esta solución ha sido descargada más de 140.000 veces por un gran número de empre- sas, con el fin de desarrollar aplicaciones informáticas. Es importante destacar además que Bonita BPM es el único producto de código libre que cumple con la definición de BPMS de Gartner. Uno de los objetivos de Bonita BPM es democratizar el BPM con una solución fácil e intuitiva que permita minimizar el costo de implantación. Esta aspira a convertirse en el líder mundial en soluciones de gestión de procesos empresariales de código abierto (Open Source Business Process Management - BPM), proporcionando soluciones de BPM flexibles y potentes para las organizaciones. 2.11.6.1. Funciones de la Plataforma Bonita BPM En su documentación oficial Bonita BPM específica una serie de funciones, que pueden ser llevadas a cabo con esta plataforma, ofrece una plataforma con un grupo de funciones bastante completas, seguidamente detallaremos dichas funciones: Permite modelar tus procesos de forma sencilla con el editor gráfico. Posibilita la gestión de asignaciones, mediante la asignación de actores mapeados con la organización. Gestionar los datos complejos de manera sencilla con el sistema de gestión de datos de negocio Permite la integración con sistemas externos de forma sencilla, permitiendo además que el usuario pueda ser creativo; ya que cuenta con la libertad, para crear nuevas extensiones. Admite conexión con prácticamente cualquier sistema empresarial directamente: CRMs, ECMs, ERPs, bases de datos, entre otros. 53 CAPÍTULO 2. MARCO CONCEPTUAL Ofrece fácil integración a través del uso de APIs disponibles y extensibles mediante Java o REST. Posibilita el diseño de interfaces que son capaces de funcionar en cualquier dispo- sitivo móvil. Despliega tus procesos en un potente y robusto motor de ejecución. Aplica Integración continua en el despliegue de tus procesos. Posibilita la creación de aplicaciones completamente personalizadas para tus usua- rios. Bonita BPM no solo te permite construir tus aplicaciones más rápido sino además, te permite actualizarlas más fácilmente. Aplica cambios a tu aplicación en tiempo real, sin interrupciones. Corrige errores de manera instantánea con la habilidad de reparar y relanzar tareas u omitirlas. Bonitasoft permite monitorear los procesos con la visualización gráfica de los casos. Además, sigue tus métricas de negocio mediante reportes. Asegura una alta disponibilidad de tu plataforma BPM mediante clustering. 2.11.6.2. Versiones Existen dos versiones de Bonita: 1. Versión comunidad (Community Version) Código abierto. Amplio conjunto de funcionalidades. Gratuita. 2. Versiones con suscripción (Suscripted Version): Bonita BPM también ofrece ver- siones pagadas, las cuales cuentan con soporte profesional y funciones adicionales, descritas a continuación: Trabajo en Equipo (Teamwork) • Acelerar la productividad. • Facilitar la colaboración. • Crear formularios web dinámicos. Eficiencia (Efficiency) 54 CAPÍTULO 2. MARCO CONCEPTUAL • Plataforma móvil. • Capacidad para crear sub-tareas. • Amplia biblioteca de plantillas de procesos. Rendimiento (Performance) • Funcionalidades de gran alcance. • Capacidad de cambiar los parámetros y cambios organizativos en caliente. • Gestión de errores. 2.11.6.3. Elementos propios de Bonita BPM A continuación en la Tabla 2.6 se muestra una breve descripción de los elementos BPMN propios de Bonita BPM. Tabla 2.6: Elementos BPMN Propios de Bonita BPM. Tipo Descripción Imagen Evento Un evento es algo que ocurre durante el curso de un proceso o una coreografía. Estos eventos afectan el flujo del mode- lo y suelen tener una causa (desenca- denante) o un impacto (Resultado). Los eventos son círculos con centros abiertos para permitir que los marcadores inter- nos diferencien diferentes Disparadores o Resultados. Hay tres tipos de eventos, en función de cuándo afectan al flujo: Inicio, Intermedio y Fin. Actividad Una actividad es un término genérico para el trabajo que la empresa realiza en un proceso. Una actividad puede ser ató- mica o no atómica (compuesto). Los ti- pos de Actividades que forman parte de un modelo de proceso son: Subproceso y tarea, que son rectángulos redondea- dos. 55 CAPÍTULO 2. MARCO CONCEPTUAL Decisión Se utiliza para controlar la divergencia y la convergencia de los flujos de secuen- cia en un proceso y en una coreografía. Por lo tanto, determinará ramificación, bifurcación, fusión y unión de rutas. Los marcadores internos indicarán el tipo de control de comportamiento. Flujo de secuencia Se utiliza un flujo de secuencia para mostrar el orden en que las actividades se realizarán en un proceso y en una co- reografía. Área Funcional o Pool Un área funcional es la representa- ción gráfica de un participante en una colaboración. También actúa como un "swimlane o canales 2 un contenedor gráfico para dividir un conjunto de Ac- tividades de otras áreas funcionales. Un área funcional puede tener detalles in- ternos en la forma del proceso que se ejecutará o puede no tener detalles in- ternos, es decir, puede ser una çaja ne- gra". Carril o Lane Un carril es una subpartición dentro de un proceso, a veces dentro de un área funcional y se extenderá en todo el pro- ceso, ya sea vertical u horizontalmente. Los carriles se utilizan para organizar y clasificar las actividades. Anotación Las anotaciones son un mecanismo para que un modelador proporcione informa- ción de texto adicional para el lector de un Diagrama BPMN. Fuente: Elaboración Propia. 56 CAPÍTULO 2. MARCO CONCEPTUAL 2.11.6.4. Módulos de Bonita BPM La versión gratuita de Bonita BPM está compuesta de varios módulos, detallados a continuación: Bonita Engine Es un motor genérico y extensible, una API de java que permite al usuario interactuar “programáticamente” con los diferentes procesos, con el fin de integrar nuevos servicios o estándares susceptibles de aparecer en el mundo BPM. Es el encargado de la conexión de los procesos que existen en el sistema, así como el despliegue y ejecución de los mis- mos. La flexibilidad del motor de ejecución de Bonita le permite adaptarse a todo tipo de arquitectura de sistemas de información, del más sencillo al más complejo, permitiendo además que los usuarios sean capaces de añadir nuevos estándares o servicios que pueden aparecer con posterioridad en el mundo BPM. Es suficientemente potente para aguantar cargas intensivas. El módulo de Bonita Studio se encuentra conectado directamente a este otro módulo para poder funcionar. A continuación se muestra en la Figura 2.21 como esta conformado el esquema entre los distintos modulos con el motor de Bonita. Figura 2.21: Esquema del Motor Bonita. Fuente: Elaboración propia. Bonita Studio 57 CAPÍTULO 2. MARCO CONCEPTUAL Es la aplicación gráfica cuya función es diseñar los procesos BPM usando la notación anteriormente comentada: BPMN (Business Process Management Notation) sobre un área de diseño (pizarra) de forma muy intuitiva basada en “arrastrar” los elementos y en su configuración específica mediante una o varias pestañas habilitadas para ello. Éste puede también conectar procesos a otras piezas del sistema de información (tales como: mensajería, ERP, ECM, bases de datos...) para generar una aplicación de negocios autónoma accesible como formulario web. Bonita Studio permite también al usuario di- señar gráficamente el formulario web que será mostrado al usuario final para interactuar con el proceso. Además, el Studio permite al usuario comenzar con procesos diseñados con otros estándares y tecnologías tales como XPDL o jBPM. Para ello, confía en Eclipse. En la Figura 2.22 se pueden observar las interfaces de Bonita Studio. Figura 2.22: Interfaz de Bonita Studio. Fuente: http://www.bonitasoft.com/ Bonita User Experience (User XP) Es la aplicación encargada de la gestión de todo lo relacionado con los procesos BPM desplegados, esta permite a cada usuario final gestionar todas las tareas y procesos crea- dos en los que esté involucrado. El portal también permite al propietario de un proceso administrarlo y obtener informes sobre procesos. Por suerte es muy intuitiva ya que su interfaz se “parece” a una aplicación de gestión de correo web (webmail-like). 58 CAPÍTULO 2. MARCO CONCEPTUAL 2.12. Servicios Web Un servicio web es una tecnología que utiliza un conjunto de protocolos y estándares que sirven para intercambiar datos entre aplicaciones, independientemente del lenguaje de programación en el cual hayan sido desarrolladas y de la plataforma en la cual se estén ejecutando. En los servicios web se hace uso de diversos formatos (XML, JSON, etc) para representar los datos o información a intercambiar, así como también se hace uso de un conjunto de protocolos sobre los cuales se establece la comunicación. 2.12.1. Características de los Servicios Web Utilización de estándares de internet: La única forma para que los servicios web sean utilizados por la cantidad de sistemas heterogéneos existentes en Internet, es el empleo del protocolo de transferencia de datos HTTP utilizado por todos los navegadores Web. Basados en tecnologías de paso de mensajes: La interacción entre el cliente y el proveedor del servicio es empaquetada en unidades autodescriptivas denominadas mensajes. Dicha interacción se describe en función de los mensajes intercambiados. Combinan lo mejor de la tecnología de componentes y de la tecnología web: Los servicios web presentan una funcionalidad de caja negra que puede ser reutilizada sin preocuparse de cómo es implementada y esto permite interfaces bien definidas. 2.12.2. Ventajas y Desventajas de los Servicios Web Entre las ventajas de los servicios web se encuentran: Aportan interoperabilidad entre aplicaciones de software independientemente de sus propiedades o de las plataformas sobre las que se instalen. Permiten que servicios y software de diferentes compañías ubicadas en diferentes lugares geográficos puedan ser combinados fácilmente para proveer servicios inte- grados. Entre las desventajas de los servicios web se encuentran: Al apoyarse en HTTP, pueden esquivar medidas de seguridad basadas en firewall, cuyas reglas tratan de bloquear o auditar la comunicación entre programas a ambos lados de la barrera. 59 CAPÍTULO 2. MARCO CONCEPTUAL Para realizar transacciones no pueden compararse en su grado de desarrollo con los estándares abiertos de computación distribuida como CORBA (Common Object Request Broker Architecture). 2.13. Lenguaje de Programación Un lenguaje de programación es aquel elemento dentro de la informática que nos per- mite crear programas mediante un conjunto de instrucciones, operadores y reglas de sin- taxis; que pone a disposición del programador para que este pueda comunicarse con los dispositivos hardware y software existentes. Los lenguajes de programación se clasifican por su nivel de abstracción del procesador, en este caso la abstracción es un principio por el cual se aísla toda aquella información que no es resulta relevante a un determinado nivel de conocimiento. 2.13.1. Tipos de Lenguajes de Programaión Lenguaje de bajo nivel: Es el que proporciona poca o ninguna abstracción del microprocesador de un ordenador. Consecuentemente es fácilmente trasladado a lenguaje de máquina. Por lo general se utiliza este tipo de lenguaje para progra- mar controladores (drivers). Además se trabaja a nivel de instrucciones, es decir, su programación es al más minimo detalle y está orientado a la máquina. Lenguaje de medio nivel: Es un lenguaje de programación informática como el lenguaje C, que se encuentran entre los lenguajes de alto nivel y los lenguajes de bajo nivel. Suelen ser clasificados muchas veces de alto nivel, pero permiten ciertos manejos de bajo nivel. Son precisos para ciertas aplicaciones como la creación de sistemas operativos, ya que permiten un manejo abstracto (independiente de la má- quina, a diferencia del ensamblador), pero sin perder mucho del poder y eficiencia que tienen los lenguajes de bajo nivel. Lenguajes de alto nivel: Se caracterizan por expresar los algoritmos de una manera adecuada a la capacidad cognitiva humana, en lugar de a la capacidad ejecutora de las máquinas. En los primeros lenguajes de alto nivel la limitación era que se orien- taban a un área específica y sus instrucciones requerían de una sintaxis predefinida. Se clasifican como lenguajes procedimentales. Otra limitación de los lenguajes de alto nivel es que se requiere de ciertos conocimientos de programación para realizar las secuencias de instrucciones lógicas. 60 CAPÍTULO 2. MARCO CONCEPTUAL 2.13.2. Lenguajes interpretados Lenguajes interpretados: Este tipo de lenguajes de programación, no requieren un có- digo a ser compilado, ya que consisten en scripts que son interpretados en tiempo real por un intérprete, lo cual permite maximizar la eficiencia de los programas, en la mayoría de los casos. Entre los principales programas de este tipo que podemos encontrar, tenemos: Java, Perl, Python, Ruby, ASP, Bash, entre otros. Por lo general, los lenguajes interpretados son de alto nivel y están orientados a ob- jetos y eventos, lo que facilita la programación web y la programación cliente/servidor, por lo cual, actualmente son lenguajes con mucho auge en el ámbito informático. Estos lenguajes son de gran utilidad para la programación web y la creación de programas clien- te/servidor, y se hacen cada día más populares gracias al auge de Internet y la tecnología de nube, lo que los convierte en la punta de lanza para la creación de la nueva generación de programas, ya sean comerciales o completamente Open Source. 2.14. Python Según Rossum (2009) Python es un lenguaje de programación poderoso y fácil de aprender. Cuenta con estructuras de datos eficientes y de alto nivel y un enfoque sim- ple pero efectivo a la programación orientada a objetos. La refinada sintaxis de Python y su tipado dinámico, junto con su naturaleza interpretada, hacen de éste un lenguaje que es ideal para scripting y desarrollo rápido de aplicaciones en diversas áreas y sobre la ma- yoría de las plataformas en la actualidad. El intérprete de Python y la extensa biblioteca estándar están a libre disposición en forma binaria y de código fuente para las principales plataformas desde el sitio web de Python. El intérprete de Python puede extenderse fácilmente con nuevas funcionalidades y ti- pos de datos implementados en C o C++ (u otros lenguajes accesibles desde C). Python también puede usarse como un lenguaje de extensiones para aplicaciones personaliza- bles. Cuando se sale del intérprete de Python, las funciones y variables que fueron definidas se pierden. Por lo que se recomienda escribir los programas en un editor de texto, esto con la intención de preparar la entrada para el intérprete y ejecutarlo con ese archivo como entrada, actualmente esto se conoce como crear un script. Pero cuando los programas se vuelven mas largos una opción es separarlo en distintos archivos para que el manteni- miento del mismo sea más secillo. Además se pueden hacer uso de funciones que le sea de gran utilidad, pero para soportar esto Python posee una manera para las definiciones en un archivo y estas poder ser usadas en un script o en una instancia interactiva del intérprete. Dicho archivo se le denomina módulo; donde las definiciones de un módulo pueden ser importadas a otro módulo o al módulo principal ( donde estan la colección de 61 CAPÍTULO 2. MARCO CONCEPTUAL variables que son accesibles mediante un script el cual puede ser ejecutado en un nivel superior). 2.14.1. Módulos Un módulo es una archivo que contiene definiciones y declaraciones de Python. El nombre de este archivo es en si el nombre del módulo con el sufijo .py agregado. Un módulo puede contener tanto declaraciones ejecutables como definiciones de fun- ciones. Cuyas declaraciones están pensadas para inicializar el módulo y se ejecutan sola- mente la primera vez que el módulo se importa en algún lado. Por lo general es costumbre ubicar todas las declaraciones import al principio del script. Los nombres de los módulos importados se ubican en el espacio de nombres global del módulo que hace la importa- ción. Hay una variante de la declaración import la cual importa los nombres de un módulo directamente al espacio de nombres del módulo que esta realizando la importación. A continuación se explica el funcionamiento de 3 módulos de Python. Pyinotify: Es un módulo para monitorear los cambios que puedan ocurrir en un sis- tema de archivos. Se basa en una característica del kernel de Linux llamada initify, esta característica no es más que un notificador impulsado por eventos, las notifi- caciones que generan son exportan desde el espacio del kernel al del usuario por medio de tres llamadas al sistema. Pyinotify acopla estas llamadas que realiza el sistema y facilita una implementación encima de ellas, ofreciendo así una manera génerica y abstracta de manipular estas funcionalidades. Mysql.connector: Este módulo permite que los programas realizados en Python puedan acceder a las bases de datos MySQL. Este módulo está escrito en Python y no tiene ninguna dependencia a excepción de la biblioteca estándar de Python. Este módulo proporciona casi todas las características de MySQL Server, también realiza conversiones de valores de parámetro entre tipos de dato Python y MySQL translator: Este módulo implementa dos clases Traductor y LanguageDetector. La clase Traductor se puede utilizar para traducir texto. esta clase proporciona una función llamada translate la cual se encarga de tomar tres argumentos: mensaje , lang-from y lang-to, devolviendo el texto traducido como una cadena Unicode. Si no se da lang-from, el servicio de traducción de Google lo detecta automáticamente. Si no se da lang-to, el valor predeterminado es el inglés. La clase LanguageDetector se puede utilizar para detectar el idioma del texto. Con- tiene una función llamada detect . La función detect sólo toma un argumento, el mensaje, la pieza de texto para detectar el idioma. 62 3 Marco Metodológico Luego de saber cual es el problema de se desea solucionar con esta investigación, de definir los objetivos y argumentado teóricamente del mismo, es adecuado indicar cuáles serán los procedimientos utilizados para conseguir dichos objetivos. De modo que ,que en este capítulo se suministra la información detallada sobre la metodología utilizada para la realización de esta investigación. 3.1. Metodologías de Desarrollo La Gestión de Procesos de Negocio (BPM) en la actualidad, es un marco de trabajo con un enfoque empresarial operativo cuya finalidad consisten en coordinar las actividades y decisiones que todas las partes involucradas deben realizar durante el proceso de negocio, permitiendo a una organización mejorar eficientemente a través de la gestión sistemática de los procesos de negocio. Para el desarrollo de la solución de Gestión de Procesos de Negocio (BPM) se toma- rá como base una metodología basada en las mejores prácticas del ciclo de vida BPM propuesto por Smith y Fingar (2003). Las etapas del ciclo de vida del BPM están condi- cionadas por varios autores o fabricantes de BPMS. Estas se pueden apreciar en diversos materiales donde el número y nomenclatura de las fases son diferentes en cada ciclo, es decir, estas son distribuidas de manera distinta, pero en general implican su enfoque al mismo contexto. Dicho esto, se decidió emplear la metodología basada en las mejores prácticas del ciclo 63 CAPÍTULO 3. MARCO METODOLÓGICO de vida BPM que se aprecia en la Figura 3.1 la cual fue propuesta por (Smith & Fingar, 2003), está esta compuesta por dos macro procesos: el primero consiste en la creación del proceso de negocio (engloba las fases de descubrimiento, modelado, despliegue y ejecución) y el segundo en la administración del proceso una vez este ejecutado (engloba las fases de monitoreo y optimización). Figura 3.1: Ciclo de vida BPM. Fuente: Elaboración propia. A continuación se explica en que consiste cada una de las etapas de la metodología del ciclo de vida BPM. 3.2. Ciclo de Vida BPM 3.2.1. Descubrimiento En esta primera etapa se busca elaborar la descripción de cada una de las actividades que conforman el proceso, especificando todos los detalles de cada uno de los requisitos 64 CAPÍTULO 3. MARCO METODOLÓGICO y nos centrándonos específicamente, en todas aquellas funcionalidades claves. Estas ac- tividades van enlazadas con los participantes del proceso y con aquellos sistemas que lo soportan, para lograr convertir el proceso en algo claro por medio del conocimiento con- tenido en estas fuentes. Para este punto es necesario detallar como es el comportamiento actual de forma objetiva y no ajustando las opciones que son subjetivas a los diferentes participantes del proceso. 3.2.2. Modelado Esta etapa implica el modelado, manipulación y diseño de los procesos de negocio. Esta etapa de modelado tiene en cuenta actividades, reglas, relaciones, participantes, sistemas e información para construir un modelo que sea entendido por el dueño del proceso y que pueda cambiarse fácilmente para poder responder rápido a las modificaciones internas del negocio o a los cambios del mercado. Para la construcción de estos modelos dinámicos, las herramientas existentes no son suficiente: se hace necesaria una notación que pueda ser entendida tanto por los hom- bres del negocio como por los hombres de tecnología, además de unas herramientas que faciliten la captura de los elementos abstractos del negocio y que impacten al proceso y la aplicación rápida y efectiva de los cambios en éste. 3.2.3. Despliegue En esta etapa se pretende llevar el proceso y sus actividades a la plataforma tecnológica sobre la cual va a correr y en general, a los diferentes participantes que van a intervenir en su ejecución (manuales y automáticos). Además se establecen las relaciones que dicho proceso va a tener con otros procesos y al llevar el proceso a sus participantes, se distribuye el trabajo de cada uno de estos y se asignan los recursos que van a ser utilizados durante la ejecución del proceso. En esta etapa se integran los componentes necesarios para implementar el proceso. Para implementar los procesos es necesaria una serie de configuraciones y reglas descritas a continuación: Importación y configuración de procesos y actividades. Definición de reglas de negocio. Integración con sistemas (EAI). 65 CAPÍTULO 3. MARCO METODOLÓGICO 3.2.4. Ejecución En esta etapa se busca administrar las actividades llevadas a cabo por cada participante del proceso para asegurar la correcta ejecución del mismo. El sistema administrador de procesos es el que se encarga de esta etapa y es responsable de que las diferentes plata- formas o sistemas que soportan el proceso sean transparentes para el usuario. Además deben asegurar la correcta comunicación entre los diferentes entes que intervienen en el proceso y el correcto funcionamiento de los mismos. Además, aquí es cuando se recolecta la información para el monitoreo de los procesos. Es la etapa en donde se explota el proceso desarrollado previamente mediante: Espacio de trabajo. Lista de tareas pendientes. Gestión de excepciones. Inicio de procesos desde formularios. Configuración y personalización del espacio de trabajo. 3.2.5. Monitoreo En esta etapa se realiza seguimiento continuo a las actividades del proceso con el fin de asegurar que éste se lleve a cabo adecuadamente. El monitoreo se realiza durante la ejecución del proceso debiendo identificar y administrar las excepciones o errores que se presenten, la necesidad y asignación de recursos, los cambios que se produzcan durante la marcha y en general, toda situación que represente un cambio o mejora en el proceso. Esta etapa puede realizarse manualmente o apoyarse en una herramienta tecnológica. 3.2.6. Optimización Para la etapa de optimización se busca el mejoramiento continuo del proceso, eliminan- do inconsistencias para asegurar que su ejecución corresponda con el diseño del mismo. En pocas palabras esta etapa pretende que la realidad del proceso sea lo más similar al diseño del mismo. La manera de optimizar es tomando la información de la etapa de mo- delado y datos de desempeño de la etapa de monitoreo y se comparan, logrando identifi- car los problemas que puedan presentar los procesos y se proponen acciones correctivas. Dichas acciones se aplican en la etapa de descubrimiento. 66 4 Marco Aplicativo En este capítulo se presenta la implementación de la propuesta de solución del Trabajo Especial de Grado. Dicha propuesta se basa en la aplicación de la metodología BPM para el Web. 4.1. Definición de Requerimientos El presente Trabajo Especial de Grado, se agrega a un sistema que actualmente se en- cuentra en funcionamiento, y que preserva páginas Web venezolanas, realizando rastreos periódicos, utilizando el rastreador Web Heritrix, y alojando los Archivos WARC en un Clúster Hadoop. El requerimiento principal es la recolección de datos sobre incidentes adversos y even- tos ocurridos durante el rastreo de un sitio Web con Heritrix, con el fin de poder imple- mentar, a través de una solución de Gestión de Procesos de Negocio(BPM), un sistema de notificaciones, tomando las tareas y reglas de negocio pertinentes y necesarias, para generar un proceso que permita el envío de notificaciones electrónicas al Administrador del Archivo Web. Las fases de la metodología BPM que fueron llevadas a cabo son: des- cubrimiento, modelado, despliegue y ejecución. Las etapas de monitoreo y optimización no se encontraron en el alcance del presente trabajo, ya que estas se realizan cuando se lleva la implementación a producción dentro de una organización. La plataforma BPM que se utilizó para esta implementación fue la versión Community de Bonitasoft, la cual permitió un control total del proceso, sus casos, actividades, usua- 67 CAPÍTULO 4. MARCO APLICATIVO rios, notificaciones, entre otros. Adicional a esto, se contó con la utilización de un script desarrollado en python para la monitorización en tiempo real de los archivos de salida generados por el rastreador Web, Heritrix. 4.2. Diseño Técnico Existen varios sitios que se dedican a la preservación de contenido Web, y todos ellos necesitan un rastreador Web; sitios como el The British Library, Portuguese Web Archive, Internet Memories Foundation, Padicat, entre otros; en su mayoría, utilizan como he- rramienta de rastreo Heritrix. Sin embargo, no utilizan ninguna herramienta BPM para monitorear el proceso de archivado Web. Inicialmente, se pensó en utilizar únicamente Bonita BPM para conectarse a Heritrix, y así monitorear cada uno de los estados generados por los distintos rastreos; mediante la conexión a la REST API de Heritrix 3.2.0. Sin embargo, al realizar la primeras pruebas, se pudo comprobar que aunque la REST API de Heritrix ofrece facilidades para la creación, modificación y ejecución de rastreos; no proporciona el acceso a los distintos archivos logs y reportes(salidas de Heritrix), que almacenan los distintos estados o incidencias ocurridos durante un rastreo. Tomando en consideración está premisa, se decidió crear una Base de Datos(BD) que estructurará la información proveniente de los archivos de salida de Heritrix y los alma- cenará, para que posteriormente Bonita BPM acceda a ellos. Se utilizó el Sistema Gestor de Base de Datos, MySQL, para diseñar una BD relacional que permitió conectar Heritrix con Bonita BPM. No obstante, una vez diseñada la BD fue clara la necesidad de emplear una tercera herramienta o programa, que habilitará la lectura de los archivos de salida de Heritrix(logs y reportes) en tiempo real y almacenará cada entrada en la BD. Realizando algunas investigaciones, se determinó que el módulo de Python, Pyinotify, cuya función específica es monitorear cambios de sistemas de archivos, era la mejor op- ción. Por lo tanto, se desarrolló una solución que utiliza un script en Python para leer los archivos de salida de Heritrix en cuanto son modificados y los almacena en la Base de Datos MySQL, a la cual accederá Bonita BPM utilizando un conector JDBC. En el Desarrollo del Proceso, se realizó una modificación de la arquitectura del Pro- totipo de Archivo Web de la Facultad de Ciencias. En la Figura 4.1, se muestra la nueva Arquitectura con la modificación añadida. 68 CAPÍTULO 4. MARCO APLICATIVO Figura 4.1: Arquitectura del Prototipo de Archivo Web, añadiendo las modificaciones necesarias. Fuente:Elaboración propia. 4.3. Herramientas Tecnológicas A continuación, se describen las herramientas seleccionadas para la implementación de la solución propuesta. 4.3.1. Bonita BPM Bonita BPM es una poderosa plataforma de aplicaciones basadas en BPM para crear aplicaciones empresariales personalizadas y basadas en procesos altamente atractivas pa- ra hacer las cosas, aprovechar al máximo el BPM y adaptarse a los cambios del negocio en tiempo real. (BonitaSoft, 2016) (Ver más sobre Bonita en la Sección 2.11.6). A continuación se detallan los elementos de Bonita BPM, que fueron utilizados para el modelado de este proceso: Agrupamiento y Senda (Pool y Lane):Un agrupamiento es un contenedor para un proceso en un diagrama. Un senda o canal es una división de un agrupamiento. En la Figura 4.2 se muestra un ejemplo de dicho elemento. 69 CAPÍTULO 4. MARCO APLICATIVO Figura 4.2: Pool y Lane, Bonita BPM. Fuente:Elaboración propia. Eventos de Inicio y Fin (Start and End Events): Indican donde empieza y donde termina un proceso. En la Figura 4.3 se pueden apreciar los eventos propios de Bonita BPM. Figura 4.3: Eventos Inicio y Fin, Bonita BPM. Fuente:Elaboración propia. Compuerta XOR (Gateway XOR): Una puerta de enlace XOR (o exclusiva) repre- senta más comúnmente una decisión de fusión. Sólo se necesita una entrada a una puerta de enlace XOR para que el proceso continúe, su interfaz se aprecia en la Figura 4.4. Figura 4.4: Compuerta XOR, Bonita BPM. Fuente:Elaboración propia. Lanzar y Capturar Enlace (Link Throw-Link Catch):Un enlace de lanzamiento se conecta a un enlace de captura, estos elementos propios de Bonita BPM se observan en la Figura 4.5. Actividad de Llamada(Call Activity Subprocess):La actividad de llamada, llama a un subproceso. El subproceso se ejecuta dentro de la secuencia de su proceso padre, pero se define en un canal separado. En la Figura 4.6 se observa la actividad de llamada de Bonita BPM. 70 CAPÍTULO 4. MARCO APLICATIVO Figura 4.5: Lanzar y , Capturar Enlace, Bonita BPM. Fuente:Elaboración propia. Figura 4.6: Actividad de Llamada propia de Bonita BPM. Fuente:Elaboración propia. Temporizador(Timer): Un temporizador intermedio, actúa como un mecanismo de retardo basado en una duración específica o una fecha y hora específicas, en la Figura 4.7 se puede observar su interfaz. Figura 4.7: Temporizador, Bonita BPM. Fuente:Elaboración propia. 4.3.2. Servicios Web Un servicio Web es un conjunto de protocolos y estándares abiertos utilizados para el intercambio de datos entre aplicaciones o sistemas. Los servicios Web son utilizados por aplicaciones realizadas en distintos lenguajes de programación y que se ejecutan en diferentes plataformas para interoperar a través de Internet con el fin de ofrecer servi- cios entre ellas. Los proveedores ofrecen sus servicios como procedimientos remotos y los usuarios solicitan un servicio llamando a estos procedimientos a través de la Web. (W3C)(Ver más sobre Servicios Web en la Sección 2.12) 4.3.3. Python Python es un lenguaje de programación de alto nivel, interpretado y multipropósito. En los últimos años su utilización ha ido constantemente creciendo y en la actualidad es uno 71 CAPÍTULO 4. MARCO APLICATIVO de los lenguajes de programación más empleados para el desarrollo de software. Python puede ser utilizado en distintas plataformas y sistemas operativos, los más populares son: Windows, Mac OS X y Linux. Python es open source, es decir, cualquiera puede cooperar a su desarrollo y divulgación. Además, no es necesario pagar por una licencia para distri- buir software desarrollado con esté lenguaje, hasta su intérprete se distribuye de forma gratuita para diferentes plataformas. La ùltima versión de Python recibe varios nombres, entre ellos, Python 3000 y Py3K, aunque, habitualmente, se le denomina simplemente Python 3. (Ver más sobre Python en la Sección 2.14) 4.3.4. MySQL Según (Oracle, 2017), MySQL es el sistema manejador de bases de datos de código abierto más popular del mundo. Se ha convertido en una de las mejores opciones de Base de Datos relacionales para aplicaciones basadas en la Web. Gracias a su confiabilidad y facilidad de uso, se decidió optar por este manejador para almacenar toda la informa- ción referente a cuando se inicia unnuevo rastreo. (Ver más sobre MySQL en la Sección 2.9.4) 4.4. Etapas del Proyecto 4.4.1. Descubrimiento La etapa de descubrimiento consistió en estudiar y analizar a fondo las diferentes tareas involucradas en el proceso, todo esto con el fin de crear un flujo de trabajo que represen- tará al proceso de estudio y que pudiera ser modelado mediante el estándar BPMN 2.0 y soportado bajo una herramienta tecnológica BPMS. La primera actividad es definir la manera de acceder a los archivos de salida generados por Heritrix para verificar y almacenar cualquier cambio, y además poder hacerlo con interacciones en tiempo real. Para ello, se utilizó el lenguaje de programación Python, donde se tomaron de ejemplo algunos códigos que implementaban el módulo "pyinotify", usado para monitorear directorios de archivos de forma recursiva. La siguiente actividad es la especificación de los archivos de Heritrix que son de interés para el proceso a modelar. Es necesario entender primero la estructura de archivos que presenta Heritrix en sus directorios Archivos de Entrada • crawler-beans.cxml - archivo de configuración de rastreo en heritrix 72 CAPÍTULO 4. MARCO APLICATIVO • negative-surts.txt - SURT que deberán evitarse durante el rastreo, por una ra- zón u otra • seeds.txt - archivo de semillas URL Archivos de salida: • negativo-surts.dump • reports/frontier-summary-report.txt • reports/seeds-report.txt • warcs/*.warc.gz.open • warcs/*warc.gz Archivos de registro • job.log • logs/alerts.log • logs/crawl.log • logs/nonfatal-errors.log • logs/progress-statistics.log • logs/runtime-errors.log • logs/uri-errors.log - En base a todo lo observado en cada uno los archivos anteriormente mencionados, se de- cidió tomar información de sólo 3 de ellos; ya que están ampliamente relacionados con el resto. Primero tenemos el archivo de registro "job.log", donde se registra de forma inme- diata cualquier nuevo evento, estado o incidencia. Se identificaron también los archivos seeds.txt y seeds-report.txt, que contienen la URL a rastrear y el código de estado(HTTP o propio de Heritrix) final del rastreo, respectivamente. Luego del análisis de las diferentes fases o estados que pueden registrarse durante un rastreo Web, se tomaron todas las actividades o tareas extraídas de cada una de estas fases y se organizaron secuencialmente, se definieron entradas y salidas y se desarro- lló un proceso el cual simula de forma genérica el rastreo de Archivos Web, hecho por Heritrix. Se pudo observar, que este proceso está conformado únicamente por tareas de servicio que se ejecutan de forma periódica para asegurar un control apropiado de las notifica- ciones al Administrador del Archivo Web. En esta etapa, se considera la forma de utilizar los temporizadores, evento de tiempo en Bonita BPM, para lograr que la ejecución de un rastreo y sus posteriores estados sean detectados lo más rápido posible. Para ello, se tomó 73 CAPÍTULO 4. MARCO APLICATIVO como ejemplo el sistema de Escenario de Colaboración Empresarial (Business Collabora- tion Scenario), el cual utiliza temporizadores para hacer al proceso recursivo; ya que con consultas a la BD cada cierto tiempo determina el paso a seguir. Este sistema fue de gran utilidad para estudiar y analizar a fondo el uso de los eventos de tiempo en Bonita BPM, y además la colaboración entre procesos lograda mediante el paso de mensaje o llamadas a subprocesos. A partir de estas premisas, como primer punto, se observó que el proceso de notificación de estados de rastreos del Archivo Web está formado por dos subprocesos. El primero de ellos es las notificaciones enviadas por correo electrónico al Administrador del Archivo Web, con el fin de informarle los hechos de interés que ocurran durante los rastreos. El segundo subproceso corresponde al Archivo Web como tal, el cual es la verificación de cualquier cambios de estado en algún rastreo y la realización de las modificaciones o acciones pertinentes. Por lo tanto, se determinó que en el proceso resultante interactúan tres actores o roles los cuales son: Subproceso 1: Archivo Web de Venezuela • Sistema: Encargado de manejar los cambios en la Base de Datos MySQL mo- delando los pasos ejecutados por el script de Python. • Heritrix: Encargado de verificar si algún rastreo fue iniciado, así como de ob- tener todos los estados posteriores lo que incluye alertas, errores y rastreos terminados. Subproceso 2: Notificaciones • Administrador: Encargado de recibir notificaciones de advertencias o errores sobre un rastreo iniciado. A continuación, en la Tabla 4.1 se describen las actividades de cada actor y las reglas de negocio que estos deben cumplir. 74 CAPÍTULO 4. MARCO APLICATIVO Tabla 4.1: Flujo Diseñado en la Fase de Descubrimiento. Actor Actividad Descripción Regla de Negocio Administrador Recibir No- tificaciones Mediante un conector SMTP se le envían al Ad- ministrador las notificaciones relevantes Si un rastreo fue iniciado, se le indica al administrador, junto con la fecha en la que ocurrió. Si un rastreo está ejecutándose, se le indica al administrador, junto con la fecha actual. Si un rastreo finalizó, se le indica al ad- ministrador, indicando además la fecha en que se inicio, la fecha en que finalizo, su código de estado y si se invocó al Servicio Web. Si un rastreo no finalizó, se le indica al ad- ministrador, indicando además la fecha en que se inicio, la fecha en que finalizo, su código de estado y si se invocó al Servicio Web. Sistema Modificar las Banderas y campos de la Base de Datos El historial de estados de un rastreo dispone de un campo flag, que es cambiado a uno(1) cuando el estado es verificado, para poste- riormente decidir si se envía una notificación o se continua con la ejecución. Si un rastreo fue ejecutado, se actualiza esa entrada en la Base de Datos como visitada, luego de enviar la notificación al Adminis- trador. Si un rastreado está pausado, preparándo- se o deteniéndose, se actualiza en la Base de Datos como visitado, sin enviar ningu- na notificación al Administrador, y se con- tinua con el flujo verificando si el estado del rastreo ha cambiado. Si un rastreo esta corriendo o ya finalizó, se coloca como visitado en la Base de Datos y se envía la notificación correspondiente al Administrador. Si ocurre un error o se levanta una alerta, se le indica al Administrador con la noti- ficación correspondiente y se coloca como visitado en la Base de Datos. 75 CAPÍTULO 4. MARCO APLICATIVO Heritrix Ejecución de Tempo- rizadores Se encarga de la ejecución recursiva de los tres(3) temporizado- res Si un rastreo fue ejecutado entonces, se continua para verificar los nuevos estados que van surgiendo, en caso contrario se es- pera el tiempo establecido, 10 minutos, pa- ra volver a realizar la verificación. Si un rastreo fue ejecutado, se comienza la obtención de los estados siguientes. Si exis- te un nuevo estado para el rastreo se pro- cede a verificar que tipo de estado es. En caso contrario se espera, por 10 segundos, para volver a comprobar la existencia de un nuevo estado. Cuando un rastreo termina, bien sea que haya finalizado de forma exitosa o no, se verifica si el código de estado final ya fue generado, si es así se procede a enviar las notificaciones correspondientes. En ca- so contrario, se espera un tiempo para vol- ver a verificar si el código ya fue asignado al rastreo. Fuente: Elaboración Propia. 4.4.2. Modelado Ya culminada la fase de descubrimiento, y después de haber analizado y detallado las actividades, actores y reglas de negocio, se puede realizar la fase de modelado con la notación BPMN. En esta fase se utilizó la herramienta de gestión de procesos de negocio Bonita BPM. Primero, fue pertinente la creación de la Base de Datos en el sistema manejador de bases de datos MySQL, la cual sirvió como repositorio centralizado para toda la información 76 CAPÍTULO 4. MARCO APLICATIVO asociada a los rastreos del Archivo Web. Dicha Base de Datos, contiene cuatro(4) tablas relacionadas en las que se almacenan todos los datos necesarios para llevar a cabo el flujo de los archivos de salida generados en cada rastreo ejecutado. En la Figura 4.8 se puede observar la estructura de la Base de Datos, y las tablas con sus atributos y tipos de datos respectivos. Figura 4.8: Estructura de la Base de Datos para el control de los logs generados por los rastreos en Heritrix. Fuente:Elaboración propia. Una vez definida la BD, se procedió a crear el script de ejecución en Python, el cual mediante la librería Pyinotify accede al directorio allData, que es donde se almacena toda la información de los rastreos ejecutados por Heritrix para el Archivo Web de Venezue- la. A continuación, se detalla el código en Python, empezando con lo módulos que necesita el script, para este caso tenemos: 1 import pyinotify 2 import os 3 import mysql.connector 4 from mysql.connector import errorcode 77 CAPÍTULO 4. MARCO APLICATIVO 5 import datetime, dateutil.parser 6 from googletrans import Translator pyinotify: Pyinotify permite monitorear eventos de sistemas de archivos en Linux a través del subsistema inotify Linux kernel. Puede supervisar cuando se crea, se accede, se elimina, se modifica, etc. os: Este módulo proporciona una forma portátil de utilizar la funcionalidad depen- diente del sistema operativo. mysql.connector: Proporciona controladores, para administrar una Base de Datos MySQL en Python. googletrans: Permite traducir texto en varios idiomas. Como segundo punto, tenemos que en el script se encuentran definidas tres(3) clases, que son: 1. La primera, es la clase MyDB, la cual es utilizada para construir y ejecutar consultas SQL, de Base de Datos MySQL, a partir de una lista de parámetros. Está clase cuenta con solo tres(3) funciones: __init__:Realiza la conexión con la BD "heritrixCrawls", indicando si ocurrió algún error. query: Ejecuta las consultas en la Base de Datos, recibe dos parámetros "query 2 "params", que corresponden con el tipo de consulta y sus parámetros. __del__: Se encarga de cerrar la conexión con la BD. 78 CAPÍTULO 4. MARCO APLICATIVO 1 class MyDB(object): 2 _db_connection = None 3 _db_cur = None 4 def __init__(self): 5 try: 6 self._db_connection = mysql.connector.connect( user='root',password='root',database=' heritrixCrawls') 7 except mysql.connector.Error as err: 8 if err.errno == errorcode. ER_ACCESS_DENIED_ERROR: 9 print ("Nombre de usuario o contrase\~na incorrectos") 10 elif err.errno == errorcode.ER_BAD_DB_ERROR: 11 print ("La base de datos no existe") 12 else: 13 print (err) 14 self._db_cur = self._db_connection.cursor(buffered =True) 15 16 def query(self, query,params): 17 self._db_cur.execute(query,params) 18 self._db_connection.commit() 19 return self._db_cur.lastrowid 20 21 def __del__(self): 22 self._db_connection.close() 2. La clase Log, se encarga de escribir los eventos generados por el módulo pyinotify en un archivo llamado out.log. Cuenta con solo dos funciones, una para inicializar la clases y la segunda "process_default"llena las líneas del archivos out.log. 1 class Log(pyinotify.ProcessEvent): 2 def my_init(self, fileobj): 3 self._fileobj = fileobj 4 5 def process_default(self, event): 6 self._fileobj.write(str(event)+ " " + str(event. pathname) + '\n') 7 self._fileobj.flush() 3. La clase TrackModifications, se encarga de tomar el evento generado por pyinotify, y según el archivo que haya sufrido algún cambio y de que tipo sea dicho cambio, se ejecutarán una serie de funciones. 79 CAPÍTULO 4. MARCO APLICATIVO traducir: En Heritrix, los errores, advertencias e incluso los estados se generan con una descripción en inglés. Está función toma es descripción que muestra Heritrix y la traduce al español, utilizando la función translate. process_IN_CLOSE_WRITE: Si un archivo es de escritura y se modifica, el tipo de evento que ocurre se llama. IN_CLOSE_WRITE. Está función es utilizada específicamente si el reporte seed-report.txt sufre algún cambio. Ejecuta la función _parse_crawl process_IN_MODIFY: Si un archivo es modificado, ocurre el tipo de evento IN_MODIFY, el cual solo se tomará en cuenta cuando el archivo que lo ge- nere sea job.log.Ejecuta la función _parse_job. Aunque pyinotify cuenta con muchos otros eventos, y en el archivo out.log se contemplan todos, para el tratamiento de los archivos solo utilizaremos estos dos. 1 class TrackModifications(pyinotify.ProcessEvent): 2 _directory = None 3 _separate = None 4 5 def traducir(self, words): 6 translator = Translator() 7 text = translator.translate(words,dest='es') 8 return text.text 9 10 def process_IN_CLOSE_WRITE(self, event): 11 if self._separate[1] == 'seeds-report.txt': 12 self._parse_crawl(event.pathname, self. _separate[0]) 13 else: 14 pass 15 16 def process_IN_MODIFY(self, event): 17 self._directory = os.path.normpath(event. pathname).split(os.sep) 18 self._separate= os.path.split(event.pathname) 19 if self._separate[1] == 'job.log': 20 self._parse_job(event.pathname, self. _separate[0], self._directory[3]) 21 else: 22 pass 23 .... _parse_job: Función encargada de ejecutar las acciones que siguen luego de que el archivo job.log haya sido modificado. Responsable de insertar y modi- 80 CAPÍTULO 4. MARCO APLICATIVO ficar los campos relacionados a todos los estados, advertencias y errores que pueden surgir, en las tablas job_history y trace_history. 1 c lass TrackModi f i ca t ions ( p y i n o t i f y . ProcessEvent ) : 2 . . . . 3 def _parse_ job ( s e l f , f i lename ) : 4 db= MyDB() 5 words = l i n e L i s t [ −1:] . s t r i p ('[]') . r ep lace ("'" ,"") . r ep lace ('"' ,"") . s p l i t ( ) 6 dtDate = d a t e u t i l . par se r . parse ( words [0 ]) ) 7 dtDate = dtDate . s t r f t i m e ('%Y/%m/%d %H:%M:%S') 8 f = open("/"+"/" . j o i n ( s e l f . _ d i r e c t o r y [0:−1])+'/seeds.txt') 9 seed = f . r ead l i ne () 10 i f words [1] == 'INFO' : 11 i f words [2] != 'Job' : 12 i n s e r t = " " " INSERT INTO j o b _ h i s t o r y ( s ta te_da te , desc r ip t ion_en , de s c r i p t i on_e s , job_entry_type , job_name ) VALUES ( %s , %s , %s , %s , %s ) ; " " " 13 i d_ job = db . query ( i n s e r t , ( dtDate , words [2 ] , s e l f . t r a d u c i r ( words [2 ]) , words [1 ] , s e l f . _ d i r e c t o r y [−2]) ) 14 i f words [2] == 'RUNNING' : 15 i n s e r t = " " " INSERT INTO t r a c e _ h i s t o r y ( c rawl_s ta r t_da te , ur l , job_name , j o b _ i d e n t i f i e r ) VALUES ( %s , %s , %s , %s ) ; " " " 16 i d _ t r a c e = db . query ( i n s e r t , ( dtDate , seed , s e l f . _ d i r e c t o r y [−2] , words [3 ]) ) 17 i n s e r t = " " " INSERT INTO t r a c e _ j o b _ h i s t o r y ( id_ j ob_h i s t o r y , i d _ t r a c e _ h i s t o r y , j o b _ i d e n t i f i e r ) VALUES ( %s , %s , %s ) ; " " " 18 db . query ( i n s e r t , ( id_ job , id_ t race , words [3 ]) ) 19 e l i f words [2] == 'FINISHED' : 20 update = " " " UPDATE t r a c e _ h i s t o r y SET crawl_end_date=%s WHERE URL =%s AND j o b _ i d e n t i f i e r=%s " " " 21 db . query ( update , ( dtDate , seed , words [3 ]) ) 22 else : 23 i n s e r t = " " " INSERT INTO j o b _ h i s t o r y ( s ta te_da te , desc r ip t ion_en , de s c r i p t i on_e s , job_entry_type , job_name ) VALUES ( %s , %s , %s , %s , %s ) ; " " " 24 db . query ( i n s e r t , ( dtDate , words [2] + " " + words [3 ] , s e l f . t r a d u c i r ( words[2]+" "+words [3 ]) , words [1 ] , s e l f . _ d i r e c t o r y [−2]) ) 25 e l i f words [1] == 'WARNING' : 26 i n s e r t = " " " INSERT INTO j o b _ h i s t o r y ( s ta te_da te , desc r ip t ion_en , de s c r i p t i on_e s , job_entry_type , job_name ) VALUES ( %s , %s , %s , %s , %s ) ; " " " 27 db . query ( i n s e r t , ( dtDate , words [2] + " " + words[3]+ " " + words[4]+ " " + words[5]+ " " + words[6]+ " " + words[7]+ " " + words [8 ] , s e l f . t r a d u c i r ( words [2] + " " + words[3]+ " " "+ words[4]+ " " + words[5]+ " " + words[6]+ " " + words[7]+ " " + words[8]), words[1]),self._directory[-2])) 28 elif words[1]=='SEVERE': 29 words = lineList[-1:]).strip('[]').replace('"',"").replace("'",""). split("SEVERE") 30 if '(JE 4.1.6)' in words): 31 words[1] = words[1]).strip('[]').split("( JE 4 .1 .6 )") 32 tmp = words[1]).strip('[]').split("(") 33 insert = """INSERT INTO j o b _ h i s t o r y ( s ta te_da te , desc r ip t ion_en , de s c r i p t i on_e s , job_entry_type , job_name ) VALUES ( %s , %s , %s , %s , %s ) ; " " " 34 db . query ( i n s e r t , ( dtDate , tmp [0 ] , s e l f . t r a d u c i r (tmp [0 ]) , 'ERROR ' , s e l f . _ d i r e c t o r y [−2]) ) 35 e l s e : 36 pass 37 db . __del__ () 38 . . . 81 CAPÍTULO 4. MARCO APLICATIVO _parse_crawl: Cuando un rastreo finaliza está función es la encargada de ve- rificar el código final de estado del rastreo haya o no finalizado, y modificar los datos correspondientes en la tabla trace_history de la BD. 1 class TrackModifications(pyinotify.ProcessEvent): 2 .... 3 def _parse_crawl(self, filename, dirname): 4 f = open(filename) 5 lineList = f.read().splitlines() 6 update = """UPDATE trace_history SET status=%s , id_status=(SELECT id FROM status_code WHERE status_code=%s) WHERE url=%s AND id_status IS NULL""" 7 db.query(update,(words[1],words[0],str(words [2])[:-1])) Función principal, que ejecuta a pyinotify para todos los eventos. Con WatchManager() se manejan las notificaciones y se toman acciones a través de métodos de procesamiento específicos. Para un EVENT_TYPE, se ejecutará una función process_EVENT_TYPE. La clase Notifier, con el parámetro default_proc_fun=handler, quien interna- mente, es un objeto llamable que en los nuevos eventos se llamará handler(new_event). La instrucción siguiente agrega una nueva observación en el primer parámetro(wm) y re- cursivamente en todos sus subdirectorios (con rec=True). Con la instrucciónwm.add_watch (’home/allData’, rec = True, auto_add=True) se comienzan a procesar los eventos. 1 def main(): 2 fo = open('/home/andreina/Documents/out.log', 'w') 3 try: 4 wm = pyinotify.WatchManager() 5 6 handler = TrackModifications(Log(fileobj=fo)) 7 notifier = pyinotify.Notifier(wm, default_proc_fun=handler) 8 wm.add_watch('/home/allData/', pyinotify. ALL_EVENTS,rec=True, auto_add=True) 9 notifier.loop() 10 finally: 11 fo.close() 12 13 if __name__ == '__main__': 14 main() 82 CAPÍTULO 4. MARCO APLICATIVO Entrando en materia del modelado del proceso, lo primero que se realizó fueron los dia- gramas de procesos de negocio en Bonita BPM Studio. En estos diagramas se modeló todo el proceso, incluyendo actores, tareas y las respectivas reglas de negocio. Los actores, fue- ron representados a través del elemento canal de BPMN, separados en dos agrupamientos. De esta forma, se tienen los canales "Sistema", "Heritrix.en el agrupamiento .Archivo Web de Venezuela 2.Administrador.en el agrupamiento de "Notificaciones". 4.4.2.1. Subproceso: Notificaciones En la Figura 4.9, podemos observar el subproceso de Notificaciones, el cuál contiene una única senda, el Administrador, y está solo compuesto por los eventos de inicio y fin, y una tarea de Servicio. Figura 4.9: Subproceso Notificaciones Fuente:Elaboración propia. En la Figura 4.10 se puede observar la tarea de servicio para enviar los distintos correos de notificación, que incluye el aviso de nuevos rastreos, rastreo en ejecución, adverten- cias,errores y finalización de un rastreo. Está tarea de servicio es bastante relevante; ya que una vez que el proceso es iniciado, a partir de la llamada realizada por el subproceso Archivo Web de Venezuela, se utiliza un conector SMTP (propio de Bonita BPM) para realizar la conexión con el email del Administrador del Archivo Web y así mantenerlo al tanto de cualquier incidencia o cambio. Procederemos a la conexión con SMTP y las condiciones establecidas para enviar el mensaje. En las Figuras 4.11 y 4.12, se encuentran las ventanas de configuración de usuario y contraseña del correo electrónico del remitente, y la ventana para configurar destinatario y remitente. 83 CAPÍTULO 4. MARCO APLICATIVO Figura 4.10: Tarea de Servicio: Enviar Correo de Notificación Fuente:Elaboración propia. Figura 4.11: Configuración de Usuario y Contraseña del Correo Electrónico del Re- mitente Fuente:Elaboración propia. Figura 4.12: Configuración de los destinatarios de correo electrónico y remitente Fuente:Elaboración propia. 84 CAPÍTULO 4. MARCO APLICATIVO Una vez definidos destinatario y remitente, se configuro el asunto y cuerpo del mensaje, dependiendo del tipo de incidencia o cambio, donde: launchedCrawl: Nuevo rastreo está preparado para iniciarse. warningCrawl: Se ha generado una advertencia. errorCrawl:Se ha generado un error. runningCrawl: Rastreo en ejecución. successfulCrawling: Rastreo Finalizado. unsuccessfulCrawl: Rastreo no Finalizado. unsuccessfulCrawlWS: Rastreo no Finalizado, pero debido a la naturaleza del error se decidió llamar al Web Services de ejecución de rastreos. En la Figura 4.13 se puede apreciar como el asunto y el mensaje del correo son asigna- dos cada uno por medio de un script, mostrados en las Figura 4.14 y 4.15 respectivamente. Figura 4.13: Asunto y Mensaje del Correo a Enviar Fuente:Elaboración propia. 85 CAPÍTULO 4. MARCO APLICATIVO Figura 4.14: Asignación de Asunto del Mensaje Fuente:Elaboración propia. Figura 4.15: Asignación del Cuerpo del Mensaje Fuente:Elaboración propia. 86 CAPÍTULO 4. MARCO APLICATIVO Figura 4.16: Subproceso Archivo Web de Venezuela Fuente:Elaboración propia. 4.4.2.2. Subproceso: Archivo Web de Venezuela En el subproceso Archivo Web de Venezuela, Figura 4.16, encontramos los roles de Sistema y Heritrix. Este subproceso es el más complicado; ya que es donde se manejan todos los estados, advertencias y errores que pueden tener lugar durante la ejecución de un rastreo Web en Heritrix. Además, es importante tener presente, que es un proceso que está constantemente monitoreando la Base de Datos en busca de cambios. Para lograr este monitoreo constante, fue necesaria la implementación de temporiza- dores, eventos que tiempo en Bonita BPM, que establecen una cuenta regresiva durante una tarea hasta que se alcance un plazo predeterminado (temporizador de límite) para que está vuelva a ejecutarse. Se emplearon también eventos de lanzamiento y captura de señal,que fueron necesa- rios, debido a las llamadas recursivas que son parte integral del proceso. Se utilizaron estos eventos en particular; ya que permiten cortar gráficamente una secuencia de pro- ceso larga y/o compleja y enlazar partes que no están próximas entre sí en la pizarra de modelado. Los eventos de enlace se utilizan para crear conexiones punto a punto dentro de la misma agrupación. Pueden utilizarse para vincular dos partes diferentes del mismo proceso. Para las actividades dentro del proceso se utilizaron tareas de servicio, que ejecutan funciones de forma automática siendo completamente procesadas por el motor de eje- cución Bonita sin requerir la intervención humana.Estas tareas permanecen invisibles al usuario final mientras realizan sus operaciones. 87 CAPÍTULO 4. MARCO APLICATIVO Figura 4.17: Subproceso: Archivo Web de Venezuela, control de nuevos rastreos Fuente: Elaboración propia. En la Figura 4.17, podemos ver claramente que Heritrix es quien inicia el proceso. Pos- terior al evento de Inicio, tenemos una primera puerta de enlace cuya única función es unir tres flujos de secuencia entrantes, incluyendo un evento de captura de señal que permite que otras tareas, más adelante en el proceso, puedan conectarse al inicio del pro- ceso con solo tener un evento de lanzamiento que lo enlace a este. Además del evento de señal, la puerta de enlace une al flujo un temporizador, el cual espera un tiempo estable- cido, diez(10) minutos para ser exactos, para que la tarea de servicio vuelva a verificar si existen o no nuevos rastreos que atender. La segunda puerta necesita más atención puesto que divide el flujo de secuencia y por lo 88 CAPÍTULO 4. MARCO APLICATIVO Figura 4.18: Tarea de Servicio: Ejecutando nuevos rastreo Fuente:Elaboración propia. Figura 4.19: Consulta a la Base de Datos: Comprobar si existen Nuevos Rastreos Fuente:Elaboración propia. tanto requiere condiciones en los flujos de secuencia salientes.Si no se ha iniciado algún nuevo rastreo, respuesta que se obtiene a partir de la consulta realizada a la Base de Datos en la tarea de servicio(Figura 4.19), se llama al temporizador. Por otro lado si la respuesta es positiva y ocurrió algún nuevo rastreo desde la última comprobación se pasa a la siguiente tarea (Figura 4.20), la cual es desempeñada por el Sistema. Figura 4.20: Tarea de Servicio: Guardar Lanzamiento en la Base de Datos Fuente:Elaboración propia. En esta tarea, se actualiza el campo flag del job_history(Figura 4.21),campo usado para indicar que el registro de la Base de Datos ya fue verificado. Una vez que se ha marcado el estado como visitado, se procede a la siguiente tarea(Figura 4.22) que se encarga obtener los datos básicos del estado modificado(Figuras 4.23) mediante una consulta a la Base de datos 89 CAPÍTULO 4. MARCO APLICATIVO Figura 4.21: Update a la Base de Datos: Estado Visitado Fuente:Elaboración propia. Figura 4.22: Tarea de Servicio: Obtener Datos del Lanzamiento del Rastreo Fuente:Elaboración propia. Figura 4.23: Consulta a la Base de Datos: Obtener datos básicos del Lanzamiento Fuente:Elaboración propia. En la Figura 4.23, observamos la continuación del flujo del proceso, donde tenemos primero un puerta de enlace, que establece si el nuevo rastreo inicio correctamente o si ocurrió un error durante el lanzamiento. Si el lanzamiento fue exitoso,se utiliza una actividad de llamada(Figura 4.24), para invocar al subproceso de Notificaciones y así avisar al Administrador de que se instancio un nuevo rastreo, enviando en la llamada los datos básicos de dicho rastreo (Figura 4.25), como el nombre del Job, la fecha del 90 CAPÍTULO 4. MARCO APLICATIVO lanzamiento y el tipo de mensaje requerido. Si por el contrario, ocurrió un error, se utiliza un evento de lanzamiento de enlace que enlaza el proceso directamente al evento de captura de enlace que se encuentra justo debajo y no se realiza la llamada al subproceso de Notificaciones. Figura 4.24: Subproceso: Archivo Web de Venezuela, iniciado nuevo rastreo Fuente: Elaboración propia. Una vez realizada la llamada y enviado los datos pertinentes, el flujo continua funcio- nando independiente a lo que ocurra en Notificaciones. Tenemos de nuevo una puerta de enlace encargada de unir tres flujos de entrada, que incluyen un evento de captura de enlace y un temporizador. Este es el segundo temporizador del subproceso, que tiene un tiempo de espera asignado de diez(10) segundos; ya que este solo verifica cambios en el estado de un rastreo ya iniciado, y generalmente el tiempo entre los estado de un rastreo 91 CAPÍTULO 4. MARCO APLICATIVO es muy corto. La salida de la puerta de enlace es una Tarea de Servicio (Figura 4.27), que verifica si para el rastreo ejecutado existe un nuevo estado. Figura 4.25: Actividad de Llamada: Notificar Lanzamiento de un Nuevo Rastreo. Fuente: Elaboración propia. Figura 4.26: Actividad de Llamada: Datos enviados por lanzamiento de un nuevo rastreo Fuente:Elaboración propia. Figura 4.27: Tarea de Servicio: Estado actual del Rastreo Fuente:Elaboración propia. Está consulta, ilustrada en la figura 4.28, devuelve el identificador del nuevo estado del rastreo, el cual si es vacío indica que se debe volver al temporizador y esperar. No obstante, si existe un nuevo identificador se procede a la siguiente tarea, mostrada en la Figura 4.29, que se encarga de modificar el campo flag en la tabla job_history para el estado obtenido(Figura 4.30) y de nuevo se realiza una consulta para obtener los datos básicos del estado en la siguiente tarea (Figura 4.31 y Figura 4.32). 92 CAPÍTULO 4. MARCO APLICATIVO Figura 4.28: Consulta a la Base de Datos: Nuevo estado en un rastreo Fuente:Elaboración propia. Figura 4.29: Tarea de Servicio:Guardar Estado en la Base de Datos Fuente:Elaboración propia. Figura 4.30: Update a la Base de Datos: Nuevo estado en un rastreo Fuente:Elaboración propia. Figura 4.31: Tarea de Servicio:Obtener Datos del Estado Actual del Rastreo Fuente:Elaboración propia. 93 CAPÍTULO 4. MARCO APLICATIVO Figura 4.32: Consulta a la Base de Datos: Datos Básicos del Nuevo estado Fuente:Elaboración propia. Continuando con el flujo del proceso tenemos la Figura 4.33, donde podemos observar que interviene únicamente el Sistema; ya que una vez obtenido el identificador y los datos del nuevo estado del rastreo, nos encontramos con que este puede ser de varios tipos: Figura 4.33: Subproceso: Archivo Web de Venezuela, Tipos de estados y acciones a tomar Fuente: Elaboración propia. INFO(Informativo): Usado para informar de algún cambio necesario en el rastreo, incluye los estados con descripción: • PREPARING: preparando nuevo rastreo. • PAUSED: rastreo pausado. • RUNNING: rastreo en ejecución. • STOPPING: deteniendo rastreo. 94 CAPÍTULO 4. MARCO APLICATIVO • FINISHED: rastreo finalizado. WARNING(Advertencia): Estado que indica que algún error puede ocurrir pronta- mente. ERROR: Estado obtenido cuando ha ocurrido un error, por lo que el rastreo no puede continuar. Tenemos una primera puerta de enlace, donde se comprueba si el nuevo estado es de tipo Informativo o se trata de una Alerta o Error. Si se trata de una Alerta, en la siguiente puerta de enlace tomamos el flujo de salida a la actividad de llamada correspondiente (Figura 4.34) y posteriormente con un evento de lanzamiento volvemos al evento de captura de la Figura 4.24. Si por el contrario, se trata de un Error se tomará el flujo contrario hacia otra actividad de llamada(Figura 4.36) y el evento de lanzamiento se conecta con el evento de captura de enlace mostrado en la Figura 4.17. Figura 4.34: Actividad de Llamada: Notificar Advertencia. Fuente: Elaboración propia. Figura 4.35: Actividad de Llamada: Datos enviados por una advertencia Fuente:Elaboración propia. Por otro lado, si en la primera puerta de enlace se detecta un estado informativo, pa- samos a verificar si la descripción del estado es RUNNING o FINISHED. Si la condición no se cumple tenemos otro evento de lanzamiento de enlace hacia el evento de captura mostrado en la Figura 4.24, esto debido a que luego de un estado informativo la ejecución del rastreo continua y es necesario obtener el siguiente estado. 95 CAPÍTULO 4. MARCO APLICATIVO Figura 4.36: Actividad de Llamada: Notificar Error. Fuente: Elaboración propia. Figura 4.37: Actividad de Llamada: Datos enviados por un error Fuente:Elaboración propia. Ocurre lo contrario si la condición se cumple; ya que si un rastreo se encuentra en ejecución o ya finalizó es necesario realizar una serie de tareas distintas. La primera es ejecutada por una tarea de servicio, Figura 4.38, la cual obtiene los datos de identificación del rastreo en cuestión almacenados en la tabla trace_history, como se muestra en la Figura 4.39. Figura 4.38: Tarea de Servicio:Obtener Datos de Identificación Fuente:Elaboración propia. Figura 4.39: Consulta a la Base de Datos: Datos de Identificación de un rastreo fina- lizado o en ejecución Fuente:Elaboración propia. Siguiendo a la última tarea de servicio de la Figura 4.33, tenemos que el subproceso continua en la Figura 4.40, donde con una puerta de enlace se dividen ambos casos (en 96 CAPÍTULO 4. MARCO APLICATIVO ejecución y finalizado). Si el rastreo está en ejecución simplemente con una actividad de llamada(Figura 4.41) se invoca al proceso de Notificaciones, con los datos mostrados en la Figura 4.42, para que este se lo informe al Administrador y con un evento de lanza- miento de enlace se conecta al evento de captura de la Figura 4.24 para continuar con los siguientes estados del rastreo hasta su finalización. Figura 4.40: Subproceso: Archivo Web de Venezuela, Rastreos en Ejecución y Códi- gos de Estado Fuente: Elaboración propia. 97 CAPÍTULO 4. MARCO APLICATIVO Figura 4.41: Actividad de Llamada: Notificar Rastreo En Ejecución. Fuente: Elaboración propia. Figura 4.42: Actividad de Llamada: Datos enviados por un rastreo en ejecución Fuente:Elaboración propia. Por otro lado, si el rastreo finalizó, volvemos a Heritrix, donde nuevamente se tiene una puerta de enlace que conecta dos flujos de entrada, el del condicional anterior y un temporizador. Como flujo de salida se tiene una tarea de servicio(Figura 4.43) que verifica, una vez finalizado el rastreo, el código de estado asociado a este. Mediante una consulta a la Base de Datos,ilustrada en la Figura 4.44 ,se obtiene el código de estado final si este existe sino se realiza la llamada al temporizador el cual espera diez(10) segundos para volver a ejecutar la tarea y verificar si ya está asignado el código. Figura 4.43: Tarea de Servicio:Generando Código de Estado del Rastreo Fuente:Elaboración propia. Una vez obtenido el código de estado, que puede ser un código HTTP o alguno propio de Heritrix, pasamos entonces a la siguiente tarea de servicio(Figura 4.45) la cual obtiene toda la información pertinente del código identificado de la tabla status_code en la Base de Datos, como se muestra en la Figura 4.46. Seguidamente, con la información obtenida se ejecuta la siguiente tarea(Figura 4.47), la cual busca la información concerniente a las fechas de inicio y fin del rastreo, así como también del estado del rastreo en la tabla trace_history. 98 CAPÍTULO 4. MARCO APLICATIVO Figura 4.44: Consulta a la Base de Datos: Datos de Identificación del código de es- tado final Fuente:Elaboración propia. Figura 4.45: Tarea de Servicio:Obtener Información del Estado Final del Rastreo Fuente:Elaboración propia. Figura 4.46: Consulta a la Base de Datos: Datos Básicos de un código de estado Fuente:Elaboración propia. Figura 4.47: Tarea de Servicio:Obtener estado del rastreo Fuente:Elaboración propia. Con todos los datos obtenidos a partir de las tareas de la Figura 4.40, se procede a verificar si el código de estado obtenido amerita una llamada al servicio web de ejecución de un nuevo rastreo, verificado con la primera puerta de enlace de la Figura 4.48. Posterior a esto se tiene una puerta de enlace que es la encargada de verificar si un rastreo finalizó o no; esto se debe a que aunque Heritrix asigna el estado FINISHED a todos los rastreo finalizados este no necesariamente fue culminado, está condición depende del código de estado y que Heritrix identifica asignando las palabras CRAWLED o NOTCRAWLED. Sí, 99 CAPÍTULO 4. MARCO APLICATIVO Figura 4.48: Consulta a la Base de Datos: Estado de rastreo y fechas del rastreo finalizado Fuente:Elaboración propia. el rastreo finaliza con CRAWLED entonces con una actividad de llamada(Figura 4.49) se ejecuta el subproceso de Notificaciones para indicarle al Administrador lo ocurrido enviándole los datos correspondientes (Figura 4.50). En caso contrario, es decir, que el rastreo finalice con NOTCRAWLED se ejecuta una actividad de llamada distinta (Figura 4.51) con datos diferentes (Figura 4.52). Finalmente ambas actividades de llamada siguen hacia una puerta de enlace que realiza el lanzamiento de un enlace hacia el evento de captura mostrado en la Figura 4.17 para que así el proceso permanezca esperando hasta la ejecución de nuevos rastreos. Figura 4.49: Subproceso: Archivo Web de Venezuela, Rastreos Finalizados Fuente: Elaboración propia. Figura 4.50: Actividad de Llamada: Notificar Finalización Exitosa. Fuente: Elaboración propia. 100 CAPÍTULO 4. MARCO APLICATIVO Figura 4.51: Actividad de Llamada: Datos enviados por rastreo finalizado exitosa- mente Fuente:Elaboración propia. Figura 4.52: Actividad de Llamada: Notificar Finalización Fallida. Fuente: Elaboración propia. Figura 4.53: Actividad de Llamada: Datos enviados por un finalizado fallidamente Fuente:Elaboración propia. 4.4.3. Despliegue Una vez culminada la etapa de modelado, la etapa de despliegue corresponde a la con- figuración de la plataforma tecnológica sobre la cual se va a ejecutar el proceso modelado en la etapa anterior, en este caso Bonita BPM. Se pueden identificar dos (2) actividades que se realizaron en está etapa: la definición y configuración de los participantes del proceso y la transformación del diagrama modelado a cogido BPEL para la ejecución del proceso. Cuando un proceso está listo para la implementación, lo primero que se debe crear es 101 CAPÍTULO 4. MARCO APLICATIVO un archivo en Bonita BPM Studio que se pueda instalar en el portal de BPM de Bonita. A continuación, se presentan los pasos para crear el archivo con extensión ’.bar’: 1. Luego de realizar las configuraciones necesarias, dentro del Bonita Studio, se realiza la compilación del proceso como se indica en la Figura 4.54. Figura 4.54: Compilar Proceso. Fuente:Elaboración propia. 2. Seleccionamos los dos procesos: Archivo Web de Venezuela y Notificaciones tal cual se observa en la Figura 4.55. Figura 4.55: Selección de Procesos a Compilar Fuente:Elaboración propia. 3. Esperamos que finalice la compilación, como se aprecia en la Figura 4.56. 102 CAPÍTULO 4. MARCO APLICATIVO Figura 4.56: Finalizando Compilación Fuente:Elaboración propia. Posterior a esto, ambos procesos deben instalarse en Bonita BPM Portal, donde como usuario Administrador se cargan en la pestaña BPM, sección Procesos, como se observa en las Figuras 4.57 y 4.58. Figura 4.57: Vista Proceso Notificaciones Fuente:Elaboración propia. Figura 4.58: Vista Proceso Archivo Web de Venezuela Fuente:Elaboración propia. 103 CAPÍTULO 4. MARCO APLICATIVO Una vez que el usuario ingresa al portal, los procesos aparecen descritos como en la Figura 4.59, donde ambos se encuentran habilitados; pero solo el proceso de Archivo Web de Venezuela inicia; ya que es este quien llamará cuando sea oportuno o necesario al proceso de Notificaciones. Figura 4.59: Procesos Habilitados para el usuario de la organización Fuente:Elaboración propia. 4.4.4. Ejecución A continuación se muestran todos los aspectos necesarios para ejecutar el proceso, una vez terminada la fase de despliegue. Debido a que el proceso resultante no consta de un único flujo de actividades,sino que por el contrario, existen dos subprocesos (Notificaciones y Archivo Web de Venezuela), y dentro de estos subprocesos existen diferentes flujos que son definidos por los cambios o incidencias ocurrido en Heritrix. Es decir, en cada ejecución se pueden realizar diferentes actividades basadas en las diferentes situaciones que puedan ocurrir, lo que significa que no todas las tareas del proceso se lleven a cabo en cada ejecución. Por esta razón, y con el fin de mostrar y exponer las diferentes situaciones posibles a la hora de la ejecución del proceso, se tomaron los casos más relevantes tratando de mostrar todas las actividades que se pueden ejecutar. Así, las situaciones que fueron ejecutadas y son mostradas a continuación son las si- guientes: 4.4.4.1. Rastreo Ejecutado Genera una Advertencia Dado que la ejecución de estos subprocesos, depende totalmente de Heritrix, como primer paso podemos establecer que durante la ejecución de un rastreo Web realizado 104 CAPÍTULO 4. MARCO APLICATIVO Figura 4.60: Heritrix: Job FUNDACREDESA Fuente:Elaboración propia. por Heritrix(Ver Figura 4.60) se generó una advertencia, la cual es incluida en el archivo job.log del rastreo correspondiente, como podemos observar en la Figura 4.61; y es una vez allí donde comienza el subproceso de Archivo Web de Venezuela, el cual detectando en la Base de Datos el nuevo registro, realiza la llamada al subproceso de Notificaciones indicándole que se trata de una Advertencia. Figura 4.61: Heritrix: Archivo ’job.log’, FUNDACREDESA Fuente:Elaboración propia. Notificaciones, enviará el correo electrónico al administrador informándole que Heri- trix durante una de sus rastreos generó una advertencia, incluyendo al además el nombre del rastreo y otros datos como la fecha en que ocurrió, como podemos observar en la 105 CAPÍTULO 4. MARCO APLICATIVO Figura 4.62. Figura 4.62: Notificaciones: Heritrix emitió una Advertencia Fuente:Elaboración propia. 4.4.4.2. Rastreo Ejecutado Finaliza con un Error Figura 4.63: Heritrix: Job FUNDACREDESA Fuente:Elaboración propia. Como en el caso anterior, se debe establecer como primer paso que durante la ejecución de un rastreo Web realizado por Heritrix(Ver Figura 4.63) se generó un error terminan- do así la ejecución del rastreo, el cual es incluido en el archivo job.log, como podemos 106 CAPÍTULO 4. MARCO APLICATIVO observar en la Figura 4.64; desde este momento comienza el subproceso de Archivo Web de Venezuela, el cual detectando en la Base de Datos el nuevo registro, realiza la llamada al subproceso de Notificaciones indicándole que se trata de un Error. Notificaciones, enviará el correo electrónico al administrador informándole que Heri- trix durante una de sus rastreos registro un Error, incluyendo al además el nombre del rastreo y otros datos como la fecha en que ocurrió, como se detalla en en la Figura 4.65. Figura 4.64: Heritrix: Archivo ’job.log’, FUNDACREDESA Fuente:Elaboración propia. Figura 4.65: Notificaciones: Heritrix informa de un Error Fuente:Elaboración propia. 107 CAPÍTULO 4. MARCO APLICATIVO 4.4.4.3. Rastreo Ejecutado Finalizado Estableciendo como primer que la ejecución de un rastreo Web realizado por Heri- trix(Ver Figura 4.66), finalizó, generando un código de estado, y aceptando como premisa que todo los estados que el rastreo generó, desde su lanzamiento hasta que finaliza, están incluidos en el archivo job.log, como podemos observar en la Figura 4.67; y que el códi- go de estado final está registrado en el archivo seeds-report.txt, como lo indica la Figura 4.68, se inicia el subproceso de Archivo Web de Venezuela, el cual detectando en la Base de Datos el nuevo lanzamiento de un rastreo, realiza la llamada al subproceso de Notifi- caciones indicándole que se hay un nuevo rastreo y continuará con las comprobaciones de estado. Figura 4.66: Heritrix: Job CIDA Fuente:Elaboración propia. Notificaciones, enviará el correo electrónico al administrador informándole que Heri- trix ha comenzado un nuevo rastreo, incluyendo al además el nombre del rastreo y otros datos como la fecha en que ocurrió, como se detalla en en la Figura 4.69. Inmediatamente después de que el subproceso Archivo Web de Venezuela, identifique que el estado del rastreo es .En Ejecución", realizará la llamada a Notificaciones, para que este subproceso envíe el correo electrónico al administrador informándole que el rastreo se encuentra en ejecución, incluyendo al además el nombre del rastreo y otros datos como la fecha en que ocurrió, como se detalla en en la Figura 4.70. 108 CAPÍTULO 4. MARCO APLICATIVO Figura 4.67: Heritrix: Archivo ’job.log’, CIDA Fuente:Elaboración propia. Figura 4.68: Heritrix: Archivo ’seeds-report.txt’, CIDA Fuente:Elaboración propia. Figura 4.69: Notificaciones: Nuevo Rastreo Fuente:Elaboración propia. Finalmente, una vez detectado que el rastreo finalizó, es decir que el subproceso Archi- vo Web de Venezuela detecta el estado "Finalizado", se realiza la llamada correspondiente al subproceso Notificaciones, quien enviará el último correo electrónico correspondiente a ese rastreo al administrador, informándole que el rastreo finalizó e indicando también el código de estado final y la descripción asociada al mismo, como se detalla en en la Figura 4.71. 109 CAPÍTULO 4. MARCO APLICATIVO Figura 4.70: Notificaciones: Rastreo en Ejecución Fuente:Elaboración propia. Figura 4.71: Notificaciones: Rastreo Finalizado Fuente:Elaboración propia. 4.4.4.4. Rastreo Ejecutado No Finalizado Un rastreo Web realizado por Heritrix(Ver Figura 4.72), no finalizó, generando un có- digo de estado, entonces sabiendo que todo los estados que el rastreo generó, desde su lanzamiento hasta que finaliza, están incluidos en el archivo job.log (ver Figura 4.73) y que el código de estado final está registrado en el archivo seeds-report.txt (Ver Figu- ra 4.74) se inicia el subproceso de Archivo Web de Venezuela, el cual detectando en la Base de Datos el nuevo lanzamiento de un rastreo, realiza la llamada al subproceso de Notificaciones indicándole que se hay un nuevo rastreo. 110 CAPÍTULO 4. MARCO APLICATIVO Figura 4.72: Heritrix: Job INZIT Fuente:Elaboración propia. Figura 4.73: Heritrix: Archivo ’job.log’, INZIT Fuente:Elaboración propia. Figura 4.74: Heritrix: Archivo ’seeds-report.txt’, INZIT Fuente:Elaboración propia. 111 CAPÍTULO 4. MARCO APLICATIVO Notificaciones, enviará el correo electrónico al administrador informándole que Heri- trix ha comenzado un nuevo rastreo, incluyendo al además el nombre del rastreo y otros datos como la fecha en que ocurrió, como se detalla en en la Figura 4.75. Figura 4.75: Notificaciones: Nuevo Rastreo Fuente:Elaboración propia. El subproceso Archivo Web de Venezuela, continúa monitoreando la Base de Datos e identificando todos los estados, en el momento que el estado del rastreo sea "Finalizado", se realiza la llamada correspondiente al subproceso Notificaciones, quien enviará el último correo electrónico correspondiente a este rastreo al administrador, informándole que el rastreo no finalizó e indicando también el código de estado final y la descripción asociada al mismo, como se detalla en en la Figura 4.76. Figura 4.76: Notificaciones: Rastreo No Finalizado Fuente:Elaboración propia. 112 CAPÍTULO 4. MARCO APLICATIVO 4.4.5. Pruebas Funcionales y No Funcionales Se realizaron 5 pruebas funcionales y de integración, constituidas por uno o más casos, las cuales serán descritas a continuación NOMBRE DEL CASO DE PRUEBA:Accediendo a los archivos de Heritrix • Código del Caso de Prueba: CP1-Python ◦ Descripción: Si ocurre algún evento en el directorio allData de Heritrix, debe ser detectados en el mismo momento en que ocurren ◦ Prerrequisitos: Debe ocurrir un cambio en el directorio allData, cambio que puede ser generado por Heritrix o por personal autorizado ◦ Pasos a Seguir: 1. Ejecutar el script en Python, para que monitorice el directorio allData. 2. Al ocurrir un evento este debe ser inmediatamente detectado. 3. Una vez detectado, debe escribirse el tipo de evento y en que archivo o carpeta ocurrió en el archio out.log ◦ Resultado Esperado: Poder observar de forma inmediata en el archivo out.log el evento ocurrido. ◦ Resultado Obtenido: Con Pyinotify, cualquier evento ocurrido en allData, desde la creación de una archivo hasta su eliminación, es registrado de forma automática en out.log. Código del Caso de Prueba: CP2-Python • Descripción: Determinar que eventos de pyinotify son los indicados para de- tectar los cambios en job.log y seeds-report.txt • Prerrequisitos: Debe ocurrir un cambio en los archivo job.log o seeds-report.txt • Pasos a Seguir: 1. Ejecutar el script en Python, para que monitorice el directorio allData. 2. Modificar los archivo job.log y seeds-report.txt, para probar los siguien- tes eventos de pyinotify IN_ACCESS, IN_ATTRIB, IN_CLOSE_NOWRITE, IN_CLOSE_WRITE e IN_MODIFY. 3. Una vez detectado los eventos, verificar cuales de ellos registraron las ac- tividades pertinentes. • Resultado Esperado: Identificar uno o más eventos que registren cuando He- ritrix agrega una nueva entrada al archivo job.log y cuando crea el archivo seeds-report.txt y lo llena. 113 CAPÍTULO 4. MARCO APLICATIVO • Resultado Obtenido: Los eventos IN_CLOSE_WRITE e IN_MODIFY fu eron los que detectaron los cambios en seeds-report.txt y job.log respectivamente. NOMBRE DEL CASO DE PRUEBA:Detectando Nuevo Rastreo. • Código del Caso de Prueba: CP1-BonitaBPM ◦ Descripción:Una vez que se detecta un nuevo estado con descripción ’Job launched’se debe iniciar el flujo del proceso de Archivo Web de Venezuela ◦ Prerrequisitos: Debe ser ejecutado un nuevo rastreo en Heritrix y ser al- macenado de forma satisfactoria en la Base de Datos ◦ Pasos a Seguir: 1. Ejecutar nuevo rastreo en Heritrix. 2. El rastreo es detectado por Pyinotify y almacenado en la Base de Datos. 3. En Bonita BPM, el subproceso Archivo Web de Venezuela, debe detec- tar el nuevo registro en la Base de Datos y enviar la notificación al Administrador. ◦ Resultado Esperado: Ejecutar el rastreo y recibir de forma inmediata la notificación al correo configurado ◦ Resultado Obtenido: El nuevo rastreo fue instanciado, pero nunca llego a ejecutarse porque ocurrió un ERROR debido a fallas en el archivo de con- figuración, por lo cual se estableció como condición que el primer estado de un rastreo pudiera ser un error o una advertencia. • Código del Caso de Prueba: CP2-BonitaBPM ◦ Descripción: Una vez que se detecta un nuevo estado con descripción ’Job launched’se debe iniciar el flujo del proceso de Archivo Web de Venezuela ◦ Prerrequisitos: Debe ser ejecutado un nuevo rastreo en Heritrix y ser al- macenado de forma satisfactoria en la Base de Datos ◦ Pasos a Seguir: 1. Ejecutar nuevo rastreo en Heritrix. 2. El rastreo es detectado por Pyinotify y almacenado en la Base de Datos. 3. En Bonita BPM, el subproceso Archivo Web de Venezuela, debe detec- tar el nuevo registro en la Base de Datos y enviar la notificación al Administrador. ◦ Resultado Esperado: Ejecutar el rastreo y recibir de forma inmediata la notificación al correo configurado 114 CAPÍTULO 4. MARCO APLICATIVO ◦ Resultado Obtenido: Se detecto el nuevo rastreo ejecutado y se envió la notificación de correo electrónico. • Código del Caso de Prueba: CP3-BonitaBPM ◦ Descripción: Dado que una rastreo puede iniciar con error, fue necesario agregar está comprobación al BPMN. ◦ Prerrequisitos: Debe ser ejecutado un nuevo rastreo en Heritrix y ser al- macenado de forma satisfactoria en la Base de Datos ◦ Pasos a Seguir: 1. Ejecutar nuevo rastreo en Heritrix. 2. El rastreo inicia con un Error, antes de ser ejecutado. 3. Se detecta el error, con Pyinotify y se almacena en la Base de Datos. 4. En Bonita BPM, el subproceso Archivo Web de Venezuela, debe detec- tar el nuevo registro en la Base de Datos y enviar la notificación al Administrador. ◦ Resultado Esperado: Ejecutar el rastreo y recibir de forma inmediata la notificación al correo configurado ◦ Resultado Obtenido: Se detecto el nuevo rastreo ejecutado y se envió la notificación de correo electrónico. NOMBRE DEL CASO DE PRUEBA:Detectando Nuevo Estado. • Código del Caso de Prueba: CP4-BonitaBPM ◦ Descripción: Una vez que se detecta un nuevo que se ejecutó un nuevo rastreo, se debe comprobar y obtener todos los estados generados poste- riormente. ◦ Prerrequisitos: Una vez ejecutado en rastreo en Heritrix, sin errores, se debe generar un estado nuevo en el rastreo. ◦ Pasos a Seguir: 1. Ejecutar nuevo rastreo en Heritrix. 2. El rastreo es detectado por Pyinotify y almacenado en la Base de Datos. 3. En Bonita BPM, el subproceso Archivo Web de Venezuela, debe detec- tar el nuevo registro en la Base de Datos y enviar la notificación al Administrador. 4. Una vez que la notificación es enviada, se procede a verificar si existe un nuevo estado para el rastreo ejecutado. 115 CAPÍTULO 4. MARCO APLICATIVO 5. De ser así se debe verificar de que tipo es y ejecutar las acciones perti- nentes. En caso contrario, se continua verificando por nuevos estados hasta que el rastreo finalice o ocurra un error. ◦ Resultado Esperado: Recibir las notificaciones de rastreo en ejecución y rastreo finalizado una vez que se ha ejecutado un rastreo ◦ Resultado Obtenido: El nuevo rastreo fue instanciado y todos sus estados fueron almacenados en la Base de Datos, visitados y notificado. • Código del Caso de Prueba: CP5-BonitaBPM ◦ Descripción: Si el nuevo estado se trata de una alerta, esta debe detec- tarse y notificarse para que el Administrador pueda tomar las medidas pertinentes. ◦ Prerrequisitos: Debe ser ejecutado un nuevo rastreo en Heritrix, el cual durante su ejecución debe generar un advertencia. ◦ Pasos a Seguir: 1. Ejecutar nuevo rastreo en Heritrix. 2. El rastreo es detectado por Pyinotify y almacenado en la Base de Datos. 3. Durante el rastreo ocurre una advertencia, indicando que posiblemen- te pueda ocurrir un error. 4. En Bonita BPM, el subproceso Archivo Web de Venezuela, debe de- tectar la advertencia en la Base de Datos y enviar la notificación al Administrador. ◦ Resultado Esperado: Recibir de forma inmediata la notificación de ad- vertencia al correo configurado ◦ Resultado Obtenido: Se detecto la advertencia y se envió la notificación de correo electrónico. NOMBRE DEL CASO DE PRUEBA:Llamadas recursivas • Código del Caso de Prueba: CP6-BonitaBPM ◦ Descripción: Dado que es un proceso que esta en constante monitoreo, al terminar una ejecución se debe volver a un paso anterior, sin embargo como el BPMN es muy extenso se necesita de un evento que permita enla- zar una parte del flujo con otra, para esto se consideraron los eventos de señal. ◦ Prerrequisitos: En un rastreo debe detectarse un estado de finalización,un error o una advertencia. 116 CAPÍTULO 4. MARCO APLICATIVO ◦ Pasos a Seguir: 1. Ejecutar nuevo rastreo en Heritrix. 2. El rastreo es detectado por Pyinotify y almacenado en la Base de Datos. 3. En Bonita BPM, el subproceso Archivo Web de Venezuela, debe detec- tar el nuevo registro en la Base de Datos y enviar la notificación al Administrador. 4. Una vez que la notificación es enviada, se procede a verificar si existe un nuevo estado para el rastreo ejecutado. 5. Si el estado detectado es un error, advertencia o la finalización del rastreo, se deben enviar las notificaciones correspondientes y volver al inicio utilizando eventos de envío y captura de señal ◦ Resultado Esperado: Una vez enviada la notificación correspondiente, volver a la verificar si existe un nuevo rastreo o no, conectando los flujos mediante los eventos de señal ◦ Resultado Obtenido: Después de enviar las notificaciones, los eventos de captura de señal no continuaban con la ejecución del proceso de forma inmediata. • Código del Caso de Prueba: CP7-BonitaBPM ◦ Descripción: Debido a que los eventos de señal no permitían un flujo fluido del proceso, se realizaron pruebas con los eventos de lanzamiento y captura de un enlace. ◦ Prerrequisitos: En un rastreo debe detectarse un estado de finalización,un error o una advertencia. ◦ Pasos a Seguir: 1. Ejecutar nuevo rastreo en Heritrix. 2. El rastreo es detectado por Pyinotify y almacenado en la Base de Datos. 3. En Bonita BPM, el subproceso Archivo Web de Venezuela, debe detec- tar el nuevo registro en la Base de Datos y enviar la notificación al Administrador. 4. Una vez que la notificación es enviada, se procede a verificar si existe un nuevo estado para el rastreo ejecutado. 5. Si el estado detectado es un error, advertencia o la finalización del ras- treo, se deben enviar las notificaciones correspondientes y cal evento de captura de enlace creado. 117 CAPÍTULO 4. MARCO APLICATIVO ◦ Resultado Esperado: Una vez enviada la notificación correspondiente, volver a la verificar si existe un nuevo rastreo o no, conectando los flujos mediante los eventos de lanzamiento y captura de enlaces ◦ Resultado Obtenido: Después de enviar las notificaciones, el evento de lanzamiento de enlace conectaba de forma inmediata el flujo al evento de captura de enlace colocado al principio del flujo. • Código del Caso de Prueba: CP8-BonitaBPM ◦ Descripción: Observando los logs de ejecución de Heritrix, se observó que para algunos estados era necesario un evento de captura de enlace en un punto intermedio del flujo. ◦ Prerrequisitos: En una rastreo debe detectarse una advertencia,debe es- tar en ejecución o en algún estado intermedio que no requiera de notifi- cación. ◦ Pasos a Seguir: 1. Ejecutar nuevo rastreo en Heritrix. 2. El rastreo es detectado por Pyinotify y almacenado en la Base de Datos. 3. En Bonita BPM, el subproceso Archivo Web de Venezuela, debe detec- tar el nuevo registro en la Base de Datos y enviar la notificación al Administrador. 4. Una vez que la notificación es enviada, se procede a verificar si existe un nuevo estado para el rastreo ejecutado. 5. Si el estado detectado una advertencia, uno de los estados intermedios que no requiere notificación o si el rastreo se encuentra en ejecución, mediante un evento de lanzamiento de señal se conecta el flujo del proceso con Heritrix en la fase de verificación de un nuevo estado, en lugar de al comienzo de la ejecución. ◦ Resultado Esperado: Una vez realizadas las acciones pertinentes a ca- da tipo de estado señalado anteriormente, volver mediante el evento de lanzamiento de enlace a la verificación de nuevos estados en el rastreo. ◦ Resultado Obtenido: Con el evento de lanzamiento de enlace, se vuelve de forma fluida a la verificación de nuevos estados en el rastreo. NOMBRE DEL CASO DE PRUEBA:Obtener código de estado • Código del Caso de Prueba: CP9-BonitaBPM ◦ Descripción: Una vez finalizado un rastreo, se debe obtener el código de estado final del mismo. Para esto se utilizo una tarea de servicio que 118 CAPÍTULO 4. MARCO APLICATIVO tomara el código de la Base de Datos ◦ Prerrequisitos: Un rastreo de haber finalizado. ◦ Pasos a Seguir: 1. Ejecutar nuevo rastreo en Heritrix. 2. El rastreo es detectado por Pyinotify y almacenado en la Base de Datos. 3. En Bonita BPM, el subproceso Archivo Web de Venezuela, debe detec- tar el nuevo registro en la Base de Datos y enviar la notificación al Administrador. 4. Una vez que la notificación es enviada, se procede a verificar si existe un nuevo estado para el rastreo ejecutado. 5. Una vez detectado el estado de finalización de un rastreo, se tomar el valor de código de estado de la tabla status_code en la Base de Datos ◦ Resultado Esperado: Una vez finalizado el rastreo, obtener el código de estado final para posteriormente enviar la notificación al Administrador. ◦ Resultado Obtenido: Una vez finalizado el rastreo, al intentar obtener el código de estado ocurría un error; ya que este aún no había sido almace- nado en la Base de Datos • Código del Caso de Prueba: CP10-BonitaBPM ◦ Descripción: Una vez finalizado un rastreo, se debe obtener el código de estado final del mismo. Para esto se necesita monitorear si ya fue guardado el código en la Base de Datos. ◦ Prerrequisitos: Un rastreo de haber finalizado. ◦ Pasos a Seguir: 1. Ejecutar nuevo rastreo en Heritrix. 2. El rastreo es detectado por Pyinotify y almacenado en la Base de Datos. 3. En Bonita BPM, el subproceso Archivo Web de Venezuela, debe detec- tar el nuevo registro en la Base de Datos y enviar la notificación al Administrador. 4. Una vez que la notificación es enviada, se procede a verificar si existe un nuevo estado para el rastreo ejecutado. 5. Una vez detectado el estado de finalización de un rastreo, se debe ve- rificar si existe el código de estado final asociado a la tabla status_code en la Base de Datos 119 CAPÍTULO 4. MARCO APLICATIVO ◦ Resultado Esperado: Una vez finalizado el rastreo, obtener el código de estado final para posteriormente enviar la notificación al Administrador. ◦ Resultado Obtenido: Una vez finalizado el rastreo, se verifica si código de estado ya fue generado, de no ser así se continúa comprobándolo. En caso de que ya exista se envía la notificación al administrador. NOMBRE DEL CASO DE PRUEBA:Notificación de Rastreos Simultáneos • Código del Caso de Prueba: CP11-BonitaBPM ◦ Descripción: Una vez comprobado que para un rastreo se enviaban todas las notificaciones, se ejecutaron rastreos de forma simultánea para probar que para cada uno fueran enviadas las alertas correspondientes. ◦ Prerrequisitos: Deben haberse ejecutado múltiples rastreos ◦ Pasos a Seguir: 1. Ejecutar dos o más nuevos rastreos en Heritrix. 2. Los nuevos rastreos son detectados por Pyinotify y almacenados en la Base de Datos. 3. En Bonita BPM, el subproceso Archivo Web de Venezuela, debe detec- tar cada uno de los rastreos ejecutados y enviar las distintas notifica- ciones al Administrador. 4. Una vez que se detectan todos los nuevos rastreos, Bonita BPM, de- be verificar para cada uno de ellos sus distintos estados, enviado las notificaciones correspondientes cuando sea preciso. ◦ Resultado Esperado: Para cada una de los rastreos deben recibirse las di- ferentes notificaciones, por separado,indicando la información pertinente al rastreo referido. ◦ Resultado Obtenido: Se reciben las notificaciones por correo, de cada uno de los rastreos, con los datos correctos para cada uno de ellos. Con las pruebas que se realizaron se pudo comprobar que sus procesos funcionan de forma correcta, permitiendo extraer los datos de los archivos logs y reportes de Heritrix de forma inmediata al ocurrir un cambio y almacenarlos de forma estructural en la Base de Datos. Se pudo comprobar además que los datos almacenado son utilizados de forma apropiada por Bonita BPM para notificarle al Administrador cualquier hecho relevante que ocurra, incluyendo no solo los cambios en los estados de un rastreo sino también cualquier advertencia o error generado. 120 Conclusiones y Recomendaciones Al concluir la realización de este Trabajo Especial de Grado, se desarrolló exitosamente una Solución de Gestión de Procesos de Negocio para el Prototipo de Archivo Web de Venezuela, que permite la orquestación de sus módulos y la visualización de las distintas alertas y notificaciones asociadas a los rastreos generados en el subproceso de adquisi- ción de contenidos, utilizando los metadatos provistos por los archivos logs y reportes del rastreador Heritrix y analizando las herramientas disponibles en el mercado para poder construir dicha solución. La investigación se consolidó siguiendo una adaptación de la metodología del ciclo de vida BPM, con la realización de las etapas que conforman el ciclo, que van desde el descubrimiento, modelado y despliegue hasta la ejecución de un sistema que permite a los usuarios visualizar y recibir notificaciones cuando ocurre algo inusual o de importancia en el Prototipo de Archivo Web. Para la solución se tuvo como apoyo la herramienta de Gestión de Procesos de Negocio(BPM), Bonita BPM, la librería Pyinotify de Python, la cual fue usada para la extracción de la información y por último la Base de Datos MySQL para el posterior almacenamiento de la información extraída de los logs y reportes del rastreador Heritrix , gracias a estas herramientas fue posible la realización de este trabajo, además se puede afirmar que se logró modelar, monitorear y ejecutar un proceso que cumple con las expectativas antes mencionadas. Esta solución de Gestión de Proceso de Negocio (BPM) ofrece un gran aporte para el Prototipo de Archivo Web, ya que realiza un constante monitoreo de cada rastreo que se inicia, manteniendo informado al Administrador del Prototipo, por medio de notificacio- nes y alertas, las cuales son enviadas vía correo electrónico, incluyendo datos importantes como fechas de ejecución y la descripción asociada a cada estado o cambio, tanto en espa- ñol como en inglés, facilitando así la gestión del Archivo Web y la detección de errores o la prevención de los mismos. Además, la Base de Datos utilizada para almacenar los datos alusivos a los rastreos de Heritrix, será utilizada como fuente de datos para la solución de Inteligencia de Negocio que se encuentra en desarrollo para el Prototipo de Archivo Web de Venezuela Fue necesario realizar una adaptación del ciclo de vida BPM; ya que las fases de moni- toreo y optimización no se encontraron en el alcance del presente trabajo, ya que estas se realizan cuando se lleva la implementación a producción dentro de una organización, sin 121 CAPÍTULO 4. CONCLUSIONES Y RECOMENDACIONES embargo las otras fases del ciclo de vida BPM, nos permitieron avanzar rápida y ordena- damente durante el desarrollo, dando como resultado un producto usable y que satisface las necesidades de orquestación y notificación del Prototipo de Archivo Web, mediante la utilización de los archivos de salida generados por el rastreador Heritrix en cada ras- treo. Durante el desarrollo de la solución, se presentaron algunas limitantes al momento de acceder a los archivos del rastreador Heritrix; ya que aunque este rastreado web cuenta con una REST API, esta no cuenta con el acceso a los archivos logs y de reporte que fueron utilizados en esta solución, por lo que no se pudo realizar un conexión directa con Bonita BPM, sin embargo una vez establecida la utilización de una Base de datos intermedia y de la librería Pyinotify, el desarrolló de la solución fue más rápido ya que se comprendió el uso de las distintas herramientas y la conexión entre ellas. Para que sea posible ejecutar automáticamente un nuevo rastreo, desde el proceso de Archivo Web realizado, debe existir una conexión entre el proceso y el módulo de Adqui- sición del Prototipo de Archivo Web, por lo que se recomienda como trabajo a futuro la creación de un servicio Web que se encargue de realizar la llamada a Heritrix, indicando sobre quien es el nuevo rastreo que se iniciará. Al finalizar un rastreo, en Heritrix, se almacenan los archivos WARC finales. El proceso del Prototipo de Archivo Web detecta cuando finaliza un rastreo ejecutado, sin embar- go, no puede informarle al módulo de almacenamiento e indexación que debe almacenar nuevos WARC, ni detectar si hubo algún cambio en el sitio Web desde el último rastreo, por lo que se plantea como trabajo a futuro la creación de un servicio web que se comuni- que con el módulo de almacenamiento e indexación para indicar la presencia de nuevos WARC, de forma tal que se pueda lograr la integración entre el proceso del Prototipo de Archivo Web y el cluster Hadoop. Por otra parte la REST API de Heritrix permite su invocación para la creación de un nuevo Job, añadir un Job al directorio, configurar, ejecutar, pausar y terminar un Job, entre otros. Sin embargo, no provee el acceso a los archivos logs y de reporte finales pertenecientes a la ejecución de un rastreo, implementando está función en la REST API de Heritrix se podría realizar la conexión directa con el proceso modelado en este trabajo, permitiendo así reemplazar la utilización de la librería pyinotify. 122 Bibliografía (2011). Heritrix output. https://webarchive.jira.com/wiki/spaces/ Heritrix/pages/6422703/Heritrix+Output. (2013). Monitoring a filesystem with python and pyinotify. https://webarchive. jira.com/wiki/spaces/Heritrix/pages/5735682/Logs. (2017). Mysql. https://es.wikipedia.org/wiki/MySQL. Allweyer., T. (2011). Creating a simple business collaboration scenario with a bpms. https://www.kurze-prozesse.de/blog/wp-content/uploads/ 2011/06/A-Simple-Business-Collaboration-Scenario.pdf. Alvarado, P. (2011). Bonita soft: Gestor de procesos de negocios bpm. Master’s thesis, Universidad Nacional de Colombia, Fac. de Ciencias Económicas, Unidad de informática y comunicaciones. Bogotá. Archive, I. (09 de 06 de 2011). Heritrix. http://rastreador.archive.org/. Bergamin., J. (2011). Monitoring a filesystem with python and pyinotify. https://www.saltycrane.com/blog/2010/04/ monitoring-filesystem-python-and-pyinotify/. Bermes, E. and Illien, G. (2009). Metrics and strategies for web heritage management and preservation. 92 statistics ans evaluation, information tecnology and preservation and conservation. Technical report, Milan, Italy. Brown, A. (2006). Archiving websites. london: Facet publishing. Technical report. Carhuatocto, R. (2011). jbpm, bonita, intalio, processmaker, activiti. ¿qué bpm suite uso? https://holisticsecurity.io/2011/07/21/ jbpm-bonita-intalio-processmakeractiviti-que-bpm-suite-uso/. Carreño, A. (2016). Informe final de pasantías. Technical report. Castillo, L. and Milano, G. (2014). Definición de las estrategias para el desarrollo del mó- dulo de administración a los contenidos preservados en formato warc para el prototipo de archivo web de venezuela. Master’s thesis, UCV, Fac. Ciencias, Esc. Computación. Caracas: UCV. 123 https://webarchive.jira.com/wiki/spaces/Heritrix/pages/6422703/Heritrix+Output https://webarchive.jira.com/wiki/spaces/Heritrix/pages/6422703/Heritrix+Output https://webarchive.jira.com/wiki/spaces/Heritrix/pages/5735682/Logs https://webarchive.jira.com/wiki/spaces/Heritrix/pages/5735682/Logs https://es.wikipedia.org/wiki/MySQL https://www.kurze-prozesse.de/blog/wp-content/uploads/2011/06/A-Simple-Business-Collaboration-Scenario.pdf https://www.kurze-prozesse.de/blog/wp-content/uploads/2011/06/A-Simple-Business-Collaboration-Scenario.pdf http://rastreador.archive.org/ https://www.saltycrane.com/blog/2010/04/monitoring-filesystem-python-and-pyinotify/ https://www.saltycrane.com/blog/2010/04/monitoring-filesystem-python-and-pyinotify/ https://holisticsecurity.io/2011/07/21/jbpm-bonita-intalio-processmaker activiti-que-bpm-suite-uso/ https://holisticsecurity.io/2011/07/21/jbpm-bonita-intalio-processmaker activiti-que-bpm-suite-uso/ BIBLIOGRAFÍA Cejas, J. (2008). Intalio bpm introducción. https://es.slideshare.net/ jcejas/intaliobpms-introduccion. Coba, L. (2013). Comparativo bpm. https://es.slideshare.net/luiscoba/ comparativo-bpm. Fitch, K. (2003). Web site archiving: An approach to recording every materially. Technical report, Sanctuary Cove, Australia. G., M. (2011). Heritrix3. https://webarchive.jira.com/wiki/display/ Heritrix/Heritrix3. Herrera., A. (2012). Arquitectura software. http://arquitecturasoftwareai. blogspot.com/2012/10/attribute-driven-design-add-20.html. Herrera, R. and Fontalvo, T. Seis sigma métodos estadísticos y sus apli- caciones. http://biblioteca.utec.edu.sv/siab/virtual/elibros_ internet/55821.pdf. Herrera, R. and Fontalvo, T. (2001). ¿qué es seis sigma? meto- dología e implementación. https://www.gestiopolis.com/ que-es-seis-sigma-metodologia-e-implementacion/. Hurtado de Barrera, J. (2014). Un Marco de Referencia para la Implementación de Archivos Web. Quiron, Caracas, Venezuela, 5ta edición. edition. IIPC (2013). International internet preservation consortium. http://netpreserve. org/. ISO (2008). Iso. the warc file format. Technical report. ISO (2009). Iso. 28500 information and documentation-warc file format. Technical re- port, Nueva Zelanda. Martinez, M. and Kabchi, M. (2004). Desarrollo del módulo de acceso a los contenidos preservados en formato warc para el prototipo de archivo web de venezuela. Master’s thesis, UCV, Fac. Ciencias, Esc. Computación. Caracas: UCV. Masanès, J. (2006). Web archive. Technical report, New York, USA: Springer-Verlag. Montero, E. and Pérez, H. (2016). Estudio de conceptos, estrategias y técnicas que permi- tan el desarrollo del módulo de indexación y búsqueda para el prototipo de archivo web venezuela para la búsqueda de los contenidos web almacenados en un cluster hadoop bajo el formato warc. Master’s thesis, UCV, Fac. Ciencias, Esc. Computación. Caracas: UCV. Ospina Torres, M. (2014). Un marco de referencia para la implementación de archivos web. Master’s thesis, UCV, Fac. Ciencias, Esc. Computación. Caracas: UCV. 124 https://es.slideshare.net/jcejas/intalio bpms-introduccion https://es.slideshare.net/jcejas/intalio bpms-introduccion https://es.slideshare.net/luiscoba/comparativo-bpm https://es.slideshare.net/luiscoba/comparativo-bpm https://webarchive.jira.com/wiki/display/Heritrix/Heritrix3 https://webarchive.jira.com/wiki/display/Heritrix/Heritrix3 http://arquitecturasoftwareai.blogspot.com/2012/10/attribute-driven-design-add-20.html http://arquitecturasoftwareai.blogspot.com/2012/10/attribute-driven-design-add-20.html http://biblioteca.utec.edu.sv/siab/virtual/elibros_internet/55821.pdf http://biblioteca.utec.edu.sv/siab/virtual/elibros_internet/55821.pdf https://www.gestiopolis.com/que-es-seis-sigma-metodologia-e-implementacion/ https://www.gestiopolis.com/que-es-seis-sigma-metodologia-e-implementacion/ http://netpreserve.org/ http://netpreserve.org/ BIBLIOGRAFÍA Ospina Torres, M. H. and Leon Luna, C. P. (2013). Una arquitectura basada en software libre para archivos web. Technical report. Peralta, M. (2008). Sistema de información. http://www.monografias.com/ trabajos7/sisinf/sisinf.shtml. Pérez, J. (2004). Gestión por procesos. Madrid, España: ESIC Editorial., Madrid, España, 4ta edición. edition. Rivero, L. and Garcia, J. (2013). Implementación de los módulos de adquisición y al- macenamiento de un prototipo para el archivado de sitios web en venezuela. Master’s thesis, UCV, Fac. Ciencias, Esc. Computación. Caracas: UCV. seb m (2012). Pyinotify. https://github.com/seb-m/pyinotify/wiki. Silberschatz, A., K. H. and Sudarshan, S. (2002). Fundamentos de Base de Datos. Bombay. España: McGRAW-HILL., 4ta edición. edition. Silva, R. (2009). Sistema de información. http://www.monografías.com. Silva, R. (2010). Tipos de sistemas de información. http://si-2010-1-e4. blogspot.com/. Smith, H.and Fingar, P. (2003). Business process management (bpm): The third wave. Technical report, Tampa, EUA: Meghan-Kiffer Press. UNESCO (2003). Directrices para la preservaciÓn del patrimonio digital. Technical re- port, Australia: Biblioteca Nacional de Australia. Valdéz, L. (2009). Modelado del proceso de gestión de cambios según itil bajo el software libre intalio. Master’s thesis, UCV, Fac. Ciencias, Esc. Computación. Caracas: UCV. Villasís, J. (2013). Metodología para el análisis, diseño e implementación de procesos con tecnología bpm (business process management) y desarrollo de un caso prácti- co. Master’s thesis, Escuela Politécnica del Ejército, Departamento de Ciencias de la Computación. Sangolquí, Ecuador. White, S. and Miers, D. (2009). Bpmn. guía de referencia y modelado. Technical report, Florida, EUA: Future Strategies Inc. 125 http://www.monografias.com/trabajos7/sisinf/sisinf.shtml http://www.monografias.com/trabajos7/sisinf/sisinf.shtml https://github.com/seb-m/pyinotify/wiki http://www.monograf�as.com http://si-2010-1-e4.blogspot.com/ http://si-2010-1-e4.blogspot.com/ Resumen Introducción Problema de Investigación Planteamiento del Problema Objetivos Objetivo General Objetivos Específicos Alcance Marco Conceptual Patrimonio Digital Preservación Web Archivos Web Módulo de Adquisición Módulo de Almacenamiento Archivos WARC Módulo de Indexación y Búsqueda Herramienta de Rastreo Tipos de Rastreo Heritrix Arquitectura Principales Características de Heritrix Salidas de Heritrix Registros de Heritrix Limitaciones de Heritrix Sistema de Información Actividades que realizan los sistemas de información Tipos de Sistemas de Información Sistemas de Soporte a Ejecutivos Sistema de Soporte de Decisiones Sistemas de Información Gerencial Sistemas de Trabajo de Conocimiento y Sistemas de Automatización de la Oficina Sistemas de Procesamiento de Transacciones Base de Datos Definición Modelos de Base de datos Base de Datos Relacionales Sistemas Gestores de Bases de Datos Objetivos de los SGBD Ventajas de los SGBD Ventajas de los SGBD MySQL Características de MySQL Procesos de Negocio Componentes de un Proceso de Negocio Principales Tipos de Procesos de Negocio Gestión de Procesos de Negocio (BPM, Business Process Management) Sistemas de Gestión de Procesos de Negocio (BPMS, Business Process Management Systems) Modelo y Notación de Procesos de Negocios (BPMN, Business Process Model and Notation) Elementos de BPMN Lenguaje de Ejecución de Procesos de Negocios (BPLE, Business Process Execution Language) Beneficios de una Herramienta BPMS en una Organización Bonita BPM Funciones de la Plataforma Bonita BPM Versiones Elementos propios de Bonita BPM Módulos de Bonita BPM Servicios Web Características de los Servicios Web Ventajas y Desventajas de los Servicios Web Lenguaje de Programación Tipos de Lenguajes de Programaión Lenguajes interpretados Python Módulos Marco Metodológico Metodologías de Desarrollo Ciclo de Vida BPM Descubrimiento Modelado Despliegue Ejecución Monitoreo Optimización Marco Aplicativo Definición de Requerimientos Diseño Técnico Herramientas Tecnológicas Bonita BPM Servicios Web Python MySQL Etapas del Proyecto Descubrimiento Modelado Subproceso: Notificaciones Subproceso: Archivo Web de Venezuela Despliegue Ejecución Rastreo Ejecutado Genera una Advertencia Rastreo Ejecutado Finaliza con un Error Rastreo Ejecutado Finalizado Rastreo Ejecutado No Finalizado Pruebas Funcionales y No Funcionales Conclusiones y Recomendaciones Bibliografía