Universidad Central de Venezuela Facultad de Ciencias Escuela de ComputaciÃ³n Centro de ComputaciÃ³n GrÃ¡fica TÃ‰CNICAS DE REDUCCIÃ“N DE MALLAS EN TIEMPO REAL EMPLEANDO WEBGL Trabajo Especial de Grado en la Lic. De ComputaciÃ³n Autor: AndrÃ©s AgustÃ­n Gomes Restrepo Tutor: Esmitt RamÃ­rez Caracas, Febrero de 2018 Agradecimientos y dedicatorias Dedico este trabajo principalmente a mi familia y amigos por haberme dado su apoyo incondicional. En especial a mis padres Maritza Restrepo y AgustÃ­n Gomes y mi tÃ­o JosÃ© Alex Restrepo que gracias a ellos tuve la oportunidad de cursar mis estudios en esta instituciÃ³n. Agradecimientos a mi tutor Esmitt RamÃ­rez por ser mi guÃ­a durante todo este proceso. Resumen En ComputaciÃ³n GrÃ¡fica, lograr un balance entre el nivel de detalle y la portabilidad de un algoritmo es esencial. Al aumentar la complejidad del modelo geomÃ©trico se suavizan los bordes y se mejora la percepciÃ³n de sus elementos, pero se reduce su portabilidad. Con el objetivo de mantener el balance es necesario reducir dicha complejidad en dispositivos con menor capacidad. Para lograr esto es necesario un algoritmo que simplifique el modelo, sea en tiempo real, adecuado para cualquier dispositivo y conserve la topologÃ­a del modelo, manteniendo la apariencia estÃ©tica. En este Trabajo Especial de Grado se presenta un algoritmo capaz de realizar simplificaciones en tiempo real utilizando las capacidades de procesamiento paralelo de la GPU (Graphics Processing Unit) sobre WebGL. Esto permite que empleando un navegador con capacidades de acceso al API (Application Programming Interface) de WebGL pueda realizarse el proceso de simplificaciÃ³n y exportarse de forma eficiente para su uso en otras aplicaciones. El algoritmo propuesto reduce la cantidad de polÃ­gonos de una malla geomÃ©trica sin afectar su topologÃ­a. Las pruebas realizadas demuestran la efectividad de esta propuesta. Keywords: ReducciÃ³n de mallas, nivel de detalle, simplificaciÃ³n, WebGL, API, Threejs Ãndice INTRODUCCIÃ“N ....................................................................................................................................................................... 6 CAPÃTULO 1 PLANTEAMIENTO DEL PROBLEMA .......................................................................................................... 7 1.1 CONCEPTOS BÃSICOS ........................................................................................................................................................... 7 1.2 COMPUTACIÃ“N EN TRES DIMENSIONES Y MALLAS................................................................................................................. 8 1.3 DESCRIPCIÃ“N DEL PROBLEMA ............................................................................................................................................. 12 1.4 OBJETIVO GENERAL ........................................................................................................................................................... 13 1.5 OBJETIVOS ESPECÃFICOS ..................................................................................................................................................... 13 CAPÃTULO 2 REDUCCIÃ“N DE MALLAS ........................................................................................................................... 14 2.1 PRIMEROS ALGORITMOS DE SIMPLIFICACIÃ“N DE MALLAS ................................................................................................... 14 2.2 BIBLIOTECAS PARA LA REDUCCIÃ“N DE MALLAS.................................................................................................................. 16 2.2.1 Biblioteca CGAL ........................................................................................................................................................ 16 2.2.2 Biblioteca VTK ........................................................................................................................................................... 20 2.3 TÃ‰CNICAS MODERNAS DE REDUCCIÃ“N DE MALLAS ............................................................................................................. 28 2.3.1 Billboard clouds para simplificaciÃ³n extrema de modelos ........................................................................................ 28 2.3.2 SimplificaciÃ³n de mallas en tiempo real utilizando la GPU ...................................................................................... 31 CAPÃTULO 3 SOLUCIÃ“N PROPUESTA .............................................................................................................................. 40 3.1 DESCRIPCIÃ“N GENERAL ...................................................................................................................................................... 40 3.2 IMPLEMENTACIÃ“N .............................................................................................................................................................. 41 3.3 IMPLEMENTACIÃ“N DEL ALGORITMO DE SIMPLIFICACIÃ“N .................................................................................................... 43 3.4 IMPLEMENTACIÃ“N DE LA INTERFAZ .................................................................................................................................... 45 4 PRUEBAS Y RESULTADOS ................................................................................................................................................ 49 4.1 AMBIENTE DE PRUEBAS ...................................................................................................................................................... 49 4.2 MODELOS UTILIZADOS ....................................................................................................................................................... 49 4.3 PRUEBAS CUANTITATIVAS .................................................................................................................................................. 50 4.4 PRUEBAS CUALITATIVAS .................................................................................................................................................... 51 5 CONCLUSIONES Y RECOMENDACIONES .................................................................................................................... 58 BIBLIOGRAFÃA........................................................................................................................................................................ 60 6 IntroducciÃ³n En ComputaciÃ³n GrÃ¡fica, uno de los principales objetivos es lograr un balance entre el nivel de detalle y la portabilidad de un algoritmo. Nivel de detalle se entiende como la complejidad que posee un modelo geomÃ©trico en computadora. Al aumentar la complejidad se suavizan los bordes y se mejora la percepciÃ³n de los diferentes elementos que componen el modelo. Por otro lado, la portabilidad se entiende como la capacidad que tiene un algoritmo de ejecutarse en diferentes dispositivos. Al aumentar la portabilidad, una mayor cantidad de usuarios son capaces de hacer uso de la aplicaciÃ³n en sus dispositivos. La evoluciÃ³n en la complejidad de los modelos superÃ³ la capacidad de procesamiento de los dispositivos, debido a la creaciÃ³n de herramientas digitales capaces de hacer una correspondencia entre objetos del mundo real y modelos de computadora (proceso conocido como mapping), como los escÃ¡neres CT (Computed Tomography), MRI (Magnetic Resonance Imaging) o los lÃ¡seres para escanear grandes superficies que generan modelos en computadoras con niveles de detalle inmanejables por los dispositivos de uso domÃ©stico (e.g. generalmente, se requieren equipos con altas capacidades grÃ¡ficas). Para un dispositivo de distribuciÃ³n comercial, no es posible desplegar en una aplicaciÃ³n grÃ¡fica mÃºltiples de estos modelos. Una de las soluciones mÃ¡s implementadas para solventar inconveniente es el uso de la tÃ©cnica LOD (Level Of Detail), que reduce la complejidad de los modelos segÃºn su distancia con respecto a la cÃ¡mara. Una forma de reducir dicha complejidad para un modelo es utilizando algoritmos de simplificaciÃ³n. Un algoritmo de simplificaciÃ³n busca reducir los elementos que componen un modelo sin afectar su topologÃ­a, manteniendo la apariencia estÃ©tica. Estos algoritmos suelen ser lentos debido a que se deben hacer cÃ¡lculos complejos por cada elemento del modelo, con el fin de determinar la mejor manera de eliminar un elemento del objeto 3D. En este Trabajo Especial de Grado se describe un algoritmo que es capaz de realizar simplificaciones en tiempo real utilizando las capacidades de procesamiento paralelo de la GPU (Graphics Processing Unit). Esto implementado en la API (Application Programming Interface) grÃ¡fico WebGL [1], sobre el lenguaje Javascript. En el capÃ­tulo 1 se plantea el inconveniente que se desea resolver con el algoritmo de reducciÃ³n de mallas geomÃ©tricas. En el capÃ­tulo 2 se explica en detalle los algoritmos de simplificaciÃ³n y el Ã¡rea de la ComputaciÃ³n enfocada en la simplificaciÃ³n de mallas. En el capÃ­tulo 3 se describen los detalles referentes a la soluciÃ³n desarrollada en este trabajo. En el capÃ­tulo 4 se describe la implementaciÃ³n del algoritmo de simplificaciÃ³n de mallas en tiempo real. En el capÃ­tulo 5 se exponen los resultados obtenidos al realizar pruebas de rendimiento sobre el algoritmo de simplificaciÃ³n en tiempo real. En el capÃ­tulo 6 se presentan las conclusiones y trabajos futuros. 7 CapÃ­tulo 1 Planteamiento del problema Antes de poder describir el inconveniente existente al trabajar con modelos con alto nivel de detalle se deben definir algunos conceptos bÃ¡sicos. 1.1 Conceptos BÃ¡sicos La ComputaciÃ³n GrÃ¡fica es el campo de las ciencias de la computaciÃ³n encargada del estudio, diseÃ±o y despliegue de imÃ¡genes por medio del computador. Existe la representaciÃ³n digital de imÃ¡genes en dos dimensiones, como objetos geomÃ©tricos 2D, texto e imÃ¡genes digitales en general. Esta representaciÃ³n se hace modificando imÃ¡genes con diferentes transformaciones geomÃ©tricas. A continuaciÃ³n estudiaremos las transformaciones geomÃ©tricas de traslaciÃ³n, escalamiento y rotaciÃ³n. TraslaciÃ³n, en la translaciÃ³n se desplaza cada punto de la imagen, una distancia constante en una direcciÃ³n especÃ­fica, con lo que permanecerÃ¡ inalterada la imagen pero trasladada del punto original, a esta transformaciÃ³n geomÃ©trica se la denomina rÃ­gida ya que la imagen permanece inalterada (rÃ­gida) durante la transformaciÃ³n. ğ‘‡ğ‘£ğ‘· = ( 1 0 0 ğ‘£ğ‘¥ 0 1 0 ğ‘£ğ‘¦ 0 0 1 ğ‘£ğ‘§ 0 0 0 1 )( ğ‘ğ‘¥ ğ‘ğ‘¦ ğ‘ğ‘§ 1 ) = ( ğ‘ğ‘¥ + ğ‘£ğ‘¥ ğ‘ğ‘¦ + ğ‘£ğ‘¦ ğ‘ğ‘§ + ğ‘£ğ‘§ 1 ) = ğ’‘+ ğ‘£ Escalamiento, en el escalamiento se multiplican los valores del modelo geomÃ©trico por un vector ğ‘£ = ( ğ‘£ğ‘¥ ,ğ‘£ğ‘¦,ğ‘£ğ‘§, ), en el que cada elemento de ese vector alterarÃ¡ el grosor del modelo original proporcionalmente a su valor en su respectivo eje (puede incluso ser negativo y hacer un efecto espejo). ğ‘†ğ‘£ = ( ğ‘£ğ‘¥ 0 0 0 ğ‘£ğ‘¦ 0 0 0 ğ‘£ğ‘§ )( ğ‘ğ‘¥ ğ‘ğ‘¦ ğ‘ğ‘§ ) = ( ğ‘£ğ‘¥ğ‘ğ‘¥ ğ‘£ğ‘¦ğ‘ğ‘¦ ğ‘£ğ‘§ğ‘ğ‘§ ) RotaciÃ³n, en la rotaciÃ³n se hace rotar al modelo geomÃ©trico segÃºn un vector de rotaciÃ³n junto a un Ã¡ngulo de rotaciÃ³n, esta transformaciÃ³n tambiÃ©n es rÃ­gida, ya que no altera la forma del modelo, solo su direcciÃ³n. ğ‘…(ğœƒ) = ( ğ‘ğ‘œğ‘ ğœƒ âˆ’ğ‘ ğ‘–ğ‘›ğœƒ ğ‘ ğ‘–ğ‘›ğœƒ ğ‘ğ‘œğ‘ ğœƒ ) ğ‘…(ğœƒ)ğ‘£ = ( ğ‘ğ‘œğ‘ ğœƒ âˆ’ğ‘ ğ‘–ğ‘›ğœƒ ğ‘ ğ‘–ğ‘›ğœƒ ğ‘ğ‘œğ‘ ğœƒ ) ( ğ‘¥ ğ‘¦) = ğ‘¥â€² = ğ‘¥ğ‘ğ‘œğ‘ ğœƒ âˆ’ ğ‘¦ğ‘ ğ‘–ğ‘›ğœƒ ğ‘¦â€² = ğ‘¥ğ‘ ğ‘–ğ‘›ğœƒ + ğ‘¦ğ‘ğ‘œğ‘ ğœƒ La rotaciÃ³n serÃ¡ en direcciÃ³n de las agujas del reloj si el Ã¡ngulo es negativo, y contra las agujas del reloj si es positivo. La principal limitante de la representaciÃ³n en dos dimensiones es la dificultad para hacer una representaciÃ³n fiel a la realidad, para poder lograr esto se necesitarÃ¡ usar estructuras geomÃ©tricas mÃ¡s complejas. En ComputaciÃ³n GrÃ¡fica se hace uso de algoritmos particulares para entornos 2D, 3D, y en muchos trabajos se mezclan libremente por lo que a veces es difÃ­cil determinar con certeza las diferencias entre estos campos. En la computaciÃ³n en 3D el elemento principal para desplegar objetos y superficies son las mallas, a continuaciÃ³n se explicarÃ¡ en quÃ© consisten las mallas. 8 1.2 ComputaciÃ³n en tres dimensiones y mallas Una malla es una superficie compuesta por figuras geomÃ©tricas generadas por intercepciones entre puntos en el espacio, formando figuras geomÃ©tricas como triÃ¡ngulos, cuadrilÃ¡teros, tetraedros, polÃ­gonos convexos o polÃ­gonos con agujeros. Una malla posee, vÃ©rtices, aristas, caras, polÃ­gonos y superficies. Estos elementos son los que forman la base de la estructura de una malla. Se puede ver un ejemplo de estos elementos en la Figura 1. (a) VÃ©rtices (b) Aristas (c) Caras Figura 1: Elementos bÃ¡sicos de una malla. (a) VÃ©rtices, o puntos en el espacio. (b) Aristas, conexiones entre los vÃ©rtices. (c) Caras, figura geomÃ©trica formada a partir de la conexiÃ³n de 3 o mÃ¡s vÃ©rtices. Los vÃ©rtices son la base atÃ³mica de la malla que describen una posiciÃ³n en el espacio y otros atributos como color, vector normal y coordenadas de textura, los vÃ©rtices por si mismos no describen una superficie por ser elementos inconexos. Las aristas son las conexiones entre dos vÃ©rtices relacionados, estas no poseen atributos ni valores por sÃ­ mismas, ya que son estructuras derivadas de las caras. Las caras son superficies planas formadas por la conexiÃ³n entre tres o mÃ¡s vÃ©rtices. En las caras es donde se harÃ¡ uso de los atributos pertenecientes a los vÃ©rtices aplicando en ella los colores, texturas y fenÃ³menos fÃ­sicos que requieran de los vectores normales. En el trabajo de Hoppe [2] una malla se define como un par (ğ‘½,ğ‘²) donde ğ‘½ = { ğ’—ğ’Š âˆˆ ğ‘¹ ğŸ‘ | ğ’Š âˆˆ { ğŸ, . . . ,ğ’} } es un conjunto de vÃ©rtices en el espacio y ğ¾ un complejo simplicial. Un complejo simplicial es un espacio topolÃ³gico construido mediante puntos unidos por una conexiÃ³n lineal, formando los polÃ­gonos que darÃ¡n forma al modelo. El conjunto simplicial estÃ¡ conformado por subconjuntos de V que representan los elementos de la malla. Los simplejos que contengan solo un elemento, son los vÃ©rtices de la malla, los simplejos que contengan dos elementos, son las aristas de la malla, y los simplejos que contengan tres elementos, son las caras de la malla. {ğ‘£0} = 0âˆ’ ğ‘ ğ‘–ğ‘šğ‘ğ‘™ğ‘’ğ‘—ğ‘œ {ğ‘£0,ğ‘£1} = 1âˆ’ ğ‘ ğ‘–ğ‘šğ‘ğ‘™ğ‘’ğ‘—ğ‘œ {ğ‘£0,ğ‘£1,ğ‘£2} = 2 âˆ’ ğ‘ ğ‘–ğ‘šğ‘ğ‘™ğ‘’ğ‘—ğ‘œ 9 En algunas definiciones se harÃ¡ uso de operadores para englobar conjuntos de simplejos. Estas operaciones solo se utilizan como herramienta para resumir algunos conceptos, por lo que es posible que no se consigan otras referencias ademÃ¡s de Lindstrom [3]. Los operadores âŒŠ âŒ‹ âŒˆ âŒ‰ que se denominarÃ¡n en este trabajo como operadores de conjuntos. Funcionan de la siguiente manera. Siendo ğ’” un n-simplejo, el operador de conjunto inferior âŒŠğ’”âŒ‹ retorna todos los elementos (n-1)-simplejo pertenecientes a ğ’” y el operador de conjunto superior âŒˆğ’”âŒ‰ retorna todos los (n+1)-simplejos que contengan a ğ’” (ver Figura 2). Los 0-simplejos son todos los vÃ©rtices de la malla. Los 1-simplejos son las aristas de la malla ğ = { âŒŠğ’†âŒ‹ğŸ, âŒŠğ’†âŒ‹ğŸ }. Si la arista es orientada se la expresa como ï¿½âƒ—ï¿½ = (âŒŠğ’†âŒ‹ğŸ, âŒŠğ’†âŒ‹ğŸ). Todas las aristas se consideran orientadas y solo se diferenciarÃ¡n entre ï¿½Ì…ï¿½ ğ‘¦ ï¿½âƒ—ï¿½ para resolver ambigÃ¼edades. Las aristas se pueden clasificar como borde, simple o mÃºltiple, las aristas bordes solo coinciden con una cara |âŒˆğ’”âŒ‰| = ğŸ, las aristas simples coinciden con exactamente dos caras |âŒˆğ’”âŒ‰| = ğŸ, y las aristas mÃºltiples coinciden con tres o mÃ¡s caras |âŒˆğ’”âŒ‰| â‰¥ ğŸ‘ . Los 2-simplejos son las caras de la malla ğ’• = { ï¿½âƒ—ï¿½ ğ’•ğŸ, ï¿½âƒ—ï¿½ ğ’• ğŸ, . . , ï¿½âƒ—ï¿½ ğ’• ğ’ } = { (ğ’— ğ’• ğŸ,ğ’— ğ’• ğŸ), (ğ’— ğ’• ğŸ,ğ’— ğ’• ğŸ), . . , (ğ’— ğ’• ğ’,ğ’— ğ’• ğŸ)}. Por facilidad se expresarÃ¡ como ğ’• = (ğ’—ğ’•ğŸ,ğ’— ğ’• ğŸ, . . ,ğ’— ğ’• ğ’) que significa {(ğ’— ğ’• ğŸ,ğ’— ğ’• ğŸ), (ğ’— ğ’• ğŸ,ğ’— ğ’• ğŸ), â€¦ , (ğ’— ğ’• ğ’,ğ’— ğ’• ğŸ)}. En la Figura 2 se exponen unos ejemplos del uso de los operadores de conjunto. (a) El operador de conjunto superior aplicado a un vÃ©rtice retorna las aristas que contengan ese vÃ©rtice. (b) Al aplicarle el operador de conjunto superior al resultado de (a) retorna las caras que contienen las aristas que contienen al vÃ©rtice v. (c) Al aplicarle el operador de conjunto inferior al resultado de (a) retorna los vÃ©rtices contenidos en las aristas que contienen al vÃ©rtice v. (d) El conjunto inferior de una arista retorna los vÃ©rtices que la componen. (e) Al aplicar el operador de conjunto superior al resultado de (d) retorna todas las aristas que contengan al menos uno de los vÃ©rtices que contiene la arista e. (f) Al aplicar el operador de conjunto superior al resultado de (e) retorna las caras que contengan al menos una arista que contenga al menos uno de los vÃ©rtices que contiene la arista e. Figura 2: Ejemplo del uso de los operadores de conjunto âŒˆğ‘ âŒ‰ y âŒŠğ‘ âŒ‹. 10 Existen otros elementos que posee la malla que se diferencian de estos primeros en que no contienen informaciÃ³n referente a la topologÃ­a de la malla. Estos atributos poseen informaciÃ³n como el color, las coordenadas de la textura, vectores normales, que son utilizados en la fase de renderizado del modelo para aÃ±adir mÃ¡s detalles a la malla, como mÃ¡s realismo o una mejor apariencia. Las fuentes mÃ¡s comunes para generar las mallas son cuando un artista o ingeniero crea el modelo utilizando alguna aplicaciÃ³n de modelado o cuando se escanea directamente de un objeto del mundo real. Esto genera un archivo que contiene todos los vÃ©rtices de la malla y sus conexiones para formar la topologÃ­a, en la mayorÃ­a de los casos, el elemento geomÃ©trico mÃ¡s utilizado para las mallas es el triÃ¡ngulo, por lo que es comÃºn que la mayorÃ­a de los formatos estÃ©n planteados originalmente para trabajar con triÃ¡ngulos, algunos ejemplos de estos formatos son: 1. .raw: Este es un formato bÃ¡sico. En este cada lÃ­nea contiene tres vÃ©rtices descritos de la forma: X1 Y1 Z1 X2 Y2 Z2 X3 Y3 Z3, lo que ademÃ¡s de proporcionar los vÃ©rtices, tambiÃ©n describe las caras para formar la topologÃ­a de la malla. Hay que tomar en cuenta que este formato no contiene informaciÃ³n relacionada a los atributos, como las texturas o normales, solo la topologÃ­a del modelo. 2. .obj: Este es un formato mÃ¡s completo. En este se especifican los vÃ©rtices uno por uno, luego los vÃ©rtices de textura, los vectores normales y las caras. TambiÃ©n dispone de soporte para otros atributos como los materiales o vectores paramÃ©tricos, para un mayor nivel de detalle. A continuaciÃ³n se presenta un ejemplo de un archivo obj. #De esta forma se declara un comentario #Los vÃ©rtices se declaran con una v seguida de las coordenadas (x, y, z) mÃ¡s una coordenada w opcional que serÃ¡ un valor de contrapeso utilizado para curvas racionales y superficies, si no se especifica su valor por defecto es 1 â€¦ v -5.000000 5.000000 0.000000 v 5.000000 5.000000 0.000000 1.000000 â€¦ #Los vÃ©rtices tendrÃ¡n un Ã­ndice segÃºn su orden comenzando por 1 que se utiliza para declarar otros elementos. #Las coordenadas de textura comienzan con vt y se especifican las coordenadas (x, y) y un valor opcional w que definirÃ¡ la profundidad, por defecto es 0 â€¦ vt 0.500000 1.000000 0.000000 vt 1.000000 0.000000 â€¦ #Los vectores normales comienzan con vn y la direcciÃ³n del vector (x, y, z), estos vectores no necesariamente son vectores unitarios. â€¦ vn 0.707000 0.000000 0.707000 ... #Las caras se definen comenzando con una f y tres o mÃ¡s grupos de Ã­ndices que representan los vÃ©rtices mencionados anteriormente, si solo se desea definir caras sin atributos solo se deben agregar los Ã­ndices 11 de los vÃ©rtices, si se desea agregar atributos, se concatena el Ã­ndice del atributo al Ã­ndice del vÃ©rtice utilizando el sÃ­mbolo â€œ/â€ como separador. ... #VÃ©rtices sin atributos f 1 2 3 ... #VÃ©rtices con texturas f 3/1 4/2 5/3 ... #VÃ©rtices con texturas y vectores normales f 6/4/1 3/5/3 7/6/5 ... #VÃ©rtices con vectores normales sin texturas f 6//1 3//3 7//5 ... 3. .dae: Este formado comÃºnmente conocido como COLLADA, es usado con el fin de servir de formato de intercambio para aplicaciones interactivas en 3D. En este se define un esquema XML estÃ¡ndar con el que se puede intercambiar informaciÃ³n digital entre diferentes aplicaciones grÃ¡ficas que de otra manera usarÃ­an protocolos privados e incompatibles entre ellas. En este documento la informaciÃ³n se guarda en un formato de etiquetas XML quedando de la siguiente forma: <library_visual_scene> <visual_scene> <node> <library_physics_scene> <physics_scene> <instance_physics_model> <instance_rigid_body> Target=â€â€ <instance_ridig_constraint> <instance_force_field> <library_physics_models> <physics_model> <rigid_body> <instance_physics_material> <rigid_constraint> <library_physics_materials> <physics_material> <library_force_fields> 12 <force_fields> <scene> <instance_physics_scene> <instance_visual_scene> Las mallas son utilizadas en una gran variedad de programas de computadora donde se busca representar de una manera mÃ¡s grÃ¡fica al usuario el resultado del programa. Algunos programas que hacen uso de las mallas son los editores de video con los que se pueden generar animaciones con altos niveles de detalle o agregar efectos especiales a un video. Otros serÃ­an los editores CAD (Computer Aided Design/Drafting), que son aplicaciones cuyo objetivo principal es el apoyo para la creaciÃ³n, modificaciÃ³n y anÃ¡lisis de un modelo geomÃ©trico con los que se pueden diseÃ±ar elementos a ser fabricados o impresos en 3D con una precisiÃ³n de milÃ­metros, los motores grÃ¡ficos para videojuegos, los videojuegos buscan tener los grÃ¡ficos mÃ¡s realistas y con el mayor nivel de detalle que el hardware disponible en su Ã©poca pueda soportar. Un ejemplo de algunos programas que hacen uso de las mallas son: 1. AutoCAD: Es un conjunto de herramientas para el modelado en 3D dirigido para los aficionados a esta Ã¡rea de trabajo. Trae un conjunto de herramientas bÃ¡sicas de modelado junto a algunas opciones para exportar al formato STL (STereoLithography) que describe la superficie del modelo con un formato triangulado especificando Ãºnicamente los vÃ©rtices ordenados y las normales de las caras. Este formato es ampliamente utilizado para las impresiones 3D y fabricaciÃ³n asistida por computadora [4]. 2. Cinema4D: Es un programa profesional para realizar animaciones y modelos 3D. Es utilizado comÃºnmente para generar efectos especiales en televisiÃ³n. Este tipo de programa se enfatiza en generar modelos realÃ­sticos, y la interacciÃ³n entre estos queda en manos del usuario [5]. 3. Video Juegos: Los video juegos son una de las Ã¡reas de la computaciÃ³n que mÃ¡s uso hacen de las mallas para sus representaciones grÃ¡ficas. Un ejemplo de estas aplicaciones es la saga de juegos Mass Effect, implementado sobre el motor grÃ¡fico Unreal Engine. Este motor grÃ¡fico en su Ãºltima versiÃ³n incluyÃ³ una nueva tÃ©cnica de iluminaciÃ³n en tiempo real con voxel desarrollada por la empresa Nvidia, y hace uso del motor de efectos de Nvidia physx. En este tipo de programas se hace Ã©nfasis en hacer lo mÃ¡s realista las fÃ­sicas e interacciones entre los modelos y dar un nivel de detalle aceptable [6]. 4. X-Plane y Google Earth: En estos programas su principal objetivo recae en otras Ã¡reas de la computaciÃ³n, pero hacen uso de la ComputaciÃ³n GrÃ¡fica para hacer mÃ¡s inmersiva la experiencia. En el caso de X-Plane la ComputaciÃ³n GrÃ¡fica tiene un mayor peso ya que su propÃ³sito es simular la experiencia de pilotar un aviÃ³n con el mayor realismo (ver [7][8]). 1.3 DescripciÃ³n del problema Un aspecto que tienen en comÃºn la gran mayorÃ­a de programas que hacen uso de las mallas, es que al momento de desplegar la escena requieren de un variado nÃºmero de mallas para representar el escenario y los elementos que interactÃºan en ella. Estas mallas que se despliegan pueden llegar a poseer magnitudes enormes de informaciÃ³n. En los Ãºltimos aÃ±os el nivel de detalle de las mallas ha llegado al nivel de utilizar cientos de millones de polÃ­gonos. 13 En el proyecto â€œThe Digital Michelangeloâ€ [9] de la universidad de Stanford en California, Estados Unidos, que comenzÃ³ oficialmente en 1997, se escaneÃ³ la famosa estatua de David de 1504 del escultor Michelangelo. La versiÃ³n digital mÃ¡s grande generada por este proyecto contiene aproximadamente dos billones de polÃ­gonos y siete mil imÃ¡genes a color. Existen otros proyectos como â€œThe Forma Urbis Romae Fragmentâ€ [10] tambiÃ©n de la universidad de Stanford donde se escaneÃ³ un mapa de la antigua Roma. La versiÃ³n digital completa de este mapa posee cerca de ocho billones de polÃ­gonos. En el juego â€œInfamous Second Sonâ€ de Sony Computer Entertainment [11], los modelos de los personajes poseen cada uno alrededor de ciento veinte mil polÃ­gonos y hasta veintiocho megabytes en texturas, lo cual puede ser considerado una gran cantidad cuando coincidan muchos personajes en un mismo instante de tiempo. Cuando una aplicaciÃ³n grÃ¡fica requiere de hacer uso de un modelo en malla, primero necesita cargarlo en memoria para poder acceder a su informaciÃ³n interna. Esto no siempre es posible, debido a la alta exigencia de recursos. Esto genera un inconveniente, ya que esto reduce la cantidad de usuarios que serÃ¡n capaces de ejecutar la aplicaciÃ³n en sus dispositivos de uso personal. Una primera soluciÃ³n podrÃ­a ser cargar en la memoria solo el segmento que se necesita de la malla en un momento dado y no tener que cargarla por completo. El inconveniente con esto es que el pasar informaciÃ³n del disco duro a la memoria RAM es un proceso lento que puede causar un efecto cuello de botella con el resto de los componentes de la aplicaciÃ³n. El objetivo es reducir la cantidad de polÃ­gonos que se necesitan desplegar sin tener que reducir el nivel de detalle de los modelos originales, esto se logra con algoritmos de simplificaciÃ³n, que alteran de manera temporal el modelo segÃºn los requerimientos del usuario, facilitando su despliegue sin alterar el modelo original. 1.4 Objetivo General Desarrollar un algoritmo de simplificaciÃ³n de mallas en tiempo real aprovechando las capacidades de procesamiento paralelo de la GPU. 1.5 Objetivos EspecÃ­ficos ï‚· Construir una soluciÃ³n computacional que permita, dada una malla como entrada, obtener una malla de salida con un menor nivel de detalle manteniendo las cualidades visuales originales. ï‚· Crear un algoritmo de reducciÃ³n de mallas para la GPU. ï‚· Soportar la variaciÃ³n de los niveles de simplificaciÃ³n, incrementando el factor de reducciÃ³n de elementos. ï‚· Permitir visualizar el modelo original y el simplificado con el fin de realizar comparaciones entre ambos modelos. ï‚· Proveer la extracciÃ³n del modelo simplificado de la aplicaciÃ³n para su uso en otras aplicaciones. 14 CapÃ­tulo 2 ReducciÃ³n de mallas En este capÃ­tulo se describe los algoritmos clÃ¡sicos para realizar simplificaciones de mallas, y algunos de los mÃ¡s recientes, donde se definen las funciones matemÃ¡ticas utilizadas en el algoritmo de simplificaciÃ³n implementado en este trabajo. 2.1 Primeros algoritmos de simplificaciÃ³n de mallas El objetivo principal de la simplificaciÃ³n de mallas es reducir el nÃºmero de polÃ­gonos a desplegar de una forma dinÃ¡mica y posible de regular. En la Figura 3, se puede observar el efecto de reducir el nivel de elementos en un modelo 3D. Figura 3: De izquierda a derecha: Ejemplo de la simplificaciÃ³n de malla con el modelo original y dos niveles diferentes de simplificaciÃ³n. La estructura general de los algoritmos de simplificaciÃ³n consiste en dos o tres etapas. En la primera se hace uso de una heurÃ­stica para discernir el orden como se eliminarÃ¡n los polÃ­gonos, aristas o vÃ©rtices. Esto se logra categorizÃ¡ndolos segÃºn su disposiciÃ³n, o agregÃ¡ndoles un costo segÃºn su impacto en la topologÃ­a o su distancia con respecto a la soluciÃ³n. Otro trabajo que hizo avances importantes en esta fase de la simplificaciÃ³n fue Garland [13]. En este trabajo se plantea cada vÃ©rtice ğ’— como la soluciÃ³n de un conjunto de planos. Estos planos se generan a partir de expandir las caras que poseen al vÃ©rtice âŒˆâŒˆğ’—âŒ‰âŒ‰ como se expone en la Figura 4. 15 Figura 4: Ejemplo del plano generado a partir de una cara. A cada vÃ©rtice se le asigna un error que estÃ¡ dado por la distancia al cuadrado entre el vÃ©rtice y estos planos, que originalmente serÃ¡ cero, y a medida que se colapsen aristas los nuevos vÃ©rtices acumularÃ¡n error segÃºn su distancia con respecto a los planos de los vÃ©rtices colapsados. En la segunda fase, se eliminan o colapsan los elementos de la malla. El orden estarÃ¡ dictado por el resultado de la primera fase, dando prioridad a los elementos que poseen menos impacto en la topologÃ­a general de la malla. Se dice que un elemento es colapsado cuando se reduce su magnitud de elementos. La forma de colapso mÃ¡s comÃºn es el colapso de aristas. Esta operaciÃ³n consiste en contraer una arista a un nuevo vÃ©rtice ğ’™, colapsando en el proceso los polÃ­gonos que hagan uso de esta arista como se puede ver en la Figura 5. Figura 5: Ejemplo de la operaciÃ³n de colapso de arista, la arista e es colapsada uniendo sus dos vÃ©rtices p y u en un nuevo vÃ©rtice x, eliminando en el proceso las caras ğ‘¡1 ğ‘¦ ğ‘¡2 Cuando se elimina un elemento de la malla se generan agujeros que afectan negativamente la apariencia de la malla, por lo que es deseable cubrir esa zona nuevamente. Se plantea un ejemplo de este proceso en la Figura 6. 16 Figura 6: Ejemplo del efecto de eliminar un vÃ©rtice. (a) Malla original. (b) malla resultante al eliminar el vÃ©rtice v. (c) Ejemplo de triangulaciÃ³n para cubrir la zona afectada. NÃ³tese la diferencia en caras entre el ejemplo a (8 caras) y el ejemplo c (6 caras) Ya con algunos conceptos bÃ¡sicos aclarados, se explicarÃ¡n los algoritmos de simplificaciÃ³n de algunas de las bibliotecas grÃ¡ficas mÃ¡s relevantes. 2.2 Bibliotecas para la reducciÃ³n de mallas Con el pasar de los aÃ±os, se ha trabajado y profundizado en el Ã¡rea de la simplificaciÃ³n de mallas, lo que ha llevado a los algoritmos de simplificaciÃ³n a estar en constante cambio y evoluciÃ³n. Existen muchos tipos de bibliotecas que proveen algoritmos visuales que ayudan a aÃ±adir interfaces a la aplicaciÃ³n, o desplegar fÃ¡cilmente modelos y escenas. Otra clase de bibliotecas son las orientadas en algoritmos geomÃ©tricos, cuya funciÃ³n es proveer algoritmos capaces de crear, manipular o desplegar elementos geomÃ©tricos complejos como las mallas. A continuaciÃ³n se describe en detalle dos de las bibliotecas mÃ¡s utilizadas orientadas en algoritmos geomÃ©tricos, que emplean algunos de los mÃ¡s resaltantes algoritmos de simplificaciÃ³n desarrollados. 2.2.1 Biblioteca CGAL La primera biblioteca que describiremos serÃ¡ la biblioteca CGAL [14] (The Computational Geometry Algorithms Library) fundada como el proyecto CGAL, creada originalmente en 1996 por la ESPRIT (European Strategic Programme for Research in Information Technology) con la alianza de importantes institutos de Europa e Israel, (ver [15] [16] [17] [18] [19] [20] [21] [22]). La biblioteca CGAL originalmente estaba distribuida bajo una licencia libre para uso acadÃ©mico y una licencia comercial para otros usos. Actualmente se encuentra bajo licencia GPL (General Public License) versiÃ³n 3. CGAL ofrece algoritmos orientados en geometrÃ­a computacional, escrita originalmente para el lenguaje C++, luego se agregÃ³ soporte a los lenguajes Python y Java. La tÃ©cnica de reducciÃ³n estÃ¡ndar presentada en la biblioteca CGAL estÃ¡ fuertemente basada en los artÃ­culos [3] y [23], con algunas contribuciones de [2], [13] y [24]. El algoritmo usado en esta biblioteca desglosa en 2 etapas importantes. 17 La primera etapa, denominada etapa de recolecciÃ³n, consiste principalmente en asignarle un costo a cada arista de la malla. La segunda etapa, denominada etapa de colapso, consiste en ir evaluando las aristas segÃºn su costo de manera creciente, si la arista evaluada cumple ciertos requisitos geomÃ©tricos y topolÃ³gicos, esta se contrae y es reemplazada por un nuevo vÃ©rtice. Se prosigue por recalcular el costo de todas las otras caras involucradas y se reorganizan segÃºn los nuevos costos las aristas restantes. En caso de no cumplir los requisitos, la arista es descartada del proceso de selecciÃ³n de aristas, esto es para prever que el contraer la arista lleve a un agujero en la malla u otros escenarios desfavorables. Existen algoritmos que pueden contraer aristas inexistentes como lo es el caso de [13], en el cual se puede considerar a un par de vÃ©rtices parte de una pseudo-arista, y contraer tanto aristas como pseudo-aristas, esto implica que se pueden generar aristas mÃºltiples, pero el algoritmo utilizado por la biblioteca CGAL solo puede manejar aristas simples por lo que se omite esta soluciÃ³n. Durante la etapa de recolecciÃ³n se itera por todas las aristas de la malla, y a cada arista se le realiza el cÃ¡lculo de su costo segÃºn el impacto que tendrÃ­a en la apariencia general de la malla de ser contraÃ­da, en la biblioteca CGAL se dispone de dos estrategias para calcular este costo, la primera es el algoritmo de Lindstrom, planteado en los artÃ­culos [3] y [23]. Este es el algoritmo que es utilizado por defecto en la biblioteca CGAL. En este algoritmo se toma en cuenta el impacto en la forma y volumen de la malla para calcular el costo. La segunda estrategia para calcular el costo en la biblioteca CGAL, consiste en calcular el tamaÃ±o de la arista y asignarlo como su costo. Al contraer la arista (ver Figura 7) el nuevo vÃ©rtice es colocado en el centro anterior de la arista. Esta estrategia es mucho mÃ¡s rÃ¡pida pero tiene un gran impacto en la apariencia general de la malla, ya que en las zonas cÃ³ncavas se expande y en las zonas convexas se contrae. Algoritmo de Lindstrom En el algoritmo de Lindstrom se simplifica el modelo utilizando la operaciÃ³n de colapso de aristas. Para elegir la posiciÃ³n del nuevo vÃ©rtice ğ’™ se intenta minimizar ciertos cambios en la geometrÃ­a de la malla como el volumen y el Ã¡rea, para conseguir esto se requiere resolver una ecuaciÃ³n lineal de la forma ğ’‚ğ’Š ğ’•ğ’™ = ğ’ƒğ’Š siendo ğ’™ la intercepciÃ³n entre tres planos no paralelos. Se requieren tres restricciones de este tipo, pero se utilizan mÃ¡s de tres restricciones (ğ’‚ğ’,ğ’ƒğ’), esto en el caso de que dos o mÃ¡s de ellas sean linealmente dependientes. Si dos de estos planos ğ’‚ğ‘› son cercanamente paralelos, pequeÃ±as perturbaciones en los coeficientes del plano generan grandes variaciones en el resultado final. Para evitar esto, los planos deben cumplir las siguientes condiciones antes de poder ser aceptados: (ğ‘–)ğ‘› = 1:ğ‘1 â‰  0 (ğ‘–ğ‘–)ğ‘› = 2: (ğ‘1 ğ‘‡ ğ‘2) 2 < (â€–ğ‘1â€–â€–ğ‘2â€– cos(ğ›¼)) 2 (ğ‘–ğ‘–ğ‘–)ğ‘› = 3: ((ğ‘1 Ã— ğ‘2) ğ‘‡ğ‘3) 2 > (â€–ğ‘1 Ã— ğ‘2â€–â€–ğ‘3â€– sin(ğ›¼)) 2 La primera condiciÃ³n para poder aceptar el plano candidato (i) es que el Ã¡ngulo del plano no sea igual a 0, la segunda y tercera condiciÃ³n (ii), (iii) descarta todo plano con una diferencia angular inferior a ğœ¶ entre el plano candidato y los planos previamente aceptados. Si estas condiciones se cumplen se puede decir que es compatible con los otros planos. Con los tres planos compatibles, conseguir ğ’™ solo serÃ¡ resolver la siguiente ecuaciÃ³n. ğ‘¥ = ğ´âˆ’1ğ‘ 18 Siendo ğ’‚ğ’ ğ‘» las filas de la matriz ğ‘¨. Figura 7: Ejemplo de los tetraedros generados por el nuevo vÃ©rtice v y las caras ğ‘¡0, ğ‘¡3 ğ‘¦ ğ‘¡8 Varias de las ecuaciones se consiguen minimizando una funciÃ³n ligada a las ecuaciones ya conseguidas, esta funciÃ³n se expresa de la siguiente forma: ğ‘“(ğ‘¥) = 1 2 ğ‘¥ğ‘‡ğ´ğ‘¥ âˆ’ ğ‘ğ‘‡ğ‘¥ + 1 2 ğ‘ = 1 2 (ğ‘¥ğ‘‡ 1) ( ğ´ âˆ’ğ‘ âˆ’ğ‘ğ‘‡ ğ‘ ) ( ğ‘¥ 1 ) = 1 2 ï¿½Ì…ï¿½ğ‘‡ï¿½Ì…ï¿½ï¿½Ì…ï¿½ Donde ï¿½Ì…ï¿½ la Hessiana de ğ’‡. La matriz Hessiana, es la matriz compuesta por las segundas derivadas de la funciÃ³n f. Teniendo una forma como esta: ï¿½Ì…ï¿½ = ( ğœ•2ğ‘“ ğœ•ğ‘¥1 2 ğœ•2ğ‘“ ğœ•ğ‘¥1ğœ•ğ‘¥2 â‹¯ ğœ•2ğ‘“ ğœ•ğ‘¥1ğœ•ğ‘¥ğ‘› ğœ•2ğ‘“ ğœ•ğ‘¥2ğœ•ğ‘¥1 ğœ•2ğ‘“ ğœ•ğ‘¥2 2 â‹¯ ğœ•2ğ‘“ ğœ•ğ‘¥2ğœ•ğ‘¥ğ‘› â‹® â‹® â‹± â‹® ğœ•2ğ‘“ ğœ•ğ‘¥ğ‘›ğœ•ğ‘¥1 ğœ•2ğ‘“ ğœ•ğ‘¥ğ‘›ğœ•ğ‘¥2 â‹¯ ğœ•2ğ‘“ ğœ•ğ‘¥ğ‘› 2 ) Quedando ï¿½Ì…ï¿½ como una matriz de tamaÃ±o ğŸ’ Ã— ğŸ’ semidefinida simÃ©trica. Para minimizar ğ’‡ teniendo ğ’ ecuaciones (ğ’‚ğ’Š,ğ’ƒğ’Š) ya encontradas, definimos ğ‘¸ como una matriz de tamaÃ±o ğŸ‘ âˆ’ ğ’ Ã— ğŸ‘ cuyas filas son ortogonales entre ellas y los vectores ğ’‚ğ’Š. Quedando las otras ğŸ‘ âˆ’ ğ’ ecuaciones como. ğ‘„(ğ´ğ‘¥ âˆ’ ğ‘) = 0 19 Donde ğ‘¨ğ’™ âˆ’ ğ’ƒ es el gradiente de ğ’‡. Por lo que el mÃ­nimo de ğ’‡ se obtiene cuando la proyecciÃ³n de su gradiente en el espacio de ğ‘¸ desaparece. PreservaciÃ³n de volumen A continuaciÃ³n se detalla como calcular la nueva posiciÃ³n del vector ğ’™. El objetivo es conseguir un balance entre tres factores topolÃ³gicos importante. Estos son, reducir el impacto en el volumen, en la geometrÃ­a y en el Ã¡rea, para minimizar el cambio en el volumen de la malla, se debe calcular el volumen de los tetraedros creados entre el nuevo vÃ©rtice ğ’™ y los otros tres vÃ©rtices de una cara ğ’•ğ’Š. En la Figura 7 se plantea el proceso de colapso de una arista y como este altera los demÃ¡s elementos de la malla. ğ‘‰(ğ‘¥, ğ‘¥ğ‘¡ğ‘–0,ğ‘¥ ğ‘¡ğ‘– 1,ğ‘¥ ğ‘¡ğ‘– 2) = 1 6 det (ï¿½Ì…ï¿½ ï¿½Ì…ï¿½ğ‘¡ğ‘–0 ï¿½Ì…ï¿½ ğ‘¡ğ‘– 1 ï¿½Ì…ï¿½ ğ‘¡ğ‘– 2) = 1 6 ((ğ‘¥ğ‘¡ğ‘–0 Ã— ğ‘¥ ğ‘¡ğ‘– 1 + ğ‘¥ ğ‘¡ğ‘– 1 Ã— ğ‘¥ ğ‘¡ğ‘– 2 + ğ‘¥ ğ‘¡ğ‘– 2 Ã— ğ‘¥ ğ‘¡ğ‘– 0) ğ‘‡ğ‘¥ âˆ’ [ğ‘¥ğ‘¡ğ‘–0,ğ‘¥ ğ‘¡ğ‘– 1,ğ‘¥ ğ‘¡ğ‘– 2]) = 1 6 ((ğ‘¥ğ‘¡ğ‘–0 Ã— ğ‘¥ ğ‘¡ğ‘– 1 + ğ‘¥ ğ‘¡ğ‘– 1 Ã— ğ‘¥ ğ‘¡ğ‘– 2 + ğ‘¥ ğ‘¡ğ‘– 2 Ã— ğ‘¥ ğ‘¡ğ‘– 0) ğ‘‡ âˆ’ [ğ‘¥ğ‘¡ğ‘–0,ğ‘¥ ğ‘¡ğ‘– 1,ğ‘¥ ğ‘¡ğ‘– 2])ï¿½Ì…ï¿½ = 1 6 ï¿½Ì…ï¿½ğ‘‰ğ‘–ï¿½Ì…ï¿½ El volumen queda representado en la forma de una matriz de tamaÃ±o ğŸ Ã— ğŸ’ asociada a la cara ğ’•ğ’Š. Al contraer la arista ğ’‚ se aÃ±ade o substraer volumen de la malla, por lo que se desea que el volumen generado entre el nuevo vÃ©rtice y los triÃ¡ngulos tales que {ğ’•ğ’Š} = âŒˆâŒˆâŒŠğ’‚âŒ‹âŒ‰âŒ‰ sea lo mÃ¡s cercano a 0. 1 6 âˆ‘ï¿½Ì…ï¿½ğ‘‰ğ‘–ï¿½Ì…ï¿½ ğ‘– = 0 Esto limita la soluciÃ³n a un plano y se puede aÃ±adir esto como la primera restricciÃ³n lineal para x. ğ’‡ğ‘½ğ’‘ se puede expresar como un problema cuadrÃ¡tico indeterminado, quedando expresado de la siguiente forma: ğ‘“ğ‘‰ğ‘(ğ‘¥) = 1 2 ï¿½Ì…ï¿½ğ‘‡ï¿½Ì…ï¿½ğ‘‰ğ‘ï¿½Ì…ï¿½ = 1 2 ï¿½Ì…ï¿½ğ‘‡ ( 1 18 âˆ‘ï¿½Ì…ï¿½ğ‘‰ğ‘– ğ‘‡ ğ‘– âˆ‘ï¿½Ì…ï¿½ğ‘‰ğ‘– ğ‘– ) ï¿½Ì…ï¿½ De esta forma se tiene que ğ’‡ğ‘½ğ’‘ es la distancia al cuadrado entre ğ’™ y la soluciÃ³n Ã³ptima (el plano que no altera el volumen de la malla) por lo que nada diferente de ğ’‡ğ‘½ğ’‘ = ğŸ serÃ¡ un mÃ­nimo garantizado, como son varias las restricciones que se deben cumplir, como preservar el volumen, Ã¡rea, geometrÃ­a, no existe un valor ğ’™ que minimice todas las restricciones por lo que se debe designar un peso a cada funciÃ³n con el cual calcular el costo de la arista. OptimizaciÃ³n de volumen Calcular el volumen de los tetraedros asociados al vÃ©rtice, determina el volumen que se agrega o substrae al volumen general de la malla, pero tambiÃ©n se debe tomar en cuenta el volumen general sin signo que se genera, con esto se puede calcular la desviaciÃ³n general del volumen despuÃ©s de contraer la arista, como es comÃºn se utiliza el cuadrado de los valores en vez de su valor absoluto para resolver los cÃ¡lculos. ğ‘“ğ‘‰0(ğ‘¥) = 1 2 ï¿½Ì…ï¿½ğ‘‡ï¿½Ì…ï¿½ğ‘‰0ï¿½Ì…ï¿½ = 1 2 ï¿½Ì…ï¿½ğ‘‡ ( 1 18 âˆ‘ï¿½Ì…ï¿½ğ‘‰ğ‘– ğ‘‡ ğ‘– ï¿½Ì…ï¿½ğ‘‰ğ‘–) ï¿½Ì…ï¿½ 20 Se calcula similar a la ecuaciÃ³n de preservaciÃ³n de volumen. OptimizaciÃ³n de la topologÃ­a En las zonas planas donde ğ’‡ğ‘½ğŸ es igual a cero, cualquier valor que se elija de ğ’™ dejarÃ¡ intacto el volumen general de la malla, existen casos donde el mejor resultado se obtiene al elegir valores de ğ’™ que eviten incluir triÃ¡ngulos delgados y alargados, buscando una mayor uniformidad en la forma general de los triÃ¡ngulos involucrados, esto se logra minimizando la suma de las longitudes al cuadrado de las aristas âŒˆğ’™âŒ‰, y maximizar el Ã¡rea por perÃ­metro de los triÃ¡ngulos âŒˆâŒˆğ’™âŒ‰âŒ‰ quedando: ğ‘¥ âˆ’ ğ‘¥ğ‘– = (ğ¼ âˆ’ ğ‘¥ğ‘–)ï¿½Ì…ï¿½ = ï¿½Ì…ï¿½ğ‘†ğ‘–ï¿½Ì…ï¿½ Donde ï¿½Ì…ï¿½ğ‘ºğ’Š estÃ¡ asociada al vÃ©rtice formado por ğ’™ y un vÃ©rtice adyacente âŒŠâŒˆğ’™âŒ‰âŒ‹ âˆ’ {ğ’™} = {ğ’™ğ’Š}, quedando asÃ­ la funciÃ³n objetiva con la siguiente forma: ğ‘“ğ‘†(ğ‘¥) = 1 2 ï¿½Ì…ï¿½ğ‘‡ï¿½Ì…ï¿½ğ‘†ï¿½Ì…ï¿½ = 1 2 ï¿½Ì…ï¿½ğ‘‡ (2 âˆ‘ï¿½Ì…ï¿½ğ‘†ğ‘– ğ‘‡ ğ‘– ï¿½Ì…ï¿½ğ‘†ğ‘–) ï¿½Ì…ï¿½ De esta forma se obtiene una soluciÃ³n Ãºnica para ğ’™. 2.2.2 Biblioteca VTK La biblioteca VTK (Visual ToolKit) [25] fue originalmente creada con el fin de servir como apoyo prÃ¡ctico para el libro â€œThe Visualization Toolkit: An Object-Oriented Approach to 3D Graphicsâ€ en el aÃ±o 1993, escrita por Schroeder, Ken Martin y Bill lorensen. Escrita para el lenguaje C++, recientemente se introdujo soporte para Python y Java. En esta biblioteca se presentan cuatro mÃ©todos de simplificaciÃ³n: vtkDecimate, vtkDecimatePro, vtkQuadricDecimation y vtkQuadricClustering, a continuaciÃ³n se explicarÃ¡ brevemente cada uno. FunciÃ³n vtkDecimate Esta funciÃ³n estÃ¡ basada en el trabajo de Schroeder [12]. Donde se hacen varias iteraciones sobre todos los vÃ©rtices, si el vÃ©rtice cumple con ciertos criterios, se elimina junto con todos los triÃ¡ngulos que utilicen este vÃ©rtice, luego se cubrirÃ¡ el agujero creado al eliminar estos triÃ¡ngulos con una nueva triangulaciÃ³n. El algoritmo se divide en 3 pasos: 1. Caracterizar cada vÃ©rtice segÃºn su geometrÃ­a y topologÃ­a 2. Evaluar el criterio de simplificaciÃ³n y eliminar el vÃ©rtice segÃºn sea el caso 3. Re-triangular el agujero creado en el Paso 2 CaracterizaciÃ³n del vÃ©rtice segÃºn su geometrÃ­a y topologÃ­a El primer paso es caracterizar los vÃ©rtices segÃºn la geometrÃ­a y topologÃ­a local por cada uno. Con el resultado de este paso se podrÃ¡ determinar si un vÃ©rtice es un potencial candidato a ser eliminado, y que criterio utilizar. 21 En la Figura 8 se listan una serie de etiquetas con las cuales se catalogan los vÃ©rtices segÃºn una de las siguientes categorÃ­as: simple, complejo, borde, arista interior o vÃ©rtice esquina. Simple Complejo Borde Arista Interior VÃ©rtice esquina Figura 8: Diferentes categorÃ­as de vÃ©rtices Un vÃ©rtice simple estÃ¡ rodeado por un cÃ­rculo completo de caras, y cada arista que usa al vÃ©rtice es usada por exactamente dos caras. En caso de ser utilizado por una cara que no se encuentra dentro del cÃ­rculo que lo rodea se le denominarÃ¡ complejo. Un vÃ©rtice que se encuentre en el borde de la malla, o que estÃ© dentro de un semicÃ­rculo de caras, serÃ¡ un vÃ©rtice borde. Un vÃ©rtice simple puede a su vez clasificarse como una arista interior, esto depende de la geometrÃ­a local, ya que si el Ã¡ngulo diedro (el Ã¡ngulo formado entre dos planos que parten de una arista comÃºn) entre dos caras adyacentes es superior a cierto valor predefinido, existirÃ¡ una arista caracterÃ­stica. Si un vÃ©rtice es utilizado entre dos aristas caracterÃ­sticas, el vÃ©rtice es categorizado como arista interior. Cuando un vÃ©rtice es utilizado por tres o mÃ¡s aristas caracterÃ­sticas este se clasificara como vÃ©rtice esquina. Los vÃ©rtices complejos no serÃ¡n eliminados, todos los demÃ¡s son candidatos para eliminar. Criterio de simplificaciÃ³n En este paso se determina cuando los triÃ¡ngulos que componen el cÃ­rculo que encierra el vÃ©rtice seleccionado pueden ser eliminados o no. Para los vÃ©rtices simples se utiliza la distancia del vÃ©rtice al plano como criterio, en la Figura 9 se muestra un ejemplo de esta distancia. Si la distancia estÃ¡ dentro del rango predefinido, puede ser eliminado, de lo contrario se conserva el vÃ©rtice. Figura 9: Distancia del vÃ©rtice con respecto al plano promediado entre los vÃ©rtices que lo rodean. Los vÃ©rtices borde y arista interior utilizan como criterio la distancia al borde. En la Figura 10 se puede ver un ejemplo de este escenario. En este caso el algoritmo calcula la distancia entre la lÃ­nea definida por los dos vÃ©rtices que crean el borde o arista caracterÃ­stica. Si la distancia es menor que un valor d predefinido, el vÃ©rtice puede ser eliminado. 22 Figura 10: Distancia entre el vÃ©rtice y el borde o arista caracterÃ­stica Si un vÃ©rtice puede ser eliminado, el Ã¡rea que se removiÃ³ debe ser triangulada nuevamente. Se denominarÃ¡ bucle al Ã¡rea creada por eliminar el vÃ©rtice. Como se muestra en la Figura 11, se tratarÃ¡ de dividir el bucle trazando una lÃ­nea entre dos vÃ©rtices que lo compongan, con el fin de tener tres o mÃ¡s vÃ©rtices en ambos lados. Si el bucle se puede dividir de esta manera, se triangula cada mitad por separado. TriangulaciÃ³n Al eliminar un vÃ©rtice y sus triÃ¡ngulos asociados se debe generar un nuevo conjunto de vÃ©rtices que los reemplacen. Para cada bucle se debe realizar una triangulaciÃ³n cuyos triÃ¡ngulos no se intercepten ni degeneren. En adiciÃ³n, es importante que al momento de generar nuevos triÃ¡ngulos se tome en cuenta la calidad visual del modelo. La triangulaciÃ³n se realiza con una divisiÃ³n de bucle recursiva. Cada bucle se divide en dos y cada mitad se trabaja individualmente, la divisiÃ³n estÃ¡ dada por la lÃ­nea generada por dos vÃ©rtices no adyacentes en el bucle. La recursiÃ³n se detendrÃ¡ cuando queden solo tres vÃ©rtices, los cuales serÃ¡n el triÃ¡ngulo que se guardarÃ¡ en la malla y se finalizarÃ¡ el proceso. Como se aprecia en la Figura 11, cuando el bucle no es plano y tiene forma de estrella, el bucle debe dividirse segÃºn un plano de divisiÃ³n, que serÃ¡ ortogonal al plano promedio generado por los vÃ©rtices del bucle. Esto para evitar que se sobrepongan los nuevos triÃ¡ngulos. Si se cumple la condiciÃ³n de que existan 3 Ãºnicos vÃ©rtices de un lado del plano se acepta el plano de divisiÃ³n, en caso de no poder generarse un plano de divisiÃ³n que cumpla este requisito se toma como un fallo y se revierte el colapso del vÃ©rtice. Figura 11: Ejemplo de un plano de divisiÃ³n que divide en dos el bucle generado al eliminar el vÃ©rtice. Como existen muchas formas de realizar esta divisiÃ³n, el objetivo es tomar la soluciÃ³n que reduzca la diferencia con la malla original, por lo que se debe utilizar una relaciÃ³n de aspecto, con la cual se medirÃ¡ la distancia entre el bucle y el plano de divisiÃ³n dividido por el tamaÃ±o de la lÃ­nea de divisiÃ³n. El mejor plano es el que maximice la relaciÃ³n de aspecto, si se define un umbral mÃ­nimo de distancia para aprobar un plano por ejemplo 0.1, se generan resultados aceptables. 23 FunciÃ³n vtkDecimatePro El cambio mÃ¡s importante entre esta funciÃ³n y vtkDecimate, es la generaciÃ³n progresiva de mallas, que estÃ¡ basado en el algoritmo presentado en el trabajo de Hoppe de mallas progresivas [26]. Este algoritmo igual que vtkDecimate estÃ¡ basado en el trabajo de Schroeder, con la diferencia de que los vÃ©rtices son clasificados segÃºn la distancia que hay entre el vÃ©rtice seleccionado y el plano que se genera promediando las normales de todos los vÃ©rtices que componen las caras pertenecientes el bucle de triÃ¡ngulos que rodea el vÃ©rtice (bucle mencionado anteriormente que es formado al eliminar un vÃ©rtice). DespuÃ©s de ser clasificados, se procesan y la malla es simplificada. Entonces la malla es dividida segÃºn las aristas caracterÃ­sticas y complejas para repetir el proceso recursivamente en cada uno de estos fragmentos de malla segÃºn una profundidad especÃ­fica. Mallas progresivas En Hoppe [2] se describe un mÃ©todo de simplificaciÃ³n de malla que con el uso de tres transformaciones simples: colapso de arista, divisiÃ³n de arista e intercambio de arista, simplifica la topologÃ­a de las mallas. En este se plantea utilizar solo la transformaciÃ³n simple de colapso de arista, que llaman ğ‘’ğ‘ğ‘œğ‘™({ğ‘£ğ‘ ,ğ‘£ğ‘¡}), y se plantea una funciÃ³n inversa llamada separaciÃ³n de vÃ©rtice. Esta funciÃ³n, denominada vsplit(s,l,r,t,A) toma un vÃ©rtice ğ’—ğ’” y agrega uno nuevo ğ’—ğ’• y dos nuevas caras {ğ’—ğ’”,ğ’—ğ’•,ğ’—ğ’} y {ğ’—ğ’”,ğ’—ğ’•,ğ’—ğ’“} (si la arista {ğ’—ğ’”,ğ’—ğ’•} es una arista borde, se tiene ğ’—ğ’“ = ğŸ y solo se agrega una cara). Una malla inicial ğ‘´ğ’ se puede simplificar a una malla mÃ¡s simple ğ‘´ğŸ utilizando una secuencia de n transformaciones ğ‘’ğ‘ğ‘œğ‘™({ğ‘£ğ‘ ,ğ‘£ğ‘¡}): ğ‘€ğ‘› ğ‘’ğ‘ğ‘œğ‘™ğ‘›âˆ’1 â†’ . . . ğ‘’ğ‘ğ‘œğ‘™1 â†’ ğ‘€1 ğ‘’ğ‘ğ‘œğ‘™0 â†’ ğ‘€0 Y como la transformaciÃ³n de colapso de arista es reversible podemos representar una malla ğ‘´ğ’ como una serie de transformaciones aplicadas a una malla simple ğ‘´ğŸ: ğ‘€0 ğ‘£ğ‘ ğ‘ğ‘™ğ‘–ğ‘¡0 â†’ ğ‘€1 ğ‘£ğ‘ ğ‘ğ‘™ğ‘–ğ‘¡1 â†’ . . . ğ‘£ğ‘ ğ‘ğ‘™ğ‘–ğ‘¡ğ‘›âˆ’1 â†’ ğ‘€ğ‘› Geomorphs Una propiedad que se puede resaltar en este planteamiento de mallas progresivas es la transiciÃ³n visualmente fluida entre dos mallas ğ‘´ğ’Š y ğ‘´ğ’Š+ğŸ (una geomorph) que se puede lograr. Asumiendo que la malla no contiene mÃ¡s atributos ademÃ¡s de la posiciÃ³n de los vÃ©rtices, se puede plantear las divisiones de arista como: ğ‘£ğ‘ ğ‘ğ‘™ğ‘–ğ‘¡ğ‘–(ğ‘ ğ‘–, ğ‘™ğ‘– , ğ‘Ÿğ‘–,ğ´ğ‘– = (ğ‘£ğ‘ ğ‘– ğ‘–+1 ,ğ‘£ğ‘š0+ğ‘–+1 ğ‘–+1 )) La idea es construir un geomorph ğ‘´ğ‘®(ğœ¶) cuyo parÃ¡metro varÃ­e entre ğŸ â‰¤ ğœ¶ â‰¤ ğŸ de tal forma que ğ‘´ğ‘®(ğŸ) sea ğ‘´ğ’Š y ğ‘´ğ‘®(ğŸ) sea ğ‘´ğ’Š+ğŸ, y asÃ­ la aplicaciÃ³n puede pasar de una malla a otra de una forma fluida. Ya que la transformaciÃ³n ğ‘’ğ‘ğ‘œğ‘™ es transitiva, se puede generar una transformaciÃ³n compuesta de una secuencia de transformaciones ğ‘’ğ‘ğ‘œğ‘™, con esto se puede construir un geomorph entre cualquier malla ğ‘´ğ’ y otra ğ‘´ğ’Š. Dada una malla ğ‘´ğ’„ y otra versiÃ³n mÃ¡s simplificada de esta ğ‘´ğ’‡, existe una correspondencia indirecta entre cada vÃ©rtice de ğ‘´ğ’‡ con un Ãºnico vÃ©rtice de ğ‘´ğ’„, esta relaciÃ³n estarÃ¡ dada por la transformaciÃ³n compuesta ğ‘¨ğ’„ que serÃ¡ la 24 uniÃ³n de todas las transformaciones ğ‘’ğ‘ğ‘œğ‘™. MÃ¡s precisamente, cada vÃ©rtice ğ’—ğ’‹ de ğ‘´ ğ’‡ corresponde a un vÃ©rtice ğ’—ğ‘¨ğ’„(ğ’‹) en ğ‘´ğ’„ ğ´ğ‘(ğ‘—) = { ğ‘— , ğ‘— â‰¤ ğ‘š0 + ğ‘ ğ´ğ‘(ğ‘†ğ‘— âˆ’ ğ‘š0âˆ’1) , ğ‘— > ğ‘š0 + ğ‘ Con esta correspondencia se pueden generar geomorphs ğ‘´ğ‘®(ğœ¶) tal que ğ‘´ğ‘®(ğŸ) sea ğ‘´ğ’„ y ğ‘´ğ‘®(ğŸ) sea ğ‘´ğ’‡, simplemente definiendo el geomorph tal que ğ‘´ğ‘®(ğœ¶) = (ğ‘²ğ’‡,ğ‘½ğ‘®(ğœ¶)) para tener la conectividad de ğ‘´ğ’‡ y la posiciÃ³n de los vÃ©rtices ğ‘£ğ‘— ğº(ğ›¼) = (ğ›¼)ğ‘£ğ‘— ğ‘“ + (1âˆ’ ğ›¼)ğ‘£ğ´ğ‘(ğ‘—) ğ‘ En la Figura 12 podemos ver un ejemplo de un geomorph entre dos mallas, una ğ‘´ğŸğŸ•ğŸ“ y otra ğ‘´ğŸ’ğŸğŸ“ (a) Î± = 0.00 (b) Î± = 0.25 (c) Î± = 0.50 (d) Î± = 0.75 (e) Î± = 1.00 Figura 12: Ejemplo de un geomorph ğ‘€ğº(ğ›¼) definido entre ğ‘€ğº(0) = ğ‘€175(con 500 caras) y ğ‘€ğº(1) = ğ‘€425 (con 1000 caras) FunciÃ³n vtkQuadricDecimation En esta se utiliza una nueva mÃ©trica de error cuadrÃ¡tica descrita en el trabajo de Hoppe [27]. El algoritmo de simplificaciÃ³n utilizado es el mismo que en vtkDecimate y vtkDecimatePro. Nueva mÃ©trica cuadrÃ¡tica para simplificaciÃ³n de mallas En la mayorÃ­a de los algoritmos de simplificaciÃ³n, se busca reducir el nivel de detalle de la malla con una secuencia de colapsos de aristas, estas transformaciones tienen la ventaja de poder almacenarse su inversa y con esta generar una presentaciÃ³n progresiva de la malla. En un esquema basado en colapsos de arista se deben resolver 2 cuestiones. La primera es asignar la posiciÃ³n y atributos unificados al nuevo vÃ©rtice v y la segunda es ordenar como se realizan estos colapsos. Una manera muy comÃºn de resolver esto es definir una mÃ©trica C para determinar ambos. A v se le asigna un valor minimizando C(v) que se utiliza tambiÃ©n para ordenar los candidatos para ser colapsados. En este trabajo se define la funciÃ³n C(v) como una funciÃ³n geomÃ©trica cuadrÃ¡tica basada en el trabajo de Garland [13] con la diferencia, de que en vez de incluir los atributos en los cÃ¡lculos ampliando las dimensiones de los vectores ej.: ğ’— âˆˆ ğ‘¹ğŸ‘+ğ’ se calculan de manera separada. 25 En el caso de no poseer atributos, en otras palabras que m=0, se calcula para cada cara la distancia de un punto ğ’— = (ğ’‘) âˆˆ ğ‘¹ğŸ‘ al plano que contiene la cara. Y a cada vÃ©rtice se le asigna la sumatoria de las distancias de las caras que contienen al vÃ©rtice, ponderada por el Ã¡rea de la cara: ğ‘„ğ‘£(ğ‘£) = âˆ‘ğ‘ğ‘Ÿğ‘’ğ‘(ğ‘“) âˆ™ ğ‘„ğ‘“(ğ‘£) ğ‘“âˆ‹ğ‘£ . Derivando ğ‘¸ğ’‡(ğ’—) para una cara ğ’‡ = (ğ’—ğŸ,ğ’—ğŸ,ğ’—ğŸ‘) recordando que se estÃ¡ planteando el caso m=0. La distancia de un punto p a un plano ğ‘· âŠ‚ ğ‘¹ğŸ‘ que contiene a f es ğ’ğ‘¡ğ’‘+ ğ‘‘, teniendo que la normal n se puede expresar como ğ’ = ( ğ’‘2 âˆ’ ğ’‘1) Ã— (ğ’‘3 âˆ’ ğ’‘1) / â€–(ğ’‘2 âˆ’ ğ’‘1)Ã— (ğ’‘3 âˆ’ ğ’‘1)â€– y el escalar ğ’… = âˆ’ğ’ ğ’•ğ’‘ğŸ. Una manera de conseguir estos parÃ¡metros es resolviendo el siguiente sistema de ecuaciones. ( ğ‘1 ğ‘‡ 1 ğ‘2 ğ‘‡ 1 ğ‘3 ğ‘‡ 1 )( ğ‘› ğ‘‘ ) = ( 0 0 0 ) Con la condiciÃ³n de que â€–ğ’â€– = ğŸ. La distancia cuadrada de entre un punto p y el plano P es. ğ‘„ğ‘“(ğ’— = (ğ’‘)) = (ğ’ğ‘‡ğ‘£ + ğ‘‘)2 = ğ’—ğ‘‡(ğ’ğ’ğ‘‡)ğ‘£ + 2ğ‘‘ğ’ğ‘‡ğ’—+ ğ‘‘2 Que puede ser representado como una funciÃ³n cuadrÃ¡tica ğ’—ğ‘»ğ‘¨ğ’—+ ğŸğ’ƒğ‘»ğ’—+ ğ’„ donde A es una matriz simÃ©trica de tamaÃ±o ğŸ‘ Ã— ğŸ‘, b es un vector de tamaÃ±o 3, y c un escalar, quedando como. ğ‘„ğ‘“ = (ğ‘¨,ğ’ƒ, ğ’„) = ((ğ’ğ’ğ‘‡), (ğ‘‘ğ’),ğ‘‘2) Como se mencionÃ³ antes, en el trabajo de Garland [13], se aÃ±aden los atributos de los vÃ©rtices y caras de la malla (normales, texturas, etc.), incrementando la dimensiÃ³n donde se trabaja, y calculando todo al mismo tiempo, pasando de calcular la distancia de un punto al plano que contiene a la cara, se calcula la distancia de un punto al hÃ­per-plano que contenga no solo a la cara, sino tambiÃ©n a los atributos, lo que conlleva a que no necesariamente se busque el punto geomÃ©tricamente mÃ¡s cercano, sino un punto geomÃ©trico probablemente mÃ¡s lejano, con una mejor aproximaciÃ³n a los atributos. Para compensar esto se hace uso de un atributo ğ€ğ’‹ de precisiÃ³n elegido por el usuario que va a denotar la importancia de cada atributo ğ’‹ âˆˆ {ğŸâ€¦ğ’}. 26 Figura 13: Correspondencia entre el punto p con sus atributos s y su proyecciÃ³n en el plano que contiene a la cara (ğ‘£1,ğ‘£2,ğ‘£3). En [2], como se muestra en la Figura 13, se calcula de manera diferente, en vez de calcular todo en una misma funciÃ³n de dimensiÃ³n ğ‘¹3+ğ‘š, aquÃ­ se proyecta en ğ‘¹3 y se calculan por separado. De esta forma la mÃ©trica de error para una cara f queda como la suma. ğ‘„ğ‘“ (ğ’— = ( ğ’‘ ğ‘  )) = ğ‘„ğ‘ ğ‘“ (ğ’—)+ âˆ‘ğ‘„ğ‘ ğ‘— ğ‘“ (ğ’—) ğ‘š ğ‘—=1 Donde el error geomÃ©trico ğ‘¸ğ’‘ ğ’‡ (ğ’—) es la distancia cuadrada desde p a una proyecciÃ³n ğ’‘â€² en ğ‘¹ğŸ‘ que contiene f, y el error de los atributos ğ‘¸ğ’”ğ’‹ ğ’‡ (ğ’—) es la desviaciÃ³n cuadrÃ¡tica entre s y la interpolaciÃ³n ğ’”â€² de los atributos de la cara f. El error geomÃ©trico es solo una versiÃ³n extendida con ceros del trabajo de Garland [13]: ğ‘„ğ‘ ğ‘“ = (ğ‘¨,ğ’ƒ, ğ’„) = ( ( ğ’ğ’ğ‘‡ â‹± 0 â‹± â‹± 0 â‹± â‹± 0 â‹± ) , ( ğ‘‘ğ’ 0 ) ,ğ‘‘2) Para formar el tÃ©rmino de error de atributos ğ‘¸ğ’”ğ’‹ ğ’‡ se define primero una funciÃ³n lineal ï¿½Ì‚ï¿½ğ‘—(ğ’‘) = ğ’ˆğ‘— ğ‘‡ğ’‘+ ğ‘‘ğ‘— Que representa los valores esperados para todos los atributos de todos los puntos ğ’‘ âˆˆ ğ‘¹ğŸ‘. El gradiente ğ’ˆğ’‹ y el escalar ğ’…ğ’‹ se definen de la siguiente manera. Como ï¿½Ì‚ï¿½ğ’‹(ğ’‘) debe interpolar los vÃ©rtices de la cara ğ’‡ = (( ğ’‘ğŸ ğ’”ğŸ ) , ( ğ’‘ğŸ ğ’”ğŸ ) , ( ğ’‘ğŸ‘ ğ’”ğŸ‘ )) y coincidir la interpolaciÃ³n lineal sobre el plano P. Adicionalmente ï¿½Ì‚ï¿½ğ’‹(ğ’‘) para un punto arbitrario ğ’‘ âˆˆ ğ‘¹ğŸ‘ debe ser idÃ©ntico al valor ï¿½Ì‚ï¿½ğ’‹(ğ’‘â€²) por ser su proyecciÃ³n en el plano P; esto es equivalente a predefinir ğ’ğ‘»ğ’ˆğ’‹ = ğŸ. Se pueden conseguir los valores de ğ’ˆğ’‹ y ğ’…ğ’‹ resolviendo este sistema de ecuaciones. 27 ( ğ’‘1 ğ‘‡ 1 ğ’‘2 ğ‘‡ 1 ğ’‘3 ğ‘‡ 1 ğ’‘4 ğ‘‡ 0) ( ğ‘”ğ‘— ğ‘‘ğ‘— ) = ( ğ‘ 1, ğ‘— ğ‘ 2, ğ‘— ğ‘ 3, ğ‘— 0 ) Y ğ‘¸ğ’”ğ’‹ ğ’‡ (ğ’—) = (ï¿½Ì‚ï¿½ğ’‹(ğ’‘) âˆ’ ğ’”ğ’‹) ğŸ = (ğ’ˆğ’‹ ğ‘»ğ’‘ + ğ’…ğ’‹ âˆ’ ğ’”ğ’‹) ğŸ, se puede expresar como: ( ( ğ‘”ğ‘—ğ‘”ğ‘— ğ‘‡ â‹± 0 â‹± âˆ’ğ‘”ğ‘— â‹± 0 â‹± â‹± 0 â‹± â‹± 0 â‹± 0 â‹± 0 â‹± ğ‘”ğ‘— ğ‘‡ â‹¯0â‹¯ 1 â‹¯0â‹¯ â‹± 0 â‹± â‹± 0 â‹± 0 â‹± 0 â‹±) , ( ğ‘‘ğ‘—ğ‘”ğ‘— 0 âˆ’ğ‘‘ğ‘— 0 ) , ğ‘‘ğ‘— 2 ) Donde el valor 1 aparece en ğ‘¨ğŸ‘+ğ’‹,ğŸ‘+ğ’‹ y el valor âˆ’ğ’…ğ’‹ aparece en ğ’ƒğŸ‘+ğ’‹. Juntando todas estas expresiones cuadrÃ¡ticas, queda: ğ‘„ğ‘“ = (ğ‘¨,ğ’ƒ, ğ‘) = ( ( ğ’ğ’ğ‘‡ âˆ‘ ğ’ˆğ‘—ğ’ˆğ‘— ğ‘‡ ğ‘— âˆ’ğ’ˆ1 â‹¯ âˆ’ğ’ˆğ‘š âˆ’ğ’ˆ1 ğ‘‡ â‹® ğ¼ âˆ’ğ’ˆğ‘š ğ‘‡ ) , ( ğ‘‘ğ’+ âˆ‘ ğ‘‘ğ‘—ğ’ˆğ‘— ğ‘— âˆ’ğ‘‘1 â‹® âˆ’ğ‘‘ğ‘š ) ,ğ‘‘2 +âˆ‘ ğ‘‘ğ‘— 2 ğ‘— ) Las primeras 3 filas y las primeras 3 columnas de la matriz A son densas, pero el resto de la sub-matriz ğ’Ã—ğ’ es la identidad I. Al aÃ±adir el atributo ğ€ğ’‹ de precisiÃ³n ğ‘„ = ğ‘¸ğ’‘ + âˆ‘ ğ€ğ’‹ ğŸğ‘¸ğ’”ğ’‹ğ’‹ . La sub-matriz ğ’ Ã—ğ’ pasa a ser una matriz con el escalar ğ€ğ’‹ ğŸ en su diagonal, por lo que solo se necesita de una variable. Todo en conjunto requiere de 11 + 4m variables, lo que hace su costo de almacenamiento lineal en m. FunciÃ³n vtkQuadricClustering En esta implementaciÃ³n se usa un mÃ©todo completamente diferente a las anteriores 3 soluciones. AquÃ­ se hace uso de la agrupaciÃ³n de vÃ©rtices y la mÃ©trica de error cuadrÃ¡tica descrito en el trabajo de Lindstrom [27]. En el trabajo de Lindstrom [27] se presenta un hÃ­brido, que separa los vÃ©rtices por grupos como lo presenta el trabajo de Rossignac [28]. Con la integraciÃ³n del error mÃ©trico cuadrÃ¡tico presentado por Garland [13] y despuÃ©s mejorado por Lindstrom [23]. La matriz A propuesta originalmente por Garland [13], se asume es invertible, aunque en prÃ¡ctica esto no necesariamente es el caso, como por ejemplo cuando la superficie es plana o tiene cero curvatura gaussiana. Para resolver esto Lindstrom [23] proponen resolver el problema asegurÃ¡ndose que este sobre-condicionado, quedando los valores del determinante de A lo suficientemente grandes. 28 En este caso por el contrario solo se utilizan tres condiciones, y se trata el problema de una manera un poco diferente, teniendo a x como la proyecciÃ³n ortogonal del centro de la celda en el espacio de todas las soluciones a Ax = b. Para lograr esto se aplica una descomposiciÃ³n en valores singulares ğ‘¨ = ğ‘¼ğšºğ‘½ğ‘», que para una matriz semidefinida simÃ©trica positiva A es equivalente a hacer una descomposiciÃ³n de valor propio. Esto se puede lograr utilizando rotaciones de Jacobi. ğœğ‘– + { 1 ğœğ‘–â„ ğ‘ ğ‘– ğœğ‘– ğœ1â„ > ğœ– 0 ğ‘ ğ‘– ğ‘›ğ‘œ Donde ğˆğŸ es el mayor valor singular y ğ es un valor umbral, definido en dicho trabajo como ğŸğŸ âˆ’ğŸ‘. Por lo tanto, el vÃ©rtice x, mÃ¡s cercano al centro de la celda ğ’™ que satisface Ax = b es ğ‘¥ = ğ‘¥ + ğ‘‰Î£+ğ‘ˆğ‘‡(ğ‘ âˆ’ ğ´ğ‘¥) Lo que se puede resumir en ğ‘¨âˆ’ğŸğ’ƒ siempre que ğšº+ = ğšºâˆ’ğŸ. Ya estudiadas dos de las bibliotecas mÃ¡s relevante en algoritmos geomÃ©tricos, se presenta un breve resumen de algunos algoritmos modernos que cambian la forma en que se plantea la simplificaciÃ³n de malla tradicional. 2.3 TÃ©cnicas modernas de reducciÃ³n de mallas En la constante evoluciÃ³n de los algoritmos para la simplificaciÃ³n de mallas se han hecho importantes avances que han cambiado la forma en la que se planteaba originalmente como se deberÃ­a simplificar una malla. Entre los mÃ¡s resaltantes trabajos que han innovado en esta Ã¡rea se encuentran los que se estudian a continuaciÃ³n. 2.3.1 Billboard clouds para simplificaciÃ³n extrema de modelos En esta tÃ©cnica presentada por DÃ©coret et al. [29] se busca tratar el problema con un enfoque diferente. Tradicionalmente las tÃ©cnicas de reducciÃ³n de mallas buscan eliminar vÃ©rtices o aristas progresivamente para disminuir la cantidad de polÃ­gonos a desplegar y asÃ­ aligerar la carga de trabajo, y la diferencia principal entre las diferentes tÃ©cnicas es el impacto en el nivel de detalle y el consumo de recursos y tiempo. En la tÃ©cnica presentada en este trabajo se busca transpolar los vÃ©rtices de textura de las caras de la malla a unos nuevos planos que se irÃ¡n definiendo segÃºn la topologÃ­a de la malla, la ventaja de esta tÃ©cnica es que se pueden hacer reducciones extremas de las mallas, pasando de 5000 o mÃ¡s caras, a solo unas 32 manteniendo un nivel aceptable de detalle. DescripciÃ³n general del algoritmo Como se muestra en la Figura 14, se comienza generando un conjunto de planos parcialmente transparentes de tamaÃ±o, orientaciÃ³n y resoluciÃ³n de textura independientes. Estos planos se generan de tal forma que se acoplen a la geometrÃ­a del modelo y se ira proyectando en ellos toda la informaciÃ³n de las caras del modelo, conservando valores como el mapa de normales para ser utilizado por el pÃ­xel shader. La forma en la que se generan estas billboard clouds se puede expresar como un problema de optimizaciÃ³n definido por una funciÃ³n de error, y una funciÃ³n de costo. La funciÃ³n de error se basa en la norma euclidiana ğ‘³âˆ que se computa en el espacio-objeto y es independiente de la vista. 29 La estrategia en la que se basa la funciÃ³n de error, es definir un error mÃ¡ximo tolerable ğœº, y el objetivo es generar los planos que estÃ©n dentro de ese umbral tal que el costo sea mÃ­nimo, el algoritmo es una optimizaciÃ³n exhaustiva que va seleccionando los planos capaces de proyectar la mayor cantidad de caras posibles. (a) (b) (c) (d) Figura 14: Ejemplo de Billboard Cloud, (a) Modelo original con 5138 caras, (b) Billboards unicolores para mostrar cÃ³mo se agruparon las caras, (c) Billboards con las texturas cargadas solo 32 polÃ­gonos desplegados (d)Ejemplo de las texturas generadas para los planos. Para estimar la relevancia de un plano con respecto de otro, se utiliza la densidad definida en base a la validez, cobertura y la penalizaciÃ³n. La validez del plano se expresa por medio de un booleano que dicta si un plano simplifica una cara o no, la cobertura se utiliza como medida de calidad, evitando asignar a un plano una cara con mala proyecciÃ³n. PenalizaciÃ³n es la mÃ©trica para descartar planos que no entren dentro del umbral aceptable. Y asÃ­ queda definida la densidad ğ’…(ğ‘·) como: ğ’…(ğ‘·) = ğ‘ª(ğ‘·) âˆ’ ğ‘·ğ’†ğ’ğ’‚ğ’ğ’•ğ’š(ğ‘·) Donde ğ‘ª(ğ‘·) es la cantidad de caras para las que el plano ğ‘· es una representaciÃ³n validad, se le denomina cobertura de P. Para calcular si un plano simplifica una cara se utiliza la distancia euclidiana (La longitud de una lÃ­nea recta que conecte ambos puntos) entre los vÃ©rtices de la cara y el plano, y esta debe ser menor a É›, quedando que los planos vÃ¡lidos entran en un rango en forma de esfera alrededor de cada vÃ©rtice. Los planos que son una representaciÃ³n valida del vÃ©rtice ğ’— se describen como ğ’—ğ’‚ğ’ğ’Šğ’…ğœº(ğ’—) que son los planos que interceptan la esfera de radio ğœº, de la misma forma para un plano ğ‘·, ğ’—ğ’‚ğ’ğ’Šğ’…(ğ‘·) son todas las caras que cubre ğ‘·. En la Figura 15 se puede ver un ejemplo del rango donde un plano es vÃ¡lido para simplificar un vÃ©rtice. 30 Figura 15: Proximidad y penalizaciÃ³n por proyecciones no adecuadas Una opciÃ³n es utilizar ğ’—ğ’‚ğ’ğ’Šğ’…(ğ‘·) como una mÃ©trica para medir la relevancia de un plano con respecto a otro, pero si se hace esto, un plano que cubre varias caras pequeÃ±as tendrÃ­a mayor relevancia que uno que cubre una cara de mayor Ã¡rea. Este comportamiento podrÃ­a traer consecuencias no deseadas. Por esto se calcula el Ã¡rea de la proyecciÃ³n de la cara en el plano. Dando de esta manera un mayor peso a las caras con mayor Ã¡rea proyectada sobre el plano. ğ‘ª(ğ‘·) = âˆ‘ ğ’‚ğ’“ğ’†ğ’‚ğ’‘(ğ’‡) ğ’‡âˆˆğ’—ğ’‚ğ’ğ’Šğ’…ğœº(ğ‘·) Algunas veces existen planos que son Ã³ptimos para unas caras pero fallan en capturar todos los atributos de las demÃ¡s caras, por esto se le da la capacidad a las caras de penalizar aquellos planos que no las proyectan adecuadamente. Para una normal ï¿½âƒ—âƒ—ï¿½ los planos vÃ¡lidos son los que se encuentran a una distancia no mayor a ğœº, donde ğœº es el umbral de error que define el usuario, tambiÃ©n se toma en cuenta los que se encuentren a ğœº distancia de ser vÃ¡lidos por la izquierda, estos se agrupan como ğ’ğ’Šğ’”ğ’”ğœº(ğ’‡). Se podrÃ­an considerar ğ’—ğ’‚ğ’ğ’Šğ’…ğœº(ğ’‡) y ğ’ğ’Šğ’”ğ’”ğœº(ğ’‡) como partes contiguas del segmento ğŸğœº ğ’š ğœº, quedando la penalizaciÃ³n como: ğ‘·ğ’†ğ’ğ’‚ğ’ğ’Šğ’›ğ’‚ğ’„ğ’ŠÃ³ğ’(ğ‘·) = ğ’˜ğ’‘ğ’†ğ’ğ’‚ğ’ğ’Šğ’›ğ’‚ğ’„ğ’ŠÃ³ğ’ âˆ‘ ğ’‚ğ’“ğ’†ğ’‚ğ’‘ ğ’‡âˆˆğ’ğ’Šğ’”ğ’”(ğ‘·) (ğ’‡) Los planos se definen usando las coordenadas esfÃ©ricas (ğœ½,ğ‹) para la direcciÃ³n normal, y la distancia ğ† hasta el origen, en este espacio, los planos vÃ¡lidos para cada vÃ©rtice serÃ¡n representados como superficies producidas por la funciÃ³n ğ† = ğ’‡(ğœ½,ğ‹) (ver Figura 16). Se calcula el dominio variando ğ† en un rango âˆ’ğœº ğ² ğœº. 31 Figura 16: (a) Se resalta la cara f y los vÃ©rtices que al componen. (b) Conjunto de planos vÃ¡lidos para cada vÃ©rtice segÃºn la funciÃ³n ğ† = ğ’‡(ğœ½,ğ‹). (c) Dominio valido para cada plano (entre âˆ’ğœº ğ’š ğœº ). (d) DiscretizaciÃ³n de la intercepciÃ³n del dominio valido de cada plano (e) Cobertura general de la malla. Es espacio debe ser dividido en bins ğ‘©ğœ½ğ’Š,ğ‹ğ’‹,ğ†ğ’Œ y en cada bins calcularse su densidad. Para una cara f dada, ğ’—ğ’‚ğ’ğ’Šğ’…ğœº(ğ’‡) representa todos los bins que pertenecen al conjunto soluciÃ³n para la cara f. Estos bins se consideran vÃ¡lidos para f si en ellos existe al menos un plano que sea vÃ¡lido para f, esto es calculable iterando en las coordenadas ğœ½,ğ‹. Con unas ciertas coordenadas ğœ½,ğ‹ y una cara f se calcula el rango [ğ†ğ’ğ’Šğ’,ğ†ğ’ğ’‚ğ’™] que intercepta ğ’—ğ’‚ğ’ğ’Šğ’…ğœº(ğ’‡), se calcula ğ‘ª(ğ’‡) que es constante para una direcciÃ³n dada, y se suma como la cobertura de los bins entre ğ†ğ’ğ’Šğ’ ğ’š ğ†ğ’ğ’‚ğ’™ y como penalizaciÃ³n para los bins entre ğ†ğ’ğ’Šğ’ âˆ’ ğœº ğ’š ğ†ğ’ğ’Šğ’. Para tener en cuenta el antialising ğ‘ª(ğ’‡) es ponderado por el porcentaje del bin que estÃ¡ cubierto. Los planos se generan en base a las zonas mÃ¡s densas de estos bins, buscando intercepciones entre los ğ’—ğ’‚ğ’ğ’Šğ’…(ğ’‡ğ’Š), dando mayor prioridad al plano que cubra mÃ¡s Ã¡rea total. Luego, se itera sobre el conjunto de bins con mayor densidad, en busca de un plano donde se proyecten todas las caras del conjunto. Una vez seleccionado el plano, se actualiza la densidad removiendo los valores de las caras ya colapsadas y se prosigue a buscar el siguiente bin con mayor densidad. Refinamiento adaptativo Cada plano ğ‘ƒğ‘– tiene asignado un conjunto ğ’—ğ’‚ğ’ğ’Šğ’…ğœº ğ‘­ (ğ‘·ğ’Š), el cual contiene las caras que serÃ¡n proyectadas en Ã©l. Por cada cara primero se conseguirÃ¡ su bounding box, y se proseguirÃ¡ por proyectarlas ortogonalmente en el plano, el tamaÃ±o de las texturas se calcula segÃºn el tamaÃ±o de su bounding box. En muchas ocasiones un plano es soluciÃ³n de varias caras al mismo tiempo, para aumentar el detalle y reducir cualquier espacio en blanco que pueda quedar entre diferentes billboards se proyecta la textura en todos los planos que sean soluciÃ³n para la cara. Para aÃ±adir iluminaciÃ³n tambiÃ©n se debe recalcular el mapa de normales proyectado en los bounding box para ser aÃ±adido al plano. 2.3.2 SimplificaciÃ³n de mallas en tiempo real utilizando la GPU Un aspecto importante de la ComputaciÃ³n GrÃ¡fica, es el pipeline grÃ¡fico, que son los pasos necesarios para desplegar una representaciÃ³n 2D en el monitor de la escena. En este pipeline existen pasos donde un desarrollador puede cargar su propio cÃ³digo con el fin de alterar el resultado de este pipeline. 32 Una de las principales diferencias entre la GPU y la CPU (Central Processing Unit) es la gran cantidad de procesos que esta puede ejecutar en paralelo, contando con hasta los 5632 nÃºcleos. Cuando la CPU comÃºnmente maneja entre 2 y 32 nÃºcleos. Durante un prolongado periodo de tiempo la simplificaciÃ³n de malla se considerÃ³ un algoritmo exclusivo de la CPU, por la complejidad de las operaciones necesarias para simplificar un modelo, pero con la introducciÃ³n de los shaders que daba la posibilidad de interactuar con la geometrÃ­a de la malla durante el pipeline, se abriÃ³ la posibilidad de realizar estas operaciones complejas en el despliegue de la malla. MÃ©todos exitosos como los propuestos por Garland [13] y Lindstrom [3] y [23] estÃ¡n pensados para trabajar en la CPU, esto conlleva tiempos de procesamiento que hacen imposible realizar simplificaciones en tiempo real. Por esto se busca en este trabajo incluir las siguientes contribuciones: ï‚· Reformular el trabajo de â€œVertex ClÃºsterâ€ de Lindstrom [27] para adoptar el ambiente de trabajo paralelo de la GPU ï‚· Una estructura de datos en forma de Ã¡rbol octal (una estructuras de dato en forma de Ã¡rbol que cada nodo tiene exactamente 8 hijos) para propÃ³sito general en la GPU ï‚· SimplificaciÃ³n de malla adaptativa con requerimientos fijos de memoria ï‚· PreservaciÃ³n de detalles segÃºn importancia utilizando warping no lineal En la conferencia SIGGRAPH del aÃ±o 2000, Peter Lindstrom presentÃ³ su trabajo â€œOut-of-Core Simplification of large Polygonal Modelsâ€ [27], en donde aÃ±adÃ­a al trabajo de Rossignac y Borrel [28], la mÃ©trica cuadrÃ¡tica para calcular la soluciÃ³n y error estimado, presentado en el trabajo Lindstrom [3] y [23]. En Lindstrom [27], una vez definido el nÃºmero de subdivisiones que tendrÃ¡ la rejilla, se carga la malla original un triÃ¡ngulo por vez, se identifica en que celda cae cada vÃ©rtice del triÃ¡ngulo y se marca con el Ã­ndice de la celda. Si la celda no ha sido inicializada, se genera un Ã­ndice (normalmente en orden incremental) y se crea la matriz de error cuadrÃ¡tico con ceros. Si dos o mÃ¡s vÃ©rtices de un mismo triÃ¡ngulo caen sobre la misma celda, se colapsa y descarta el triÃ¡ngulo, de lo contrario se agregan los vÃ©rtices al grupo ğ‘‰ğ‘œğ‘¢ğ‘¡ y la cara al grupo ğ‘‡ğ‘œğ‘¢ğ‘¡. Antes de cargar el siguiente triÃ¡ngulo se calcula el error cuadrÃ¡tico y se suma a la celda de cada uno de sus vÃ©rtices. El error cuadrÃ¡tico para un triÃ¡ngulo ğ‘¡ estÃ¡ dado por. ğ‘¡ = (ğ‘¥1,ğ‘¥2, ğ‘¥3) ğ‘„ = ( ğ´ âˆ’ğ‘ âˆ’ğ‘ğ‘‡ ğ‘ ) = ğ‘›ğ‘›ğ‘‡ ğ‘› = ( ğ‘¥1 Ã— ğ‘¥2 + ğ‘¥2 Ã— ğ‘¥3 + ğ‘¥3 Ã— ğ‘¥1 âˆ’[ğ‘¥1, ğ‘¥2,ğ‘¥3] ) Una vez sumados todos los errores cuadrÃ¡ticos de los vÃ©rtices en los errores cuadrÃ¡ticos acumulados en sus respectivas celdas, se calcula el vector representativo de la celda y se despliega la malla simplificada. En el trabajo de DeCoro y Tatarchuk [30] se utiliza esta estrategia de simplificaciÃ³n out-of-core (algoritmos elaborados para trabajar con volÃºmenes de informaciÃ³n demasiado grandes para ser almacenada en la memoria del 33 computador) presentada por Lindstrom, y la capacidad de procesamiento paralelo de la GPU para realizar simplificaciones en tiempo real con niveles de detalle aceptables. Figura 17: Utilizando el algoritmo de simplificaciÃ³n en tiempo real en la GPU de DeCoro y Tatarchuk se pueden generar estos cuatro niveles de detalles un orden de magnitud mÃ¡s rÃ¡pido que un algoritmo que reside en la CPU que genera solo 1 nivel de detalle. DescripciÃ³n general del algoritmo El algoritmo DeCoro y Tatarchuk se puede reducir a 3 pasos sencillos y requiere que se cargue la malla dos veces durante el pipeline de renderizado. El modelo se divide en una rejilla de tamaÃ±o definido por el usuario, y se genera un off-screen buffer (para realizar el renderizado sin que se despliegue en pantalla) que sirve de arreglo bidimensional para almacenar la data que serÃ¡ trabajada por el pipeline grÃ¡fico. El tamaÃ±o del buffer dependerÃ¡ del nivel de detalle solamente, permitiendo que el algoritmo pueda trabajar con mallas de cualquier tamaÃ±o. Los pasos que realizarÃ¡ este algoritmo como se muestra en la Figura 18 son los siguientes: 34 Figura 18: La malla original es dividida en una rejilla de 9x9x9. En el paso 1 se calcula el error cuadrÃ¡tico para cada celda y se almacena en los buffers que contienen el error cuadrÃ¡tico en valores de pÃ­xel. En el paso 2 se minimiza el error cuadrÃ¡tico para calcular el vÃ©rtice representativo de cada celda como se explicÃ³ en el algoritmo de Lindstrom [27]. En el paso 3 se genera la malla simplificada con la informaciÃ³n del paso 2. Paso 1: GeneraciÃ³n del mapa de grupo cuadrÃ¡tico. Dada una malla y su respectivo bounding box, junto con el nÃºmero de divisiones para cada dimensiÃ³n, se renderizan los vÃ©rtices, y se le asigna un identificador Ãºnico a cada celda creada al dividir el bounding box. Se considerara el buffer como un arreglo indexado por los identificadores de las celdas. Cada campo del arreglo va a almacenar la suma del error cuadrÃ¡tico para esa celda (10 valores punto flotante para una matriz de tamaÃ±o ğŸ’ Ã— ğŸ’ simÃ©trica), la posiciÃ³n de vÃ©rtice promedio en esa celda (3 valores punto flotante) y el conteo de vÃ©rtices. El vertex shader determina que celda corresponde a cada vÃ©rtice y su posiciÃ³n en el arreglo, y el geometry shader, que tiene acceso a todos los vÃ©rtices en el triÃ¡ngulo utiliza su posiciÃ³n global y calcula su error cuadrÃ¡tico de la cara, y se lo asigna a cada uno de sus vÃ©rtices para que se acumule en el mapa de textura por el pÃ­xel shader que propaga los colores calculados con composiciÃ³n aditiva habilitado. Paso 2: Calcular la posiciÃ³n Ã³ptima del vÃ©rtice representativo. Utilizando el mapa cuadrÃ¡tico generado en el Paso 1, se calcula el vÃ©rtice representativo de cada celda. Se dibuja un cuadrado del mismo tamaÃ±o de los buffers utilizados en el Paso 1 en un nuevo buffer. En el pÃ­xel shader se toman los valores de error cuadrÃ¡ticos generados antes y se calcula la posiciÃ³n Ã³ptima que tendrÃ¡ el nuevo vÃ©rtice con inversiÃ³n de matriz. Si el determinante de la matriz estÃ¡ por debajo de un umbral impuesto por el usuario (por ejemplo ğŸğ’†âˆ’ğŸğŸ) se toma como singular, por lo tanto se utiliza una posiciÃ³n promediada y se guarda el resultado en el nuevo arreglo. Paso 3: GeneraciÃ³n de la malla simplificada. Se vuelve a pasar al pipeline la malla original para mover los vÃ©rtices a su posiciÃ³n simplificada, y eliminar los que se hayan descartado. El vertex shader identifica la celda a la que pertenece cada vÃ©rtice nuevamente, y el geometry shader verifica si los 3 vÃ©rtices de la cara estÃ¡n en una misma celda, si es asÃ­ se elimina la cara. En caso de no ser asÃ­ se retorna la nueva posiciÃ³n segÃºn el resultado del Paso 2, que serÃ¡ la nueva posiciÃ³n del triÃ¡ngulo que serÃ¡ almacenada en un buffer de la GPU para uso posterior. Se pueden calcular mÃºltiples niveles de detalle sin tener que repetir todos los pasos. Si la resoluciÃ³n se reduce a la mitad se omite el Paso 1, y se crea el mapa cuadrÃ¡tico reduciendo la resoluciÃ³n del mapa cuadrÃ¡tico anterior. El Paso 2 se ve inalterado, pero el Paso 3 puede utilizar la malla ya simplificada anteriormente como entrada, ya que la conectividad es la misma. 35 Esto permite la creaciÃ³n de diferentes niveles de detalle (LOD), considerablemente mÃ¡s rÃ¡pido que realizar todos los pasos nuevamente. DivisiÃ³n en rejilla no uniforme usando una funciÃ³n de warping Una manera para incrementar la adaptabilidad del algoritmo, es deformar la malla original y aumentar el nivel de detalle en zonas de mayor complejidad. Se puede aplicar una funciÃ³n para deformar la malla durante el proceso de simplificaciÃ³n, pero se aplica la operaciÃ³n inversa al calcular el error cuadrÃ¡tico. El Ãºnico cambio al utilizar esta funciÃ³n de warping es que altera en que celda caen los vÃ©rtices, para poder calcular con precisiÃ³n el error cuadrÃ¡tico es importante no alterar la posiciÃ³n de los vÃ©rtices ni el espacio ocupado por la rejilla. Un uso importante para esta funciÃ³n de warping es para simplificaciones dependientes del punto de visiÃ³n, donde el algoritmo da prioridad a las zonas mÃ¡s cercanas al espectador, se puede observar un ejemplo de esto en la Figura 19. La forma mÃ¡s simple de lograr esto es aplicando la matriz de transformaciÃ³n World View Projection donde los diferentes modelos son pasados a un Ãºnico espacio global, luego transformados a un espacio dependiente de la posiciÃ³n del espectador y por ultimo transformados al espacio de proyecciÃ³n donde se proyecta la imagen en una escena plana, en este Ãºltimo comÃºnmente se aplica la transformaciÃ³n de perspectiva. Transformaciones dependientes del espectador son Ãºtiles para aplicaciones animadas en tiempo real. Figura 19: A la izquierda un ejemplo de la simplificaciÃ³n en tiempo real sin utilizar funciÃ³n de warping. A la derecha el mismo ejemplo utilizando una funciÃ³n de warping dependiente de la posiciÃ³n del espectador, que en este caso estÃ¡ situado a su izquierda. Como se muestra en la Figura 21, otro uso importante de esta funcionalidad es el incrementar el nivel de detalle en zonas relevantes para el usuario, por lo que se debe permitir utilizar funciones de warping que hagan especial Ã©nfasis en las zonas importantes, para lograr esto se usa una funciÃ³n de contrapeso gaussiano ğ’‡(ğ’™) centrada en el punto de interÃ©s quedando como 36 ğ‘“ğœ‡,ğœ,ğ‘(ğ‘¥) = (1âˆ’ ğ‘)ğºğœ‡,ğœ(ğ‘¥)+ ğ‘ ï¿½Ì‚ï¿½ğœ‡,ğœ(ğ‘¥) = âˆ« ğºğœ‡,ğœ(ğ‘¡)ğ‘‘ğ‘¡ ğ‘¥ âˆ’âˆ = 1 2 (1 + erf ğ‘¥ âˆ’ ğœ‡ ğœâˆš2 ) ğ¹ğœ‡,ğœ,ğ‘(ğ‘¥) = ï¿½Ì‚ï¿½ğœ‡,ğœ(ğ‘¥) âˆ’ ï¿½Ì‚ï¿½ğœ‡,ğœ(0) ï¿½Ì‚ï¿½ğœ‡,ğœ(1) âˆ’ ï¿½Ì‚ï¿½ğœ‡,ğœ(0) (1âˆ’ ğ‘)+ ğ‘ğ‘¥ En esta definiciÃ³n, la ecuaciÃ³n ğ‘®ğ,ğˆ (ğ’™) es la distribuciÃ³n normal estÃ¡ndar, y erf(.) es la funciÃ³n de error gaussiano. Se define un parÃ¡metro de balance b, que determina un contrapeso mÃ­nimo para regiones fuera del Ã¡rea de interÃ©s, si se establece que b=1 es equivalente a un muestreo uniforme (ver Figura 20). Figura 20: Ejemplo de las funciones de warping con diferentes parÃ¡metros ğœ y ğ‘ (a) ejemplo de la funciÃ³n ğ‘“ğœ‡,ğœ,ğ‘(ğ‘¥). (b) ejemplo de la funciÃ³n ğ¹ğœ‡,ğœ,ğ‘(ğ‘¥) 37 Figura 21: Ejemplo de la simplificaciÃ³n adaptativa, a la izquierda un modelo simplificado tradicionalmente, y a la derecha un modelo simplificado utilizando una funciÃ³n de warping Ãrboles octales probabilÃ­sticos Al usar una rejilla de tamaÃ±o definido, se debe introducir el tamaÃ±o de la rejilla antes de comenzar el proceso de simplificaciÃ³n, y no permite fÃ¡cilmente incluir niveles impares de precisiÃ³n. Y la informaciÃ³n debe ser almacenada en un gran arreglo de tamaÃ±o fijo para que las direcciones de memoria puedan ser calculadas directamente, sin importar la cantidad de clÃºster que realmente tengan informaciÃ³n. La propuesta consiste en utilizar una estructura de datos, que permita mÃºltiples niveles de resoluciÃ³n, desde la mÃ¡s baja hasta una mÃ¡s detallada, donde cada nivel contiene el doble de detalle que el anterior. Cada celda va almacenar el error cuadrÃ¡tico estimado de una rejilla de un nivel de detalle determinado. Cuando se mapea un vÃ©rtice de la malla a la rejilla en el paso de simplificaciÃ³n, esta representaciÃ³n permite un nivel de muestro superior en zonas con mÃ¡s detalles. En la Figura 22 se aprecia un ejemplo de la distribuciÃ³n en un Ã¡rbol octal de la celda de divisiÃ³n. 38 Figura 22: Ejemplo de un Ã¡rbol octal representando los diferentes niveles de subdivisiÃ³n en un cubo. Operaciones: El octal define las operaciones de alto nivel ADDVERTEX (v) y FINDCLUSTER (v) utilizadas en el Paso 1 y Paso 3, respectivamente. Estas hacen uso de las operaciones de bajo nivel WRITE (k,d) y d=READ (k) para escribir o leer la informaciÃ³n d en la posiciÃ³n k. ConstrucciÃ³n probabilÃ­stica: Durante la creaciÃ³n del Ã¡rbol en el Paso 1, se utiliza la operaciÃ³n ADDVERTEX en cada vÃ©rtice a insertar en el Ã¡rbol. En un Ã¡rbol de profundidad mÃ¡xima ğ‘™ğ‘šğ‘ğ‘¥, un vÃ©rtice tiene ğ‘™ğ‘šğ‘ğ‘¥ niveles en donde puede ser ubicado. Una implementaciÃ³n de ADDVERTEX podrÃ­a hacer ğ‘™ğ‘šğ‘ğ‘¥ corridas por el Ã¡rbol, para asignar cada vÃ©rtice en cada posible nivel. Esto resultarÃ­a en la construcciÃ³n del Ã¡rbol mÃ¡s precisa, pero el tiempo de simplificaciÃ³n crecerÃ­a proporcionalmente. Alternativamente, se puede considerar el error cuadrÃ¡tico de la rejilla ğ‘¸ğ’„ como el resultado de integrar los errores cuadrÃ¡ticos ğ‘¸ğ’™ en cada punto x en la superficie contenida en C, escalado segÃºn el Ã¡rea diferencial dA. En una malla con una gran cantidad de polÃ­gonos, se puede aproximar esta cantidad tomando la suma del error cuadrÃ¡tico de los vÃ©rtices ğ‘¸ğ’— contenidos en C, que son calculados por las caras adyacentes ğ‘¸ğ’‡ y sus correspondientes Ã¡reas ğ‘¨ğ’‡. ğ‘„ğ‘ = âˆ« ğ‘„ğ‘¥ğ‘‘ğ´ ğ‘¥âˆˆğ¶ â‰ˆ âˆ‘ âˆ‘ ğ‘„ğ‘“ ğ´ğ‘“ 3 ğ‘“âˆˆğ‘ğ‘‘ğ‘—(ğ‘£)ğ‘£âˆˆğ¶ Para reducir la cantidad de muestreos, se propone asignar el nivel de los vÃ©rtices de manera aleatoria. En vez de una distribuciÃ³n aleatoria uniforme, utiliza una funciÃ³n que crece exponencialmente en niveles superiores, y como existen exponencialmente menos vÃ©rtices en niveles inferiores, el muestreo se mantiene relativamente igual. Almacenamiento probabilÃ­stico: Como con el almacenamiento uniforme, se almacenan los niveles del Ã¡rbol octal, en buffers off-screen, utilizÃ¡ndolos como un arreglo, y dividiÃ©ndolo en secciones por cada nivel. Una vez ADDVERTEX(v) calcule el nivel donde se almacenarÃ¡ v, se genera un Ã­ndice k para el vÃ©rtice y se invoca WRITE(k,v) para guardarlo. La funciÃ³n WRITE utiliza una funciona hash de distribuciÃ³n uniforme para guardar los vÃ©rtices en el buffer, para reducir el espacio de almacenamiento, se reserva espacio para menos nodos de los que son necesarios para el nivel entero. Por lo que la probabilidad de que WRITE(k,v) sea vÃ¡lido se espera sea igual al porcentaje de nodos ocupados en ese nivel. 39 Acceso al Ã¡rbol: DespuÃ©s de crear el Ã¡rbol en el Paso 1, se utilizarÃ¡ FINDCLUSTER(v) en el Paso 3 para determinar la celda correspondiente y el nivel del vÃ©rtice v. Al ser una estructura de mÃºltiples niveles, se mitiga el efecto de valores perdidos. En este caso ADDVERTEX(v) mantiene la propiedad de que cada punto en el espacio estÃ¡ representado por un nodo en la estructura, la Ãºnica incÃ³gnita es en quÃ© nivel de detalle se encuentra. Para acelerar la velocidad de la bÃºsqueda, se utiliza una bÃºsqueda binaria en los diferentes niveles. Como la profundidad del Ã¡rbol es ğ‘¶(ğ¥ğ¨ğ (ğ‘µğ’„)), donde ğ‘µğ’„ es el nÃºmero total de celdas, una bÃºsqueda binaria probabilÃ­stica sobre la profundidad, reducirÃ­a el orden a ğ‘¶(ğ¥ğ¨ğ  (ğ¥ğ¨ğ (ğ‘µğ’„))). Detectar colisiones de hash: Como la funciÃ³n WRITE utiliza tablas hash, se puede encontrar el caso en que dos vÃ©rtices tengan como resultado el mismo Ã­ndice en la tabla. Una soluciÃ³n es que WRITE, almacene las llaves y el valor, permitiendo a READ determinar si se consiguiÃ³ o no una colisiÃ³n. En la aplicaciÃ³n no es posible debido a las limitaciones en la composiciÃ³n aditiva utilizada para acumular el error cuadrÃ¡tico. Por lo tanto, se utiliza el modo de composiciÃ³n mÃ¡ximo para solo el componente alfa y solo se escribe k en un buffer y â€“k en el otro. La operaciÃ³n READ verifica que los valores sean iguales a k y -k respectivamente. Figura 23: Ejemplo de la simplificaciÃ³n con rejilla uniforme y Ã¡rbol octal, a la izquierda una rejilla uniforme de tamaÃ±o 643, con 13K triÃ¡ngulos, a la derecha la misma malla simplificada utilizando un Ã¡rbol octal con 6 niveles de detalle (equivalente en espacio a una rejilla de 643), en este caso la cantidad de triÃ¡ngulos es de 4K, y se mantiene un nivel de detalle similar en zonas relevantes como el contorno de las patas, piernas, orejas y ojos. 40 CapÃ­tulo 3 SoluciÃ³n Propuesta En este capÃ­tulo se describe el esquema general del diseÃ±o utilizado para desarrollar la soluciÃ³n. 3.1 DescripciÃ³n general Primero se presenta una descripciÃ³n bÃ¡sica de la estructura del sistema de simplificaciÃ³n en tiempo real en la GPU. Figura 26: Ejemplo del algoritmo de simplificaciÃ³n en tiempo real utilizando la GPU. Como se aprecia en la imagen, existen muchas similitudes con el algoritmo desarrollado por DeCoro, con la diferencia de un paso adicional antes de generar la malla simplificada. En la Figura 26 se describen las diferentes estructuras generadas en el proceso de simplificaciÃ³n. El proceso se asemeja al implementado en el trabajo de DeCoro y Tatarchuk [30], las diferencias se detallan en el prÃ³ximo capÃ­tulo Figura 27: Proceso de simplificaciÃ³n de mallas en tiempo real. Como se aprecia en la Figura 27, se diseÃ±Ã³ una Ãºnica clase encargada de procesar el modelo geomÃ©trico. Este mÃ³dulo requiere de que se suministre un objeto 3D en malla y ofrece dos mÃ©todos para ejecutar sobre la malla suministrada: Graficar Original: Este mÃ©todo grafica la malla original y permite realizar operaciones sobre la misma. Entre las cuales estÃ¡n: Dibujar un escenario, delinear la malla del modelo, mostrar informaciÃ³n tÃ©cnica de la malla, como el nÃºmero de vÃ©rtices y caras, asÃ­ como un log de los cÃ¡lculos realizados sobre la malla. Simplificar: Este mÃ©todo que se describe en sus distintos pasos en la Figura 27, es el mÃ©todo que realiza los cÃ¡lculos necesarios para simplificar la malla. El mÃ©todo Simplificar posee las mismas funciones que ofrece el 41 mÃ©todo de Graficar Original. Con la diferencia de que en este mÃ©todo se implementan sobre la malla resultante del proceso de simplificaciÃ³n. La entrada de la aplicaciÃ³n es el modelo en malla que se busca simplificar. La malla es procesada utilizando la GPU para aprovechar sus capacidades de procesamiento paralelo. La salida de la aplicaciÃ³n serÃ¡ la malla original simplificada. El algoritmo de simplificaciÃ³n consiste en 4 pasos que se detallan a continuaciÃ³n: En el primer paso, dada la malla, el bounding box, y una cantidad definida por el usuario de dimensiones, se envÃ­a la informaciÃ³n al pipeline grÃ¡fico. Se utiliza la imagen que retorna el pipeline grÃ¡fico como matriz de almacenamiento, donde cada pÃ­xel representa una celda. En el Vertex Shader cada vÃ©rtice debe calcular su posiciÃ³n en esta matriz. En la implementaciÃ³n de DeCoro y Tatarchuk [30], se utiliza el Geometry Shader para realizar el cÃ¡lculo del error cuadrÃ¡tico, pero en este trabajo este cÃ¡lculo se realiza en el Vertex Shader, por limitaciones tÃ©cnicas(la API WebGL no posee un Geometry Shader). El fragment shader acumula el error cuadrÃ¡tico utilizando la funciÃ³n de blending. En el segundo paso, se envÃ­a al pipeline grÃ¡fico el resultado del primer paso junto a un plano con el mismo tamaÃ±o de la matriz de almacenamiento. En el Vertex Shader solo se retornan los valores sin alterar. En el Fragment Shader, se extrae la informaciÃ³n de la matriz de almacenamiento, se determina el vÃ©rtice representativo utilizando inversiÃ³n de matrices y se retorna una nueva matriz conteniendo los vÃ©rtices representativos de cada celda. En el tercer paso, se envÃ­a la malla original y la matriz de almacenamiento generada en el segundo paso al pipeline grÃ¡fico. En el Vertex Shader los vÃ©rtices determinan su nueva ubicaciÃ³n utilizando la matriz de almacenamiento. En nuestra implementaciÃ³n cada vÃ©rtice se reubica a su nueva posiciÃ³n en el Vertex Shader. En la implementaciÃ³n de DeCoro y Tatarchuk [30], los vÃ©rtices son reposicionados en el Geometry Shader. En el Fragment Shader se retorna para ser almacenado en el conjunto de matrices la estructura de la malla simplificada. En el cuarto paso, se extrae la informaciÃ³n de las matrices de almacenamiento generadas en el tercer paso y se genera la malla simplificada, este paso es solo necesario si se desea tener la malla resultante en la memoria RAM. Esto permite luego generar un archivo distribuible y utilizar el modelo resultante en otra aplicaciÃ³n. 3.2 ImplementaciÃ³n En este capÃ­tulo se detalla la implementaciÃ³n del algoritmo de simplificaciÃ³n en tiempo real utilizando la GPU en WebGL. Para el desarrollo del algoritmo de simplificaciÃ³n en tiempo real utilizando la GPU en WebGL se hizo uso de la metodologÃ­a ASD (Adaptive Software Development), que gracias a sus ciclos rÃ¡pidos de aprendizaje y mejora, lo convierte la metodologÃ­a ideal para la realizaciÃ³n de un proyecto con tantos componentes ofuscados por los mÃºltiples API de desarrollo utilizados. En la implementaciÃ³n del algoritmo de simplificaciÃ³n en tiempo real, se hizo uso de los siguientes lenguajes: HTML (Hypertext Markup Language), que es el lenguaje estÃ¡ndar para la creaciÃ³n de pÃ¡ginas y aplicaciones web, se utilizÃ³ para la creaciÃ³n de las etiquetas necesarias para almacenar la informaciÃ³n requerida y dar estructura a todos los distintos elementos que conformarÃ­an la aplicaciÃ³n. CSS (Cascading Style Sheets), es el lenguaje desarrollado para describir la apariencia de un documento escrito en HTML; este lenguaje es utilizado para darle forma y agregarles estilos a todas las etiquetas creadas con HTML, para el desarrollo del algoritmo de simplificaciÃ³n en tiempo real se hizo uso del framework de diseÃ±o web Bootstrap, que se encarga de abstraer toda la complejidad del lenguaje css y acelera el desarrollo del diseÃ±o de la pÃ¡gina web. Javascript, que junto con CSS y HTML, completan el conjunto de lenguajes con los que se genera todo el contenido dentro del World Wide Web, es el lenguaje encargado de brindar dinamismo a la pÃ¡gina web y es donde estÃ¡ implementado el framework WebGL, con el que Javascript es capaz de tener acceso a los comandos internos 42 de la tarjeta grÃ¡fica. Para el desarrollo del algoritmo de simplificaciÃ³n se hizo uso de la biblioteca Threejs, una de la biblioteca mÃ¡s importante que encapsula toda la complejidad del lenguaje WebGL, facilitando el desarrollo de los shaders necesarios para realizar la simplificaciÃ³n de mallas. Al momento de implementar el algoritmo de simplificaciÃ³n, debido a la necesidad de que existieran dos entornos independientes que se encargaran de manejar tanto el modelo original como el simplificado, se englobÃ³ toda la lÃ³gica con la que se procesa la malla en una clase (ver Figura 28) que puede ser instanciada mÃºltiples veces. La estructura general de Ã©sta clase se define a continuaciÃ³n. Para lograr la simplificaciÃ³n de mallas en tiempo real, el algoritmo se dividiÃ³ en los siguientes pasos. Primero se carga el modelo en cualquiera de los formatos soportados y se traduce a las estructuras de datos que proporciona la biblioteca Threejs. El primer paso es calcular el Bounding Box, resultando en dos vÃ©rtices representativos con el valor mÃ¡ximo y mÃ­nimo de cada coordenada. Utilizando los valores del Bounding Box aplicamos operaciones de escalado y traslaciÃ³n para transformar los vÃ©rtices pertenecientes al objeto al espacio de valores entre los nÃºmeros uno (1) y dos (2). Las posiciones se trasladan con el fin de evitar errores de precisiÃ³n punto flotante al momento de realizar los cÃ¡lculos de error cuadrÃ¡tico. Se calcula la metadata que necesitaremos para poder determinar cÃ³mo se agruparÃ¡n los vÃ©rtices. La metadata estÃ¡ compuesta por los siguientes elementos: ï‚· A cada vÃ©rtice se le asigna la posiciÃ³n de los otros vÃ©rtices de su cara, para simular el funcionamiento del Geometry Shader en el Vertex Shader. ï‚· Se asigna como atributo a todos los vÃ©rtices los valores mÃ¡ximo y mÃ­nimo, el nÃºmero de dimensiones definidas por el usuario para dividir la rejilla, y el tamaÃ±o de la textura que se utilizara para almacenar toda la informaciÃ³n de la rejilla. Figura 28: Diagrama de la clase principal en el algoritmo de simplificaciÃ³n de mallas. Class WebGL +Constructor +setShaders +InitGL +initTextureFramebuffer +setTextureBuffer +RemoveMesh +Resize +setDialogText +Load +LoadModel +StepOne +StepTwo +StepThree +StepFour +DebugLog +Animate +LoadScene 43 3.3 ImplementaciÃ³n del algoritmo de simplificaciÃ³n En esta secciÃ³n detalla la implementaciÃ³n de los pasos descritos en la secciÃ³n 3.1. En el primer paso se debe calcular el error cuadrÃ¡tico, primero el Vertex Shader determina si dos o mÃ¡s vÃ©rtices de la cara pertenecen a una misma celda, en caso de ser asÃ­ la cara debe colapsada, por lo que se descarta. Debido a que no se posee un Geometry Shader con el que eliminar los elementos a descartar, le asignamos al vÃ©rtice una posiciÃ³n que se salga del rango de la cÃ¡mara. En el caso de que todos los vÃ©rtices de la cara pertenezcan a distintas celdas se genera la matriz de error cuadrÃ¡tico de la siguiente forma: ğ‘£ = (ğ‘¥1,ğ‘¥2, ğ‘¥3) ğ‘„ = ( ğ´ âˆ’ğ‘ âˆ’ğ‘ğ‘‡ ğ‘ ) = ğ‘›ğ‘›ğ‘‡ El vÃ©rtice v representa cada vÃ©rtice, y el valor n estÃ¡ compuesto por la siguiente fÃ³rmula. ğ‘› = ( (ğ‘£1 Ã— ğ‘£2)+ (ğ‘£2 Ã— ğ‘£3)+ (ğ‘£3 Ã— ğ‘£1) âˆ’(ğ‘£2 âˆ™ ğ‘£3) ) Como se muestra a continuaciÃ³n, con el fin de recuperar el error cuadrÃ¡tico acumulado en el Vertex Shader, se ajusta la posiciÃ³n del vÃ©rtice a la del pÃ­xel de la textura donde se almacenarÃ¡ la informaciÃ³n de la celda. vec3 pos; //Primero es necesario trasladar los valores de posiciÃ³n del vÃ©rtice //al rango de valores entre el [0 Â­ Dim), con el fin de utilizarlos como //Ã­ndice de la posiciÃ³n en el Grid, donde Dim es el nÃºmero de //dimensiones definido por el usuario, luego utilizamos la funciÃ³n //floor() que redondea hacÃ­a abajo los nÃºmeros. Quedando 3.4 => 3 vec3 CellIndex = floor((VertPos Â­ min)*Dim/(max Â­ min)); //Si el Ã­ndice es igual a Dim, se sale del rango del grid por lo que se le //resta 1 para movilizarlo a la posiciÃ³n del grid mÃ¡s cercana, quedando //el Ã­ndice en 3D de la posiciÃ³n dentro del Grid if(CellIndex.x == Dim)CellIndex.xÂ­=1.0; if(CellIndex.y == Dim)CellIndex.yÂ­=1.0; if(CellIndex.z == Dim)CellIndex.zÂ­=1.0; //El Ã­ndice 3D se transforma en un Ã­ndice de 1D. float temp = CellIndex.x + CellIndex.y * Dim + CellIndex.z*Dim*Dim ; //El Ã­ndice en 1D se transforma en 2D en el rango [0 Â­ RTDim] para poder //almacenar la informaciÃ³n en una textura plana 2D, fijando la coordenada //Z en 1.0, donde RTDim es el tamaÃ±o de la textura donde se almacenara el //Grid pos.y = floor(temp/RTDim); pos.x = temp Â­ (pos.y * RTDim); pos.z = 1.0; //Se suma 1 a las coordenadas X, Y para evitar los valores iguales a 0. //ya que existe perdida de informaciÃ³n si los pixeles se encuentran cerca //del borde de la pantalla. 44 pos.x +=1.0; pos.y +=1.0; //Se traslada los Ã­ndices al rango (Â­1 Â­ 1), que es el rango de valores que utiliza //el monitor. Al momento de hacer el cÃ¡lculo se incrementa el valor del parÃ¡metro //RTDim, con el fin de evitar los bordes, ya que causaba inconsistencia entre distintos //dispositivos. float trtdim = RTDim + 1.0; pos.x = ((pos.x / trtdim)*2.0) Â­ 1.0; pos.y = ((pos.y / trtdim)*2.0) Â­ 1.0; El Vertex Shader pasa al Fragment Shader la informaciÃ³n calculada a travÃ©s de un arreglo de trece (13) posiciones. La informaciÃ³n que transmite el Vertex Shader al Fragment Shader se lista a continuaciÃ³n: ï‚· Nueve (9) valores pertenecen a la diagonal superior de la matriz simÃ©trica. ï‚· Tres (3) valores para la posiciÃ³n (X,Y,Z) del vÃ©rtice. ï‚· Un (1) valor para acumular la cantidad de vÃ©rtices que pertenecen a la celda. El Fragment Shader acumula la informaciÃ³n suministrada por el Vertex Shader sin modificarla. Para acumular la informaciÃ³n se hace uso de la funciÃ³n de blending (gl.ONE, gl.ONE) que se suma todos los valores de los pÃ­xeles que coinciden coordenadas. Las funciones de blending toman en cuenta el valor alpha de los vÃ©rtices, con el fin de proporcionar transparencia a las imÃ¡genes. Al utilizar la funciÃ³n de blending (gl.ONE, gl.ONE) se multiplica por uno los valores del vÃ©rtice, ignorando el valor alpha del mismo. El resultado del pipeline grÃ¡fico se almacena en una textura de tamaÃ±o igual a âˆšğ·ğ‘–ğ‘šğ‘’ğ‘›ğ‘ ğ‘–ğ‘œğ‘›ğ‘’ğ‘ 3. Donde las dimensiones es el nÃºmero de divisiones que tendrÃ¡ el Bounding Box determinado por el usuario. Esto con el fin de poder almacenar los 13 valores necesarios por celda, se hizo uso de un conjunto de 4 texturas, que utilizando sus 3 valores RGB y el valor Alpha, suman 16 campos donde se puede almacenar la informaciÃ³n y queda un margen de mejora para futuros cÃ¡lculos adicionales. En el segundo Shader, se genera un plano con el mismo tamaÃ±o que las texturas de almacenamiento. El plano se envÃ­a junto con la metadata y las texturas generadas en el primer shader al pipeline grÃ¡fico para calcular el vÃ©rtice representativo. En el Vertex Shader se retorna la informaciÃ³n sin alterar y finaliza su ejecuciÃ³n. En el Fragment Shader cada pÃ­xel accede a su pÃ­xel correspondiente de las texturas generadas en el primer paso. Cada pÃ­xel construye la matriz de error cuadrÃ¡tico y calcula el pÃ­xel promedio utilizando el valor promedio y el conteo de vÃ©rtices. Para determinar el vÃ©rtice representativo se invierte la matriz de error cuadrÃ¡tico y se resuelve la siguiente ecuaciÃ³n: ğ´ğ‘¥ = ğ‘ ğ‘¥ = ğ´âˆ’1ğ‘ La matriz deja de ser invertible cuando todos los planos sean linealmente dependientes. Al sumar un pequeÃ±o tÃ©rmino a la diagonal se incrementa el determinante causando que la matriz sea invertible. Debido a estas situaciones y a la pÃ©rdida de precisiÃ³n punto flotante al insertar y extraer datos en el pipeline grÃ¡fico en WebGL, el error cuadrÃ¡tico tiende a ser impreciso. Para mejorar la calidad del resultado al realizar la simplificaciÃ³n se hace uso de dos vÃ©rtices representativos, el primero y mÃ¡s importante es el vÃ©rtice resultante al resolver la ecuaciÃ³n de error cuadrÃ¡tico. El segundo vÃ©rtice se genera a partir de promediar la posiciÃ³n acumulada de los vÃ©rtices pertenecientes a la celda. El vÃ©rtice que se utilizarÃ¡ como vÃ©rtice representativo serÃ¡ el promedio entre ambos vÃ©rtices. 45 El Fragment Shader almacena en una textura del tamaÃ±o del plano generado, se retorna en cada pÃ­xel la posiciones (X, Y, Z) del vÃ©rtice representativo en los valores RGB y se deja el valor alfa fijÃ³ en 1.0. En el paso tres, se envÃ­a la malla original junto con la textura que contiene los vÃ©rtices representativos para reubicar los vÃ©rtices pertenecientes a la malla, con el fin de poder extraer la nueva malla del pipeline grÃ¡fico se genera una nueva textura de tamaÃ±o âˆšğ‘ğ‘¢ğ‘šğ‘’ğ‘Ÿğ‘œğ‘  ğ‘‘ğ‘’ ğ‘£Ã©ğ‘Ÿğ‘¡ğ‘–ğ‘ğ‘’ğ‘  ğ‘’ğ‘› ğ‘™ğ‘ ğ‘šğ‘ğ‘™ğ‘™ğ‘. En el Vertex Shader el vÃ©rtice representante de cada cara verifica si la cara debe ser colapsada y detiene su ejecuciÃ³n en caso de ser asÃ­. Si es necesario reubicar los vÃ©rtices, el vÃ©rtice representante extrae la nueva posiciÃ³n de los vÃ©rtices de su cara de la textura generada en pasos anteriores, y retorna las posiciones nuevas para los vÃ©rtices de la cara. En el Fragment Shader se retorna la informaciÃ³n sin alterar. Con solo conocer las nuevas posiciones de los vÃ©rtices no se puede determinar la estructura topolÃ³gica de la malla. Es necesario poder preservar la interconectividad de las caras si se desea reconstruir la nueva malla preservando la estructura de la malla original. Para conservar la interconectividad se utilizarÃ¡n 3 texturas, donde cada pÃ­xel representarÃ¡ una cara. Con tres (3) texturas poseemos doce (12) tÃ©rminos donde se puede almacenar la informaciÃ³n de los vÃ©rtices de la malla. Al conocer que el pÃ­xel correspondiente en una misma posiciÃ³n en las distintas texturas representa la misma cara, se pueden relacionar los vÃ©rtices, y por lo tanto, determinar la topologÃ­a de la malla. En el paso 4, se debe construir la malla simplificada utilizando la informaciÃ³n generada en los anteriores pasos. Primero se debe extraer la informaciÃ³n de las texturas, y almacenarse en un set de arreglos en formato punto flotante. Luego se itera por los arreglos extrayendo la informaciÃ³n posicional de los vÃ©rtices que conforman la malla simplificada y almacenan en orden en una nueva estructura interna de Threejs llamada BufferGeometry, que luego es utilizado para formar la nueva malla. 3.4 ImplementaciÃ³n de la interfaz Para la interfaz se tuvieron que tomar en cuenta dos elementos cruciales. Como se aprecia en la Figura 29, se agregÃ³ el botÃ³n Cargar con el que se puede suministrar a la aplicaciÃ³n un archivo obj (la biblioteca threejs trae soporte por defecto tambiÃ©n al formato de archivos js) que internamente se traduce a las estructuras internas de la biblioteca Threejs. La segunda es brindar la capacidad de comparar el modelo original con su versiÃ³n simplificada dividiendo la pantalla de visualizaciÃ³n en dos, donde a cada mitad corresponde un entorno grÃ¡fico. En el entorno izquierdo se graficarÃ¡ el modelo original, y en el entorno derecho se graficarÃ¡ el modelo resultante al modelo de simplificaciÃ³n. 46 Figura 29: Prueba del modelo TreehouseLogo (izquierda) y la malla simplificada (derecha) utilizando el algoritmo de simplificaciÃ³n utilizando 32 dimensiones. Existen mÃºltiples elementos descriptivos en la aplicaciÃ³n, que se agregaron para facilitar informaciÃ³n al usuario con los que se pueden estudiar el rendimiento del algoritmo y medir su funcionamiento. Una funcionalidad importante para apreciar cÃ³mo se afectÃ³ la cantidad y estructura de las caras pertenecientes al modelo, es el delineado de las caras. Como se aprecia en la Figura 30 esta opciÃ³n estÃ¡ disponible bajo el nombre de Wireframe, que al activarse resalta con lÃ­neas blancas los bordes de todas las caras, mostrando las interconexiones entre todos los vÃ©rtices del modelo. Figura 30: Ejemplo de la funcionalidad Wireframe. Se puede apreciar como el delineado de los bordes de las caras permite apreciar la diferencia en la estructura y cantidad de las caras. Otra herramienta que se implementÃ³ con el fin de poder analizar los resultados del algoritmo de simplificaciÃ³n es el delineado de las celdas. Como se muestra en la Figura 31 esta funcionalidad se llamÃ³ Grid, con Ã©sta se puede tener 47 un mejor entendimiento de cÃ³mo trabaja el algoritmo internamente y el por quÃ© simplifica las mallas de la forma en que lo hace al permitir determinar la forma en que se estÃ¡n agrupando los vÃ©rtices, y percibir que vÃ©rtice estÃ¡ remplazando los vÃ©rtices que fueron colapsados. La funciÃ³n Grid, se implementÃ³ principalmente para evaluar el proceso de simplificaciÃ³n, ya que se desconoce sus posibles beneficios para el uso prÃ¡ctico de la aplicaciÃ³n. Figura 31: Ejemplo del delineado de las celdas, que demuestra la forma en que el algoritmo agrupa los vÃ©rtices, para realizar los cÃ¡lculos que hace y la forma en que colapsa las caras. Un elemento necesario para poder medir la efectividad del algoritmo de simplificaciÃ³n, son las pantallas informativas, que consisten en un segmento de la pÃ¡gina dedicada a mostrar informaciÃ³n interna de las mallas y del proceso de simplificaciÃ³n. Las pantallas informativas consisten en campos de texto que se actualizan constantemente. Existen pantallas informativas para ambos entornos grÃ¡ficos. Donde se muestra el nÃºmero de caras y vÃ©rtices que componen a la malla, adicionalmente muestra los Ãºltimos mensajes emitidos por la aplicaciÃ³n. Un ejemplo de estas pantallas se puede apreciar en la Figura 32, el elemento nÃºmero 1. Para poder hacer uso del algoritmo de simplificaciÃ³n es necesario definir la cantidad de subdivisiones que tendrÃ¡ el Bounding Box. Esto se logra con un campo editable de texto (el elemento nÃºmero 2 de la Figura 32) donde se puede definir la cantidad de divisiones que tendrÃ¡ el Bounding Box. El elemento nÃºmero 3 de la Figura 32 es el botÃ³n Cargar, su funciÃ³n es recalcular la malla simplificada, con el fin de actualizar la cantidad de divisiones del Bounding Box que se utiliza como parÃ¡metro durante el proceso de simplificaciÃ³n. 48 Figura 32: Modelos predefinidos para realizar pruebas del algoritmo de simplificaciÃ³n Para facilitar realizar pruebas con la aplicaciÃ³n se agregÃ³ una lista de modelos predefinidos ya cargados en el servidor (Elemento nÃºmero 4 de la Figura 32). El botÃ³n â€œDescargar Modeloâ€ quÃ© se observa en la Figura 32 como el elemento nÃºmero 5, se implementÃ³ para permitir al usuario extraer el modelo simplificado en el formato obj. Esta funcionalidad hace uso del mÃ©todo OBJExporter de la biblioteca Threejs, que genera la informaciÃ³n en texto plano que contendrÃ¡ el archivo en formato obj. Para realizar la descarga se usÃ³ el siguiente cÃ³digo en JavaScript: var element = document.createElement('a'); element.setAttribute( 'href', 'data:text/plain;charset=utfÂ­8,' + encodeURIComponent(WebGL2.get_new_mesh()) ); //Se crea un elemento del tipo â€œaâ€, y se le agrega como atributo la informaciÃ³n //generada por la funciÃ³n OBJExporter de threejs en texto plano. //Al definirle el atributo descarga, y tipo texto, el navegador por defecto //iniciara el proceso de descarga del archivo result.ob. element.setAttribute('download', "result.obj"); element.style.display = 'none'; document.body.appendChild(element); element.click(); //Se simula un evento tipo Click, con el fin de iniciar el proceso de descarga document.body.removeChild(element); //Se elimina el elemento creado para no dejar informaciÃ³n ya no necesaria //en memoria. Con los detalles de implementaciÃ³n descritos, se presenta en el siguiente capÃ­tulo los resultados de las pruebas realizadas. 49 4 Pruebas y resultados En este capÃ­tulo se describen un conjunto de pruebas bÃ¡sicas y una comparaciÃ³n entre los diferentes resultados y las limitantes del desarrollo realizado. 4.1 Ambiente de pruebas El dispositivo donde se realizaron las pruebas se compone de: ï‚· Procesador : IntelÂ® Coreâ„¢ i7-3770 @ 3.40GHz ï‚· Memoria : 12.00 Gb DDR3 1333 Mhz ï‚· GPU : Asus GeForce GT 610 Graphic Card 1 GB DDR3 Para el desarrollo de la aplicaciÃ³n se hizo uso de las bibliotecas: ï‚· Threejs - Biblioteca que se encarga de encapsular lÃ³gica de WebGL [31] ï‚· OrbitControls - Biblioteca para el manejo de la cÃ¡mara [32] ï‚· Less - Biblioteca que encapsula la lÃ³gica del lenguaje CSS [33] ï‚· Stats - Biblioteca que mide los frames por segundo (fps) [34] ï‚· Loaders - En este trabajo se utilizan mÃºltiples bibliotecas, como OBJLoader.js, MTLLoader.js y las funciones internas de Threejs, que se encargan de traducir de los formatos de objeto en malla 3D a estructuras manejables por la aplicaciÃ³n. ï‚· Bootstrap â€“ Es un framework para el modelado de la interfaz de la pÃ¡gina [35] Las bibliotecas se almacenan en el mismo hosting desde el cual se sirve la aplicaciÃ³n Web, a excepciÃ³n de la biblioteca de Bootstrap que se importa directamente del hosting de sus creadores. Para facilitar el acceso a la aplicaciÃ³n se hizo uso de la plataforma GitHub[36] para servirla pÃºblicamente utilizando su funcionalidad llamada GitHub pages [37] con la que se puede publicar un proyecto web desde sus repositorios. Actualmente (Primer trimestre del aÃ±o 2018) se encuentra publicado el algoritmo de simplificaciÃ³n a travÃ©s del url (Uniform Resource Locator) gomesandres.github.io. 4.2 Modelos utilizados Para la realizaciÃ³n de las pruebas se utilizaron los siguientes modelos: Treehouse_logo.js Flamingo.js GloveLow_poly.obj Modelo que representa el logo de la pÃ¡gina teamtreehouse.com [38] Modelo que refleja un flamenco como su nombre indica. Modelo que simula un par de guantes 2680 VÃ©rtices 542 VÃ©rtices 2144 VÃ©rtices 8040 Caras 1626 Caras 6432 Caras 50 4.3 Pruebas cuantitativas Se realizÃ³ un conjunto de pruebas a diferentes modelos con el fin de medir el comportamiento del algoritmo de simplificaciÃ³n. Modelo Dimensiones VÃ©rtices Originales Caras Originales VÃ©rtices Simplificado Caras Simplificado treehouse_logo.js 10 1342 2680 138 284 15 1342 2680 214 436 32 1342 2680 416 836 Flamingo.js 10 273 542 108 233 15 273 542 173 347 32 273 542 237 469 GloveLow_poly.obj 10 1076 2144 408 940 15 1076 2144 726 1534 32 1076 2144 1040 2073 Tabla 1: Conjunto de pruebas para medir el desempeÃ±o segÃºn la cantidad de caras y vÃ©rtices que fueron eliminadas durante el proceso de simplificaciÃ³n. Como se puede apreciar en al Tabla 1, el porcentaje de reducciÃ³n de vÃ©rtices y caras, varÃ­a entre el 3,31% de elementos eliminados hasta un total de 89,71%. Ã‰sta variaciÃ³n entre la cantidad de elementos eliminados se debe a la manera en que se distribuyen los vÃ©rtices de las mallas. Modelos en malla que distribuyen con mayor uniformidad los vÃ©rtices en su perÃ­metro tienden a tener una menor cantidad de caras colapsadas durante el proceso de simplificaciÃ³n. Modelo Dimensiones Paso 1 Paso 2 Paso 3 Paso 4 treehouse_logo.js 10 47,47ms 35,09ms 29,01ms 53,62ms 15 47,30ms 27,48ms 35,08ms 70,18ms 32 54,77ms 38,69ms 29,47ms 50,93ms Flamingo.js 10 29,52ms 24,96ms 27,41ms 38,21ms 15 31,06ms 28,44ms 26,24ms 35,11ms 32 36,50ms 32,55ms 29,60ms 48,57ms GloveLow_poly.obj 10 36,40ms 26,32ms 28,33ms 54,77ms 15 34,34ms 25,18ms 24,14ms 31,71ms 32 39,37ms 30,88ms 25,83ms 37,58ms 51 Tabla 2: Conjunto de pruebas para medir los tiempos de ejecuciÃ³n de las distintas funciones que conformar el algoritmo de simplificaciÃ³n. En la Tabla 2, se muestra un conjunto de pruebas de tiempo de ejecuciÃ³n. Estas pruebas se hicieron sobre los principales pasos del proceso de simplificaciÃ³n, que se detallaron en anteriores capÃ­tulos. Los tiempos que se muestran en la Tabla 2, estÃ¡n expresados en milisegundos. Debido a que el entorno WebGL aÃºn es experimental, durante las pruebas los tiempos presentaban considerables variaciones, por lo que se tuvo que realizar mÃºltiples pruebas y promediar los tiempos. 4.4 Pruebas cualitativas Se presentan un conjunto de pruebas visuales, realizadas sobre los modelos de prueba. Figura 33: Prueba cualitativa del modelo treehouse_logo.js, utilizando 32 dimensiones. Como se puede apreciar en la Figura 33. Cuando aplicamos el algoritmo de simplificaciÃ³n utilizando como parÃ¡metro 32 dimensiones al modelo treehouse_logo.js, se obtiene como resultado un modelo que conserva muchas de las caracterÃ­sticas estÃ©ticas del modelo original. 52 Figura 34: Captura de la prueba con 32 dimensiones donde se nota con mayor claridad las diferencias generadas por el proceso de simplificaciÃ³n. En la Figura 34 se pueden resaltar las diferencias entre los modelos. En el lado izquierdo del modelo se puede notar un pequeÃ±o segmento que fue colapsado por el algoritmo de simplificaciÃ³n. Figura 35: Prueba cualitativa sobre el modelo treehouse_logo.js, utilizando como parÃ¡metro 15 dimensiones En la Figura 35 se modificÃ³ el parÃ¡metro de dimensiones con el fin de incrementar el factor de simplificaciÃ³n. El nÃºmero de caras y vÃ©rtices resultantes se redujo a la mitad. Lo primero que se puede notar es como la apariencia estÃ©tica de la malla se deformo en la parte central del modelo donde existe mayor cantidad de detalles. Figura 36: Prueba cualitativa sobre el modelo Flamingo.js, utilizando como parÃ¡metro 32 dimensiones. 53 Como se puede apreciar en la Figura 36, se utilizÃ³ el algoritmo de simplificaciÃ³n utilizando 32 dimensiones como parÃ¡metro, sobre el modelo Flamingo.js. La malla resultante conserva la mayorÃ­a de las caracterÃ­sticas estÃ©ticas principales. En los segmentos del modelo con mayor cantidad de detalle se notan algunas variaciones, como lo son el extremo de las patas del flamenco. Figura 37: Prueba cualitativa sobre el modelo Flamingo.js utilizando como parÃ¡metro 15 dimensiones. En la Figura 37, se realizÃ³ la prueba sobre el modelo Flamingo.js utilizando como parÃ¡metro 15 dimensiones. En el modelo resultado se conservan la mayorÃ­a de los detalles estÃ©ticos. Los segmentos que se ven mÃ¡s afectados son las puntas de las patas y el sector de la cabeza. La pÃ©rdida de detalle en los sectores mÃ¡s afectados se debe a la cercanÃ­a de los vÃ©rtices que la conforman. Causando que la mayorÃ­a de los vÃ©rtices que la conforman pertenezcan a una misma celda, y sean colapsados por el algoritmo. 54 Figura 38: Prueba cualitativa sobre el modelo GloveLow_poly.obj utilizando como parÃ¡metro 32 dimensiones En la Figura 38 se puede notar el resultado al realizar la prueba cualitativa sobre el modelo GloveLow_poly.obj. Al utilizar 32 dimensiones se puede notar como la malla resultante conserva la mayorÃ­a de las caracterÃ­sticas quedando como principal diferencia a resaltar la pÃ©rdida de suavidad. En la Figura 39 se muestra el resultado de la aplicaciÃ³n perceptualdiff [39] luego de realizar un anÃ¡lisis de diferencias basado en la percepciÃ³n. En total existen 8736 pixeles con diferencias entre ambas imÃ¡genes. Figura 39: Imagen generada por la aplicaciÃ³n perceptualdiff, que resalta los pixeles con diferencias entre dos imÃ¡genes segun un algoritmo por percepciÃ³n. Utilizando como base el modelo GloveLow_poly.obj. Con imÃ¡genes del modelo original y simplificado usando como parÃ¡metro 32 dimensiones. Como se aprecia en la Figura 39 los segmentos mÃ¡s resaltantes son los bordes, donde se acentÃºa la pÃ©rdida de suavidad en el modelo. Las diferencias restantes se deben en su mayorÃ­a a los efectos de la iluminaciÃ³n sobre el modelo. 55 Figura 40: Prueba cualitativa sobre el modelo GloveLow_poly.obj, utilizando como parÃ¡metro 24 dimensiones En la Figura 40 se muestra la prueba cualitativa sobre el modelo GloveLow_poly.obj, utilizando como parÃ¡metro 24 dimensiones, se puede notar como se acentÃºan las diferencias en los bordes y en la suavidad, pero se conservan todas las cualidades estÃ©ticas principales. En la Figura 41 se realizÃ³ la evaluaciÃ³n de percepciÃ³n utilizando el algoritmo de perceptualdiff, donde lo principal a destacar es como se incrementa el Ã¡rea donde existen diferencias en los bordes del modelo, pero en contra de lo esperado, se reducen las diferencias en la zona interna de los modelos. Figura 41: Imagen generada por la aplicaciÃ³n perceptualdiff, sobre el modelo GloveLow_poly.obj, original y simplificado utilizando como parÃ¡metro 24 dimensiones. 56 Figura 42: Prueba cualitativa sobre el modelo GloveLow_poly.obj, utilizando como parÃ¡metro 15 dimensiones En la Figura 42, al utilizar 15 dimensiones la topologÃ­a se ve alterada debido a que los vÃ©rtices pertenecientes al borde de los dedos son colapsados, uniendo ambas manos. En la Figura 43 se puede apreciar, como a pesar de utilizar una menor cantidad de dimensiones (14 dimensiones), la topologÃ­a del modelo original se conserva mejor. Esto es debido a que al momento de agrupar los vÃ©rtices con la rejilla, los vÃ©rtices pertenecientes a los bordes de los dedos son agrupados en celdas distintas. Figura 43: Prueba cualitativa sobre el modelo GloveLow_poly.obj, utilizando como parÃ¡metro 14 dimensiones En la Figura 44 se nota como se repite el incremento en el nÃºmero de pÃ­xeles con diferencias cerca del borde del modelo. Una diferencia que se puede notar, es como se crearon zonas donde existen una gran cantidad de pÃ­xeles 57 con diferencias. Esto es debido a deformaciones en el modelo, con tan solo 14 dimensiones, cada celda colapsa una gran cantidad de vÃ©rtices, llevando a que se unan segmentos de la malla que antes eran disconexos. Figura 44: Imagen generada por la aplicaciÃ³n perceptualdiff, sobre el modelo GloveLow_poly.obj, original y simplificado utilizando como parÃ¡metro 14 dimensiones. 58 5 Conclusiones y recomendaciones En este Trabajo Especial de Grado se realizÃ³ un algoritmo capaz de realizar simplificaciones de mallas en tiempo real en WebGL, haciendo uso de la GPU. Reduciendo la cantidad de elementos pertenecientes a una malla, reduciendo de esta manera el uso de recursos del ordenador. Durante el desarrollo de este Trabajo Especial de Grado, existieron elementos que resaltaron ya sea por su complejidad o ser un hecho imprevisto. A continuaciÃ³n se detallan estos elementos mÃ¡s resaltantes. La funciÃ³n que necesito de la mayor cantidad tiempo para ser implementada, fue la extracciÃ³n de la informaciÃ³n resultante del pipeline grÃ¡fico en cada uno de los pasos del proceso de simplificaciÃ³n detallados en el capÃ­tulo 3. Al no tener acceso a las instrucciones internas del procesador grÃ¡fico, fue necesario desarrollar una alternativa utilizando tÃ©cnicas como deferred rendering, que consiste en almacenar el resultado del pipeline grÃ¡fico en texturas para su uso posterior. Estudiando los distintos algoritmos de simplificaciÃ³n de mallas, resulta ser un Ã¡rea de estudio con bastantes alternativas e ideas muy creativas para resolver el inconveniente que representa trabajar con mallas con un nivel de detalle inmanejable en las tecnologÃ­as disponibles. El trabajo que mÃ¡s resalto por su originalidad, era el trabajo de DÃ©coret et al. [29], Billboard Clouds. Donde se presenta una soluciÃ³n, que a diferencia de las soluciones tradicionales, busca generar una nueva malla, en vez de modificar la existente. Resultando en simplificaciones extremas de un 98% de reducciÃ³n de polÃ­gonos La API WebGL, es una plataforma de desarrollo versÃ¡til, que permite el desarrollo e investigaciÃ³n de algoritmos en una plataforma mucho mÃ¡s portable y con mayor soporte entre plataformas, facilitando la colaboraciÃ³n de mÃºltiples desarrolladores en un mismo proyecto. La posibilidad de realizar desarrollos grÃ¡ficos utilizando un elemento tan portable como lo es el navegador Web, permite masificar con facilidad las aplicaciones. Estos hechos percibidos durante la realizaciÃ³n del trabajo de grado, resaltaron la utilidad y la importancia de Ã©ste API de desarrollo. Ya descritas las principales conclusiones obtenidas durante el desarrollo del Trabajo Especial de Grado falta mencionar las principales recomendaciones para futuros desarrollos en la aplicaciÃ³n aquÃ­ descrita. La principal dificultad encontrada durante el proceso de desarrollo del algoritmo de simplificaciÃ³n en tiempo real, eran las limitantes en la API WebGL, el beneficio de la movilidad que posee al estar implementado en una plataforma tan portable como los navegadores Web, viene con la desventaja de solo poder proveer de funciones genÃ©ricas que sean compatibles con la mayor cantidad de dispositivos. Esta desventaja dificultÃ³ el desarrollo de algunos pasos importantes en el proceso de simplificaciÃ³n que involucraban herramientas como el Geometry Shader. El no poseer un Geometry Shader priva de la posibilidad de eliminar las caras que fuesen a ser colapsadas durante el pipeline grÃ¡fico, causando que sea necesario un paso adicional. Una funcionalidad indispensable en esta aplicaciÃ³n, es la capacidad de poder cargar cualquier modelo 3D para ser simplificado. Actualmente el algoritmo es capaz de cargar modelos en formato obj y js. Incluso para estos formatos existen modelos con dificultades para ser procesados, debido a diferencias entre diferentes aplicaciones de modelado 3D. Se recomienda ampliar y fortalecer las funcionalidades que se encargan de traducir estos formatos, con el fin de facilitar el uso de la aplicaciÃ³n y aumentar de esta forma su utilidad. Durante el desarrollo del algoritmo de simplificaciÃ³n de mallas en tiempo real, se notÃ³ que mÃºltiples entornos WebGL alojados en una misma pÃ¡gina web comparten el tick grÃ¡fico. El resultado de que mÃºltiples entornos WebGL compartan el mismo tick grÃ¡fico, es que se procese un mismo nÃºmero de frames por segundo en cada entorno. Ã‰sta cualidad causa que los entornos que posean una menor cantidad de informaciÃ³n que procesar generen frames con igual velocidad que el entorno con mayor informaciÃ³n. En la aplicaciÃ³n desarrollada en el trabajo de 59 grado esto evita que se pueda medir con exactitud el beneficio resultante del proceso de simplificaciÃ³n. Una mejora de la aplicaciÃ³n actual serÃ­a permitir que cada entorno genere frames independiente al resto. Permitiendo notar el impacto de la reducciÃ³n de elementos. 60 BibliografÃ­a [1] WebGL, The Khronos Group, www.khronos.org [2] Hoppe Hughs et al â€œMesh Optimization,â€ Proc. SIGGRAPH 93, ACM SIGGRAPH, Aug. 1993, pp. 19â€“26. [3] Lindstrom Peter and Turk Greg. Fast and memory efficient polygonal simplification. In IEEE Visualization, pages 279â€“286, 1998. [4] AutoCAD, Autodesk Inc. www.autodesk.com [5] Cinema 4D, MAXON Computer GmbH www.maxon.net [6] Mass Effect, Electronic Arts, www.masseffect.com [7] X-Plane, Laminar Research, www.x-plane.com [8] Google Earth, Google, www.google.com [9] The Digital Micheangelo Project, graphics.stanford.edu [10] The Forma Urbis Romae Fragment, formaurbis.stanford.edu [11] Constantin Zach, Engine Postmortem of inFAMOUS: Second Son by Adrian Bentley [12] Schroeder William, Zarge Jonathan, and Lorensen William. Decimation of Triangle Meshes. Conference Proceedings of SIGGRAPH 1992, pp. 65-70. [13] Garland Michael and Heckbert Paul. Surface simplification using quadric error metrics. In Proc. SIGGRAPH '97, pages 209â€“216, 1997. [14] The Computational Geometry Algorithms Library (CGAL), CGAL Open Source Project, www.cgal.org/ [15] Universidad de Utrecht, www.uu.nl [16] Instituto Federal de TecnologÃ­a de ZÃºrich, www.ethz.ch [17] Universidad Libre de BerlÃ­n, www.fu-berlin.de [18] Instituto Nacional de InvestigaciÃ³n en InformÃ¡tica y AutomÃ¡tica, www.inria.fr [19] Universidad Martin Lutero de Halle-Wittenberg, www.international.uni-halle.de [20] Instituto Max Planck para la InformÃ¡tica, www.mpi-inf.mpg.de [21] Universidad de Linz Johannes Kepler, www.jku.at [22] Universidad de Tel Aviv, english.tau.ac.il [23] Lindstrom Peter and Turk Greg. Evaluation of memoryless simplification. IEEE Transactions on Visualization and Computer Graphics, 5(2):98â€“115, slash 1999. 61 [24] Dey Tamal et al. Topology preserving edge contraction. geometric combinatorics. Publ. Inst. Math. (Beograd) (N.S.), 66:23â€“45, 1999. [25] The Visual Toolkit (VTK), Kitware Inc, www.vtk.org [26] Hoppe Hugh. Progressive Meshes. Conference Proceedings of SIGGRAPH 1996, pp. 99-108. [27] Lindstrom Peter. Out-of-Core Simplification of Large Polygonal Models. Conference Proceedings of SIGGRAPH 2000, pp. 259-262. [28] Rossignac Jarek, Borrel Paul. Multi-Resolution 3D Approximations for Rendering Complex Scenes. In Modeling in Computer Graphics, 1993, pp. 455â€“465. [29] DÃ©coret Xavier et al. Billboard Clouds for Extreme Model Simplification, SIGG 2003 [30] DeCoro Christopher and Tatarchuk Natalya. Real-time mesh simplification using the GPU. In Proc. of the 2007 Symposium on Interactive 3D Graphics and Games. [31] Biblioteca Threejs, threejs.org [32] OrbitControls, github.com/mattdesl/three-orbit-controls [33] Biblioteca less, lesscss.org/ [34] Biblioteca stats, WebGLstats.com/ [35] Biblioteca Bootstrap, getbootstrap.com/ [36] Plataforma de repositorios Github, github.com/ [37] Modulo para publicaciÃ³n de proyectos GitHub pages, pages.github.com/ [38] Team Tree House, teamtreehouse.com/ [39] Programa Perceptualdiff, github.com/myint/perceptualdiff