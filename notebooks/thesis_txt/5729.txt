Microsoft Word - DOCUMENTO DE TESIS DEFINITIVO_Raizu_Rei Universidad Central de Venezuela Facultad de Ciencias Escuela de Computación Aplicaciones con Tecnología en Internet Generato: Generador de sitios Web administrativos basado en la ingeniería de reverso al modelo de datos Trabajo Especial de Grado presentado ante la Universidad Central de Venezuela Por los Bachilleres: Raizulina Gutiérrez Pedrón. CI: 15.699.953 Reinaldo Velásquez Silva. CI: 14.446.319 Para optar al título de Licenciado en Computación Tutor: Prof. Sergio Rivas Caracas, Abril / 2009 Acta 3 ACTA Quienes suscriben, miembros del Jurado, designado por el Consejo de Escuela de Computación, para examinar el Trabajo Especial de Grado presentado por los Bachilleres Raizulina Gutiérrez Pedrón C.I. 15.699.953 y Reinaldo Velásquez Silva, C.I. 14.446.319, con el título “Generato. Generador de sitios web administrativos basados en la ingeniería de reverso al modelo de datos”, a los fines de optar al titulo de Licenciado en Computación, dejan constancia de lo siguiente: Leído como fue, dicho trabajo por cada uno de los miembros del Jurado, se fijo el día 30 de Abril de 2009 a las 11:00 am, para que sus autores lo defendieran en forma pública, se hizo en el Aula 1 de la Escuela de Computación, mediante una presentación oral de su contenido, luego de lo cual fueron respondidas las preguntas formuladas. Finalizada la defensa pública del Trabajo Especial de Grado, el jurado decidió aprobarlo con una nota de _____ puntos, en fe de lo cual se levanta la presente Acta, en Caracas a los 30 días del mes de Abril de año dos mil nueve, dejándose también constancia de que actuó como Coordinador del Jurado, el profesor Sergio Rivas. Prof. Sergio Rivas Tutor – Jurado Principal Prof. Andrés Sanoja Prof. Alfredo Matteo Jurado Principal Jurado Principal Prof. Alecia E. Acosta Prof. Esmeralda Ramos Jurado Suplente Jurado Suplente Dedicatoria DEDICATORIA A mis hermanos, por siempre darme su apoyo y colaboración en todo. Y especialmente le dedico este logro a mis tres padres y a mi abuela por toda la fortaleza que siempre me han dado y por cada uno de los innumerables sacrificios hechos durante toda mi vida, específicamente en el transcurso de la carrera, ellos me hicieron saber que siempre encontraría una solución a todo en medio de las tristezas y también de las alegrías; esto es en su nombre, los amo. Raizulina.Raizulina.Raizulina.Raizulina. Dedicatoria Dedicada a toda mi familia, mis hermanas, hermano, padre, sobrinos, pero en especial a mi madre por siempre mostrarme el camino a seguir. Reinaldo.Reinaldo.Reinaldo.Reinaldo. Agradecimientos AGRADECIMIENTOS Agradezco primeramente a Dios, es Él quien nos guía en cada paso para determinar nuestras acciones. A mi familia por apoyarme siempre en cada etapa de mi vida y permitirme formarme como persona capaz de realizar esta y muchas otras metas cumplidas. Específicamente a mi mamá, porque sin importarle cuanto le costaran las cosas, siempre se ha sacrificado de una u otra manera para dármelas, para apoyarme, es gracias a sus consejos, a sus regaños, a su cariño, que hoy día soy la persona que soy, con fortaleza y empeño para lograr lo hoy logrado y mucho mas. A mis amigos: Melvin, Iriana, Ivana, Daniel, Carlos, Dielí, Yuri, Sheyla, Alejandro; quienes han compartido momentos tristes y felices a mi lado, durante mi vida, y principalmente en mi carrera universitaria, por sus consejos, por su ayuda, por sus palabras de aliento, así mismo a todas aquellas amistades que me han ayudado de una u otra forma en todo momento. A los Licenciados Jesús Hernández y Yenny Guerrero, por su colaboración, aportes y disposición de su valioso tiempo para ayudarme en la realización de ciertas etapas de éste Trabajo Especial de Grado, de igual forma, al autor inicial de la tesis que tomamos como base para el desarrollo y documentación de éste trabajo, el Licenciado Luis Antonio González Reyes; gracias infinitas a ellos por aportar en el avance de esta Tesis. A la Universidad Central de Venezuela, específicamente a la facultad de Ciencias y a la escuela de Computación, por permitir formarme, desempeñarme como estudiante y profesional en el área. A los profesores por servir en tan valiosa labor, en especial al Tutor, el Prof. Sergio Rivas por su excelente dedicación como guía en la realización de éste arduo trabajo y al Prof. Antonio Leal por permitir el inicio de mi desempeño laboral durante el trabajo de pasantía, lo que me dio impulso a seguir por alcanzar esta meta profesional. RaizulinRaizulinRaizulinRaizulina.a.a.a. Agradecimientos A mi familia por apoyarme, a mis compañeros a los largo de la carrera, a todos los profesores por servir en tan digna profesión. Reinaldo.Reinaldo.Reinaldo.Reinaldo. Resumen RESUMEN Generato es una aplicación que recibe como entrada una base de datos, y a partir de esta, extrae sus metadatos. Con la información obtenida de los metadatos y junto con la información de configuración del sitio suministrada por el usuario, se genera una aplicación Web administrativa. El sistema construido, Generato, tiene como objetivo generar de forma automática aplicaciones Web que se encarguen de gestionar la información contenida en una base de datos, contribuyendo así a minimizar el tiempo en el desarrollo de este tipo de aplicaciones. La gestión que realiza el sistema sobre las diferentes bases de datos incluye operaciones como: listar, buscar, insertar, modificar y eliminar cualquier información contenida en las tablas de la misma. En su versión inicial, DEUSWEB [González, 2006], la creación de los archivos fuentes del sitio generado es llevada a cabo por un solo motor implementado en la aplicación: JSP / Servlets, el cual está constituido por un conjunto de procesadores. Para este trabajo especial de grado se propuso la implementación y configuración de un nuevo motor en la aplicación de una forma fácil, y que sea de provecho en versiones sucesivas, así como la inclusión de nuevos Sistemas Manejadores de Base de Datos para gestionar las tablas que son generadas en el sitio web. El propósito de este Trabajo Especial de Grado consiste en desarrollar el sistema que permita la creación de sitios web administrativos a partir de una base de datos existente, a través del proceso de desarrollo de software: Scrum. El alcance de este desarrollo involucra generar código PHP a partir de bases de datos MySQL, PostgreSQL, y Oracle, de igual forma combinando la generación de código JSP con ellas. Para la construcción de este sistema, se estudiaron herramientas que generan aplicaciones Web administrativas a partir de la ingeniería de reverso al modelo de datos, haciendo énfasis en la versión previa de la aplicación. Del estudio de estas aplicaciones, surgieron las funcionalidades desarrolladas en el sistema. Sin embargo el sistema desarrollado incluye nuevas funcionalidades con respecto a los sistemas evaluados, por ejemplo: el manejo de las claves foráneas y la manipulación de los archivos almacenados en la base de datos, entre otros. Contactos: Raizulina Gutiérrez Pedrón raizulinagp@gmail.com Reinaldo Velásquez rvelasquez@gmail.com Prof. Sergio Rivas sergiorivas@gmail.com Índice de Contenido 15 ÍNDICE DE CONTENIDO INTRODUCCIÓN .................................................................................................. ………25 PARTE I: MARCO TEORICO.........................................................................................29 Capítulo 1: CONCEPTOS DE BASE DE DATOS Y CONECTIVIDAD ..................... 31 1.1. MODELO ENTIDAD - RELACIÓN ................................................................................. 31 1.1.1. Entidades ........................................................................................................... 32 1.1.2. Atributos ........................................................................................................... 32 1.1.3. Relaciones ......................................................................................................... 33 1.2. MODELO RELACIONAL ............................................................................................. 34 1.2.1. Tabla ................................................................................................................. 34 1.2.2. Campos ............................................................................................................. 34 1.2.3. Tipos de Campos .............................................................................................. 35 1.2.4. Dominio ............................................................................................................ 35 1.2.5. Atributos ........................................................................................................... 35 1.2.6. Tupla ................................................................................................................. 35 1.2.7. Clave Primaria .................................................................................................. 36 1.2.8. Clave Foránea ................................................................................................... 36 1.2.9. Claves Compuestas ........................................................................................... 36 1.2.10. Esquema ............................................................................................................ 36 1.2.11. Restricciones ..................................................................................................... 37 1.2.12. Borrado en Cascada .......................................................................................... 37 1.3. METADATO ............................................................................................................... 37 1.4. JDBC ....................................................................................................................... 37 1.4.1. Cómo usar el API JDBC ................................................................................... 38 1.4.2. Obtener información sobre las características de la Base de Datos .................. 41 1.4.3. Obtener información referente a un campo o a una columna de la Base de Datos…. ......................................................................................................................... 42 1.4.4. JDBC y algunos Manejadores de Base de Datos .............................................. 43 1.4.4.1. Postgres .......................................................................................................... 43 1.4.4.2. MySQL ........................................................................................................... 45 1.4.4.3. Oracle ............................................................................................................. 47 1.4.4.4. Comparación de Tipos de Datos para cada Manejador .................................. 49 Índice de Contenido 16 1.5. RESUMEN DEL CAPÍTULO .......................................................................................... 50 Capítulo 2: DEUSWEB ...................................................................................................... 51 2.1 ¿QUÉ ES?, ¿QUÉ HACE? ............................................................................................. 51 2.2 ¿CÓMO FUNCIONA? .................................................................................................. 51 2.2.1 Arquitectura de la aplicación generadora ......................................................... 51 2.2.2 Archivos que utiliza .......................................................................................... 52 2.2.3 Ejecución de Tareas .......................................................................................... 52 2.2.4 Estructura de Directorios .................................................................................. 53 2.3 ¿QUÉ GENERA?, Y SUS FUNCIONALIDADES ............................................................... 54 2.3.1 Patrón empleado y Arquitectura del sitio a generar .......................................... 54 2.3.2 Archivos generados y Estructura de Directorios .............................................. 55 2.4 CRITERIOS DE ANÁLISIS DE FUNCIONALIDAD ............................................................ 56 2.4.1 Funionalidad ..................................................................................................... 56 2.4.2 Configuración Avanzada .................................................................................. 56 2.4.3 Legibilidad ........................................................................................................ 56 2.4.4 Aspectos Técnicos ............................................................................................ 56 2.5 CASO DE ESTUDIO PARA EL ANÁLISIS ...................................................................... 57 2.6 FUNCIONALIDADES ................................................................................................... 58 2.6.1 Pantallas para la generación del sitio web ........................................................ 58 2.6.2 Pantallas del sitio web generado ....................................................................... 63 2.7 LIMITACIONES .......................................................................................................... 65 2.8 RESULTADOS DE ANÁLISIS DE LA APLICACIÓN .......................................................... 65 2.9 RESUMEN DEL CAPÍTULO .......................................................................................... 66 Capítulo 3: SCRUM ............................................................................................................ 69 3.1 TERMINOLOGÍA DE SCRUM ....................................................................................... 69 3.2 ¿QUÉ ES UN BACKLOG? ............................................................................................. 70 3.3 ¿QUÉ ES UN SPRINT? ................................................................................................. 70 3.4 CARACTERÍSTICAS DE SCRUM .................................................................................. 71 3.5 ¿CÓMO TRABAJA SCRUM? ........................................................................................ 72 3.6 ¿QUÉ OCURRE DURANTE UN SPRINT? ....................................................................... 73 3.7 ¿CÓMO PLANEAR Y ESTIMAR? .................................................................................. 73 3.8 ¿QUIÉN LIDERA AL EQUIPO? ..................................................................................... 74 Índice de Contenido 17 3.9 ¿QUÉ OCURRE DURANTE UNA REUNIÓN SCRUM? ...................................................... 74 3.10 ¿QUÉ OCURRE AL FINAL DE UN SPRINT? ................................................................... 75 3.11 ROLES EN SCRUM ..................................................................................................... 76 3.12 SCRUM EN SOLITARIO ............................................................................................... 77 3.13 RESUMEN DEL CAPÍTULO .......................................................................................... 77 PARTE II: MARCO APLICATIVO.................................................................................79 Capítulo 4: APLICACIÓN ADAPTACIÓN SCRUM ..................................................... 81 4.1 ETAPA DEL PLANEAMIENTO INICIAL ......................................................................... 81 4.2 ETAPA DE ELABORACIÓN DEL BACKLOG .................................................................. 82 4.3 ETAPA DE UN SPRINT ................................................................................................ 83 4.4 ETAPA DE CIERRE ..................................................................................................... 84 4.5 RESUMEN DEL CAPÍTULO .......................................................................................... 84 Capítulo 5: IMPLEMENTACIÓN .................................................................................... 85 5.1 ETAPA DE PLANEAMIENTO INICIAL ........................................................................... 85 5.2 ETAPA DE ELABORACIÓN DEL BACKLOG .................................................................. 88 5.3 ETAPA DE UN SPRINT ................................................................................................ 91 5.3.1 Sprint 1: Análisis de la versión base, DEUSWEB ............................................ 91 5.3.2 Sprint 2: Desarrollo para soporte SMBD PostgreSQL ..................................... 94 5.3.3 Sprint 3: Desarrollo para soporte SMBD Oracle .............................................. 98 5.3.4 Sprint 4: Desarrollo Motor PHP ..................................................................... 100 5.3.5 Sprint 5: Creación de nuevos diseños para la interfaz de la aplicación generada ....................................................................................................................... 106 5.3.6 Sprint 6: Re-diseño de la interfaz de usuario de la aplicación ........................ 108 5.4 ETAPA DE CIERRE ................................................................................................... 109 5.4.1 Caso de estudio: Utilizando el motor PHP y el SMBD Oracle ...................... 110 5.4.2 Caso de estudio: Utilizando el motor JSP/Servlets y el SMBD PostgreSQL . 122 5.5 RESUMEN DEL CAPÍTULO ........................................................................................ 129 CONCLUSIONES ............................................................................................................ 131 LIMITACIONES Y RECOMENDACIONES ............................................................... 133 BIBLIOGRAFÍA Y REFERENCIAS ............................................................................. 135 Índice de Contenido 18 ANEXOS.... ........................................................................................................................ 137 Índice de Figuras 19 ÍNDICE DE FIGURAS Figura 1. Modelo del Sistema a desarrollar. ..................................................................... 26 Figura 2. Representación del Modelo Entidad-Relación ................................................. 31 Figura 3. Representación de una Entidad en el Modelo Entidad-Relación ..................... 33 Figura 4. Representación de una relación de grado 2 en el Modelo Entidad- Relación….. .......................................................................................................................... 34 Figura 5. Una Tabla en el Modelo Relacional ................................................................... 34 Figura 6. Representación de un Campo en una Tabla ....................................................... 35 Figura 7. Representación de un Atributo en una Tabla ..................................................... 36 Figura 8. Representación de una Tupla en una Tabla. ..................................................... 38 Figura 9. Estructura de JDBC .......................................................................................... 39 Figura 10. Código genérico de la conexión JDBC con la Base de Datos .......................... 40 Figura 11. Tabla de Interfaces para operaciones con Base de Datos ................................ 40 Figura 12. Interrelación de las clases en la especificación JDBC. ..................................... 43 Figura 13. Código ejemplo para el manejo del tipo de dato Enumerado en Postgres…… ......................................................................................................................... 44 Figura 14. Código ejemplo para el Paginado de Registros en Postgres ............................. 45 Figura 15. Código ejemplo para el Manejo de Claves Foráneas en Postgres .................... 45 Figura 16. Código ejemplo para el Manejo de Secuencia en MySQL ............................... 46 Figura 17. Código ejemplo para el Manejo del tipo de dato Enumerado en MySQL…… ......................................................................................................................... 46 Figura 18. Código ejemplo para el Paginado de Registros en MySQL ............................. 48 Figura 19. Código ejemplo para el Manejo de Archivos Binarios en Oracle .................... 49 Figura 20. Tabla Comparativa de los Tipos de Datos por cada Manejador de Base de Datos………………. ............................................................................................................ 52 Figura 21. Arquitectura General del sistema generador, Aplicación DEUSWEB ............. 55 Figura 22. Arquitectura General del Sitio Web Generado ................................................. 58 Índice de Figuras 20 Figura 23. Diagrama E-R. Caso de Estudio para la aplicación DEUSWEB ...................... 59 Figura 24. Pantalla de inicio de la aplicación DEUSWEB ................................................ 59 Figura 25. Pantalla de propiedades para la conexión a la base de datos de DEUSWEB… ....................................................................................................................... 60 Figura 26. Pantalla de selección de tablas de la aplicación DEUSWEB, para generar las páginas del sitio .......................................................................................... 61 Figura 37. Pantalla de Configuración General para generar el sitio .................................. 61 Figura 28. Pantalla para configurar la opción de Paginación del sitio a generar ............... 62 Figura 29. Pantalla para configurar la opción de Apariencia del sitio a generar ............... 62 Figura 30. Pantalla para configurar la opción de Destino y Lenguaje del sitio a generar……………… .......................................................................................................... 63 Figura 31. Pantalla de generación de archivos del sitio web ............................................. 63 Figura 32. Vista en el navegador Web de la página de bienvenida generada por DEUSWEB. .......................................................................................................................... 64 Figura 33. Vista en el navegador Web de la página generada por DEUSWEB, con opciones de Búsqueda y Listar ....................................................................................... 65 Figura 34. Vista en el navegador Web de la página generada por DEUSWEB, editar un registro de la tabla celular ............................................................................................... 71 Figura 35. Ejemplo de un Backlog en Scrum .................................................................... 72 Figura 36. Esqueleto de Scrum. ......................................................................................... 74 Figura 37. Flujo en Scrum .................................................................................................. 82 Figura 38. Estructura del Backlog general. ........................................................................ 83 Figura 39. Estructura del Backlog de un Sprint ................................................................. 86 Figura 40. Arquitectura General del Sistema Generador construido ................................. 87 Figura 41. Arquitectura General del Sistema Generado con el motor JSP………….….. . 87 Figura 42. Arquitectura General del Sistema Generado con el motor PHP ...................... 89 Figura 43. Arquitectura General del Sistema Web Administrativo ................................... 90 Índice de Figuras 21 Figura 44. Backlog General Producto Generato ................................................................ 95 Figura 45. Métodos de conexión para los SMBD MySQL y PostgreSQL en la clase ConexiónBD.java. ................................................................................................................. 96 Figura 46. Estructura del directorio Driver para el SMBD PostgreSQL de la aplicación Generato .............................................................................................................. 98 Figura 47. Archivo driver.xml con la inclusión del driver para el SMBD PostgreSQL .... 99 Figura 48. Archivo sistemas-manejadores.xml con la inclusión de PostgreSQL como Sistema Manejador de Base de Datos. ................................................................................ 102 Figura 49. Estructura del directorio Driver para el SMBD Oracle de la aplicación Generato….. ........................................................................................................................ 104 Figura 50. Archivo driver.xml con la inclusión del driver para el SMBD Oracle ........... 105 Figura 51. Estructura del directorio Driver para el manejador Oracle de la aplicación Generato………….….. ....................................................................................................... 107 Figura 52. Estructura de archivos generados por la aplicación ....................................... 108 Figura 53. Archivo motores.xml ...................................................................................... 108 Figura 54. Estructura del directorio motores ................................................................... 109 Figura 55. Estructura de la carpeta de estilos de la aplicación Generato. ........................ 110 Figura 56. Estructura de una carpeta de estilos de la aplicación Generato ..................... 111 Figura 57. Estructura de la carpeta con nuevos estilos de la aplicación Generato ........... 112 Figura 58. Estructura de la nueva carpeta de estilos agregada, Naturaleza , de la aplicación Generato. ........................................................................................................... 113 Figura 59. Paso 5. Con vista previa del estilo en que será generada la aplicación ......... 113 Figura 60. Diagrama E-R. Caso de Estudio PHP y Oracle .............................................. 114 Figura 61. Paso1.Pantalla de Bienvenida de La Aplicación Generadora Generato………….….. ....................................................................................................... 114 Figura 62. Paso 2. Conexión a la base de datos celular en Oracle (Aplicación Generadora). ....................................................................................................................... 115 Figura 63. Paso 3. Selección de las tablas de la base de datos orcl en Oracle ................. 115 Índice de Figuras 22 Figura 64. Paso 4. Selección del lenguaje PHP y el destino de los archivos generados por la aplicación .................................................................................................................. 116 Figura 65. Paso 5. Configuración de la Apariencia del sitio a generar. ........................... 116 Figura 66. Paso 5. Configuración para la Autenticación del sitio a Generar ................... 117 Figura 67. Paso 5. Configuración para la Paginación de los registros de las tablas del sitio……….. ........................................................................................................................ 117 Figura 68. Paso 6. Resumen de los parámetros seleccionados para la generación del sitio……….. ........................................................................................................................ 118 Figura 69. Paso 7. Proceso de generación de la aplicación .............................................. 118 Figura 70. Estructura de una subcarpeta asociada a agregar del sitio generado en lenguaje PHP ....................................................................................................................... 119 Figura 71. Estructura de una subcarpeta asociada a listar del sitio generado en lenguaje PHP………….….. .............................................................................................................. 119 Figura 72. Pantalla de autenticación del sitio generado por el motor PHP y el SMBD Oracle…….. ........................................................................................................................ 120 Figura 73. Pantalla de Bienvenida del sitio generado por el motor PHP y el SMBD Oracle…….. ........................................................................................................................ 120 Figura 74. Visualización de la tabla empleados de la base de datos orcl ........................ 121 Figura 75. Visualización del detalle de la tabla empleados de la base de datos orcl. ...... 123 Figura 76. Visualización de la operación agregar de la tabla bonos de la base de datos orcl con referencia a la tabla empleados ............................................................................. 124 Figura 77. Visualización de la operación agregar de la tabla bonos de la base de datos orcl………… ...................................................................................................................... 124 Figura 78. Pantalla de mensajes de confirmación de que la operación agregar registros se realizó con éxito. ............................................................................................................ 125 Figura 79. Diagrama E-R. Caso de Estudio JSP/Servlets y PostgreSQL ......................... 125 Figura 80. Paso 2. Conexión a la base de datos celular en PostgreSQL (Aplicación Generadora).. ...................................................................................................................... 125 Índice de Figuras 23 Figura 81. Paso 3. Selección de las tablas de la base de datos celular en PostgreSQL………….….. .................................................................................................. 125 Figura 82. Paso 4. Selección del lenguaje JSP/Servlets y el destino de los archivos generados por la aplicación ................................................................................................. 126 Figura 83. Archivo de extensión war generado ............................................................... 126 Figura 84. Estructura del sitio generado .......................................................................... 126 Figura 85. Contenido del Directorio WEB-INF. Aplicación generada. ........................... 127 Figura 86. Contenido del Directorio lib. Aplicación Generada ....................................... 127 Figura 87. Pantalla de Bienvenida del sitio generado por el motor JSP/Servlets y el SMBD PostgresSQL ........................................................................................................... 127 Figura 88. Visualización de la tabla fotos de la base de datos celular. ............................ 128 Figura 89. Visualización de la operación Agregar para la tabla fotos de la base de datos celular ........................................................................................................................ 128 Introducción 25 INTRODUCCIÓN Actualmente, se ha establecido una marcada tendencia en el desarrollo de aplicaciones Web, la cual se va incrementando día a día, y debido a ello, una variedad de información es manejada a través de la gran red de redes: Internet. Muchos de ésos datos se encuentran en un repositorio o base de datos, lo que facilita que el contenido del sitio o aplicación Web sea dinámico y a su vez pueda ser gestionado directamente por cada persona o empresa particular para realizar el cambio de la información que es mostrada. Existen varias formas de gestionar la información contenida en las base de datos, una de ellas, es mediante un sistema administrativo que permita realizar esa gestión a través de funcionalidades que son independientes de la información contenida en las tablas de la base de datos respectiva; pero muchas veces las personas u organizaciones particularmente no desarrollan éste tipo de sistemas, debido a que suelen ser costosos en cuanto a producción, y siendo necesaria además la administración y mantenimiento continuos de los mismos, así como de agregar u optimizar funcionalidades en la herramienta que faciliten el buen funcionamiento de ella, lo cual requiere de personal capacitado para dicho trabajo. Es por ésas razones que para el año 2006, se plantea entonces una propuesta que consiste en la construcción de una herramienta denominada DEUSWEB, que es capaz de generar sitios Web administrativos que gestionan la información contenida en la base de datos a través de funcionalidades básicas como: listar, buscar, insertar, modificar y eliminar cualquier información en el repositorio de datos. La versión existente de ésta aplicación fue desarrollada utilizando como lenguaje de programación, JAVA, la cual recibe como entrada una base de datos existente, basada en el Sistema Manejador de Base de Datos MySQL (para ésta versión de la aplicación), y a partir de esta, identificará todas las tablas y campos a través de la extracción de los metadatos de la base de datos, para así generar el sistema Web administrativo. Es por ello que se concibe la ingeniería de reverso al modelo de datos de la base de datos. Así, en el presente Trabajo Especial de Grado, se plantea la necesidad de desarrollar una aplicación que permita generar sitios Web administrativos mediante la extracción de información de una base de datos, incorporando, para reforzar ésta tarea, diferentes motores y Sistemas Manejadores de Base de Datos que faciliten la manipulación de la información Es por ello que el desarrollo de las diversas ideas y aportes a la versión existente del sistema, expresada de una manera gráfica en la figura 1 sería la siguiente: Introducción 26 Figura 1. Modelo del Sistema a desarrollar. Este trabajo parte de la versión inicial de la aplicación realizada por el Licenciado Luís Antonio González Reyes, DEUSWEB. Se desarrolla una nueva versión, agregando funcionalidades, soporte a nuevos lenguajes de programación y manejadores de base de datos, mejorando la interacción del usuario con la aplicación. Por lo tanto, se tienen como Objetivos: Objetivo General Desarrollar un sistema que permita generar sitios web administrativos mediante la extracción de información de una base de datos existente. Se desea construir de esa forma una herramienta que permita gestionar la información contenida en una base de datos; ello, mediante la incorporación de otros Sistemas Manejadores de Base de Datos que faciliten la manipulación de la información, así como de un nuevo motor encargado de realizar las tareas de generación de un tipo de código específico para el sitio web generado por el mismo sistema. Objetivos Específicos • Desarrollar el sistema siguiendo el proceso de desarrollo Scrum. • Desarrollar el motor PHP, ya que éste es uno de los lenguajes de programación más comerciales en el mercado. • Incorporar nuevos Sistemas Manejadores de Base de Datos: Oracle y PostgreSQL; siendo ambos SMBD de uso común y con gran auge comercial en el área de tecnología. • Crear nuevas hojas de estilos reestructurando al mismo tiempo la interfaz de la aplicación generadora. • Mejorar algunas características de la aplicación existente, DEUSWEB. HTML HTML JSP HTML HTML .PHP USUARIO SMBD 2 SMBD 3 SMBD 1 Parámetros de Configuración Generator Aplicación Web Administrativa Obtención de la Metadata Sistemas Manejadores de Base de Datos Introducción 27 Para el progreso de éste Trabajo Especial de Grado, la información se estructuró de la siguiente manera: el Marco Teórico, el cual abarca la teoría e investigación previa para el cumplimiento de los objetivos que se plantean y el Marco Aplicativo el cual comprende el proceso de desarrollo utilizado tanto en el sistema generador, como en el sistema generado. El Marco Teórico, se compone de los siguientes capítulos: Capítulo I: Conceptos de Base de Datos y Conectividad. En este capitulo, se describen los conceptos fundamentales para el cumplimiento del objetivo general de este trabajo. Se incluyen conceptos del Modelo Entidad – Relación y conceptos del modelo relacional, así como también un concepto fundamental, como lo es el concepto de metadato. Este capítulo finaliza, con la descripción del API JDBC. Capitulo II: DEUSWEB. Se estudia la aplicación que permite generar los sitios web administrativos, que será construida incorporando diferentes manejadores de base de datos y un motor encargado de realizar las tareas para la generación del sitio. Se emplea un caso de estudio y aspectos a considerar para la evaluación de la aplicación. Capítulo III: Scrum. Se describe el proceso de desarrollo de software que se utiliza para la construcción del sistema generador y el sistema generado, describiendo y detallando cada característica, etapa y componente de los procesos. En el Marco Aplicativo, se desarrollan los siguientes capítulos: Capítulo IV: Aplicación Adaptación Se describe el proceso de adaptación basado en cada una de las etapas del modelo de desarrollo de software que se utiliza para la construcción del sistema, describiendo y detallando cada característica, componente que conlleva al proceso. Capitulo V: Implementación En este capítulo se describe el proceso de construcción e implementación de cada uno de los módulos del sistema administrativo, en base al proceso de adaptación y desarrollo especificado en el capítulo previo. Se explica en detalle cada uno de los artefactos generados por la aplicación, y la forma en que fueron obtenidos. Parte I: Marco Teórico 29 PARTE I: MARCO TEÓRICO Capítulo 1: Conceptos de Base de Datos y Conectividad 31 Capítulo 1 Conceptos de Base de Datos y Conectividad Este capítulo, muestra los conceptos relacionados al modelo lógico basado en objetos, representado por el Modelo Entidad-Relación y quien permite ver la base de datos desde un nivel conceptual, y al modelo lógico basado en registros expresado mediante el Modelo Relacional, el cual ve los datos tanto desde un nivel conceptual como físico. De igual forma se describen los conceptos relacionados con la conectividad hacia la base de datos (Metadata y el API JDBC), ya que a través de ellos se tendrá una idea acerca de la estructura de la base de datos y de aquellas operaciones que pueden realizarse sobre la misma. 1.1 Modelo Entidad-Relación Éste modelo es introducido en 1976 por Meter Chen como una técnica para representar la estructura lógica de una base de datos en forma de gráficos. Está basado en la percepción del mundo real; constituido por una colección de objetos denominados entidades y de las relaciones entre esos objetos. Es usado para 'visualizar' los objetos que pertenecen a una base de datos como entidades, las cuales tienen unos atributos y se vinculan mediante relaciones. Así como se muestra en la figura 2: Figura 2. Representación del Modelo Entidad-Relación. Cliente Contiene Realiza Artículo Pedido Capítulo 1: Conceptos de Base de Datos y Conectividad 32 1.1.1 Entidades Una entidad es un objeto concreto o abstracto en el mundo real, y que es distinguible de otros objetos. En la base de datos, las entidades se describen mediante atributos, y son representadas por medio de un conjunto de pares: (atributo, valor). De igual forma existe el conjunto de entidades que no es más que aquella que representa la agrupación de todas las entidades de un mismo tipo y éstos conjuntos no son necesariamente disjuntos. Hay dos tipos de entidades: fuertes y débiles. Una entidad débil es una entidad cuya existencia depende de la existencia de otra entidad. Una entidad fuerte es una entidad que no es débil. La representación de una entidad se puede observar en la figura 3: Figura 3. Representación de una Entidad en el Modelo Entidad-Relación. 1.1.2 Atributos Los atributos, o también denominados propiedades, definen las características básicas de una entidad y de una relación. Se pueden tener distintos tipos de atributos como: Simple: Son aquellos atributos que no se pueden dividir o descomponer, por ejemplo: cédula, nombre de una entidad persona. Compuestos: Es cuando un atributo es dividido en pequeñas partes que poseen un significado propio, por ejemplo la dirección de una entidad persona, que puede dividirse en ciudad, avenida, calle. Derivados: Cuando los valores de un atributo son afines y ese valor se puede derivar de los valores de otros atributos. Clave: Cuando los valores del atributo son distintos para cada entidad individual. Cliente Realiza Pedido Artículo Contiene Entidad Cliente Capítulo 1: Conceptos de Base de Datos y Conectividad 33 1.1.3 Relaciones Una relación es una asociación entre varias entidades, y puede darse entre entidades del mismo o diferentes conjuntos de entidades, como se observa en la figura 4. Por ejemplo: una persona (entidad) trabaja (relación) para un departamento (entidad). El Grado de la relación va definido por la cantidad de entidades en la misma, ya que la relación puede incluir varias entidades. (Ver figura 3) Figura 4. Representación de una relación de grado 2 en el Modelo Entidad-Relación. Además toda relación posee propiedades que la caracterizan: Roles: Son las funciones que desempeñan cada uno de los conjuntos de entidades asociadas. Cardinalidad: Define el número de entidades de una clase o conjunto que pueden ser asociadas a una entidad de otra clase o conjunto. Así son posibles tres tipos de cardinalidades: • Relaciones de uno a uno, "1:1": una instancia de la entidad A se relaciona con una y solamente una de la entidad B. • Relaciones de uno a muchos, "1:N": cada instancia de la entidad A se relaciona con varias instancias de la entidad B. Por ejemplo: Una factura (entidad) se emite (relación) a una persona (entidad) y sólo una, pero una persona puede tener varias facturas emitidas a su nombre. Cliente Realiza Pedido Artículo Contiene Relación “Contiene”, de grado 2 Capítulo 1: Conceptos de Base de Datos y Conectividad 34 • Relaciones de muchos a muchos, "N:M": cualquier instancia de la entidad A se relaciona con cualquier instancia de la entidad B. Por ejemplo: Un cliente (entidad) puede comprar (relación) varios artículos (entidad) y un artículo puede ser comprado por varios clientes. 1.2 Modelo Relacional El modelo relacional es un ejemplo de un modelo basado en registros. Los modelos basados en registros se denominan así porque la base de datos se estructura en registros de formato fijo de varios tipos. Cada tabla contiene registros de un tipo particular. Cada tipo de registro define un número fijo de campos, o atributos. 1.2.1 Tabla La tabla es la representación de un conjunto de entidades, así como, de una relación dentro del modelo entidad-relación, observando la figura 5: Figura 5. Una Tabla en el Modelo Relacional. 1.2.2 Campos Un campo es la unidad básica de una tabla. La representación de un campo puede verse en la figura 6: Figura 6. Representación de un Campo en una Tabla. Campo Capítulo 1: Conceptos de Base de Datos y Conectividad 35 1.2.3 Tipos de Campos • Texto: Se introducen cadenas de caracteres hasta un máximo de 225. • Memo: Se introduce un texto extenso. • Numérico: Para introducir números. • Fecha/Hora: Sirve para introducir datos en formato de fecha u hora. • Moneda: Soporta datos en formato numérico y con un signo monetario. • Autonumérico: Se enumera automáticamente el contenido. • Si/No: Campo exclusivamente para datos del tipo lógico, Verdadero/Falso. • Objeto OLE: Sirve para introducir una foto, gráfico, Hoja de Cálculo, sonido, etc. • Hipervínculo: Sirve para definir un enlace a una página Web. • Asistente para búsquedas: Se crea un campo que permite elegir un valor de otra tabla o de una lista de valores mediante un cuadro de lista o un cuadro combinado. 1.2.4 Dominio El dominio es un conjunto finito de valores simples y de un mismo tipo, los cuales son caracterizados por un nombre y un tipo de dato. Por ejemplo, el Dominio de Idiomas: Español, Ingles, Francés, etc.; donde el tipo de dato en este caso, es un conjunto de caracteres de longitud máxima 20. 1.2.5 Atributos Los atributos representan las propiedades de una entidad, es decir, conforman las columnas de la tabla, en donde cada una de ellas posee un nombre único dentro de la tabla como se tiene en la figura 7: Figura 7. Representación de un Atributo en una Tabla. 1.2.6 Tupla La tuplas son representadas mediante las filas de la tabla, simbolizan a una entidad dentro de la tabla, como se observa en la figura 8: Atributo nombre_cliente Capítulo 1: Conceptos de Base de Datos y Conectividad 36 Figura 8. Representación de una Tupla en una Tabla. 1.2.7 Clave Primaria Se le denomina clave primaria a un campo o a una combinación de campos que identifica en forma única a una tupla o registro. Por ejemplo el id de un cliente en la tabla Cliente. El o los campos de la clave primaria no pueden poseer valores nulos. Una clave primaria cumple con las siguientes propiedades: • Unicidad: No pueden existir dos o más entidades con el mismo valor en todos los atributos que forman una clave. • Irreductibilidad o Minimizad: No existe ningún subconjunto de la clave primaria que cumpla la regla de unicidad. 1.2.8 Clave Foránea La clave foránea es una referencia, en una tabla, a la clave primaria de otra tabla; es decir, los valores de un campo o de una combinación de campos de una tabla, coinciden con los valores de la clave primaria de otra tabla. La clave foránea y la correspondiente clave primaria han de estar definidas sobre el mismo dominio. 1.2.9 Claves Compuestas Una clave es compuesta cuando dos o más campos componen la clave. 1.2.10 Esquema Es la descripción de la base de datos. El esquema se realiza mediante un conjunto de definiciones de expresadas en un DDL (Lenguaje de Definición de Datos). El resultado de esta definición es un conjunto de tablas que y relaciones que se almacenan en una tabla o conjunto de tablas especial, denominado diccionario de datos. El esquema se especifica durante la fase de diseño, y generalmente no es modificado con frecuencia. Para poder representarlo en una base de datos relacional se debe dar el nombre de sus relaciones, los atributos de las mismas, los dominios sobre los que se definen los atributos, las claves primarias y foráneas. Tupla Capítulo 1: Conceptos de Base de Datos y Conectividad 37 1.2.11 Restricciones Restricciones Inherentes • Definición matemática de la relación: o No hay dos tuplas iguales o El orden de las tuplas no es significativo. o El orden de los atributos no es significativo. o Los valores de los atributos son simples. • Regla de integridad de Entidad: Se refiere a que los campos que conforman la clave primaria no pueden tomar valores nulos, ello se debe a que la clave debe permitir identificar unívocamente cada tupla de la tabla. Restricciones Semánticas (de usuario) • Integridad Referencial: Se refiere a que todos los valores no nulos de una clave foránea referencian valores reales de la clave referenciada. En una base de datos es necesario asegurar que un valor x se encuentre en las tablas que determinan una relación. 1.2.12 Borrado en Cascada El borrado en cascada se refiere a cuando se elimina o se modifica una entidad (tupla) del conjunto de entidades (tablas) que contiene la clave primaria referenciada, se deben borrar o modificar todas las tuplas de las tablas que contienen la clave foránea. Esto indica al sistema gestor de la base de datos que cuando se elimina un registro de la tabla principal, automáticamente se borran también los registros relacionados en la tabla secundaria. 1 1.3 Metadato El Metadato es la información sobre la estructura de la base de datos. Cada Sistema Manejador de Base de Datos (SMBD) posee diferentes mecanismos que facilitan su acceso. 1.4 JDBC JDBC es el acrónimo de Java Database Connectivity, un API que permite la ejecución de operaciones sobre bases de datos desde el lenguaje de programación Java independientemente del sistema de operación donde se ejecute o de la base de datos a la cual se accede utilizando el lenguaje SQL del modelo de base de datos que se utilice. 1 http:// www.aulaclic.es/sql/b_6_1_1.htm Capítulo 1: Conceptos de Base de Datos y Conectividad 38 El API se presenta como una colección de interfaces Java y métodos de gestión de manejadores de conexión hacia cada modelo específico de base de datos. Un manejador de conexiones hacia un modelo de base de datos en particular es un conjunto de clases que implementan las interfaces Java y que utilizan los métodos de registro para declarar los tipos de localizadores a base de datos (URL) que pueden manejar. Para utilizar una base de datos particular, el usuario ejecuta su programa junto con la librería de conexión apropiada al modelo de su base de datos, y accede a ella estableciendo una conexión como se muestra a continuación en la figura 9: Figura 9. Estructura de JDBC [itapizaco, 2007]. 1.4.1 Cómo usar el API JDBC Para usar el API JDBC lo primero que se debe hacer es establecer la conexión a la base de datos. JDBC utiliza los mismos métodos y clases independientemente del driver usado para conectarse, solo se necesita cargar el driver JDBC usando el cargador de clases Class.forName; el String que le es pasado por parámetro corresponde al nombre del manejador de conexión. Luego, se usa la interfaz Connection que abre una conexión con la BD especificada y mediante el método DriverManager.getConnection, se intenta seleccionar el driver apropiado de entre los que JDBC tenga registrados en el sistema; donde se le pasa como parámetros: • El URL correspondiente a un String siguiendo la sintaxis basada en la especificación más amplia de los URLs, de la forma: jdbc:subprotocolo//servidor:puerto/base de datos. • El login, se refiere a un String, el cual indica el nombre que se utiliza para entrar al controlador de la base de datos. Capítulo 1: Conceptos de Base de Datos y Conectividad 39 • El Password que es un String que indica la clave o contraseña para el controlador de la base de datos. La clase encargada de cargar inicialmente todos los drivers JDBC disponibles es DriverManager; y no se necesita registrar el driver cargado con el driverManager porque la llamada a Class.forName lo hace automáticamente. Una vez que se tiene un objeto de tipo Connection, se pueden crear sentencias SQL, statements, ejecutables. La interfaz Statement permite ejecutar las instrucciones SQL y devolver el resultado generado. Cada una de estas sentencias puede devolver cero o más resultados, que se devuelven como objetos de tipo ResultSet. Por lo tanto, el código genérico de conexión a una Base de Datos se muestra en la siguiente figura 10: Class.forName (“nombre_del_driver”); //Se carga el driver de conexión Connetion con; //Se declara la variable con de conexión Connection con = DriverManager.getConnection ("BD_url", "usuario", "password”); // Se establece la conexión con la BD Statement select = con.createStatement(); Figura 10. Código genérico de la conexión JDBC con la Base de Datos. Además, JDBC define ocho interfaces para las operaciones con base de datos, de las cuales se derivan las clases correspondientes expresadas en la figura 11: Clase/Interface Descripción Driver Permite conectarse a una base de datos: cada gestor de base de datos requiere un driver distinto DriverManager Permite gestionar todos los drivers instalados en el sistema Connection Representa una conexión con una base de datos. Una aplicación puede tener más de una conexión a más de una base de datos DatabaseMetadata Proporciona información acerca de una Base de Datos, como las tablas que contiene, etc. Statement Permite ejecutar sentencias SQL sin parámetros PreparedStatement Permite ejecutar sentencias SQL con parámetros de entrada CallableStatement Permite ejecutar sentencias SQL con parámetros de entrada y salida, típicamente procedimientos almacenados ResultSet Contiene las filas o registros obtenidos al ejecutar un Capítulo 1: Conceptos de Base de Datos y Conectividad 40 SELECT ResultSetMetadata Permite obtener información sobre un ResultSet, como el número de columnas, sus nombres, etc. Figura 11. Tabla de Interfaces para operaciones con Base de Datos [itapizaco, 2007]. A continuación se muestra en la figura 12 la interrelación entre estas clases basado en el modelo de objetos de la especificación JDBC: Figura 12. Interrelación de las clases en la especificación JDBC [itapizaco, 2007]. Capítulo 1: Conceptos de Base de Datos y Conectividad 41 1.4.2 Obtener información sobre las características de la Base de Datos Mediante la interfaz DatabaseMetaData que proporciona JDBC es posible saber sobre las características de la base de datos con la cual se está trabajando. Esta interfaz proporciona información referente a una base de datos y cuenta con diferentes métodos a través de los cuales se puede obtener la información correspondiente a una tabla de la base de datos: • getCatalogs( ): Retorna un objeto de tipo Resulset, que contiene un campo de tipo String en cada fila del objeto. El método retorna los nombres de los catálogos que están disponibles en la base de datos. • getColumns( String catalogo, String esquema, String Tabla, String Columna): Este método retorna un objeto de tipo Resulset con la descripción de las columnas de la tabla que se especifica en el catálogo. Cada fila de este objeto esta formada por 18 campos descriptivos, como: el nombre de la columna, el nombre de la tabla que contiene la misma, el tamaño máximo de la columna, etc. Los datos que son pasados por parámetros son: nombre del catalogo, nombre del esquema, nombre de la tabla y nombre de la columna, esto con e fin de establecer un patrón para la búsqueda. Éste patrón se especifica de la misma forma que en las sentencias SQL en las que se utiliza LIKE para las coincidencias. En una expresión de búsqueda, el guión bajo (_) representa cualquier carácter de la cadena encontrada, y el tanto por ciento (%), es cualquier número de caracteres consecutivos de la cadena; los valores correspondientes al catálogo y al esquema son nulos, indicando esto que el parámetro debe obtenerse a partir del criterio de búsqueda. Por ejemplo: getColumns (null, null,”hora”, ”%”); allí en el patrón de búsqueda ho_a se encontrarían palabras como “hora”, “hola”, ”hoja”, etc., mientras que la expresión ho%a daría como resultado cualquier palabra que comience por “ho” y termine en “a”, ello independientemente del número de caracteres que contenga. • getExportedKeys(String catalogo, String esquema, String Tabla): El método retorna mediante un objeto de tipo Resulset, la descripción de cada una de las columnas que son claves foráneas y que referencia las columnas que conforman la clave primaria de la tabla. Cada fila del objeto esta formada por 14 campos descriptivos, como por ejemplo: nombre del catalogo, nombre del esquema, nombre de la tabla, etc. • getImportedKeys(String catalogo, String esquema, String Tabla): Retorna mediante un objeto de tipo Resulset, la descripción de cada una de las columnas que son claves primarias en la tabla y claves foráneas de otra. Cada fila del objeto esta formada por 14 campos descriptivos, como por ejemplo: nombre del catalogo, nombre del esquema, nombre de la tabla, etc. Capítulo 1: Conceptos de Base de Datos y Conectividad 42 • getPrimaryKeys(String catalogo, String esquema, String Tabla): Retorna mediante un objeto de tipo Resulset, la descripción de cada una de las columnas que forman la clave primaria de la tabla especificada. Cada fila del objeto esta formada por 6 campos descriptivos, como por ejemplo: nombre del catalogo, nombre del esquema, nombre de la tabla, etc. • getProcedures(String catalogo, String esquema, String Procedimiento): Retorna mediante un objeto de tipo Resulset, la descripción de cada uno de los procedimientos disponibles en el catálogo. Cada fila del objeto esta formada por 8 campos descriptivos. • getTables(String catalogo, String esquema, String Tabla, String[ ] Tipos): Retorna mediante un objeto de tipo Resulset, la descripción de cada uno de las tablas disponibles en el catálogo. Cada fila del objeto esta formada por 10 campos descriptivos, como por ejemplo: nombre del catalogo, nombre del esquema, nombre de la tabla, tipo de Tabla: “TABLE”, “VIEW”, “SYSTEM TABLE”, etc. 1.4.3 Obtener información referente a un campo o a una columna de la Base de Datos El objeto ResultSet devuelto por el método executeQuery(), permite recorrer las filas obtenidas, no proporciona información referente a la estructura de cada una de ellas; para ello es utilizado ResultSetMetaData, que permite obtener el tipo de cada campo o columna, su nombre, si es del tipo autoincremento, si es sensible a mayúsculas, si se puede escribir en dicha columna, si admite valores nulos, etc. Para obtener un objeto de tipo ResultSetMetaData solo es necesario llamar al método getMetaData() del objeto ResultSet. A continuación se detallan algunos de los métodos más importantes de ResultSetMetaData, que permiten averiguar toda la información necesaria para formatear la información correspondiente a una columna, etc. Generalmente, los métodos reciben como parámetro el número de la columna cuyo valor empieza desde uno (1): • getCatalogName(int columna): Retorna un String que corresponde al nombre de la columna en el catálogo de la base de datos. • getColumnName(int columna): Retorna un String que corresponde al nombre de la columna. • getColumnCount(int columna):Retorna un entero que indica el número de columnas en el ResultSet. • getTableName(int columna): Retorna un String que corresponde al nombre de la tabla a la que le pertenece la columna. • getColumnType(int columna): Retorna un String que indica el Tipo de la columna (uno de los tipos SQL en java.sql.Types) • isAutoIncrement(int columna): Retorna un valor lógico que indica si la columna es de tipo autoincremento. Capítulo 1: Conceptos de Base de Datos y Conectividad 43 • isNullable(int columna): Retorna un entero que indica si la columna puede contener un NULL SQL. Puede devolver los valores columnNoNulls, columnNullable o columnNullableUnknown, miembros finales estáticos de ResultSetMetaData (constantes). • isReadOnly(int columna): Devuelve un valor lógico que indica si la columna es de solo lectura. • isWritable(int columna): Devuelve un valor lógico indicando si la columna puede modificarse, aunque no lo garantiza. • isSearchable(int columna): Retorna un valor lógico que indica si es posible utilizar la columna para determinar los criterios de búsqueda de un SELECT. • getSchemaName(int columna): Devuelve un String que indica el texto correspondiente al esquema de la base de datos para esa columna. 1.4.4 JDBC y algunos Manejadores de Base de Datos Ya se ha venido explicando que JDBC es la interfaz que proporciona Java para la conexión a bases de datos. Define la manera en que un cliente puede acceder a una base de datos; contiene un conjunto de clases e interfaces que permiten ejecutar consultas, órdenes y métodos de gestión de manejadores para cada modelo en específico de base de datos relacionales, y en algunos casos se presentan características que difieren en cuanto a su manejo, según el sistema de gestión de base de datos que se vaya a emplear. 1.4.4.1 Postgres • Manejo de Secuencia Para generar una secuencia esta debe ser definida bajo el tipo SEQUENCE. Sequence crea una tabla especial que posee una sola fila, esta debe ser creada e inicializada con un nombre definido. Por ejemplo: CREATE SEQUENCE serial START 101; • Manejo del tipo de dato Enumerado Postgres no tiene un tipo de dato enum, sino que lo simula al especificar que conjunto de valores puede tomar un campo. Para esto usa un CHECK CONSTRAINT el cual chequea los valores en el momento de ejecutarse el insert. Como en la figura 13 por ejemplo: CREATE TABLE person ( personid int not null primary key, favourite_colour varchar(255) NOT NULL, CHECK (favourite_colour IN ('red', 'blue', 'yellow', 'purple'))); Figura 13. Código ejemplo para el manejo del tipo de dato Enumerado en Postgres Capítulo 1: Conceptos de Base de Datos y Conectividad 44 • Manejo de Archivos Binarios Se tiene dos formas distintas de almacenar data binaria, el tipo "bytea" que almacena la data en una tabla, o el tipo "BLOB", el cual almacena la data binaria en una tabla separada con un formato especial y haciendo referencia a esta tabla almacenando un valor de tipo "oid" en la tabla original. El tipo "bytea" no esta diseñado para almacenar grandes cantidades de data binaria. Si bien una columna de tipo bytea puede almacenar hasta 1gb de data, el procesar esta cantidad de data requiere una gran cantidad de memoria. Los BLOB si pueden manejar grandes cantidades de datos, pero presenta algunas limitaciones, específicamente el borrar una fila que contiene una referencia a un BLOB no borra el BLOB como tal, se requiere una operación separada para borrar el BLOB. También presenta problemas de seguridad ya que cualquier persona conectada a la base de datos puede ver y/o modificar cualquier BLOB incluso si no tienen permisos para ver/modificar la tabla con las referencias a los BLOB. A partir de la versión 7.2 del JDBC driver el comportamiento del tipo de datos bytea ha cambiado. Desde esta versión los métodos getBytes(), setBytes(), getBinaryStream(), y setBinaryStream() operan en un bytea. En 7.1 y versiones anteriores, estos métodos operan en el tipo de datos oid asociado con los BLOB. Es posible revertir el driver para que se comporte como en la versión 7.1 Para usar la función de archivos BLOB bien se puede usar la clase para LargeObject contenida en el driver PostgreSQL™ JDBC, o usar los métodos getBLOB() y setBLOB(). • Resultados de forma Paginada El paginado de registros se hace a nivel de declaraciones SQL, usando el comando LIMIT sin embargo este presenta ligeras diferencias entre distintos manejadores de base de datos. Para el caso de postgres se debe indicar el valor del limit y el valor del offset, y estos deben estar precedidos de su respectiva etiqueta. Así se observa en la figura 14: "select campo from tabla limit $limit offset $offset" Figura 14. Código ejemplo para el Paginado de Registros en Postgres. Capítulo 1: Conceptos de Base de Datos y Conectividad 45 • Manejo de Claves Foráneas El manejo de Claves Foráneas se realiza a través de uno o mas campos de una tabla, referenciando el mismo numero de campos de otra tabla. Como puede observarse en la figura 15: CREATE TABLE t1 ( a integer PRIMARY KEY, b integer, c integer, FOREIGN KEY (b, c) REFERENCES t2 (c1, c2) ); Figura 15. Código ejemplo para el Manejo de Claves Foráneas en Postgres. Se definen dos claves foráneas, los campos b y c están referenciados por los campos c1 y c2 de la tabla t2, con esto los valores de los campos b y c solo pueden aceptar valores que estén en los registros de la tabla t2, específicamente en los campos c1 y c2 respectivamente. Para las claves foráneas, se permite actualización y borrado en cascada, con restricciones y sin especificación. En cascada especifica que si una fila sufre un cambio (si es borrada o actualizada) entonces las filas que la referencias también deben sufrir el cambio de manera automática. Con restricción se previene la modificación o eliminación de las filas referenciadas y sin especificación significa que si ocurre una modificación se genera un error al verificar la relación de clave foránea. 1.4.4.2 MySQL • Manejo de Secuencia Las secuencias son generadas automáticamente. Usando un numérico de incremento automático. No es un tipo de dato definido, sino que son emuladas usando un campo de tipo entero (int). Por ejemplo, en la figura 16: CREATE TABLE my_table ( id INT NOT NULL AUTO_INCREMENT, data CHAR(30), ); Figura 16. Código ejemplo para el Manejo de Secuencia en MySQL. Capítulo 1: Conceptos de Base de Datos y Conectividad 46 • Manejo del tipo de dato Enumerado Posee un tipo “enum” el cual es un objeto de tipo string y la lista de valores que contiene deben ser especificados explícitamente en el momento de crear la tabla. Los valores que tomara el enumerado deben estar encerrados entre comillas y no puede ser una expresión, ni siquiera si esta expresión genera un valor de tipo string. Como en la figura 17: CREATE TABLE sizes ( name ENUM('small', 'medium', 'large') ); Figura 17. Código ejemplo para el Manejo del tipo de dato Enumerado en MySQL. • Manejo de Archivos Binarios El tipo BLOB permite almacenar una cantidad variable de data binaria. Existen cuatro tipos de BLOB los cuales son TINYBLOB, BLOB, MEDIUMBLOB, y LONGBLOB, estos solo difieren en la cantidad máxima de data que pueden almacenar. Las columnas de tipo BLOB son tratadas como cadenas binarias (byte strings). • Resultados de forma Paginada Para MySQL igualmente usamos el comando LIMIT, pero en este caso solo se debe indicar la etiqueta limit, seguida de los valores necesarios, limit y offset. Como por ejemplo en la figura 18: SELECT campos FROM table LIMIT $offset, $limit Figura 18. Código ejemplo para el Paginado de Registros en MySQL. • Manejo de Claves Foráneas Se tiene que cumplir tres condiciones para que el uso de claves foráneas sea posible: 1. Ambas tablas deben ser del tipo de tabla InnoDB y no pueden ser tablas temporales. Capítulo 1: Conceptos de Base de Datos y Conectividad 47 2. Los campos usados en la relación de clave foránea deben ser claves primarias 3. Los campos usados en la relación de clave foránea deben ser similares en su tipo de dato para que estos puedan ser comparados sin realizar ninguna conversión. Soporta actualización y borrado en cascada, con cinco opciones de comportamiento para estas funciones: • Cascada (CASCADE): Al eliminar o actualizar una fila de la tabla referenciada, automáticamente en la tabla que referencia se reflejaran los cambios en la fila que corresponda. • A Nulo (SET NULL): Al eliminar o actualizar una fila de la tabla referenciada se cambia las columnas en la tabla que referencia a nulo. Esto es solo valido si la columna de clave foránea no tiene especificado el calificador NOT NULL. • Sin acción (NO ACTION): Significa que en cualquier intento de eliminar o actualizar una clave primaria no es permitido si existe una clave foránea relacionada en la tabla referenciada. InnoDB rechaza la operación de eliminar o actualizar en la tabla referenciada. • Con Restricción (RESTRICT): Rechaza las operaciones de eliminar o actualizar. Sin acción y Con restricción son iguales, en otros sistemas de base de datos el chequeo se hace diferido, en MySQL los chequeos de claves foráneas se realizan de forma automática. • Valor por defecto (SET DEFAULT): Esta acción es reconocida por el parser, pero InnoDB rechaza cualquier definición de tabla que contenga esta cláusula. 1.4.4.3 Oracle • Manejo de Secuencia Oracle implementa los objetos denominadas secuencias, que permiten generar números en forma ordenada para implementar, por ejemplo, una clave primaria en una tabla o garantizar que esos números no se repiten y van siempre en un orden predefinido por el desarrollador (no necesariamente secuenciales), almacenando el último número utilizado en un registro especial, bloquearlo, obtener el próximo valor, actualizar el registro, desbloquearlo y utilizar el número. Mediante las secuencias, Oracle puede proporcionar una lista consecutiva de números unívocos que sirve para simplificar las tareas de programación. La Capítulo 1: Conceptos de Base de Datos y Conectividad 48 primera vez que una consulta llama a una secuencia, se devuelve un valor predeterminado. Cuando se define una secuencia se deben indicar, como mínimo, el valor de partida (valor mínimo) y el incremento. La sintaxis de creación de una secuencia es la siguiente: CREATE SEQUENCE nombre_secuencia INCREMENT BY número START WITH número MINVALUE número [o NOMINVALUE] MAXVALUE número [o NOMAXVALUE] NOCYCLE [o CYCLE]; Los parámetros significan lo siguiente: • Increment by: Indica la cantidad de incremento de la secuencia. • Start with: Es el valor de partida de la secuencia. • Minvalue: Indica cuál será el valor mínimo de la secuencia. • Maxvalue: Corresponde al valor máximo que puede tomar la secuencia. • Nocycle: Es el valor por defecto para establecer si la secuencia deberá comenzar nuevamente a generar valores una vez que ha alcanzado el máximo. • Manejo de Archivos Binarios En Oracle los datos binarios nos van a permitir guardar en la base de datos archivos, imágenes, sonidos, etc.; casi siempre es preferible guardar la ruta del archivo en la base de datos en lugar del propio archivo en modo binario, pero existen ciertas circunstancias en las que no nos queda otra solución. Lo primero que se hace es crear un objeto directorio, ya que el archivo que queremos guardar se encuentra en el servidor y se debe permitir explícitamente el acceso al directorio en cuestión al usuario que ejecutará la sentencia. Se carga el archivo existente en el servidor en un campo BLOB de una tabla. Como se observa en la figura 19, a continuación: CONNECT sys/&password@ORACLEBD as sysdba; CREATE OR REPLACE DIRECTORY IMAGES AS 'C:\ORACLE\BLOB\IMAGES'; Figura 19. Código ejemplo para el Manejo de Archivos Binarios en Oracle. Capítulo 1: Conceptos de Base de Datos y Conectividad 49 Donde IMAGES es el archivo a guardar. Oracle admite la instalación paralela de archivos binarios de aplicaciones, pero la réplica sólo puede utilizar un conjunto de archivos binarios a la vez. Cada conjunto de archivos binarios está asociado a un directorio de inicio de Oracle; los archivos binarios se encuentran en el directorio %ORACLE_HOME%\bin. 1.4.4.4 Comparación de Tipos de Datos para cada Manejador La conversión de los diferentes tipos de datos es de suma importancia si se desea trabajar con recuperación y almacenamiento de datos numéricos o con fechas SQL, las cuales presentan formatos muy bien definidos, así como el manejo de cualquier otro tipo; es por ello que a continuación se presenta en la figura 20 una tabla comparativa de los tipos de datos que son utilizados por cada manejador de base de datos: MySQL Type POSTGRES ORACLE Java Type CHAR char String VARCHAR varchar varchar String LONGVARCHAR TEXT varchar2 String NUMERIC number java.math.BigDecimal DECIMAL java.math.BigDecimal BIT boolean Bolean TINYINT Byte SMALLINT int2 Short INTEGER int, int4 Int BIGINT int8 Long REAL float4 Flota FLOAT float4 float Double DOUBLE float8 Double BINARY bytea Blob,Clob byte [] VARBINARY bytea byte [] LONGVARBINARY BLOB Lob byte [] DATE date date java.sql.Date TIME timetz Timestamp with time zone java.sql.Time TIMESTAMP timestamptz Timestamp java.sql.Timestamp ENUM - - serial - - serial8 - Figura 20. Tabla Comparativa de los Tipos de Datos por cada Manejador de Base de Datos. Capítulo 1: Conceptos de Base de Datos y Conectividad 50 1.5 Resumen del Capítulo En este capítulo se han expuesto varios conceptos fundamentales de las base de datos. En primer lugar, se describieron conceptos relacionados al Modelo Entidad – Relación, el cual representa al modelo lógico basado en objetos; dentro de estas nociones están las entidades, las relaciones. Seguidamente se definieron los conceptos afines al Modelo Relacional, que representa uno de los modelos mas extendidos en el modelo lógico basado en registros; se detallaron conceptos como tabla, campos, tipos de campos, atributos, clave primaria, clave foránea, entre otros. También se definió la estructura de la base de datos, es decir, metadato. Finalmente fue descrito lo que es el API JDBC, a través del cual una aplicación o sistema puede establecer una conexión con un Sistema Manejador de Base de Datos y de esa forma permitir operaciones correspondientes en la base de datos independientemente de cual sea ésta última. Así mismo se describieron cada una de las interfaces o clases que componen el API, como también un conjunto de métodos e instrucciones que se han de ejecutar para realizar la conexión con la base de datos. Cada una de las definiciones detalladas en éste capítulo sirven de base para el siguiente capítulo en el cual es estudiada una herramienta existente que permite generar aplicaciones web administrativas gestionando la información contenida en la base de datos. Capítulo 2: DEUSWEB 51 Capítulo 2 DEUSWEB En este capítulo se estudia y explica en detalle la aplicación generadora de sitios web administrativos existente, DEUSWEB, la cual permite generar aplicaciones web mediante la identificación de una base de datos, gestionando un conjunto de tablas pertenecientes a ella. Se toman en cuenta la estructura, funcionalidades, limitaciones, flujos de procesos utilizados y demás características que permitan ahondar en el funcionamiento de ésta herramienta. Se definen criterios de evaluación para ser aplicados a la herramienta, igualmente se especifica un caso de estudio basado en el contexto de venta y soporte técnico de teléfonos celulares. 2.1. ¿Qué es?, ¿qué hace? DEUSWEB es un sistema que permite generar aplicaciones web administrativas las cuales son capaces de gestionar la información contenida en una base de datos. DEUSWEB crea las aplicaciones administrativas a partir de una base de datos existente, mediante su estructura y características, estas aplicaciones permiten el manejo de la data contenida en la base de datos. La generación de estas aplicaciones se realiza mediante un asistente quien a través de una serie de pasos, recolecta metadata de la base de datos y opciones de configuración que definen la aplicación generada. 2.2. ¿Cómo funciona? 2.2.1. Arquitectura de la aplicación generadora: Para el diseño de esta arquitectura de la herramienta DEUSWEB, se definió como lenguaje de programación a utilizar: JAVA, utilizando el paquete java.swing para la generación de las interfaces gráficas. Además se definió como una aplicación “standalone” implementado a manera de asistente o Wizard para la generación del sitio Web administrativo. El usuario a través de la interfaz de usuario completa los datos requeridos por la aplicación. Estos datos son enviados a una clase controladora, la cual se encarga de hacer las validaciones correspondientes en caso de que sea necesario. Seguidamente el controlador se encarga de invocar a las clases que tienen ciertas operaciones que él no se encarga de manejar, donde algunas de ellas realizan la conexión a la base de datos, otras manipularán archivos, mientras que otras se encargarán de la generación del sitio Web. Luego de obtener los resultados, el controlador retorna la respuesta al usuario a través de la interfaz de usuario. Como se puede observar en la figura 21: Capítulo 2: DEUSWEB 52 Figura 21: Arquitectura General del sistema generador, Aplicación DEUSWEB [González, 2006]. 2.2.2. Archivos que utiliza: sistemas-manejadores.xml: es un archivo utilizado por la interfaz, en la selección de la base de datos, para cargar los tipos de Sistemas Manejadores que manipula la aplicación. Este archivo se encuentra en una carpeta sistemas- manejadores. drivers.xml: es un archivo utilizado por el sistema que permite conocer la ruta de los drivers de conexión a la base de datos disponibles. Este archivo se encuentra en una carpeta denominada drivers. motores.xml: es un archivo que utiliza el sistema que indica que tipo de código puede ser generado por la aplicación para la aplicación generada. Es utilizado por el sistema en las configuraciones del Destino y Lenguaje, para extraer el nombre de los motores existentes. Este archivo especifica que procesadores (que no son más que una clase java) deben ejecutarse por cada uno de los motores implementados. Cada procesador especifica una clase y también pueden especificar los parámetros que se necesiten para su ejecución. 2.2.3. Ejecución de Tareas La aplicación generadora debe basarse en tres procesos principales, de los cuales se derivan las funcionalidades del sistema: • Identificación de la base de datos y selección de las tablas: El sistema obtiene la base de datos y las tablas de la misma que la aplicación generada Interfaces USUARIO BD Controlador Validacion HTML HTML .java HTML HTML JSP basededatos archivos procesadores Motores HTML HTML Servlets Capítulo 2: DEUSWEB 53 deberá administrar. Esto se logra con la interacción del usuario y por la manipulación de los metadatos de la base de datos que realiza el sistema. • Extracción de la información de cada una de las tablas seleccionadas: El sistema, extrae los metadatos del repositorio o base datos obteniendo así, toda la información necesaria de cada una de las tablas que fueron seleccionadas. Esta información es la siguiente: Nombre de las tablas y columnas de cada tabla, identificación del tipo de dato de cada columna, identificación de AUTO_INCREMENT y NOT_NULL, longitud de la columna, identificación de claves primarias y foráneas por cada tabla. • Generación del código fuente: Con la información ya extraída y cierta información que tiene que ver con la configuración del sitio y que es suministrada por el usuario del sistema, se genera un documento XML. El sistema a través de los motores, genera la aplicación web administrativa. Teniendo como entrada el documento XML, se ejecuta el motor, configurado en la aplicación a través de otro documento XML, para producir el código fuente de la aplicación Web generada. 2.2.4. Estructura de Directorios: • Directorio aplicaciones-generadas: En esta carpeta se almacenan los archivos temporales generados por los procesadores antes de generar el archivo de extensión war. • Directorio build: Esta carpeta contiene los archivos compilados de los archivos fuentes que componen la aplicación. Se organizan en paquetes. • Directorio drivers: Contiene los archivos de extensión jar que son utilizados por la aplicación. Algunos de estos archivos son copiados a la carpeta lib de la aplicación generada. Este directorio también incluye un archivo drivers.xml, el cual contiene la ruta de los drivers de conexión a la base de datos que posee el sistema. • Directorio estilos: Esta carpeta contiene subdirectorios con los estilos que pueden ser aplicados al sitio web generado. • Directorio imágenes: Aquí se almacenan todas las imágenes generadas por la aplicación. • Directorio motores: Almacena los archivos necesarios por el motor implementado para generar el sitio web. Incluye un archivo motores.xml, el cual indica que clases java (procesadores) deben ejecutarse por cada uno de los motores. • Directorio sistemas-manejadores: Almacena el archivo sistemas- manejadores.xml que describe los Sistemas Manejadores de Base de Datos que manipula la aplicación. Capítulo 2: DEUSWEB 54 • Directorio src: Contiene los archivos fuentes de la aplicación. Se organizan en paquetes. 2.3. ¿Qué genera? y sus Funcionalidades 2.3.1. Patrón empleado y Arquitectura del sitito a generar: Patrón de Diseño MVC: El patrón implementado fue Modelo – Vista – Controlador (MVC), quien separa los datos, la interfaz de usuario y la lógica de control a través de: Modelo: Es la representación específica del dominio de la información sobre la que funciona la aplicación. La lógica de dominio añade significado a los datos. Para éste caso, el modelo viene representado por: Clases Java que encapsulan las operaciones de la aplicación. Vista: La vista representa la interfaz con el usuario u otro sistema. No accede a la base de datos y no contiene lógica de negocio. Para ésta implementación, las vistas se representan mediante: Páginas JSP, HTML, XML, etc. Controlador: Es lo que manipula al modelo según la entrada del usuario. Este componente responde a eventos, basándose en la vista actual, en el estado del modelo y en las acciones llevadas a cabo por el usuario, el controlador invoca a la API del modelo para actualizar el estado el estado del mismo y seleccionar la siguiente vista. El controlador, está representado mediante los Servlets, para ésta implementación. Arquitectura del Sistema Para el diseño de esta arquitectura, se definió como lenguaje de programación a utilizar: JAVA, implementando las tecnologías Servlets y JSP. Como se observa en la figura 22, el usuario, a través del navegador, le envía una petición al servidor. El encargado de recibir la petición en el lado servidor es el Controlador (Servlets). El Controlador, a través del modelo (Clases Java, EJBs) interactúa con el Sistema Manejador de Base de Datos para resolver la consulta. Una vez obtenidos los resultados, el modelo retorna la respuesta al controlador. El controlador genera la respuesta al cliente a través de las páginas JSP, que el cliente recibe como páginas HTML. Capítulo 2: DEUSWEB 55 Figura 22: Arquitectura General del Sitio Web Generado. 2.3.2. Archivos generados y Estructura de Directorios: • Directorio estilo: En esta carpeta se encuentra el estilo del sitio web generado y las imágenes utilizadas por el estilo. • Directorio upload: En esta carpeta se encuentra el archivo control_upload.txt, que almacena la información de las imágenes que se almacenan en la base de datos. • Directorio WEB-INF: En este directorio se almacenan las páginas del sitio y los archivos de extensión .java que son utilizados. Así como, el archivo web.xml, en el que se establece el mapeo de los servlets de esta aplicación generada. • Directorio classes: Aquí se almacenan todos los archivos de extensión java que se utilizan en el sitio. Incluyendo los archivos del control y del modelo. • Directorio vistas: Aquí se encuentran los archivos de extensión jsp. Correspondiente a las páginas con las que interactúa el usuario de la aplicación. • Directorio jspf: Contiene los archivos de extensión jsp que son utilizados como include en los archivos del directorio vistas. • Directorio lib: Contiene los archivos .jar que utiliza la aplicación. Seguidamente se muestran cada uno de los aspectos o criterios que son tomados en cuenta para el análisis del funcionamiento de la aplicación DEUSWEB, ello permite obtener una base de comportamiento y respuestas a preguntas: ¿cómo debía ser un sistema generador de sitios Web basado en la ingeniería de reverso al modelo de datos?; y también de ¿cómo debía comportarse el sitio generado? USUARIO Navegador Web LADO CLIENTE LADO SERVIDOR Servlets JSPs Clases Java BD Capítulo 2: DEUSWEB 56 2.4. Criterios de análisis de funcionalidad 2.4.1. Funcionalidad: Característica de un software que mide la capacidad de ser atractivo, y comprensible para el usuario, así como su facilidad de uso y de ser aprendido en condiciones especificas. • Facilidad de Aprendizaje: Se refiere a la facilidad con la que nuevos usuarios pueden tener una interacción efectiva. • Flexibilidad: Hace referencia a la variedad de posibilidades con las que el usuario y el sistema pueden intercambiar información. • Robustez: Es el nivel de funciones disponibles que dan apoyo al usuario en el cumplimiento de sus objetivos. 2.4.2 Configuración Avanzada: Diferentes opciones que permiten personalizar, alterar y adaptar, las paginas y el sistema generado. 2.4.3 Legibilidad: Se refiere a la facilidad de entender el código generado. 2.4.4 Aspectos Técnicos: • Lenguajes de Programación que utiliza: Capacidad de la aplicación en generar código en distintos lenguajes de programación. • Validación de los campos: Si la aplicación cuenta con la capacidad de generar validaciones para los campos que se encuentren en las paginas generadas. • Paginación: Se refiere a la funcionalidad de publicar el contenido de una tabla de forma ordenada, usando enlaces para avanzar y/o retroceder en las páginas que muestran los registros. • Autenticación: Si puede generar una página de autenticación de usuario para acceder al sistema, o a determinadas paginas del sistema. • Diseño: Si provee la capacidad de permitir escoger y/o personalizar el diseño de las paginas generadas. • Manejo de archivos: Se refiere a la capacidad que tiene la aplicación para manejar archivos binarios contenidos en la base de datos. • Publicación: Se refiere a la capacidad que tiene la aplicación para subir los archivos generados en el servidor. Capítulo 2: DEUSWEB 57 • Manejo de relaciones: Se refiere a la capacidad que tiene la aplicación identificar y manejar las relaciones presentes en la base de datos, actualizar las mismas, y proveer soporte para operaciones en cascada. 2.5. Caso de Estudio para el análisis En la figura 23, se define un caso de estudio para el análisis de la herramienta, esta definido por operaciones de venta de teléfonos celulares en tiendas especializadas en este ramo y la relación entre estas y talleres de reparación de celulares que prestan sus servicios a dichas tiendas. Capítulo 2: DEUSWEB 58 Figura 23. Diagrama E-R. Caso de Estudio para la aplicación DEUSWEB. 2.6. Funcionalidades A continuación, se muestran y explican algunas pantallas de la aplicación generadora (DEUSWEB) y del sitio generado por la aplicación. 2.6.1. Pantallas para la generación del sitio web: Pantalla inicial de la aplicación DEUSWEB: En la figura 24, se muestra una pantalla de bienvenida de la aplicación. Capítulo 2: DEUSWEB 59 Figura 24. Pantalla de inicio de la aplicación DEUSWEB. Pantalla de selección y propiedades de la base de datos: En la siguiente pantalla de la figura 25, se muestran los campos necesarios introducir los datos de conexión para la base de datos que será fuente de generación del sitio Web. Luego de introducir los datos requeridos se presiona el botón Probar conexión para verificar que la conexión sea correcta. Figura 25. Pantalla de propiedades para la conexión a la base de datos de DEUSWEB. Capítulo 2: DEUSWEB 60 Pantalla de selección de tablas: En esta pantalla de la figura 26, se seleccionan las tablas de la base de datos a partir de las cuales se crearan las páginas web del sitio. Simplemente se toman las tablas ubicadas en la lista del lado izquierdo que se desean utilizar y se pasan a la lista del lado derecho. Figura 26. Pantalla de selección de tablas de la aplicación DEUSWEB, para generar las páginas del sitio. Pantallas para las opciones de configuración general del sitio: Se muestran en las figuras 27, 28, 29 y 30 una serie de opciones de configuración que permiten especificar las propiedades y características del sitio a generar. Estas opciones son las siguientes: • Autenticación: En esta opción se indica si se quiere usar autenticación, así como los privilegios de usuarios. • Paginación: Permite especificar el numero de registros, mediante cantidades definidas que serán visualizados por página, por ejemplo el conjunto 10, 15, 20, o personalizado que es el número de registro deseado por el usuario. • Apariencia: Permite seleccionar la apariencia o el tipo de estilo visual que tendrá el sitio generado. • Destino y Lenguaje: Se define el lenguaje de programación que será usado para generar el sitio Web; y se indica la ruta donde los archivos generados serán colocados para ser publicados. Capítulo 2: DEUSWEB 61 Figura 27. Pantalla de Configuración General para generar el sitio. Figura 28. Pantalla para configurar la opción de Paginación del sitio a generar. Capítulo 2: DEUSWEB 62 Figura 29. Pantalla para configurar la opción de Apariencia del sitio a generar. Figura 30. Pantalla para configurar la opción de Destino y Lenguaje del sitio a generar. Pantalla de generación del sitio: En la pantalla de la figura 31, se muestra el proceso de generación de os archivos para la creación del sitio. Capítulo 2: DEUSWEB 63 Figura 31. Pantalla de generación de archivos del sitio web. 2.6.2. Pantallas del sitio web generado: Vista inicial del sitio generado: En la vista de la figura 32, observamos una bienvenida al sitio, así como una breve explicación de su funcionamiento. Figura 32. Vista en el navegador web de la página de bienvenida generada por DEUSWEB. Vista para buscar o listar un Celular: En la página de la figura 33, inicialmente observamos un campo de texto que permite realizar búsquedas sobre Capítulo 2: DEUSWEB 64 cualquier campo de la tabla seguidamente observamos el titulo de la tabla, a su lado. Se visualiza la opción agregar registros a la tabla. El diseño por defecto de las páginas muestra un menú en la parte derecha de las mismas, el cual lista las diferentes páginas generadas a partir de las tablas contenidas en la base de datos. Figura 33. Vista en el navegador web de la página generada por DEUSWEB, con opciones de Búsqueda y Listar. Vista para editar un registro de la tabla celular: En la vista de la figura 34 podemos observar el titulo que nos indica que estamos en modo de editar o agregar un registro, seguidamente los campos de texto resultantes de cada columna de la tabla en la base de datos. Capítulo 2: DEUSWEB 65 Figura 34. Vista en el navegador web de la página generada por DEUSWEB, editar un registro de la tabla celular. 2.7. Limitaciones Las limitaciones sobre este sistema, se basan en las funcionalidades extras que posee la aplicación. La restricción que se fija sobre los archivos que se almacenan en la base de datos es que solo puede existir un campo por tabla que almacene el contenido de un archivo y otra limitación está ligada al uso de las claves foráneas, en la que el sistema sólo identifica la relación de una tabla con otra tabla, siempre que la clave foránea este compuesta por un sólo campo. Se tiene el uso de un único SMBD para establecer la conexión y un solo lenguaje de programación en el cual es generado el sitio, pudendo esto ser una restricción para el usuario. Por otro lado las opciones de configuración avanzada dentro de la aplicación generadora son pocas. 2.8. Resultados de análisis de la aplicación Funcionalidad: Es una herramienta que presenta facilidad en su uso, lo que permite que el sitio Web pueda ser generado de forma muy rápida y fácil. Funcionalidad de la aplicación Web producida: Muy fácil de usar e intuitiva. Configuración Avanzada: Las opciones de configuración avanzada son mínimas, o básicas. Capítulo 2: DEUSWEB 66 Legibilidad: Es bastante legible, el código JSP de la aplicación y el HTML que contiene todo el diseño visual son generados en un mismo archivo, no se genera la aplicación en capas. Aunque puede tomar un tiempo entender el estilo en el cual el código es presentado, es bastante legible y esta bien organizado. Aspectos Técnicos: Lenguajes de Programación que utiliza: Solo puede generar código en el lenguaje de programación JSP/Servlets. Validación de los campos: Se generan validaciones para los campos en las páginas generadas. Paginación: Permite la visualización paginada de los registros, mostrándolos en conjuntos de un numero definido en el momento de la configuración. Autenticación: Es posible generar una pagina de autenticación, crear perfiles de usuario y definir que operaciones y acceso le es posible. Diseño: Permite escoger solo entre 3 diseños o estilos de las páginas a generar. Manejo de archivos: Manipula los archivos cargados en las tablas de la base de datos sin necesidad de alterar la base de datos de entrada o de obligar al usuario a la definición de un campo que permita almacenar el nombre de los archivos. No maneja archivos binarios. Publicación: Permite definir la ruta donde serán ubicados los archivos en el servidor local. Además permite configurar una nomenclatura para los nombres de los archivos generados. Manejo de relaciones: Maneja las relaciones entre tablas sin ninguna configuración adicional. El sistema sólo identifica la relación de una tabla con otra tabla, siempre que la clave foránea este compuesta por un sólo campo. 2.9. Resumen del Capítulo En este capítulo, se describió el proceso de desarrollo e implementación de la aplicación generadora DEUSWEB, así como de la aplicación generada por la misma, es decir, el sitio Web administrativo. Fue necesario realizar una breve descripción de los archivos utilizados y generados por ambas aplicaciones, así como de las arquitecturas planteadas y diversos procesos para un entendimiento más exhaustivo de las tareas que se realizaron para el cumplimiento de los objetivos de la aplicación existente. Capítulo 2: DEUSWEB 67 Esta aplicación le permite al usuario gestionar de forma fácil y eficiente las tablas de una base de datos, pudiendo así realizar diferentes operaciones de configuración de cualquier información en la tabla de su preferencia. Capítulo 3: Scrum 69 Capítulo 3 Scrum En éste capítulo se detalla el modelo de proceso de software, definiendo sus características generales, específicas según el área de aplicación, el tipo de organización en la que puede ser utilizado, y diferentes tamaños de proyectos. Al mismo tiempo este proceso constituye un marco de trabajo que puede ser especializado en una variedad de sistemas. A continuación se describen los aspectos más relevantes de él: El enfoque fue descrito por Takeuchi y Nonada en “El Nuevo Juego de Desarrollo de Productos” (Harbara Budines Rebién, Enero-Febrero 1986). Ellos notaron que proyectos que usan pequeños equipos multi-funcionales, históricamente producen los mejores resultados y la similitud de estos equipos de alto desempeño a la formación “scrum” en Rugby. En Rugby, Scrum es un equipo de 8 individuos, todos en el grupo actúan como una fuerza, con todos los demás jugadores en tratar de avanzar la pelota en el campo. Esto da una imagen clara a quienes están familiarizados con el Rugby. Equipos trabajan como unidades integradas con cada miembro del equipo jugando un rol bien definido y todo el equipo enfocado en una meta. En equipos de desarrollo, cada miembro del equipo debe entender su rol y las tareas para cada incremento. Todo el equipo debe tener un foco en común. Las prioridades deben estar claras, el proceso de desarrollo Scrum facilita el enfoque del equipo. Scrum puede ser usado para dirigir equipos de mantenimiento o como un enfoque de administración de programas, aunque su propósito es el de manejar la administración de proyectos de desarrollo de software. 3.1 Terminología de Scrum • Backlog: Representa una lista de tareas por realizar. • Sprint: Un periodo de tiempo, normalmente de 2 a 4 semanas, en el cual el desarrollo de una serie de Backlogs se lleva a cabo por el equipo que se comprometió. Equivalente a una iteración. • Stakeholders: Personas con un interés directo en el producto. También conocidos como “los interesados”. • Maestro Scrum: La persona o grupo de personas a cargo de el seguimiento y actualización diaria del scrum. También conocido como Facilitador Scrum, equivalente al administrador del proyecto. Capítulo 3: Scrum 70 • Equipo Scrum: Un equipo multi-funcional, (desarrolladores, Administradores de Base de Datos, usuarios de versiones no finales) responsable por el desarrollo del producto. • Dueño del Producto: Persona responsable por mantener el Backlog del producto mediante la constante interacción con los clientes y Stakeholders. • Expertos Consultores: Personas que proveen su experticia al proyecto pero no son requeridos en cada Sprint. 3.2 ¿Qué es un Backlog? El Backlog es un inventario o una lista priorizada de requerimientos funcionales, mejoras, tecnología y corrección de errores que deben incorporarse al producto a través de las sucesivas iteraciones. Representa todo aquello que esperan los clientes, usuarios, y en general los interesados en el producto. Es el artefacto más importante de Scrum, ya que dirige la construcción. Un Backlog está separado en versiones potenciales y Sprints potenciales Se tiene tres tipos de Backlog: • Backlog del Producto: Quien representa todos los requisitos que el producto entregado debe cubrir. • Backlog de Release (Entregables): Es una lista ordenada por prioridad de los requisitos que aparecen en el Backlog del Producto. No hay prioridades duplicadas. • Backlog del Sprint: Al comienzo de cada Sprint el equipo del proyecto va extrayendo y descomponiendo los elementos del Backlog de Release empezando por los de mayor prioridad y los va introduciendo en una lista denominada Backlog del Sprint, hasta que tiene suficientes elementos como para realizar el Sprint. En este momento el Backlog del Sprint se bloquea de modo que durante el Sprint no se admiten modificaciones a los requisitos que se van a cubrir. 3.3 ¿Qué es un Sprint? El Sprint es una serie de cortas fases de desarrollo para una actividad específica en donde se produce un producto visible, usable y entregable. Y con ello, la idea de entregar una funcionalidad con valor. Capítulo 3: Scrum 71 A continuación, en la figura 35 se muestra como ejemplo un formato de Backlog en el proceso de desarrollo Scrum, con su correspondiente lista de Sprint: Figura 35. Ejemplo de un Backlog en Scrum [Microsoft, 2007]. 3.4 Características de Scrum • Se crea un Backlog de trabajo por realizar con prioridades. • Completar una serie de Backlog definidos en series de iteraciones cortas o Sprints. • Una breve reunión diaria conocida como scrum, en la cual el progreso es explicado, se describe el trabajo por realizar y se identifican y tratan los impedimentos. • Una sesión breve de iteración de planeamiento en la cual los puntos del Backlog para la iteración son definidos. • Una sesión de iteración de retrospectiva en la cual todos los miembros del equipo reflexionan acerca la ultima iteración. • Scrum es facilitado por el Maestro Scrum, cuyo trabajo principal es el de eliminar los impedimentos a la habilidad del equipo en alcanzar la meta del Sprint. El Maestro Scrum no es el líder del equipo, (los equipos son auto- organizativos) pero actúa como un mediador entre el equipo y cualquier influencia que lo distraiga. Scrum permite la creación de equipos auto-organizados, fomentando el co- posicionamiento de todos los miembros del equipo y la comunicación verbal entre todos los miembros del equipo y disciplinas que están involucradas en el proyecto. Capítulo 3: Scrum 72 Un principio clave de Scrum es que reconoce que los desafíos fundamentalmente empíricos no pueden ser tratados exitosamente desde una perspectiva predictiva tradicional o de una manera planeada. Scrum adopta una aproximación empírica, aceptando que el problema no puede ser completamente entendido o definido, enfocándose en su lugar en maximizar la habilidad del equipo en entregar rápidamente y responder a los requerimientos emergentes. Figura 36. Esqueleto de Scrum [Microsoft, 2007] 3.5 ¿Como trabaja Scrum? Es un proceso de desarrollo de software para equipos pequeños. Equipos pequeños que trabajan de forma independiente son más efectivos. Como en todos los proyectos debe haber una fase de planeamiento. Durante esta fase, el equipo debe desarrollar una arquitectura e identificar un arquitecto líder. Durante el desarrollo el equipo debe estar listo para realizar cambios a esta arquitectura, pero se requiere un plan, una arquitectura y un líder arquitecto para empezar. El líder arquitecto define la visión de desarrollo del proyecto basada en esta arquitectura y verifica la consistencia de esta visión durante todas las fases de desarrollo. Después del planeamiento inicial, una serie de cortas fase de desarrollo o Sprints, entregan el producto incrementalmente. Un Sprint típicamente dura de una a cuatro semanas. Una fase de cierre usualmente completa el desarrollo del producto. El equipo lleva control de todas las tareas identificadas, capturándolas en una lista llamada Backlog. El Backlog conduce las actividades del equipo, antes de cada Sprint, el equipo actualiza el Backlog y se reestablecen las prioridades de las tareas. Cada equipo toma un número de tareas y entonces se ejecuta el Sprint. Miembros individuales de un equipo acuerdan en completar tareas que ellos creen que son factibles durante cada Sprint. Durante un Sprint no se permiten cambios que provengan fuera del equipo. Capítulo 3: Scrum 73 3.6 ¿Que ocurre durante un Sprint? Un Sprint produce un producto visible, usable y entregable que implementa una o mas interacciones del usuario con el sistema. La idea clave detrás de cada Sprint es la de entregar una funcionalidad con valor. Cada incremento en el producto se construye de previos incrementos, la meta no es completar las tareas para la fecha de entrega del Sprint. Un Sprint es un desarrollo a tiempo fijo, es decir, la fecha final del Sprint no cambia. El equipo puede reducir las funcionalidades a ser entregadas durante el Sprint, pero la fecha de entrega no puede ser modificada. Durante el Sprint el equipo realiza frecuentes (normalmente diarias) reuniones Scrum. Cuando el equipo se agrupa para una corta reunión diaria cualquier desliz se hace inmediatamente obvio a todos. La reunión envuelve a todos los miembros del equipo incluyendo aquellos que se encuentren trabajando de manera remota. Estas reuniones sirven como a un propósito de construir el equipo, invitando a los contribuyentes remotos, haciéndolos sentir parte del equipo y haciendo visible su trabajo al resto del equipo. 3.7 ¿Cómo planear y estimar? Frecuentemente el equipo de mercadeo o el cliente es quien define la fecha de entrega. Con una fecha de entrega definida, los equipos de desarrollo y mercadeo deben trabajar juntos para proveer las funciones con el mayor valor para la primera entrega del producto. Mercadeo debe establecer prioridades a las funciones, mientras que los desarrolladores del producto proveen estimados para el trabajo. Mercadeo y desarrollo deben acordar en el conjunto de funciones, si el equipo de desarrollo no puede entregar las funciones solicitadas entonces se debe negociar un conjunto de funciones reducido. En la negociación de las funciones para la entrega, la administración debe identificar los desarrolladores disponibles para el desarrollo de una función. El número de desarrolladores por cada equipo debe seguir la recomendación de Scrum: no más de 10. Por supuesto se pueden tener varios equipos. Para completar las negociaciones con el departamento de mercadeo, el grupo de desarrollo del producto debe tener los desarrolladores comprometidos al proyecto y por el rango de tiempo identificado. Una vez que las negociaciones entre mercadeo y los grupos de desarrollo son completadas, el Backlog es manejado en Sprints con orden de prioridad. Los grupos de desarrollo establecen el ambiente de desarrollo y los riesgos asociados al mismo, el equipo debe entender el riesgo de usar nuevas tecnologías, herramientas y software. El equipo de mercadeo entiende las necesidades del cliente y su valor para el mismo. En general los puntos con mas riesgo son manejados en los primeros Sprint, esto para dar tiempo necesario a recuperarse si una dificultad técnica ocurre. El planeamiento se lleva a cabo relativamente rápido ya que las suposiciones iniciales seguramente cambiaran mientras los Sprint generen las funcionalidades incrementales. Capítulo 3: Scrum 74 Figura 37. Flujo en Scrum [Microsoft, 2007]. 3.8 ¿Quién lidera al equipo? El maestro Scrum lidera las reuniones Scrum, identifica el Backlog inicial a ser completado en un Sprint y empíricamente mide el progreso hacia la meta de entregar incrementalmente un conjunto de funciones. Se asegura que todos tengan progreso en sus tareas, registra las decisiones tomadas en las reuniones y lleva control de las tareas, mantiene las reuniones Scrum cortas y enfocadas. El Maestro Scrum trabaja constantemente en reducir el riesgo del producto a través de la entrega incremental de funciones, rápida respuesta a obstáculos en el desarrollo y continuamente chequea la entrega de los puntos en el Backlog. 3.9 ¿Qué ocurre durante una reunión Scrum? Cada miembro de un equipo debe responder estas tres preguntas: 1. ¿Que haz completado, en relación al Backlog, desde la ultima reunión Scrum? 2. ¿Que obstáculos se presentaron en el camino a completar tu trabajo? Capítulo 3: Scrum 75 3. ¿Que cosas en especifico planeas completar, en relación al Backlog, desde ahora y la próxima reunión Scrum? Una reunión Scrum debe durar de 15 a 30 minutos, esto debe proveer suficiente tiempo para tratar los obstáculos, pero no provee suficiente tiempo para una tormenta de ideas. Todas las discusiones que no encajen en el modelo de estas tres preguntas son diferidas a reuniones posteriores que involucran solo a aquellos que se ven afectados por la discusión. Las metas de una reunión Scrum incluyen: • Enfocar el esfuerzo de los desarrolladores en los puntos del Backlog. • Comunicar las prioridades de los puntos del Backlog a los miembros de los equipos. • Mantener a todo el mundo informado del progreso y de los obstáculos. • Resolver los obstáculos lo más pronto posible. • Llevar el progreso en la entrega de las funciones definidas en el Backlog. • Tratar y minimizar los riesgos del proyecto. 3.10 ¿Qué ocurre al final de un Sprint? Al final de un Sprint, el equipo produce un incremento que crece a partir de previos incrementos. Después de cada Sprint el equipo se reúne con todos los stakeholders, incluyendo los administradores de alto nivel, clientes y los representantes de los mismos. Toda la información del Sprint completado es reportada. En esta reunión todo puede ser cambiado, trabajo puede ser agregado, eliminado, o cambiar de prioridad. Las impresiones del cliente dan forma a las actividades y sus prioridades, los puntos que son más importantes para el cliente tienen la mayor prioridad. Se generan nuevos planes y estimados siguiendo el mismo proceso en “¿Cómo planear y estimar?” Las responsabilidades son entonces asignadas a cada equipo para el próximo Sprint. Ya que cada Sprint produce un producto visible y usable, la entrega del producto puede darse después de cada Sprint. De hecho, una entrega de este tipo ocurre y las impresiones del lado del mercado y negocio, y del lado del cliente es una reacción a la entrega incremental. Es habitual que la entrega final se de acabo en una etapa final que se ejecuta como un Sprint final. Como resultado de la interacción de pequeños equipos en pequeños y centrados ciclos de desarrollo tenemos que: • El producto se convierte en una serie de partes manejables, • Se alcanza progreso, incluso cuando los requerimientos no son estables, • Todo es visible a todos, • La comunicación de los equipos mejora, • El equipo comparte el éxito a lo largo del proceso y al final, Capítulo 3: Scrum 76 • Los clientes reciben entregas incrementales a tiempo, • Los clientes obtienen información frecuente de cómo funciona el producto, • Una relación entre el cliente se crea, se construye la confianza y el conocimiento crece, además de crear una cultura donde todos esperan que el proyecto tenga éxito. 3.11 Roles en Scrum En Scrum solo existen tres tipos de rol: El Dueño del Producto, El Maestro Scrum y el Equipo Scrum. Todas las responsabilidades están divididas entre estos tres grupos. El Dueño del Producto es responsable por mantener el Backlog del producto mediante la constante interacción con los clientes, colocar las funcionalidades más importantes como prioridad en el Backlog y representa el interés de todos los interesados en el proyecto (Stakeholders). Identifica los requerimientos iniciales así el retorno de la inversión esperado. Los Equipos Scrum son los responsables por el desarrollo de las funcionalidades. Estos equipos multi-funcionales se auto organizan y se auto administran y son responsables en convertir un Backlog de un producto en una funcionalidad de forma incremental y de administrar su propio trabajo en el transcurso de alcanzar las metas. El Maestro Scrum es responsable del proceso Scrum, de enseñar Scrum a todos los involucrados, debe establecer Scrum para que encaje con la cultura de la organización y aun así entregue los beneficios esperados. Debe asegurarse que todos sigan las reglas y las practicas de Scrum. Los roles definidos en Scrum, están divididos en dos grupos, los cerdos y las gallinas, esto basado en la broma que trata de un cerdo y una gallina. Un cerdo y una gallina están caminando por una vía. La gallina ve al cerdo y dice “Hey, ¿por que no abrimos un restaurante?” El cerdo mira a la gallina y dice “Buena idea, ¿como quieres llamarlo?” La gallina piensa al respecto y dice “¿Por qué no lo llamamos ‘Jamón y Huevos’?” El cerdo se detiene y responde “Pensándolo bien, no quiero abrir un restaurante contigo. Yo estaría comprometido pero tu solo estarías involucrado”. Como vemos los cerdos están comprometidos a construir el software regular y frecuentemente, mientras que todos los demás son gallinas que están interesadas en el proyecto pero realmente son irrelevantes porque si falla, no es su responsabilidad, ya que ellos no son los comprometidos a realizarlo. Las necesidades, deseos, ideas e influencias de las personas con rol de gallina son tomados en consideración, pero de ninguna manera dejan que afecte o distorsione la dirección del proyecto Scrum. Así tenemos: Rol de Cerdo: Son los que se comprometen al proyecto y al proceso Scrum. Son quienes “ponen su pellejo en juego”. Capítulo 3: Scrum 77 Rol de Gallina: No son parte del proceso Scrum como tal, pero debe ser tomado en consideración. Un aspecto importante en la modelación ágil es la práctica de involucrar los usuarios y los Stakeholders entre otros como parte del proceso. Es importante que estas personas provean opiniones, reacciones y estén engranados con las salidas para proveer revisión de cada Sprint. Muchas veces los Expertos Consultores pasan de ser gallinas a cerdos como parte del equipo Scrum durante algunas iteraciones. Esta distinción es importante en Scrum y es relevante la insistencia de Scrum en tener visibilidad completa sobre el proceso. Esta regla de Scrum que distingue entre los cerdos y las gallinas permite incrementar la productividad, y poner fin a los titubeos. 3.12 Scrum en Solitario Scrum esta basado en pequeños equipos, mejora la comunicación entre los miembros del equipo. Sin embargo, existe una gran cantidad de software que es desarrollado por programadores individuales. Un software que esta siendo desarrollado por un solo programador también puede tomar beneficio de algunos de los principios de Scrum tales como: Backlog del producto, un Sprint, iteración de retrospectiva. Scrum en Solitario es una versión adaptada de Scrum para uso de los programadores individuales. 3.13 Resumen del Capítulo En éste capítulo se dio a conocer el modelo de proceso de software Scrum, el cual incluye una serie de características así como distintas fases que facilitan el desarrollo de proyectos de tamaño variable y de una manera ágil, rápida y sencilla; permite la creación de equipos auto-organizados, fomentando el co-posicionamiento y la comunicación verbal entre todos los miembros del equipo y disciplinas que están involucradas en el proyecto, siendo esto la base que se aplica a los sistemas a desarrollados, y en especifico para el sistema que es descrito en este documento. Marco Aplicativo 79 PARTE II: MARCO APLICATIVO Capitulo 4: Aplicación Adaptación Scrum 81 CAPÍTULO 4 Aplicación Adaptación Scrum El proceso de adaptación permite aplicar las diversas etapas del proceso de desarrollo Scrum, para describir el flujo de trabajo utilizado en lo que seguidamente será la implementación de una herramienta adaptable a las necesidades del usuario. A continuación se describirán las etapas del proceso en conjunto con las etapas que se ejecutan en la aplicación que es desarrollada: 4.1. Etapa de Planeamiento Inicial En esta etapa se analizan y describen las funcionalidades y requerimientos del sistema a construir en un lenguaje no técnico para su entendimiento. Básicamente se identifican y estudian los requisitos del sistema puntualizándolos en una lista de actividades, que han de ser desarrolladas para la incorporación de ciertos módulos y mejoras en la aplicación existente. Mediante el proceso SCRUM, durante el planeamiento inicial, el equipo desarrolla una arquitectura del sistema e identifica un arquitecto líder dentro del mismo, quien es uno de los integrantes encargado de guiar el modelo arquitectónico definido. Durante el desarrollo, se realiza cambios a la arquitectura basados en las necesidades que se tienen para cada módulo específico. El Líder Arquitecto define el desarrollo del proyecto apoyado en la arquitectura, es decir, se plantea las distintas vías por las cuales es desarrollado cada módulo del diseño: la programación, la instalación de las diversas herramientas y tecnologías de desarrollo (plataformas, lenguajes, compiladores, Sistemas Manejadores de Base de Datos en sus distintas versiones) que facilitan el flujo de trabajo a ser construido verificando al mismo tiempo la consistencia de ese desarrollo durante todas las fases, realizando para ello pruebas y ejecuciones constantes con la ayuda de las herramientas utilizadas para la implementación . Como herramienta de trabajo para expresar estos requerimientos y plasmar la visión del diseño de la arquitectura ideada, se utiliza una suite de herramientas como por ejemplo Microsoft Office, la cual permite mediante sus aplicaciones generar los diferentes artefactos que contendrán los requerimientos y diseños mencionados anteriormente. Capitulo 4: Aplicación Adaptación Scrum 82 4.2. Etapa de Elaboración del Backlog Durante la etapa de elaboración del Backlog, Se realiza una sesión breve de iteración de planeamiento en la cual los puntos del Backlog para la iteración son definidos, esta sesión tiene una duración entre 1 y 2 semanas de planeamiento. El equipo lleva control de todas las tareas identificadas, son capturadas en una lista de actividades específicas que son desarrolladas para la construcción de la aplicación, permitiendo de ésta manera llevar un registro del tiempo de desarrollo antes, durante y después de cada actividad por parte del equipo. Al mismo tiempo se realiza la revisión y actualización constante de ésta lista lo que conduce al reestablecimiento de prioridades de las diferentes actividades antes de cada periodo de desarrollo (Sprint). Para la creación de los archivos Backlog se utiliza como herramienta cualquier aplicación de hoja de cálculo, permitiendo en esta la definición de cada una de las actividades en un cuadro de control de tareas La elaboración del Backlog en una hoja de cálculo, puede ser detallada a continuación: Figura 38: Estructura del Backlog general. El Backlog esta compuesto por una lista de tareas agrupadas en Sprints, cada tarea tiene asociada un estatus y una cantidad de tiempo. El estatus indica si la tarea ha sido iniciada, completada o si se encuentra bloqueada. Cada Sprint define la cantidad de Capitulo 4: Aplicación Adaptación Scrum 83 horas que tomara completar la tarea, así como totales que permiten conocer la cantidad de horas-esfuerzo de un Sprint. 4.3. Etapa de un Sprint Durante la etapa de un Sprint, se realiza una breve reunión diaria bajo los lineamientos del proceso Scrum, es decir, tomando en cuenta las opiniones de todas aquellas personas relacionadas al proceso que se aplica por cada actividad, entre ellas el Maestro Scrum y quienes llevan el seguimiento y actualización diaria del proceso, reflejando todo ello detalladamente en el Backlog. En el mismo, el progreso de las actividades es expresado, se describe el trabajo realizado y por realizar, además se identifican y tratan los impedimentos para esa actividad que se desarrolla en el período especificado. La duración de un Sprint puede variar entre 1 a 4 semanas, dependiendo de la meta a alcanzar y la naturaleza del proyecto. El Backlog de un Sprint no puede ser alterado durante la duración del mismo. Las actividades más específicas del Sprint o etapas de desarrollo son mantenidas y controladas de igual forma en una hoja de cálculo. A continuación se visualiza el seguimiento de una etapa de desarrollo (Sprint) para una actividad específica: Figura 39: Estructura del Backlog de un Sprint. Luego de la finalización de un Sprint se realiza una reunión de revisión de Sprint. El propósito de esta revisión es presentar al dueño del producto y a los stakeholders las funcionalidades que están finalizadas. La reunión comienza con uno de Capitulo 4: Aplicación Adaptación Scrum 84 los miembros del equipo describiendo la meta del Sprint, el Backlog al cual se comprometieron y el Backlog completado. Al finalizar la presentación, los stakeholders son cuestionados uno a uno para obtener sus impresiones y cualquier cambio que desean, así como identificar funcionalidades que no han sido entregadas o que no fueron entregadas como se esperaba y solicitar que dichas funcionalidades sean colocadas con alta prioridad. Funcionalidades incompletas no son presentadas en la reunión. Luego diferentes miembros del equipo discuten que tareas se realizan con éxito y que se desarrollo con problemas durante el Sprint. Adicionalmente se puede llevar a cabo una reunión de Retrospectiva del Sprint, en la cual se le pregunta a todos los miembros del equipo las preguntas: ¿Qué sucedió correctamente durante el último Sprint? y ¿Qué puede ser mejorado en el próximo Sprint? La meta de esta reunión no es proveer respuesta a los posibles problemas, sino identificar tareas no-funcionales que pueden ser agregadas a los futuros Sprint las cuales puedan facilitar al equipo a encontrar vías para que el proceso Scrum funcione de la mejor manera posible. 4.4. Etapa de Cierre En la etapa de cierre, se prueba el producto construido como último paso del proceso de desarrollo. Esta etapa involucra a los desarrolladores, responsables del producto final, Stakeholders y a los usuarios, con la intención de obtener su impresión del funcionamiento del producto y sus funcionalidades. Es posible crear un Backlog para describir y controlar las tareas asociadas al cierre del desarrollo del producto y que permita consolidar tareas pendientes. 4.5. Resumen del Capítulo En éste capítulo se adaptaron las etapas del proceso de desarrollo Scrum como procedimiento a emplear en la aplicación que se desarrolla, ello sirve de base para generar los artefactos correspondientes en cada fase de trabajo. Se describe de manera detallada las posibles herramientas que son utilizadas y quienes son los encargados de emplear dichas herramientas para un sistema que se construye bajo algunos lineamientos dentro del proceso. En los próximos capítulos se explica en detalle cada uno de los productos generados por los flujos en las etapas del proceso de desarrollo de la aplicación. Capitulo 5: Implementación 85 Capítulo 5 Implementación Éste capítulo permite ahondar en la implementación de algunos módulos del sistema en términos de componentes y funciones de una manera más detallada: archivos de código fuente utilizados, scripts, ejecutables, estructuras, etc. y al mismo tiempo combinando las etapas del proceso de desarrollo SCRUM con la secuencia de construcción del sistema. Seguidamente, se describen los mecanismos de implementación y construcción de la aplicación en base a la adaptación de las etapas del proceso de desarrollo: 5.1. Etapa de Planeamiento Inicial Se toma como base el análisis, resultados de los criterios de funcionalidad probados mediante la ejecución en tiempo real de la aplicación y descripción de los procesos y componentes que conforman el sistema generador de sitios Web administrativos en su primera versión, dicho análisis sirvió para estudiar las funcionalidades básicas que debe cumplir este sistema, así mismo, su fácil manejo, su poca profundidad en la navegación y la necesidad de incluir nuevas características haciendo que la misma sea robusta y manejable para el usuario. Por lo tanto, se extraen las funcionalidades y diferentes requerimientos que necesitan ser mejorados y al mismo tiempo construidos para la aplicación; para ello son definidos a continuación en una lista de actividades permitiendo ésta, puntualizar los cada requisito obtenido del sistema y las diferentes mejoras, realizados éstos durante el desarrollo del sistema: � Configuración de ambientes de desarrollo adaptable al sistema. � Incorporación de otros Sistemas Manejadores de Base de Datos, facilitando la manipulación de la información. � Incorporación de un nuevo lenguaje de programación que se encargue de la generación de un tipo de código específico para el sitio Web generado por el mismo sistema. � Reestructuración de la interfaz de usuario de la aplicación generadora. � Implementación de nuevos estilos a la interfaz de la aplicación generada En base a ello, se aplica un proceso de análisis y diseño arquitectural, tomando en cuenta las ideas iniciales y especificadas anteriormente, así como los requerimientos analizados para idear el modelo de la aplicación a construir; estos son capturados por ambos integrantes del Equipo de desarrollo quienes juegan el papel de denominado Arquitecto Líder, encargándose de diseñar la arquitectura expuesta en la Figura 40, la cual permite ver de una manera exhaustiva las ideas expuestas y la integración de cada uno de los módulos de la aplicación generadora: Capitulo 5: Implementación 86 Figura 40: Arquitectura General del Sistema Generador construido. En el diagrama anterior, el usuario a través de la interfaz de usuario completa los datos requeridos por la aplicación. Estos datos son enviados a una clase controladora, la cual se encarga de hacer las validaciones correspondientes en caso de ser necesario. Posteriormente el controlador invoca a las clases que poseen ciertas operaciones que el mismo controlador no se encarga de manejar, algunas de las cuales realizan la conexión a la base de datos de preferencia, (en este caso se tienen tres manejadores distintos: MySQL, Postgres y Oracle) otras manipularán archivos y otras se encargarán de la generación del sitio web que puede estar basado en distintos lenguajes de programación como: JSP/Servlets ó PHP. Luego de obtener los resultados, el controlador retorna la respuesta al usuario a través de la interfaz de usuario. Para el esquema de esta arquitectura, se redefine el diseño de la versión base de la aplicación, en la cual se plantea como lenguaje de programación a utilizar: JAVA, empleando el paquete java.swing para la generación de las interfaces gráficas. Siendo este sistema una aplicación “standalone” implementado como un asistente o Wizard para la generación del sitio web administrativo. Se añade a ella la idea de utilizar un nuevo lenguaje de programación (motor) en el que es generado el sitio, en este caso se habla de PHP, del mismo modo, se decide integrar dos nuevos Sistemas Manejadores de Base de Datos a los que se puede establecer la conexión de la misma forma en que se Interfaces USUARIO BD MySQL Controlador Validacion HTML HTML .java HTML HTML JSP basededatos archivos procesadores Motores HTML HTML Servlets HTML HTML .PHP BD Postgres BD Oracle Capitulo 5: Implementación 87 realiza con el manejador existente, MySQL, y así poder realizar las respectivas operaciones de administración de la aplicación generada. Para ésta última, también se aplica el mismo proceso de análisis y rediseño arquitectural, permitiendo reflejar por separado los sistemas que son generados en base a cada motor utilizado para crear el sitio Web. En la figura 41 se observa la arquitectura del sistema generado con el motor JSP: Figura 41: Arquitectura General del Sistema Generado con el motor JSP. El usuario, a través del navegador, le envía una petición al servidor. El encargado de recibir la petición en el lado servidor es el Controlador (Servlets). El Controlador, a través del modelo (Clases Java) se conecta con los diferentes Sistemas Manejadores de Base de Datos para resolver la consulta; esto a través del protocolo JDBC. Una vez que se han obtenido los resultados, el modelo retorna la respuesta al controlador. El controlador genera la respuesta al cliente a través de las páginas JSP, que el cliente recibe como páginas HTML. En la figura 42 se observa la arquitectura del sistema generado con el motor PHP: Figura 42: Arquitectura General del Sistema Generado con el motor PHP. USUARIO Navegador Web LADO CLIENTE LADO SERVIDOR Servlets JSPs Clases Java BD Oracle BD Postgres BD MySQL USUARIO Navegador Web LADO CLIENTE LADO SERVIDOR BD Oracle BD Postgres BD MySQL archivos.php Capitulo 5: Implementación 88 El usuario, a través del navegador, le envía una petición al servidor. Los encargados de recibir la petición en el lado servidor son los archivos php. Estos se conectan con los diferentes Sistemas Manejadores de Base de Datos a través de las librerías de conexión de base de datos de PHP para resolver la consulta. Una vez que se han obtenido los resultados, ellos son procesados por los archivos php, alimentando el código de respuesta al cliente, el cual será en formato HTML. Para dar inicio a la implementación y/o construcción de la aplicación en base a las arquitecturas anteriormente expuestas, ha de ser necesaria la configuración de un ambiente de desarrollo, esto implica la instalación y el manejo de diferentes herramientas tecnológicas para la obtención de una mayor eficiencia y calidad de lo que se está produciendo; dichas herramientas se agrupan entre: Lenguajes de Programación, Sistemas Manejadores de Base de Datos, un Servidor Web, Intérpretes de Código, Plataforma de Desarrollo y Clientes de Administración para Base de Datos. Posteriormente se detallaran un poco más las herramientas que son utilizadas. 5.2. Etapa de Elaboración del Backlog Para la elaboración del backlog, es necesario tener muy en cuenta el funcionamiento del sistema a construir y de allí se obtienen cada uno de los requisitos que necesitan ser desarrollados: En el siguiente diagrama de la Figura 43, el usuario a través de la interfaz de usuario completa los datos requeridos por la aplicación para la ubicación de la base de datos, en el caso particular para este trabajo, se escoge un solo manejador de base de datos para establecer la conexión, disponibles entre ellos: SMBD MySQL, SMBD PostgreSQL y SMBD Oracle; a partir de allí, se identificaran todas las tablas y campos de las mismas, a través de la extracción de los metadatos de la base de datos seleccionada. Del mismo modo, se realizan las configuraciones de la aplicación correspondientes a las distintas características que darán lugar al sitio generado (lenguaje o motor en el que se genera, autenticación, paginación, estilos). Todos estos datos son enviados a una clase controladora, la cual se encarga de hacer las validaciones correspondientes en caso de que sea necesario. Seguidamente el controlador produce un documento XML con toda la información de la metadata extraída de las tablas seleccionadas, las opciones de configuración para la aplicación, el SMBD a usar y los datos de conexión al Sistema Manejador de Base de Base de Datos seleccionado, y por consiguiente a su respectiva base de datos, así mismo el nombre del motor a utilizar. Este archivo XML sirve como entrada a cada uno de los procesadores que se van a ejecutar para generar la aplicación; los procesadores para el motor seleccionado son enumerados en un archivo de configuración y son ejecutados secuencialmente, donde cada uno de ellos realiza una tarea específica y necesaria para generar el sitio Web administrativo en el lenguaje de programación definido por el motor. Capitulo 5: Implementación 89 Figura 43: Arquitectura General del Sistema Web Administrativo. Una vez entendido todo el proceso que se lleva a cabo en el sistema expuesto, y observando las distintas necesidades de funcionamiento, modelación y construcción para lograr una aplicación mas robusta y de fácil manejo para los usuarios finales, se procede entonces a la elaboración de la lista formal y priorizada de requerimientos y actividades; para esto se utiliza el ya mencionado Backlog General o Backlog del Producto que es representado en la figura 44: procesadores HTML HTML JSP HTML HTML .java HTML HTML Servlets HTML HTML .PHP Archivos de configuración HTML HTML XML XML Extracción de los metadatos de la BD Configuración de la aplicación USUARIO Ubicación de la Base de Datos BD BD BD_Oracle BD_Postgres Interfaces BD BD_MySQL Capitulo 5: Implementación 90 Figura 44: Backlog General Producto Generato. Como entradas a esta estructura específica se tienen: • El nombre del producto o aplicación que se desarrolla: Generato. • El despliegue de actividades agrupadas por Sprint: Debido a que se tiene como base la aplicación DEUSWEB, se listan como tareas iniciales el estudio de la misma para definir que tan expandible es respecto a agregar nuevos Sistemas Manejadores y nuevos motores, permitiendo esto identificar que se tiene solo un Sistema Manejador de Base de Datos al cual podrá conectarse el usuario, así como un único lenguaje de programación (motor) en el cual será generado el sitio Web administrativo, y algunos detalles de interfaz de usuario, por esto, surge Capitulo 5: Implementación 91 la necesidad de integrar dos nuevos Sistemas Manejadores de Base de Datos, específicamente PostgreSQL y Oracle, así como un nuevo lenguaje de programación el cual es del lenguaje PHP, la incorporación de dos nuevos estilos a la aplicación generada, y la reestructuración de algunos módulos de la interfaz de usuario(Wizard); donde cada una de estas integraciones conforman una serie de funcionalidades a las cuales se le asocian un Sprint. Por lo tanto, se listan dentro del Backlog 6 actividades agrupadas cada una por un Sprint. Al mismo tiempo, son realizadas 4 entregas que permiten evaluar el conjunto de funcionalidades al culminar el Sprint correspondiente a estas, eso se debe a que las funcionalidades de la aplicación se caracterizan por ser independientes una de otra y dado que se tienen los elementos necesarios para que al agregar una nueva funcionalidad esta pueda ser utilizada, probada y finalmente pueda generarse una nueva versión de la aplicación. • Columnas con estimaciones de tiempos de desarrollos: allí se detallan 6 iteraciones de 4 semanas cada una, lo que hace un total de 24 semanas, equivalentes a 6 meses de trabajo, los cuales son distribuidos entre las distintas actividades, que son realizadas por días de dedicación dependiendo de cada Sprint y su prioridad. 5.3. Etapa de Sprint En esta etapa, se crea la lista de las tareas específicas correspondientes a cada actividad general expresada en el Backlog del Producto Generato. Para realizar y mantener esto, se establecen algunas reuniones entre los integrantes del proyecto tomando en cuenta algunos lineamientos del Maestro Scrum, en este caso, el Tutor de éste Trabajo Especial de Grado, así como la opinión particular de los demás interesados (cada integrante del equipo desarrollador), se exponen las tareas con mas prioridad para dichas actividades y al mismo tiempo se evalúa la evolución en cuanto a su desarrollo. Cada Sprint posee una subestructura de Backlog en donde son reflejadas las tareas más pequeñas pero con orden de importancia, que se deben desarrollar para llevar a cabo una actividad principal incluida dentro del Backlog general de la aplicación Generato. Seguidamente se explica la estructura de cada Sprint que se desarrolla para la construcción del sistema: 5.3.1 Sprint 1: Análisis de la versión base, DEUSWEB. Para ésta primera iteración es necesaria la ejecución de las siguientes tareas que se listan a continuación y que se encuentran expresadas en la estructura formal del Capitulo 5: Implementación 92 Backlog del Sprint 1: Análisis de la aplicación base, DEUSWEB (Ver en la sección de Anexos), numeradas mediante un ID de Tareas: ID Tarea 1: Estudio de la aplicación DEUSWEB. Para la construcción de Generato, se tiene la necesidad de realizar primeramente el estudio de la documentación del trabajo especial de grado denominado: DEUSWEB, generador de sitios Web administrativos basado en la ingeniería de reverso al modelo de datos. Se realiza de manera total, la revisión, lectura y análisis de ideas principales de cada capítulo, compuesto por un marco teórico que abarca la investigación previa para el cumplimiento de los objetivos y alcances propuestos que comprende ese trabajo, principalmente el desarrollo de un sistema basado en Web, que genere sitios administrables con ciertas características que lo hacen de fácil uso para el usuario; y por otro lado, tiene un marco aplicativo el cual explica a manera de detalle el proceso de desarrollo que se utiliza para generar los módulos del sistema planteado. Para indagar aun más en el funcionamiento, se procede a realizar la revisión y ejecución de la aplicación física: se observa la estructura de carpetas contenedoras de archivos, clases lo que permite deducir que cada una juega una función fundamental para las tareas que realiza DEUWEB, recibiendo como entrada una base de datos existente, identificando y extrayendo la metadata, para luego mediante una serie de archivos procesadores que conforman el motor, generar los archivos fuentes del sistema administrativo; en todo este proceso se encuentran archivos XML, clases controladoras y validadoras, entre otros componentes que conforman un sistema mantenible e incremental. ID Tarea 2: Estudio del lenguaje de programación PHP. A pesar de poseer ciertos conocimientos y capacidad en el manejo del lenguaje de programación PHP, ambos desarrolladores que conforman el Equipo Scrum, se plantean la investigación de manera formal y extendida sobre ello, ya que la aplicación base sólo posee un motor desarrollado bajo el lenguaje JSP/ Servlets en el cual es generado el sitio Web administrativo, llevando ésta característica a despertar la idea de explorar sobre el comportamiento de otro lenguaje de programación. Específicamente la utilización del lenguaje PHP, ya que este es un lenguaje diseñado para la Web, además de ser muy comercial, lo que nos permite superar limitaciones que muchas veces imponen algunos enfoques de desarrollo. Se realiza la búsqueda de documentación sobre PHP: tutoriales, páginas Web oficiales y enlaces de interés [PHP, 2007] [PHP-MySQL-Tutorial, 2007] con diversos contenidos explicativos, cuyas referencias aparecen expuestas en la bibliografía de este trabajo. De igual forma, se realizan prácticas con pequeños ejemplos planteados en las mismas referencias bibliográficas consultadas, lo que permite tener un mejor dominio del lenguaje de comandos. Capitulo 5: Implementación 93 ID Tarea 3: Estudio y manejo del SMBD PostgreSQL y Oracle. Se decide iniciar el estudio de algunos Sistemas Manejadores de Base de Datos debido a que en la aplicación base, DEUSWEB, solo se tiene un Manejador al cual el sistema se conecta para la extracción de los datos. Tanto PostgreSQL como Oracle se han establecido como plataformas de administración de datos escalables y de alto rendimiento; ambos son capaces de manejar complejas rutinas, son altamente extensibles soportando datos alfanuméricos, así como datos definidos por el usuario en los diferentes campos de una tabla en específico, lo que hace ver de manera atractiva y conveniente la escogencia de estos manejadores , pues son unas de las ideales características de los manejadores de base de datos que pueden emplearse para una aplicación de fácil manejo, desarrollada para un usuario web. La investigación se da a través de la revisión de diversos documentos encontrados en la red de redes (Internet) [Postgresql, 2007] [JDBC, 2007], ejemplos de estructuras de datos, tablas creadas y completos casos de estudios basados en el lenguaje SQL que es la base para la creación de las consultas en estas plataformas de administración de datos, allí se estructuran en detalle las definiciones, características, diferentes escenarios de sistemas creados usando estos Sistemas Manejadores , así como su compatibilidad con algunas herramientas que deben ser usadas para trabajar en conjunto con ellos dentro de las aplicaciones que se desarrollan en el medio Web . ID Tarea 4: Configuración de ambientes de desarrollo. Para poder dar inicio a la implementación y/o construcción de la aplicación y tareas correspondientes, es necesaria la configuración de un ambiente de desarrollo, esto implica la investigación, instalación y el manejo de diferentes herramientas tecnológicas en últimas versiones, para la obtención de una mayor eficiencia y calidad de lo que se está produciendo: • Lenguaje de programación Java 5, para la generación del sitio basado en clases JSP/servlets. • Lenguaje de programación PHP 5, para la generación del sitio basado en clases PHP. • Sistema Manejador de Base de Datos Oracle 10g, para la conexión a la BD • Sistema Manejador de Base de Datos Postgres 8.2, para la conexión y extracción de los datos en la Base de Datos. • Sistema Manejador de Base de Datos MySQL 5.0, para la conexión a la base de datos. • Servidor Apache 2.0, para atender y servir las peticiones recibidas • Intérprete PHP 5.1, para la interpretación del código PHP. • Se utilizó el paquete de programas WAMP Server 1.6, que incluye servidor de archivos Apache 2.2.6, el Sistema Manejador de Base de Datos MySQL, PHP 5.1. Todos estos pre-configurados para el ambiente de desarrollo. Capitulo 5: Implementación 94 • Biblioteca Gráfica Swing, para el rediseño de la interfaz gráfica de la aplicación generadora. • NetBeans como plataforma de desarrollo de aplicaciones de escritorio usando Java y un entorno de desarrollo integrado (IDE). • Navicat 8.0, cliente de administración para base de datos Postgres • SQLyog 5.2 como cliente de administración para base de datos MySQL. • Ultra Edit 11, editor de texto para el manejo de texto y archivos XML. • Como herramientas de trabajo para listar las actividades a ejecutar y elaborar el diseño de la arquitectura, así como algunos diagramas que ejemplifican los diferentes artefactos que se generan, se utilizan la suite de Microsoft Office, el editor de diagramas starUML. 5.3.2 Sprint 2: Desarrollo para soporte SMBD PostgreSQL. Tomando como base la aplicación DEUSWEB, se observa que la aplicación está hecha para la reutilización de diferentes clases y archivos que no varían totalmente en su estructuración sino que son adaptables a los nuevos componentes que forman parte de la aplicación para dar forma al sistema Generato. Muchos de esos archivos están relacionados a la tarea de integración de nuevos Manejadores de Base de Datos al sistema generador, donde uno de ellos es el SMBD PostgreSQL; entonces, para dar pie a la iteración de incorporar tan importante componente, se realizan las diferentes tareas correspondientes como entradas definidas formalmente en la estructura del Backlog del Sprint 2: Desarrollo para soporte SMBD PostgreSQL (Ver sección de Anexos), listadas a continuación, numeradas mediante un ID de Tareas: ID Tarea 5: Estudio de la estructura de la aplicación para las operaciones asociadas al manejador. Se revisa detenidamente la forma en que está estructurado el módulo de la aplicación encargado de realizar cada operación asociada al Manejador de Base de Datos utilizado por la aplicación base, el cual es MySQL. Se verifica que existen diversos métodos como el de conexión a la base de datos donde se validan algunos parámetros el driver del manejado, el nombre de la BD, entre otros, para poder realizar la conexión al mismo. También se detalla el comportamiento de los métodos para la selección y carga de las tablas respectivas a la base de datos perteneciente al sistema manejador elegido en el proceso de la conexión. Particularmente la clase ConexiónBD.java está definida de modo que simplemente se adapta el nuevo manejador a ésta, a manera explícita, se reutiliza el método conectarMySQL definido en ésa clase para formar y agregar los métodos similares correspondientes a los nuevos Sistemas Manejadores. Para el sistema manejador PostgreSQL, se agrega el nuevo método llamado conectarPostgres: Capitulo 5: Implementación 95 Figura 45: Métodos de conexión para los SMBD MySQL y PostgreSQL en la clase ConexiónBD.java Métodos como el que se muestran en la figura 45, son los llamados de uso común para los diferentes manejadores de base de datos. ID Tarea 6: Agregar nuevo manejador en la configuración de la aplicación: La estructura de la aplicación generadora no cambia de manera drástica, por ejemplo, para agregar un nuevo manejador simplemente se adaptan alguno directorios con la incorporación de los drivers y librerías en la carpeta específica para ello, denominada drivers, necesaria para la conexión particular de cada manejador, en el caso de PostgreSQL, la inclusión de su driver correspondiente dentro de la estructura de directorio se muestra en la figura 46: Figura 46: Estructura del directorio Driver para el SMBD PostgreSQL de la aplicación Generato. Capitulo 5: Implementación 96 Seguidamente se refactoriza, es decir, se adapta, más no se agrega un nuevo elemento modificando el archivo de configuración, un XML estructurado, para guardar el nombre y la ruta del driver que se atribuyen por cada Manejador de Base de datos, para el caso de PostgreSQL se agrega el nuevo driver a la misma estructura donde se encuentra agregada la información para el driver de MySQL como se observa en la figura 47: Figura 47: Archivo driver.xml con la inclusión del driver para el SMBD PostgreSQL Al mismo tiempo se realiza un proceso similar para el archivo de configuración sistemas-manejadores.xml, el cual ya posee el nombre, driver, y la dirección url a la cual se conecta el Manejador MySQL cuando es seleccionado por el usuario a través de la interacción con el sistema. En la Figura 48 se observa la integración del nuevo SMBD PostgreSQL a la estructura: Figura 48: Archivo sistemas-manejadores.xml con la inclusión de PostgreSQL como Sistema Manejador de Base de Datos. Capitulo 5: Implementación 97 ID Tarea 7: Configuración de parámetros de conexión Como ya se ha mencionado en actividades iniciales, se añade un nuevo método de conexión para el Sistema Manejador de Base de Datos PostgreSQL en la clase ConexionBD.java; lo que permitirá capturar los respectivos parámetros de conexión para el establecimiento de la misma en conjunto con la base de datos creada. Por lo tanto se realiza el tratamiento de validar los parámetros para dicha conexión al manejador, para ello se reutiliza el método establecerConexion de la clase Controlador.java, el cual recibe diversos parámetros entre ellos el usuario y la clave para certificarlos. Si el SMBD seleccionado es PostgreSQL y están correctos el driver, el url, el usuario y la clave, entonces se procede a establecer la referida conexión. ID Tarea 8: Extracción de los metadatos a través del API JDBC. Se identifican las tablas de la base de datos seleccionada, para esto es utilizado un método llamado cargarTablas en la clase Controlador.java que simplemente es refactorizado, para la adaptación a los nuevos manejadores de base de datos; específicamente se aplica una instrucción SQL (query) particular para el SMBD PostgresSQL, de la misma forma en que fue utilizada una instrucción para el manejador que ya poseía el sistema. Para la extracción de la información de los campos y tipos de datos de cada una de las tablas seleccionadas, el sistema, extrae los metadatos de la base datos consiguiendo de esta forma toda la información necesaria de cada una de las tablas elegidas de la base de datos. Esta información es la siguiente: Nombre de las tablas y columnas de cada tabla, identificación del tipo de dato de cada columna, identificación de AUTO_INCREMENT y NOT_NULL, longitud de la columna, identificación de claves primarias y foráneas por cada tabla. ID Tarea 9: Chequeo de los tipos de datos soportados por el SMBD PostgreSQL. Como el API de JDBC es una colección de interfaces a través de las cuales la aplicación puede comunicarse con los Sistemas Manejadores de Base de Datos para ejecutar distintas consultas, entonces se hace necesaria la verificación y comparación de los tipos de datos que utiliza la colección con respecto a los que nativamente manipulan los Sistemas Manejadores como el caso de PostgreSQL. Realmente, lo anterior resulta ser el punto de desacuerdo dentro del desarrollo de de éste módulo del sistema y la implantación de las diferentes estructuras de datos creadas para el establecimiento de la conexión a las bases de datos, debido a que cada manejador soporta infinidades de datos distintos entre ellos, en el caso de PostgreSQL, posee una amplia gama de tipos de datos, los cuales no corresponden todos con la lista de tipos de datos proporcionados por JDBC y soportados por la aplicación Generato. Para ello, varia el método obtenerTiposDatos de la clase Controlador.java, en el que se tienen arreglos de tipos de datos de los Sistemas Manejadores de Base de Datos y éste Capitulo 5: Implementación 98 es modificado incorporando los tipos de datos más utilizados por dichos SMBD: MySQL, PostgreSQL. Al mismo tiempo, existe otra clase denominada Dao.java en la cual se hace la comparación e incorporación de los tipos de datos que soporta JDBC respecto a los tipos de datos de los SMBD, para el caso particular de esta tarea, se establece la comparación con los tipos de datos para PostgreSQL . ID Tarea 10: Agregar o modificar métodos de acuerdo a funciones específicas del manejador. Se modifican métodos para soporte a la especificación de paginación del SMBD PostgreSQL utilizando cláusulas e instrucciones SQL específicas del Manejador, así mismo se modifican métodos para soporte a la inserción y al listado al listado de registros en las tablas. 5.3.3 Sprint 3: Desarrollo para soporte SMBD Oracle. En la tercer Sprint se realiza un proceso similar al Sprint definido en el punto anterior: Desarrollo para soporte del SMBD PostgresSQL; debido a que también es integrado otro Sistema Manejador de Base de Datos a la aplicación, en este caso se hace referencia al SMBD Oracle. La lista de tareas expresadas de una manera formal se especifica desde el ID 11 al ID 16 como entradas a la estructura denominada Backlog del Sprint 3: Desarrollo para soporte SMBD Oracle (Ver en la sección de Anexos). Como se muestra en la figura 49, se incluye el driver correspondiente al SMBD Oracle en el directorio drivers específico para ello: Figura 49: Estructura del directorio Driver para el SMBD Oracle de la aplicación Generato. De igual forma, es añadida la estructura para el SMBD Oracle dentro del archivo de configuración driver.xml como se muestra en la figura 50: Capitulo 5: Implementación 99 Figura 50: Archivo driver.xml con la inclusión del driver para el SMBD Oracle. . También es incorporada la información pertinente a Oracle dentro de la estructura XML de Sistemas Manejadores, completando así la carga de tres repositorios de datos para la aplicación, como se observa en la figura 51: Figura 51: Estructura del directorio Driver para el manejador Oracle de la aplicación Generato. Capitulo 5: Implementación 100 Se puede decir que cierta diferencia radica en que no existe un Standard de definición de estructuras de datos, tablas, tipos de datos que se manejan, capacidad y un sin fin de características para todos y cada uno de los Manejadores existentes en el mercado. La particularidad en el caso de Oracle, está en que es agregado un driver específico para éste manejador, así mismo, la diferencia en los tipos de datos que soporta y sus correspondientes formatos, como es el caso particular del tipo date para la fecha , cuyo formato posee como separador el caracter “/” únicamente y así como estas muchas otras reglas y definiciones que deben ser respetadas para el uso de un Manejador particular como lo es Oracle; por lo que los tipos de datos de éste importante repositorio también son incorporados dentro de las clases y métodos específicos para la comparación con los tipos de datos que posee JDBC; esto es tratado en el método donde se establece la comparación entre los tipos de datos: settingPstmt de la clase Dao.java. 5.3.4 Sprint 4: Desarrollo Motor PHP. Para el tratamiento de ésta iteración, se realiza un conjunto de actividades que son definidas de igual forma en una estructura formal denominada Backlog del Sprint 4: Desarrollo Motor PHP (Ver sección de Anexos), cuyas tareas son numeradas mediante ID de tarea como se listan a continuación: ID Tarea 17: Estudio de la estructura de la aplicación para las operaciones asociadas al motor existente JSP /Servlets. Se realiza la revisión y el análisis de la estructura de los archivos base que permiten generar el sitio Web administrativo el motor existen (Motor JSP). La estructura del motor viene dada por su definición y de las tareas que debe realizar en el archivo llamado motores.xml y de la estructura de carpetas y los archivos plantillas contenidos en ella en la definición del motor. El archivo motores.xml, indica que clases java (procesadores) deben ejecutarse por cada uno de los motores que se implementan. Cada motor se compone de un nombre y de elementos. Un elemento es una tarea a ejecutar para generar la aplicación Web, generalmente esta tarea consiste en generar elementos de código necesarios para la aplicación, pero también puede consistir en generar la estructura de directorio, en ejecutar la compilación de los archivos fuente, incluir estilos u otra tarea específica. Cada elemento se compone de un nombre, descripción y de un conjunto de procesadores. Estos procesadores no son más que la especificación de una clase Java que ejecuta una tarea. El conjunto de procesadores se encarga de cumplir con la generación del elemento al cual pertenecen. Para la compilación de las clases generadas para el sitio Web administrativo, se hace la compresión de esas mismas clases en formato jar, así como la compresión del sitio Web completo en formato war, se utilizó el API ant el cual realiza estas tareas a través de un archivo build.xml. A través del documento XML generado, se extrae el nombre del motor que el usuario seleccionó a través de la interfaz. El sistema, al extraer el nombre del motor busca los elementos que conforman el motor. Capitulo 5: Implementación 101 Ahora el sistema, recorre todos los elementos que constituyen el motor, elementos que son necesarios en el proceso de generación del sitio Web y así mismo va ejecutando las clases junto con los parámetros requeridos. La ejecución de estas clases es posible siempre que hereden de la clase Procesador (definida por el sistema como una clase abstracta). Esta clase contiene el método: public abstract boolean Procesar ( ), a través del cual es posible ejecutar las instrucciones de cada procesador definido. También contiene métodos concretos utilizados como por ejemplo: cargar los parámetros a utilizar por cada procesador. Las instrucciones principales para la ejecución de los procesadores son: extraer su nombre y cargar la clase, instanciar la clase, luego cargar los parámetros necesarios e invocar por último al método procesar; esto por cada procesador incorporado. ID Tarea 18: Identificar procesadores definidos para el motor existente así como la necesidad de nuevos procesadores para el nuevo motor. Dentro de la estructura de archivos del motor base, son identificados los procesadores existentes y que son de uso común para el nuevo motor PHP. Estos se refieren por ejemplo a las clases como: ProcesadorCrearDirectorios.java, crea la estructura de directorios del sitio a generar en las rutas correspondientes. ProcesadorCopiarEstilo.java, permite copiar la hoja de estilos, las imágenes utilizada, y el respectivo directorio para este proceso. ProcesadorCopiarArchivosSinCambios.java, realiza la copia de archivos que no requieren ninguna modificación y los coloca en la carpeta correspondiente. Entre otros. Así mismo, al estudiar la aplicación que se desea generar basada en PHP se identifican los procesadores de posible uso común una vez que se adapten para el nuevo motor, y con ello se identifican nuevas tareas necesarias para alcanzar la generación de dicha aplicación. En este proceso se identificaron tareas que ya estaban definidas para el motor JSP, las cuales se pueden reusar o adaptar, como por ejemplo la copia de la carpeta de la aplicación Generada; además, de nuevas tareas que se deben desarrollar pues no están definidas. ID Tarea 19: Definir estructura del sitio web a generar en el nuevo motor PHP. Para realizar ésta tarea, se define la estructura de directorios y el contenido que poseen los mismos, es decir, la ubicación, qué y cuantas subcarpetas tiene el directorio principal de la aplicación que es generada con el motor PHP: Capitulo 5: Implementación 102 Figura 52. Estructura de archivos generados por la aplicación. Como se muestra en la figura 52, la estructura viene definida por una carpeta principal con el nombre de la aplicación que se genera, en este caso se le llama ModernoCelular y por cada operación o funcionalidad principal a realizar en la aplicación generada, se tiene una carpeta definida dentro de éste directorio o carpeta raíz, como por ejemplo una carpeta llamada agregar, otra para la operación de buscar, eliminar, y así continuamente por cada función que se realiza en el sitio Web generado; además de los archivos relacionados a la conexión a la Base de Datos, a la autenticación de usuario, al manejo de errores, y carpeta con el estilo, entre otros. ID Tarea 20: Configuración del nuevo motor en DEUSWEB. Se define un nuevo motor dentro del archivo de configuración destinado para ello, es decir, se agrega al archivo motores.xml la estructura del nuevo motor encargado de generar el sitio Web en el lenguaje PHP. Es un archivo utilizado por el sistema en el paso 4: Destino y Lenguaje el cual indica que tipo de código será generado para la aplicación generada. De este archivo se extraen los nombres de los motores existentes, en este caso, PHP. En la figura 53 se puede detallar la estructura de éste archivo: Capitulo 5: Implementación 103 Capitulo 5: Implementación 104 Figura 53: Archivo motores.xml Seguidamente se crea la estructura de directorios y archivos base para generar el nuevo motor esta estructura se basa en las tareas necesarias y en los procesadores encargados de realizar las mismas como se hizo referencia anteriormente a la clase ProcesadorCrearDirectorio.java, encargada de dicho proceso. Se define en la carpeta motores de la aplicación, una nueva carpeta con el nombre del motor, la cual contendrá subcarpetas de acuerdo a las operaciones que se realizan en el proceso de generar la aplicación y estas subcarpetas contienen archivos plantilla en lenguaje PHP los cuales son base a la aplicación a generar Se observa en la figura 54 la estructura de directorio motores, conformada por una subcarpeta para cada motor y un archivo de configuración para añadir la nueva estructura: Capitulo 5: Implementación 105 Figura 54: Estructura del directorio motores. ID Tarea 21: Adaptación y creación de Procesadores: Adaptación de procesadores con tareas en común. Luego de la previa identificación de las tareas y archivos de uso común que tienen el motor ya existente JSP / Servlet y el nuevo motor PHP, de ser necesario se adapta el procesador responsable para la tarea. Los procesadores con tareas en común y sin necesidad de adaptación se agregan al motor en el archivo de configuración para ser ejecutados cuando sea requerido. Como procesadores con tareas en común agregados para el nuevo motor se tienen, por ejemplo: ProcesadorCopiarArchivosDependientesXML.java, procesa los archivos que tendrán cambios solo con información contenida en el archivo XML que define la aplicación a generar. ProcesadorCopiarArchivosAutenticacion.java, procesa los archivos referentes a la autenticación a la aplicación generada si esta opción fue seleccionada por el usuario. ID Tarea 22: Creación de nuevos procesadores: Desarrollo del nuevo procesador. Al existir una nueva tarea necesaria para la ejecución del motor o si existe una marcada diferencia en la estructura y actividades que realiza un procesador particular ya existente para dicho motor, se procede entonces al desarrollo de un nuevo procesador que permita las funcionalidades faltantes y requeridas. El procesador es creado de tal manera que se toma en cuenta la compatibilidad total con los diferentes SMBD, ello se realiza por partes; comenzando el trabajo con cada sistema Manejador de Base de Datos. Se inicia primeramente con el SMBD MySQL, el cual ya estaba definido y en funcionamiento con el motor existente de la versión base; luego se hace el tratamiento para PostgreSQL y finalmente con el SMBD Oracle. La estructura de carpetas que define el motor y los archivos plantillas que se encuentran en estas carpetas se define a continuación: Capitulo 5: Implementación 106 dependientes_de_manejador: Solo se procesan los archivos necesarios para las conexiones a las diferentes Base de Datos (archivo: bdconnect.php), dado que la aplicación Generato permite la creación a partir de tres SMBD, no fue posible que todos los archivos que necesitaban instrucciones referentes al manejador de Base de Datos a utilizar estén contenidos en este conjunto y procesados por la clase correspondiente. por_tabla/archivos_principales: (Operaciones Principales: agregar, buscar, detalle, download, eliminar, guardar, insertar, listar), contiene los archivos plantillas para cada una de las operación principales de la aplicación a generar, también se realizan cambios de acuerdo al SMBD a usar, esto por la diferencia en las instrucciones para las operación con las base de datos en el lenguaje PHP. por_tabla/tabla_referenciada: contiene los archivos plantilla que tienen asociadas operaciones con las tablas referenciadas. dependientes_de_xml: contiene los archivos plantilla para el despliegue de mensajes de errores, headers de las páginas, entre otros. autenticación: Archivos relacionados a la autenticación al sistema Web generado. sin _ cambios: contiene diversos archivos los cuales no requieren cambios, solo son copiados a la aplicación generada en las carpetas correspondientes. Validaciones (validaciones a los formularios). Se empleo un archivo de clases en PHP validation.class.php, el cual engloba todas las validaciones necesarias en la formulación de la aplicación. Este archivo de validación funciona realizando los chequeos usando lenguaje PHP y realizado la validación del lado del servidor. Manejo de Archivos Binarios. El archivo filemanager.php contiene las operaciones de manejo de archivos binarios, insertar, eliminar, así como se encarga de actualizar el archivo de control de archivos binarios de Generato llamado control_upload.dw Dada la diferencia en las tareas a realizar o en la forma en que se debe realizar la tarea estos son algunos de los procesadores que se desarrollaron para el motor PHP y que ya existían en el motor JSP: ProcesadorCopiarAplicaciónPHP.java, la aplicación Generada esta contenida en una carpeta, a diferencia de un archivo .war para el motor JSP, el procesador se encarga de copiar esta capeta a la dirección indicada por el usuario. ProcesadorCopiarArchivosPrincipalesPHP.java, procesa los archivos de las operaciones principales (agregar, listar, buscar, entre otros). ProcesadorCopiarArchivosTablasReferenciadasPHP.java, se encarga del manejo de archivos que permiten las operaciones con tablas referenciadas. Capitulo 5: Implementación 107 Agregar procesador al archivo de configuración de motores para ser ejecutado. Los procesadores se agregan al archivo motores.xml configurando la ruta donde se encuentran los archivos base para el motor así como otros parámetros de ser necesario, por ejemplo la ruta destino. La ejecución de las tareas es secuencial al orden en la que están definidas en el archivo motores.xml. Durante el desarrollo se van agregando procesadores a medida que la funcionalidad o la tarea sea requerida. Esto hasta completar con todas las tareas necesarias para generar el sitio Web y con tareas de mantenimiento necesarias luego de completado el proceso de generación. 5.3.5 Sprint 5: Creación de nuevos diseños para la interfaz de la aplicación generada. Para dar inicio a al ejecución de ésta iteración se listan las actividades formalmente, enumeradas por un ID como entradas al Backlog del Sprint 5: Creación de nuevos diseños para la interfaz de la aplicación generada (Ver sección de Anexos). Cada una de estas tareas explicadas a continuación no permiten mas que el usuario pueda elegir diferentes opciones de visualización del sitio Web generado mediante la interacción con la aplicación generadora Generato, haciendo de esta manera una vista más agradable al sitio Web para quien interactúa con el sistema: ID Tarea 23: Definir estilos visuales a agregar. Para la definición de los estilos se revisa principalmente la estructura de carpetas y archivos creados para los estilos ya definidos en la versión base de la aplicación generadora; lo que permite identificar que se tiene una carpeta llamada estilos dentro del conjunto de carpetas que conforman la aplicación Generato. Dicha carpeta, contiene a su vez una cantidad de subcarpetas por cada estilo creado, está estructurada como se muestra en la figura 55: Figura 55: Estructura de la carpeta de estilos de la aplicación Generato. Cada subcarpeta del estilo específico contiene otro conjunto de carpetas como en la figura 56: Capitulo 5: Implementación 108 Figura 56: Estructura de una carpeta de estilos de la aplicación Generato. Donde se observa que existe una carpeta llamada imágenes con iconografías adecuadas, un archivo con extensión css (Hojas de estilos en cascada) con la codificación exclusiva para la creación del estilo respectivo. ID Tarea 24: Implementación de los estilos. Para la implementación de los nuevos estilos se toma como base los estilos ya definidos e integrados en la aplicación, es decir, la hoja de estilo (CSS) perteneciente a una plantilla particular, es utilizada para la reestructuración de las propiedades de los elementos que allí se encuentran desplegados. En la clase que corresponde a la interfaz del Paso 4 de la aplicación generadora, existe un método denominado ListaPoolPlantillasActionPerformed en el que son cargados los estilos para ser visualizados en el conjunto de plantillas disponibles para la selección del usuario dentro del paso respectivo. La estructura del directorio de estilos con las nuevas carpetas de las plantillas creadas, se muestra a continuación en la figura 57: Figura 57: Estructura de la carpeta con nuevos estilos de la aplicación Generato. Para la incorporación y carga de los nuevos estilos, el sistema lee el directorio estilos y cada carpeta definida allí se toma como un estilo dentro del pool de plantillas. Para el archivo a ser usado como la vista previa del estilo seleccionado en la aplicación generadora se requiere de un archivo de formato png con el nombre de preview.png y de dimensiones: 443 píxeles de ancho y 180 píxeles de alto. Este archivo se encuentra ubicado dentro de cada una de las carpetas de los estilos existentes; como puede observarse en el ejemplo de la figura58: Capitulo 5: Implementación 109 Figura 58: Estructura de la nueva carpeta de estilos agregada, Naturaleza, de la aplicación Generato. 5.3.6 Sprint 6: Re-diseño de la interfaz de usuario de la aplicación. Como última iteración para el cumplimiento de la construcción del sistema Generato, se listan las actividades correspondientes a la estructura formalmente definida como Backlog del Sprint 6: el Re-diseño de la interfaz de usuario de la aplicación (Ver en la sección de Anexos). La ejecución del conjunto de tareas que a continuación son expresadas permite que el usuario final pueda interactuar con una aplicación de fácil uso, con cortos y sencillos pasos: ID Tarea 25: Revisión de la interfaz de usuario de la aplicación. Para la realización de ésta tarea, se lleva a cabo la revisión detallada de la estructura de los pasos que corresponden a la aplicación generadora. Se hacen pruebas de tal manera que se ejecuta una y otra vez el Wizard verificando el orden, la continuidad y la navegación de los pasos, evaluando cambios que puedan darse como consecuencia de agregar o quitar algún paso en particular; esto, a criterio y gusto de ambos desarrolladores que al mismo tiempo juegan el papel de diseñadores para crear una interfaz totalmente funcional para el usuario. Se identifican los métodos que permiten obtener los parámetros que alimentan la interfaz, es decir, los métodos que leen los archivos de configuración XML para los estilos, motores, Sistemas Manejadores. ID Tarea 26: Implementación de cambios a la interfaz: Para el desarrollo de la reestructuración de la interfaz, se modifica la clase que corresponde a la Interface del paso 4, Configuración General, la cual posee dentro de sus elementos de configuración una pestaña de destino y lenguaje, indicando ésta la ruta en la que serán guardados los archivos del sitio generado y el lenguaje en el que será creado; por ésta razón se define como un nuevo paso importante y principal dentro de la lista de pasos del Wizard. Así mismo se realiza el desarrollo de la actividad que conlleva a la visualización de los estilos que se encuentran disponibles dentro del conjunto de plantillas de estilos de la aplicación generada. Para ello es que se incorpora el archivo preview.png el cual permite definir la vista previa del estilo al momento en que éste es seleccionado dentro del paso 5 de Configuración General como se observa en la figura 59: Capitulo 5: Implementación 110 Figura 59. Paso 5. Con vista previa del estilo en que será generada la aplicación. 5.4. Etapa de Cierre Esta etapa corresponde a las pruebas del sistema Generato tomando para ello un caso de estudio aplicado a las combinaciones de Sistemas Manejadores y motores utilizados para la generación del sitio Web administrativo; así mismo, se muestran algunas pantallas donde pueden ser visualizados los nuevos estilos agregados y que son utilizados en cada caso para ejemplificar el sistema. 5.4.1 Caso de estudio: Utilizando el motor PHP y el SMBD Oracle Descripción del Caso de Estudio: En este caso de estudio de la figura 60 se crea mediante el sistema manejador Oracle una base de datos denominada: orcl. Como se visualiza en el diagrama posterior, contiene una cantidad de 5 tablas, cada una de ellas con sus respectivas claves primarias y cierta cantidad de campos en los cuales se manejan diferentes tipos de datos como: Number (tipos numéricos), para campos numéricos, Varchar2 (caracteres variantes), para campos de texto, y para las validaciones de fechas es utilizado el tipo de dato Date con formato DD/MM/AAAA que provee el sistema manejador Oracle. Capitulo 5: Implementación 111 Figura 60. Diagrama E-R. Caso de Estudio PHP y Oracle A continuación se muestran algunas pantallas de la Aplicación generadora (Generato). Para la generación del sitio, se escogieron todas las Grado_Salarios grado salariominimo salariomaximo departamento numero nombre cargo comision superior fecha _ ingreso salario Empleados Bonos numero _ empleado cargo comision fecha Departamento numero nombre locacion Capitulo 5: Implementación 112 tablas que se especifican en el Modelo Entidad – Relación, descrito anteriormente. La figura 61 mostrada a continuación, representa la pantalla de Bienvenida como primer paso de la aplicación generadora Generato. Figura 61: Paso1.Pantalla de Bienvenida de La Aplicación Generadora Generato. La siguiente pantalla (figura 62), corresponde al paso 2 de la aplicación DEUSWEB. En este paso, el usuario debe introducir el tipo de Sistema Manejador de Base de Datos que utilizará, en este caso Oracle, la URL de conexión a la base de datos, el nombre de usuario con privilegio de acceso a la base de datos y la contraseña del mismo, para Probar la conexión. Capitulo 5: Implementación 113 Figura 62. Paso 2. Conexión a la base de datos celular en Oracle (Aplicación Generadora) En la siguiente pantalla (figura 63), el usuario debe seleccionar las tablas que desea administrar a través del sistema que será generado. Figura 63. Paso 3. Selección de las tablas de la base de datos orcl en Oracle Capitulo 5: Implementación 114 En la figura 64 se observa la pantalla que corresponde al nuevo paso dentro del Wizard, el Paso 4: Lenguaje y Destino: Figura 64. Paso 4. Selección del lenguaje PHP y el destino de los archivos generados por la aplicación. En la figura 65, 66 y 67 se observan las pantallas que contiene el Paso 5 de Configuración General, en el cual el usuario elige las características del sitio Web a generar como la apariencia con vista previa del estilo seleccionado, la autenticación y la paginación de los registros que serán mostrados: Figura 65. Paso 5. Configuración de la Apariencia del sitio a generar. Capitulo 5: Implementación 115 Figura 66. Paso 5. Configuración para la Autenticación del sitio a Generar. Figura 67. Paso 5. Configuración para la Paginación de los registros de las tablas del sitio. La pantalla de la figura 68 se muestra el Paso 6 con el Resumen de las características configuradas por el usuario en los pasos previos: Capitulo 5: Implementación 116 Figura 68. Paso 6. Resumen de los parámetros seleccionados para la generación del sitio. En la figura 69 se muestra el Paso 7 como paso final de la aplicación generada donde se indica una barra de progreso una vez que se está realizando la generación de sitio Web administrativo: Figura 69. Paso 7. Proceso de generación de la aplicación. Capitulo 5: Implementación 117 Una vez seguido cada paso de la aplicación generadora Generato, se crea una carpeta que contiene los archivos del sitio generado. Esta carpeta es colocada en el directorio (destino) que el usuario de la aplicación generadora escogió en su respectivo paso. A continuación se muestran los archivos generados: Donde se muestra una subcarpeta por cada operación o función principal que se ha de realizar en la aplicación generada, así como otros archivos .php correspondientes por ejemplo, a la autenticación, validaciones, mensajes de error. La estructura específica de una carpeta adecuada a una operación particular se muestra como un conjunto de archivos .php en las figuras 70 y 71: Figura 70. Estructura de una subcarpeta asociada a agregar del sitio generado en lenguaje PHP. Figura 71. Estructura de una subcarpeta asociada a listar del sitio generado en lenguaje PHP. Disponibles las carpetas y archivos proporcionados para ser ejecutados, conllevan éstos a la aplicación generada; por consiguiente se muestran las pantallas asociadas a ello: En la figura 72 se observa la pantalla de autenticación del sitio Web: Capitulo 5: Implementación 118 Figura 72. Pantalla de autenticación del sitio generado por el motor PHP y el SMBD Oracle. En la figura 73 se muestra una vez realizada la autenticación, la pantalla de bienvenida al sitio Web: Figura 73. Pantalla de Bienvenida del sitio generado por el motor PHP y el SMBD Oracle. Se observa en la siguiente pantalla de la figura 74 los registros de la tabla empleados de la base de Datos orcl basada en el SMBD Oracle: Capitulo 5: Implementación 119 Figura 74. Visualización de la tabla empleados de la base de datos orcl. En la figura 75 se muestra el detalle de la tabla empleados: Figura 75. Visualización del detalle de la tabla empleados de la base de datos orcl. Capitulo 5: Implementación 120 En la figuras 76 y 77 se observa la operación de agregar un registro a la tabla bonos, haciendo la referencia a un registro de la tabla empleados: Figura 76. Visualización de la operación agregar de la tabla bonos de la base de datos orcl con referencia a la tabla empleados. Figura 77. Visualización de la operación agregar de la tabla bonos de la base de datos orcl. Capitulo 5: Implementación 121 En la pantalla que se observa en la figura 78, se detalla la confirmación de que u registro fue agregado a la tabla bonos: Figura 78. Pantalla de mensajes de confirmación de que la operación agregar registros se realizó con éxito. Identificación de Pruebas y Resultados: Es realizada en base a una estructura de datos definida, la ejecución de la aplicación Generato, aplicación tipo Wizard que conlleva a la configuración de diferentes elementos para generar un sitio web al gusto del usuario. Para ello, se establecen una serie de ítems en un modelo de hoja de prueba (reflejado en la sección de Anexos de este trabajo) que permiten evaluar las funcionalidades de la aplicación bajo la plataforma Windows. En general, la funcionalidad se refiere a qué tan rápido y fácil le resulta a los usuarios aprender a utilizar un producto para alcanzar sus objetivos y qué tan satisfechos quedan luego de su uso. La funcionalidad solo puede ser definida haciendo referencia a uno o varios contextos específicos, significando ello, que no hay una medida absoluta de la funcionalidad, de tal manera que la funcionalidad de un artefacto es definida por el contexto en el cual el mismo es utilizado. Sin embargo existe la necesidad de obtener una medida general con la cual pueda ser posible comparar la funcionalidad de un artefacto en un rango de diferentes contextos. Es así como ha surgido la necesidad de utilizar un método para obtener un indicador que permita saber si en líneas generales un artefacto o producto funciona o no. Capitulo 5: Implementación 122 De esta manera, se observa que la funcionalidad del producto es un factor de gran importancia tanto para quienes lo desarrollan como para el usuario, pues está involucrada con aspectos como: la conveniencia, facilidad y rapidez de uso del producto, la disponibilidad del mismo, su navegabilidad y la utilidad del contenido que provee. Si los usuarios determinan que el producto no cumple con estas características, las consecuencias para quienes lo desarrollan pueden ser críticas. Una vez realizadas las pruebas de funcionalidad donde todas las actividades fueron hechas y probadas totalmente; se obtiene que por cada tarea los resultados son satisfactorios, es decir las aplicaciones, tanto la Generadora como la Generada tienen un excelente funcionamiento. También se realizan las mismas pruebas pero bajo la plataforma del sistema operativo Linux utilizando tanto el mismo método como los mismos archivos correspondientes a la aplicación, ello permitió corroborar el buen funcionamiento del sistema ya que las actividades se ejecutaron y funcionaron correctamente. 5.4.2 Caso de estudio: Utilizando el motor JSP/Servlets y el SMBD PostgreSQL Descripción del Caso de Estudio: El caso de estudio que se muestra en la figura 79 se crea mediante el sistema manejador PostgresSQL una base de datos denominada: celular. Como puede visualizarse en el diagrama siguiente, este modelo de datos contiene una cantidad de 7 tablas, cada una de ellas con sus respectivas claves primarias y cierta cantidad de campos en los cuales se manejan diferentes tipos de datos como: int (enteros tipos 4, 8), para campos numéricos, Varchar (caracteres variantes), para campos de texto, flotantes, tipos binarios para el caso de archivos como fotos, imágenes, y para las validaciones de fechas es utilizado el tipo de dato timestamp que provee este sistema manejador. Capitulo 5: Implementación 123 Figura 79. Diagrama E-R. Caso de Estudio JSP/Servlets y PostgreSQL A continuación se muestran algunas pantallas de la Aplicación generadora (Generato). Para la generación del sitio, se escogieron todas las tablas existentes en la estructura de datos anterior: La pantalla que contiene la selección de PostgreSQL como SMBD con sus respectivos datos de conexión suministrados por el usuario, es detallada a continuación en la figura 80: Fotos codigo foto Capitulo 5: Implementación 124 Figura 80. Paso 2. Conexión a la base de datos celular en PostgreSQL (Aplicación Generadora) En la figura 81 se observa la selección de las tablas de la base de datos asociada al SMBD PostgreSQL: Figura 81. Paso 3. Selección de las tablas de la base de datos celular en PostgreSQL Capitulo 5: Implementación 125 En la siguiente pantalla de la figura 82 se observa la selección del lenguaje JSP/Servlets en el que será generado el sitio Web: Figura 82. Paso 4. Selección del lenguaje JSP/Servlets y el destino de los archivos generados por la aplicación. Una vez seguidos la serie de pasos del Wizard Generato, se crea el archivo de extensión war, el cual contiene los archivos del sitio generado. Este archivo es colocado en el directorio (destino) que el usuario de la aplicación generadora escogió en su respectivo paso. A continuación se muestran los archivos generados: Figura 83. Archivo de extensión war generado. El archivo de extensión war, se descomprime automáticamente, cuando es colocado en el servidor web y la URL de acceso al sitio generado corresponderá a la siguiente estructura: http://<servidor>/<nombre escogido por el usuario para el sitio>/ La estructura del sitio generado es la siguiente: Capitulo 5: Implementación 126 Figura 84. Estructura del sitio generado. Las páginas del sitio son colocadas en la carpeta WEB-INF, la cual se describe a continuación. Figura 85. Contenido del Directorio WEB-INF. Aplicación generada. En el directorio vistas, se ubican todos los archivos JSP generados, que corresponden a la interfaz con la cual interactúa el usuario. En el directorio lib, se colocan todos los archivos de extensión jar utilizados por el sitio. En este directorio se ubica el archivo Generato.jar, el cual contiene todos los servlets generados para esta aplicación. Figura 86. Contenido del Directorio lib. Aplicación Generada. Ya disponible el archivo para ser ejecutado se tiene la aplicación generada; por lo tanto se observan las siguientes imágenes capturadas una vez realizado el proceso de generación: En la figura 87 se observa la pantalla de bienvenida al sitio Web generado: Capitulo 5: Implementación 127 Figura 87. Pantalla de Bienvenida del sitio generado por el motor JSP/Servlets y el SMBD PostgresSQL. En la figura 88 se observa la pantalla con el listado de registros de la tabla fotos perteneciente a la BD celular del sitio Web generado: Figura 88. Visualización de la tabla fotos de la base de datos celular Capitulo 5: Implementación 128 En la figura 89 se observa la pantalla que refleja a operación de agregar un registro a la tabla fotos: Figura 89. Visualización de la operación Agregar para la tabla fotos de la base de datos celular. Identificación de Pruebas y Resultados: Para la estructura de datos definida en este caso de estudio también es realizada la identificación de pruebas de funcionalidad a través del mismo método utilizado en el primer caso, bajo la plataforma Windows, se ejecuta la aplicación Generato, se genera el sitio en base al lenguaje JSP/Servlets y el manejador PostgreSQL. Por lo tanto ello también se ve reflejado en la hoja de prueba como anexo a este documento. La idea de realizar el análisis de funcionalidad es determinar si el sistema es apto para ser usado por el público que cumpla con el perfil definido, de una forma fácil y rápida, y saber si los usuarios son capaces de generar, de crear los sitios Web, es decir, si pueden cumplir las tareas que se proponen al utilizar el sistema. Una vez realizadas las pruebas de funcionalidad donde todas las actividades fueron probadas; los resultados determinan que el sistema funciona de la manera esperada. De igual forma se realizan las mismas pruebas pero bajo la plataforma del sistema operativo Linux utilizando tanto el mismo método como los mismos archivos correspondientes a la aplicación, ello permitió verificar el buen funcionamiento de la aplicación ya que las actividades se ejecutaron y funcionaron correctamente. Capitulo 5: Implementación 129 5. 5. Resumen del Capítulo En este capítulo, se describió el proceso de desarrollo que se lleva a cabo sobre la aplicación base DEUSWEB para formar finalmente una nueva aplicación que contiene ciertos módulos especificados, denominada Generato; quien se comporta como un sistema que genera en varios lenguajes, una aplicación Web administrativa que gestiona la información contenida en una base de datos, donde esta puede estar basada en alguno de los tres tipos de manejadores de base de datos mas usados en el mercado: MySQL, PostgreSQL y Oracle. Este sistema utiliza la ingeniería de reverso al modelo de datos para producir dicha aplicación y le permite al usuario crear un sitio Web administrativo a partir de alguna de las bases de datos existentes con poca interacción del usuario para producirla, ya que consta de 7 (siete) sencillos pasos. Son expuestos los diferentes artefactos generados por el sistema en cada una de las iteraciones (Sprints) del proceso de desarrollo, siguiendo la ejecución de un conjunto de actividades asociadas a cada Sprint, que darán como resultado de integración , cada módulo implementado para la producción del sistema Generato. Seguidamente se detallan los casos de estudios como estructuras de datos definidas para la identificación y elaboración de pruebas de usabilidad del sistema completo, siguiendo la generación desde el primer paso de la aplicación generadora (Generato), donde son mostradas algunas pantallas de la misma en ejecución sobre el navegador, permitiendo todo el proceso, evaluar y arrojar los resultados respectivos a la visión del usuario hacia el sistema. Capitulo 5: Implementación 130 Conclusiones 131 CONCLUSIONES La construcción de la nueva versión de la aplicación: Generato, expande el alcance de la solución que propone la herramienta, esto al ampliar la cantidad de casos en los que se puede aplicar, a través de la incorporación de distintos Sistemas Manejadores de Base de Datos como PostgresSQL y Oracle. Generato, permite generar un sitio Web administrativo funcional de forma simple y rápida, el cual puede estar en ejecución y listo para ser usado en minutos y no en horas ni semanas. Consideraciones importantes deben ser tomadas en cuenta a la hora de integrar un SMBD; deben estudiarse bien las características que distinguen al manejador: tipos de datos que soporta, tamaño de los mismos, compatibilidad con los diferentes lenguajes, servidores, y un sin fin de elementos que permiten definir el importante uso que se le puede dar dentro de una aplicación no solamente de éste tipo de sistemas sino en muchos otros basados en Web. Este tipo de sistemas son considerados trabajosos al momento de realizar las respectivas pruebas de uso, debido a la cantidad de elementos y opciones que implican pruebas que contemplen todas las combinaciones posibles; a manera específica se hace referencia a los Manejadores de Base de Datos y a los lenguajes de programación que sirven como base para los motores de generación de código para la aplicación administrativa, pueden existir diferentes combinaciones como las agregadas a la nueva aplicación, por ejemplo: el módulo basado en generación del sitio Web con lenguaje JSP/Servlets y conexión a la BD basada en el SMBD MySQL ó el SMBD PostgreSQL o el SMBD Oracle, o si así el usuario lo prefiere, elegir la generación de la aplicación administrable basada en el lenguaje de programación PHP con conexión a una base de datos basada en cualquiera de los tres SMBD expuestos anteriormente. Se aprecio que la metadata que describe a una BD y las tablas definidas en ella tiene un gran potencial, y es de mucha utilidad cuando se requiere obtener información de una BD. Es importante resaltar que el proceso de desarrollo Scrum, es utilizado por su capacidad para desarrollar proyectos de tamaño variable y hacer rápida u ordenada la implementación para el grupo desarrollador. Dentro de los objetivos logrados se expresan: • La construcción de un sistema mantenible e incremetable que permite generar aplicaciones Web administrativas a partir de la ingeniería de reverso al modelo de datos. El sistema posee la particularidad de poder generar código a través de los procesadores añadidos a la aplicación. Estos procesadores son parte de los motores que genera la aplicación Web y son configurados desde un archivo xml permitiendo así incorporar en próximas versiones aun más funcionalidades a la aplicación. • La construcción la interfaz gráfica de usuario, que permite la interacción del usuario con la aplicación generadora de forma fácil y rápida, sin poseer Conclusiones 132 tantos conocimientos para la manipulación de la misma, el usuario de la aplicación no tiene por que ser una persona especializada en el desarrollo de un sitio Web. • Se estudió la forma de extraer los metadatos de la base de datos, a través de los métodos proporcionado por el API JDBC de los Sistemas Manejadores de Base de Datos. • Se verificaron las funcionalidades del sitio Web generado, a través de dos casos de estudio, uno por cada combinación entre manejadores y motores, lo que permite comprobar el uso del sistema con diferentes tipos de datos en la base de datos. Las funcionalidades básicas del sitio Web generado son las siguientes: autenticar al usuario, listar, buscar, insertar modificar y eliminar cualquier información contenida en la base de datos. Así mismo la aplicación web generada posee otras funcionalidades adicionales que son: la selección de los valores correspondientes a la clave foránea de una tabla en particular y la manipulación de los archivos almacenados en la base de datos sin obligar al usuario a definir campos adicionales y sin alterar la estructura de la base de datos suministrada por el usuario. De los beneficios obtenidos en el desarrollo de esta aplicación tenemos los siguientes: • Minimiza el tiempo invertido por las personas u organizaciones particulares que necesitan desarrollar un sistema Web administrativo para la gestión de una base de datos. • La herramienta puede ser manipulada por personas que no posean conocimientos técnicos avanzados ni en el desarrollo de aplicaciones Web. • Se pueden extender las funcionalidades del sistema, mediante el desarrollo de nuevos motores y la inclusión de nuevos Manejadores de Base de Datos. Finalmente se puede decir, que Generato es un sistema que permite generar aplicaciones web administrativas con las funcionalidades básicas de gestión para el contenido de una base de datos, y con nuevas funcionalidades en comparación con otros sistemas existentes, que le otorga un valor agregado, y que hace posible una mejor administración de la base de datos. Limitaciones y Recomendaciones 133 LIMITACIONES Y RECOMENDACIONES Para proveer una experiencia al usuario altamente favorable en la utilización del sistema, se indican las siguientes recomendaciones para futuras versiones: Las limitaciones sobre este sistema, se basan en las funcionalidades extras que posee la aplicación. La restricción que se fija sobre los archivos que se almacenan en la base de datos es que solo puede existir un campo por tabla que almacene el contenido de un archivo. Para el caso específico de archivos binarios con el motor PHP, el manejo de ellos se limita a la versión del lenguaje PHP que se esté utilizando. Otra limitación está ligada al uso de las claves foráneas, en la que el sistema sólo identifica la relación de una tabla con otra tabla, siempre que la clave foránea este compuesta por un sólo campo, por ello deben estar totalmente definidas las claves foráneas compuestas. Además todas las tablas deben tener clave primaria, esto para trabajar en conjunto con cualquiera de los dos motores, tanto JSP/Servlets como con PHP. De igual forma, se debe tomar en cuenta que las validaciones van a depender del modelo, ya que la aplicación genera las validaciones de acuerdo con los tipos de datos. En la interfaz de usuario de Generato, se debe facilitar el paso de selección de Base de Datos para que este no use un string de conexión, sino un formulario donde el usuario indique los datos necesarios de acuerdo al SMBD seleccionado. Bibliografía y Referencias 135 BIBLIOGRAFÍA Y REFERENCIAS • [González, 2006] González R., Luis A. (2006). DEUSWEB, Generador de sitios Web administrativos basado en la ingeniería de reverso al modelo de datos. • [Itapizaco, 2007] Itapizaco (2007). Java Tutorial. Consultado en http://www.itapizaco.edu.mx/paginas/JavaTut/froufe/parte21/ cap21-3.html en Diciembre de 2007. • [Itapizaco, 2007] Itapizaco (2007). Java Tutorial. Consultado en http://www.itapizaco.edu.mx/paginas/JavaTut/froufe/parte21/cap21-4.html en Diciembre de 2007. • [Microsoft, 2007] Microsoft Corporation (2007). Consultado en http://www. microsoft.com/mspress/books/6916.aspx en Diciembre de 2007. • [PHP, 2007] PHP (2007). PHP Tutorial. Consultado en http://www.php- org/php_tutorial en Enero de 2008. • [Groff, 2003] Groff, James R., Weinberg, Paul N. (2003). Manual de Referencia SQL. pp 668-696. McGraw-Hill Interamericana de España, S.A.U. • [Date, 2001] Date, C. J. (2001). Introducción a los SISTEMAS DE BASE DE DATOS. Prentice Hall. • [Sideris, 2003] Sideris Consulting Group (2003). Oracle 9i Database Architecture & Administration. Disponible en: www.sideris.com. • [Microsoft, 2004] Microsoft Press. (2004). Agile Project Management with Scrum. Consultado en http://www.amazon.com/Agile-Project-Management MicrosoftProfessional/dp/073561993X/ref=pd_bbs_sr_1?ie=UTF8&s=books&q id=1195571683&sr=8-1 en Enero de 2008. • [Ajpdsoft, 2008] Ajpdsoft (2008). Consultado en http://www.ajpdsoft.com /modules.php?name= News&file=article&sid=272- 67k en Enero de 2008. • [Scribd, 2007] Scribd (2007). IEEE Scrum. Consultado en http://www.scribd.com/doc/25892/IEEEScrum en Diciembre de 2007. • [JDBC, 2007] JDBC PostgreSQL (2007). Binary Data. Consultado en http://jdbc.postgresql.org/documentation/80/binary-data.html en Diciembre 2007. Bibliografía y Referencias 136 • [Natureza, 2007] Naturaza-Bo (2007). Consultado en http://www.natureza- bo.com/AQUINO/VARIOS/oracleSQL.pdf en Diciembre 2008 • [MySQL-Hispano, 2007] MySQL Hispano(2007). Consultado en http://www.mysql-hispano.org/articulos/num43/analisis-comparativo.pdf en Diciembre 2008 • [Zona Oracle, 2007] Zona Oracle (2007). Consultado en http://www.zonaoracle.com/manuales-tutoriales-oracle/?id=185 en Diciembre 2008 • [PHP-MySQL-Tutorial, 2007] PHP-MySQL-Tutorial (2007). Consultado en http://www.php-mysql-tutorial.com/mysql-tutorial/index.php en Agosto 2008 • [Wikipedia, 2007] Wikipedia (2007). Scrum Development. Consultado en http://en.wikipedia.org/wiki/Scrum_(development) Anexos 137 ANEXOS 139 Backlog del Sprint 1 Análisis de la aplicación base DEUSWEB: 140 Backlog del Sprint 2 Desarrollo para soporte SMBD PostgreSQL: 141 Backlog del Sprint 3 Desarrollo para soporte SMBD Oracle 142 Backlog del Sprint 4 Desarrollo Motor PHP: 143 Backlog del Sprint 5 Creación de nuevos diseños para la interfaz de la aplicación generada: 144 Backlog del Sprint 6 Re-diseño de la interfaz de usuario de la aplicación: 145 Formato de Prueba de Funcionalidades de Generato Objetivos de esta Prueba de Funcionalidades: • Determinar si el usuario es capaz de poner en funcionamiento la Aplicación Generato siguiendo cada uno de los pasos correspondientes al Wizard. • Determinar si la información suministrada y manejada le resulta útil al usuario. Funciona No Funciona Aplicación Generadora Actividad 1: Ejecutar o Iniciar la Aplicación Generadora Generato. Actividad 2: Establecer la conexión a un SMBD a seleccionar. Actividad 3: Seleccionar las tablas correspondientes a la BD a la cual se conectó. Actividad 4: Seleccionar el Lenguaje y el Destino en el que se encontraran los archivos creados para la Aplicación Generada. Actividad 5: Seleccionar opciones de Configuración General: � Apariencia: Seleccionar un Estilo. � Autenticación. � Paginación. Actividad 6: Verificar el resumen de datos configurados en el Wizard y finalizar la Aplicación Generadora. Actividad 7: Verificar visualización correcta de mensajes de error. √√√√ √√√√ √√√√ √√√√ √√√√ √√√√ 146 Aplicación Generada: Funciona No Funciona Actividad 1: Realizar Autenticación (Opcional). ____________________________________________________________________________________________________________________________ Actividad 2: Ejecutar aplicación Generada en el navegador Web. ____________________________________________________________________________________________________________________________ Actividad 3: Ejecutar aplicación Generada en el navegador Web. ____________________________________________________________________________________________________________________________ Actividad 4: Realizar operación de Listado de Registros de una tabla. ___________________________________________________________________________________________________________________________ Actividad 5: Realizar operación de Búsqueda de Registros de una tabla. ___________________________________________________________________________________________________________________________ Actividad 6: Realizar operación Eliminar de Registros de una tabla. ____________________________________________________________________________________________________________________________ Actividad 7: Realizar operaciones de Agregar o Insertar de Registros de una tabla. ____________________________________________________________________________________________________________________________ Actividad 8: Realizar operaciones de Modificar de Registros de una tabla. ____________________________________________________________________________________________________________________________ Actividad 9: Verificar visualización correcta de mensajes de error ____________________________________________________________________________________________________________________________ Actividad 10: Verificar la paginación de registros de acuerdo a la seleccionada. _____________________________________________________________________________________________________________________________ Actividad 11: Verificar que se ejecuten correctamente las validaciones de los campos. Observaciones Finales: ____________________________________________________________________________________________________________________________________________ _________________________________________________________________________________________________________________________________________________________________ _________________________________________________________________________________________________________________________________________________________________ √√√√ √√√√ √√√√ √√√√ √√√√ √√√√ √√√√ √√√√ √√√√ √√√√ √√√√