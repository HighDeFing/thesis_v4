Tesis Universidad Central de Venezuela Facultad de Ciencias Escuela de Computación Desarrollo de una aplicación basada en la tecnoloǵıa de Cadena de Bloques sobre la plataforma Ethereum que permite recolectar y almacenar los datos de las transacciones en una base de datos NoSQL. Trabajo especial de grado presentado ante la Ilustre Universidad Central de Venezuela Por el bachiller: Carlos Pires Tutor: Prof. Jesús Lares Caracas, Mayo de 2018 iii Agradecimientos Principalmente a mi madre, por hacerme la persona que hoy soy, y por brindarme el apoyo para ser la persona que quiero ser. A mi hermano, que a pesar de la distancia, me inspiró con su valent́ıa y perseverancia. A Ezequiel, el amigo verdadero. Un agradecimiento muy especial a mi tutor Jesús Lares, por ser un docente ejemplar, ĺıder atento, responsable, enemigo de la mediocridad y como dice él, un ’hermano contemporáneo’. Mucha gratitud hacia Antonio Nardi, Horacio Coll y Rafael Olivares por ser profesionales de calidad, además de colegas de trabajo y buenos amigos que me brindaron la oportunidad de formarme como profesional y creer en mi trabajo. A la Universidad Central de Venezuela, por la tarea titánica de educar, en contra de to- das las adversidades. iv Resumen T́ıtulo: Desarrollo de una aplicación basada en la tecnoloǵıa de Cadena de Bloques sobre la plataforma Ethereum que permite recolectar y almacenar los datos de las transacciones sobre almacenes de datos NoSQL. Autor: Carlos Pires. Tutor: Jesús Lares. El presente TEG expone las bondades que brindan las nuevas tecnoloǵıas de cadena de bloques y contratos inteligentes sobre plataformas diseñadas para albergar aplicaciones dis- tribuidas, adicionalmente muestra el proceso de creación de una aplicación que se vale de una interfaz web para interactuar con dichas cadenas de bloques y finalmente, albergar dichas interacciones en almacenes de datos NoSQL con la finalidad de aplicar técnicas de anaĺıtica predictiva e inteligencia artificial que ayuden a detectar patrones de comportamiento u otro tipo de información de valor que almacenen las cadenas de bloques. Palabras clave: Cadena de bloques, Contratos inteligentes, Transacciones, Ethereum, Aplicaciones distribuidas, NoSQL. Algoritmos 6.1. Versión 0.1 de solución para el caso de uso . . . . . . . . . . . . . . . . . . . 56 6.2. Código que genera el ABI y Bytecode de un contrato dado . . . . . . . . . . 62 6.3. Código que realiza pruebas automáticas de despliegue de un contrato y fun- cionalidades . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 63 6.4. Versión 0.2 de solución para el caso de uso . . . . . . . . . . . . . . . . . . . 70 6.5. Código que realiza pruebas automáticas de despliegue de un contrato y fun- cionalidades. Versión 0.2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 77 6.6. Versión 0.3 de solución para el caso de uso . . . . . . . . . . . . . . . . . . . 83 6.7. Código que realiza pruebas automáticas de despliegue de un contrato y fun- cionalidades. Versión 0.3 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 89 6.8. Versión 1.0 de solución para el caso de uso . . . . . . . . . . . . . . . . . . . 96 6.9. Módulo que genera una instancia de Web3 conectada a la red Rinkeby(web3.js)104 6.10. Módulo que realiza el despligue del contrato en la red Rinkeby (deploy.js) . . 105 6.11. Módulo que interactúa con un contrato dada una dirección y su ABI (factory.js)106 6.12. Módulo que interactúa con un contrato dada una dirección pasada por paráme- tro y su ABI (campaign.js) . . . . . . . . . . . . . . . . . . . . . . . . . . . . 107 6.13. Módulo que inicia en una red local la aplicación web(server.js) . . . . . . . . 109 6.14. Módulo que configura las rutas del servidor web(routes.js) . . . . . . . . . . 110 6.15. Ruta que sirve como página base de la aplicación web. Muestra la lista de campañas desplegadas (index.js) . . . . . . . . . . . . . . . . . . . . . . . . . 110 6.16. Ruta que muestra el formulario para la creación de nuevas campañas (cam- paigns/new.js) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 112 6.17. Ruta que muestra los detalles de una campaña dada una dirección particular (campaigns/show.js) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 116 6.18. Módulo que maneja las contribuciones a una campaña en espećıfico (Compo- nents/ContributionForm.js) . . . . . . . . . . . . . . . . . . . . . . . . . . . 120 6.19. Módulo que maneja las solicitudes a una campaña en espećıfico (campaigns/- requests/index.js) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 123 6.20. Módulo que se encarga de construir cada una de las filas de la tabla de soli- citudes (Components/RequestRow.js) . . . . . . . . . . . . . . . . . . . . . . 126 6.21. Módulo que se encarga de construir el formulario para crear una solicitud (pages/campaigns/requests/news.js) . . . . . . . . . . . . . . . . . . . . . . . 132 vi Algoritmos 6.22. Componente que hace de cabecera a todas las páginas del cliente web (Com- ponents/Header.js) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 135 6.23. Componente que hace contenedor a todas las páginas del cliente web (Com- ponents/Layout.js) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 136 6.24. Componente que se conecta con MongoDB (server/app.js) . . . . . . . . . . 137 6.25. Ruta que asigna el módulo controlador que maneja las solicitudes (server/- routes/router.js) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 138 6.26. Modelo de una campaña para el almacenamiento en la base de datos (serve- r/models/campaign.model.js) . . . . . . . . . . . . . . . . . . . . . . . . . . 138 6.27. Modelo de una contribución para el almacenamiento en la base de datos (ser- ver/models/contribution.model.js) . . . . . . . . . . . . . . . . . . . . . . . . 140 6.28. Modelo de una solicitud para el almacenamiento en la base de datos (server/- models/request.model.js) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 140 6.29. Modelo de una aprobación de una solicitud para el almacenamiento en la base de datos (server/models/approved.model.js) . . . . . . . . . . . . . . . . . . 141 6.30. Modelo de un rechazo de una solicitud para el almacenamiento en la base de datos (server/models/rejected.model.js) . . . . . . . . . . . . . . . . . . . . . 142 6.31. Modelo de finalización de una solicitud para el almacenamiento en la base de datos (server/models/finalized.model.js) . . . . . . . . . . . . . . . . . . . . 143 6.32. Módulo encargado de manejar las solicitudes que provengan del lado del clien- te y almacenar en la base de datos utilizando los modelos definidos (server/- main.controller.js) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 144 Lista de Tablas 6-1. Especificaciones de la prueba para la versión 0.1 . . . . . . . . . . . . . . . . 60 6-2. Especificaciones de la prueba automática para la versión 0.1 . . . . . . . . . 68 6-3. Especificaciones de hardware para pruebas en Mocha . . . . . . . . . . . . . 68 6-4. Especificaciones de la prueba para la versión 0.2 . . . . . . . . . . . . . . . . 75 6-5. Especificaciones de hardware para pruebas en Mocha. Ambiente MacOS . . . 76 6-6. Especificaciones de la prueba para la versión 0.3 . . . . . . . . . . . . . . . . 89 6-7. Especificaciones de hardware para pruebas en Mocha, versión 0.3. Ambiente MacOS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 95 6-8. Especificaciones de la prueba de aceptacón para interfaces gráficas. . . . . . 148 6-9. Tabla para evaluación de interfaces gráficas. . . . . . . . . . . . . . . . . . . 148 6-10.Tabla para evaluación de la pantalla principal del cliente web. . . . . . . . . 150 6-11.Tabla para evaluación de la pantalla creación de una campaña. . . . . . . . . 152 6-12.Tabla para evaluación de botón de contribución para una campaña . . . . . 154 6-13.Tabla para evaluación de detalles de una campaña. . . . . . . . . . . . . . . 156 6-14.Tabla para evaluación de creación de una solicitud. . . . . . . . . . . . . . . 158 6-15.Tabla para evaluación de lista de solicitudes. . . . . . . . . . . . . . . . . . . 161 Lista de Figuras 2-1. Representación gráfica de la arquitectura propuesta para el TEG. . . . . . . 7 3-1. Representación gráfica de una cadena de bloques. Recuperado y traducido de: https : //bitcoin.org/en/developer � guide . . . 10 3-2. Representación simplificada de la estructura de datos que enlaza bloques mar- cados de tiempo. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13 3-3. Cadena de bloques y el árbol Merkle. Recuperado y traducido de: https : //bitcoin.org/bitcoin.pdf . . . . . . . . . 15 3-4. Representación gráfica de la cadena de bloques de Ethereum. . . . . . . . . . 22 3-5. Ethereum y su cadena de bloques en la arquitectura planteada. . . . . . . . . 23 3-6. Representación gráfica de una transacción en Ethereum. . . . . . . . . . . . 25 3-7. Ejemplo de costos de GAS. . . . . . . . . . . . . . . . . . . . . . . . . . . . 26 3-8. Ejemplo de costo final de una transacción . . . . . . . . . . . . . . . . . . . . 26 3-9. Ejemplo minado de una transacción con dificultad 100 . . . . . . . . . . . . 27 4-1. Capa intermedia planteada en la arquitectura. . . . . . . . . . . . . . . . . . 36 4-2. Capa final planteada en la arquitectura. . . . . . . . . . . . . . . . . . . . . 37 5-1. Ciclo de vida del Proceso Ágil Unificado. . . . . . . . . . . . . . . . . . . . . 44 5-2. Iteraciones de liberación de versiones. . . . . . . . . . . . . . . . . . . . . . . 45 6-1. Gerente crea una instancia de contrato inteligente mediante un cliente web. . 48 6-2. Contribuyentes ingresan ether a la campaña mediante el cliente web. . . . . . 49 6-3. Gerente se vale del cliente web para crear una solicitud de gasto. . . . . . . . 50 6-4. Los clientes se valen del cliente web para aprobar o rechazar una solicitud de gasto de una campaña. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 51 6-5. Cuando se haya alcanzado la cantidad necesaria de votos, el gerente puede finalizar la solicitud. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 52 6-6. Todas las interacciones de parte de contribuyentes y el gerente con la campaña son registradas en una instancia de MongoDB. . . . . . . . . . . . . . . . . . 53 6-7. Diagrama de caso de uso para el gerente de una campaña. . . . . . . . . . . 54 6-8. Diagrama de caso de uso para contribuyentes de una campaña. . . . . . . . . 55 6-9. IDE de Remix, compilador de Solidity en en navegador web. . . . . . . . . . 61 6-10.Ejecución de pruebas automáticas mediante el uso de la biblioteca Mocha. . 69 Lista de Figuras ix 6-11.Ejecución de pruebas automáticas mediante el uso de la biblioteca Mocha para la versioón 0.2 de la solución. . . . . . . . . . . . . . . . . . . . . . . . . . . 82 6-12.Ejecución de pruebas automáticas mediante el uso de la biblioteca Mocha para la versioón 0.3 de la solución.. . . . . . . . . . . . . . . . . . . . . . . . . . . 96 6-13.Despliegue del contrato en la red Rinkeby, retorna una dirección del contrato desplegado . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 106 6-14.Estructura del cliente web . . . . . . . . . . . . . . . . . . . . . . . . . . . . 108 6-15.Pantalla principal del cliente web. . . . . . . . . . . . . . . . . . . . . . . . . 149 6-16.Pantalla para la creación de una campaña. . . . . . . . . . . . . . . . . . . . 151 6-17.Botón de contribución para una campaña. . . . . . . . . . . . . . . . . . . . 153 6-18.Detalles de una campaña. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 155 6-19.Creación de una solicitud. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 157 6-20.Lista de solicitudes, una lista para aprobar, una lista para ser rechazada, dos en vigencia. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 160 6-21.Lista de solicitudes, una expirada, una finalizada. . . . . . . . . . . . . . . . 162 6-22.Error al dejar campos vaćıos en la creación de una campaña. . . . . . . . . . 162 6-23.Error al insertar caracteres al monto de contribución. . . . . . . . . . . . . . 163 Contenido 1 Caṕıtulo 1 -Introducción 2 2 Caṕıtulo 2 - Planteamiento del problema 4 2.1 Planteamiento del problema . . . . . . . . . . . . . . . . . . . . . . . . . . . 4 2.2 Justificación . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5 2.3 Objetivo general: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5 2.4 Objetivos espećıficos: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6 2.5 Arquitectura Propuesta para TEG . . . . . . . . . . . . . . . . . . . . . . . 6 2.6 Alcance del TEG . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8 3 Caṕıtulo 3 - Marco teórico 9 3.1 Cadena de bloques (Blockchain) . . . . . . . . . . . . . . . . . . . . . . . . . 9 3.1.1 Definición . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9 3.2 Propiedades deseables . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10 3.3 Antecedentes académicos . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11 3.4 Bitcoin Blockchain . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12 3.5 Árboles Merkle . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12 3.6 Prueba de trabajo (Proof-Of-Work) . . . . . . . . . . . . . . . . . . . . . . . 16 3.7 Casos de uso de las cadenas de bloques . . . . . . . . . . . . . . . . . . . . . 16 3.7.0.1 Criptomonedas . . . . . . . . . . . . . . . . . . . . . . . . . 16 3.7.0.2 Servicios financieros . . . . . . . . . . . . . . . . . . . . . . 17 3.7.0.3 Servicios de pólizas de seguros . . . . . . . . . . . . . . . . . 17 3.7.0.4 Servicios Gubernamentales . . . . . . . . . . . . . . . . . . 18 3.7.0.5 Cadena de Suministros . . . . . . . . . . . . . . . . . . . . . 18 3.7.0.6 Salud Púbica/Privada . . . . . . . . . . . . . . . . . . . . . 18 3.7.0.7 Internet de las cosas (Internet of things) . . . . . . . . . . . 19 3.8 Contratos inteligentes y Ethereum . . . . . . . . . . . . . . . . . . . . . . . . 19 3.8.1 Aplicaciones distribuidas (DAPP) . . . . . . . . . . . . . . . . . . . . 19 3.8.1.1 El nacimiento de las DAPPs . . . . . . . . . . . . . . . . . . 19 3.8.1.2 Definición de DAPP . . . . . . . . . . . . . . . . . . . . . . 19 3.8.1.3 Bitcoin como DAPP . . . . . . . . . . . . . . . . . . . . . . 20 3.8.1.4 Clasificación de las DAPP’s . . . . . . . . . . . . . . . . . . 20 3.8.2 Ethereum . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 21 3.8.3 Ethereum Blockchain . . . . . . . . . . . . . . . . . . . . . . . . . . . 21 Contenido xi 3.8.4 Máquina Virtual de Ethereum . . . . . . . . . . . . . . . . . . . . . . 22 3.8.5 Tipos de cuentas en Ethereum . . . . . . . . . . . . . . . . . . . . . . 23 3.8.6 Transacciones . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 24 3.8.7 Gas - Wei . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 25 3.8.8 Minado . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 26 3.8.9 Tiempo de minado y dificultad del bloque . . . . . . . . . . . . . . . 27 3.8.10 Ether . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 27 3.8.11 Contratos Inteligentes(Smart Contracts) . . . . . . . . . . . . . . . . 28 3.8.12 Contratos Inteligentes: Casos de uso . . . . . . . . . . . . . . . . . . . 29 3.8.12.1 Contratos inteligentes para Seguridad Financiera . . . . . . 29 3.8.12.2 Contratos inteligentes para Procesos Derivados . . . . . . . 29 3.8.12.3 Contratos inteligentes para la Captación de Datos . . . . . . 30 3.8.12.4 Contratos inteligentes para Hipotecas . . . . . . . . . . . . . 30 3.8.12.5 Contratos inteligentes en el Ámbito de Seguros . . . . . . . 30 3.8.12.6 Contratos inteligentes en el Ámbito Médico . . . . . . . . . 30 3.8.12.7 Contratos inteligentes junto a Internet de las cosas . . . . . 31 4 Caṕıtulo 4 - Tecnoloǵıas utilizadas 32 4.1 Lenguajes de Programación . . . . . . . . . . . . . . . . . . . . . . . . . . . 32 4.1.1 JavaScript . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 32 4.1.2 Solidity . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 32 4.2 Remix . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 33 4.3 Infura . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 33 4.4 MetaMask . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 33 4.5 NodeJS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 33 4.5.1 Web3 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 33 4.5.2 SolC . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 34 4.5.3 Ganache . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 34 4.5.4 Mocha . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 34 4.6 React . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 34 4.6.1 NextJS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 34 4.6.2 Semantic UI React . . . . . . . . . . . . . . . . . . . . . . . . . . . . 34 4.7 Justificación de tecnoloǵıas . . . . . . . . . . . . . . . . . . . . . . . . . . . . 35 4.7.1 MetaMask . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 35 4.7.2 NodeJS + Web3 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 35 4.7.3 React + NextJS + Semantic UI React . . . . . . . . . . . . . . . . . 35 4.8 Almacenamiento . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 38 4.9 Bases de Datos NoSQL . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 38 4.9.1 Tipos de Bases de Datos NoSQL . . . . . . . . . . . . . . . . . . . . 38 4.9.2 MongoDB . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 39 xii Contenido 4.9.3 Justificación de uso MongoDB . . . . . . . . . . . . . . . . . . . . . . 39 4.10 Inteligencia Artificial . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 39 4.10.1 Anaĺıtica Predictiva . . . . . . . . . . . . . . . . . . . . . . . . . . . . 39 4.10.2 Aprendizaje Automático (Machine Learning) . . . . . . . . . . . . . . 40 4.10.3 Aprendizaje profundo (Deep Learning) . . . . . . . . . . . . . . . . . 40 4.10.4 Mineŕıa de Datos (Data Mining) . . . . . . . . . . . . . . . . . . . . . 41 4.11 Alcance de la Investigación . . . . . . . . . . . . . . . . . . . . . . . . . . . . 41 5 Caṕıtulo 5 - Marco metodológico 42 5.1 Metodoloǵıa de desarrollo y justificación . . . . . . . . . . . . . . . . . . . . 42 5.2 Proceso Ágil Unificado . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 42 5.2.1 Fases . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 43 5.2.2 Disciplinas y actividades . . . . . . . . . . . . . . . . . . . . . . . . . 43 5.2.3 Iteraciones alrededor del tiempo . . . . . . . . . . . . . . . . . . . . . 44 5.2.4 Filosof́ıa del Agile Unified Process . . . . . . . . . . . . . . . . . . . . 46 6 Caṕıtulo 6 - Marco aplicativo 47 6.1 Inicio (Inception) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 47 6.1.1 Propuesta de caso de uso para el TEG . . . . . . . . . . . . . . . . . 47 6.1.1.1 Solución para evitar malversación de bienes y lavado de di- nero en recaudaciones masivas . . . . . . . . . . . . . . . . . 47 6.1.1.2 ¿Qué es una recaudación masiva? . . . . . . . . . . . . . . . 47 6.1.1.3 ¿Qué problemas presentan actualmente las recaudaciones ma- sivas? . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 47 6.1.1.4 ¿Cómo pueden Ethereum y los contratos inteligentes atacar estos problemas? . . . . . . . . . . . . . . . . . . . . . . . . 47 6.1.1.5 Solución . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 48 6.2 Elaboración (Elaboration) . . . . . . . . . . . . . . . . . . . . . . . . . . . . 56 6.3 Construcción (Construction) . . . . . . . . . . . . . . . . . . . . . . . . . . 56 6.3.1 Iteración 0: Acercamiento inicial . . . . . . . . . . . . . . . . . . . . . 56 6.3.1.1 Prueba 0.1 . . . . . . . . . . . . . . . . . . . . . . . . . . . 60 6.3.2 Iteración 1: Compilación y primera prueba automática . . . . . . . . 62 6.3.3 Iteración 2: Segundo acercamiento, reestructuración de pruebas . . . 70 6.3.3.1 Prueba versión 0.2 . . . . . . . . . . . . . . . . . . . . . . . 75 6.3.4 Iteración 3: Rechazo de solicitudes y tasas . . . . . . . . . . . . . . . 82 6.3.4.1 Prueba versión 0.3 . . . . . . . . . . . . . . . . . . . . . . . 89 6.3.5 Iteración 4: Expiración de solicitudes . . . . . . . . . . . . . . . . . . 96 6.3.6 Iteración 5: Construcción cliente web . . . . . . . . . . . . . . . . . . 104 6.3.6.1 Modulo Web3 . . . . . . . . . . . . . . . . . . . . . . . . . . 104 6.3.6.2 Despliegue del contrato en la red . . . . . . . . . . . . . . . 105 Contenido 1 6.3.6.3 Referencias a contratos desplegados en la red . . . . . . . . 106 6.3.6.4 Cliente web . . . . . . . . . . . . . . . . . . . . . . . . . . . 107 6.3.6.5 Rutas de la aplicación web . . . . . . . . . . . . . . . . . . . 110 6.3.6.6 Creación de campañas . . . . . . . . . . . . . . . . . . . . . 112 6.3.6.7 Visualizar los detalles de campañas . . . . . . . . . . . . . . 116 6.3.6.8 Contribuir a una campaña . . . . . . . . . . . . . . . . . . . 120 6.3.6.9 Visualizar solicitudes . . . . . . . . . . . . . . . . . . . . . . 123 6.3.6.10 Creación de solicitudes . . . . . . . . . . . . . . . . . . . . . 132 6.3.6.11 Elementos de interfaz . . . . . . . . . . . . . . . . . . . . . 135 6.3.7 Iteración 6: Almacenamiento de interacciones . . . . . . . . . . . . . 137 6.3.7.1 Servidor MongoDB . . . . . . . . . . . . . . . . . . . . . . . 137 6.3.7.2 Modelos . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 138 6.4 Transición(Transition) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 147 6.4.1 Iteración 0: Pruebas de interfaz de usuario . . . . . . . . . . . . . . . 147 6.4.1.1 Crear campaña . . . . . . . . . . . . . . . . . . . . . . . . . 151 6.4.1.2 Visualizar una campaña / Contribuir a una campaña . . . . 153 6.4.1.3 Crear una solicitud . . . . . . . . . . . . . . . . . . . . . . . 157 6.4.1.4 Aprobar/Rechazar/Finalizar solicitudes . . . . . . . . . . . 159 6.4.1.5 Validación y mensajes de error . . . . . . . . . . . . . . . . 162 7 Caṕıtulo 7 - Conclusiones 164 7.0.1 Seleccionar Caso de Uso . . . . . . . . . . . . . . . . . . . . . . . . . 164 7.0.2 Seleccionar una metodoloǵıa de desarrollo . . . . . . . . . . . . . . . 164 7.0.3 Preparar el ambiente de desarrollo de la plataforma Ethereum . . . . 164 7.0.4 Recopilación de datos . . . . . . . . . . . . . . . . . . . . . . . . . . . 165 7.0.5 Definir almacén de datos . . . . . . . . . . . . . . . . . . . . . . . . . 165 7.0.6 Implementar la aplicación sobre la base tecnológica de cadena de blo- ques y contratos inteligentes . . . . . . . . . . . . . . . . . . . . . . . 165 7.0.7 Pruebas de funcionamiento . . . . . . . . . . . . . . . . . . . . . . . . 165 7.0.8 Pruesta en marcha . . . . . . . . . . . . . . . . . . . . . . . . . . . . 166 7.1 Contribuciones . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 166 7.2 Recomendaciones . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 166 7.3 Trabajos futuros . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 166 Bibliograf́ıa 167 1 Caṕıtulo 1 -Introducción El alza de la tecnoloǵıa en esta época de la humanidad obliga a la sociedad a reinventarse, a medida que surgen nuevas necesidades y problemas que antes no exist́ıan, también surgen nuevas soluciones que pueden transformar todos los paradigmas que se consideraban tradi- cionales en nuevas prácticas más eficientes y que con un enfoque distinto, pueden hacerle frente a los problemas del futuro. En una sociedad tan globalizada como la de hoy en d́ıa, se presentan nuevos desaf́ıos en un abrir y cerrar de ojos, la información que se genera a diario necesita ser validada, y más importante aún, necesita ser preservada a medida que la población aumenta su magnitud de manera tan acelerada. Hace falta un nuevo enfoque que pueda brindarle confianza, seguridad y transparencia a los datos que se generan a diario. Los sistemas centralizados cada vez se ven más afectados por sus problemas de escalabi- lidad al momento de enfrentarse con gigantescos volúmenes de usuarios. A la fecha, una transacción bancaria de grandes cantidades de dinero puede tardarse horas e incluso d́ıas en hacerse efectiva, por el ritmo que lleva la sociedad actual, tal cantidad de tiempo no es lo suficientemente corto como para saciar las necesidades tan espećıficas que requieren millones de empresas cada d́ıa. Adicionalmente a eso, muchas de estas transacciones pasan por varias entidades antes de llegar a su destino final, y es bien conocido que por cada verificación que un tercero realiza a su cliente, todo tipo de impuestos son descontados del valor inicial, perdiéndose aśı gigan- tescas cantidades de dinero sólo en terceros que se encargan de hacer que el dinero llegue de un lugar a otro. Lamentablemente también somos parte de una sociedad donde existe la corrupción y la mal- versación de fondos, existen grandes cantidades de empresas, fundaciones e incluso gobiernos que parecen desaparecer dinero y recursos sin que se vean reflejados en avances en sus pro- yectos o sociedades, dejando muchas dudas sobre quién y cómo se manejan tales fondos. ¿Por qué no existe un sistema directo, transparte, confiable y rápido? . Las criptomonedas fueron los primeros protocolos en atacar los problemas antes mencionados, 3 las mismas brindan una plataforma segura, transparente y eficaz para realizar transacciones de bienes digitales. La espina dorsal de las criptomonedas actuales es conocida como cadena de bloques(Blockchain, en inglés), y esta tecnoloǵıa no se limita sólo al uso en criptomonedas, una cadena de bloques tiene tantos usos como la imaginación del ser humano puede darle. La presente investigación realizará un análisis exahustivo con respecto al desarrollo de apli- caciones que interactúan con la tecnoloǵıa de cadena de bloques mediante el uso de contratos inteligentes. El caṕıtulo II define el planteamiento del problema, justificación, el objetivo general, objeti- vos espećıficos y la arquitectura propuesta para el presente TEG. A lo largo del caṕıtulo III se encuentra el marco teórico, el cual define todos los conceptos teóricos y prácticos que sirven de referencia para el desarrollo planteado. En el caṕıtulo IV se describen las herramientas tecnológicas que se utilizarán durante el desarrollo junto con las justificaciones de uso de las mismas. La metodoloǵıa de desarrollo se describe a lo largo del caṕıtulo V junto con su justificación y fases definidas. El caṕıtulo VI muestra las fases de la metodoloǵıa de desarrollo aplicadas y sigue cuida- dosamente el proceso del desarrollo de la herramienta, junto con pruebas y despligues en ambiente de desarrollo. Finalmente, el caṕıtulo VII corresponde a las conclusiones obtenidas durante todo el desa- rrollo del TEG. 2 Caṕıtulo 2 - Planteamiento del problema 2.1. Planteamiento del problema Las cadenas de bloques pueden aplicarse a todo tipo de ámbitos, desde una pequeña em- presa, pasando por restaurantes, sellos discogáficos, hospitales, empresas multinacionales y hasta administraciones gubernamentales. Básicamente puede aplicarse a cualquier escenario donde quiera llevarse un registro, desde el origen a través del tiempo, de un bien f́ısico o virtual, como puede ser una imagen digital o un neumático de un auto. Con la tecnoloǵıa que componen las cadenas de bloques, un paradigma descentralizado, transparente, confiable y directo se cierne sobre los enfoques tecnológicos actuales. Los enfoques y nuevos paradigmas que plantean las cadenas de bloques y contratos inteli- gentes (Smart contracts, en inglés), prometen dar solución a una gran parte de los problemas que se plantean en los antecedentes de esta investigación, sin embargo, al ser una tecnoloǵıa reciente surgen algunas incertidumbres que son de mucho interés en el ámbito mundial: ¿Es realmente la tecnoloǵıa de cadena de bloques junto a los contratos inteligentes capaces de resolver tales problemáticas?, ¿Qué tan complejo es implementar una solución utilizando estas tecnoloǵıas?, ¿Qué tan efectivas son estas soluciones?, ¿En qué ambientes pueden ser implementadas?, ¿Cómo es posible realizar una recopilación datos dada una cadena de blo- ques?, ¿Es posible encontrar de patrones de comportamiento en esos datos? Ethereum, una plataforma con su propia cadena de bloques y especializada en el alojamien- to de contratos inteligentes con interactúan con ella, sirve como ambiente para el presente trabajo especial de grado, el cual plantea realizar, dado un caso de uso seleccionado, una herramienta que pueda explotar al máximo las ventajas que las cadenas de bloques y los contratos inteligentes pueden brindar para resolver distintas problemáticas (contempladas en la primera parte de este TEG), que requieren de soluciones eficientes y confiables. Adi- cionalmente la recopilación de datos que se agregan en las cadenas de bloques es una tarea fundamental en el desarrollo de la solución que se apoya en este tipo de enfoques jóvenes. 2.2 Justificación 5 2.2. Justificación Debido a la globalización creciente en la tecnoloǵıa, es necesario estudiar el desarrollo de aplicaciones que comiencen a interactuar con estas nuevas tendencias, gracias a que las mis- mas pueden resolver los problemas que van surgiendo a medida que la sociedad evoluciona. Los altos tiempos de espera de transacciones monetarias, las tediosas auditoŕıas, la inter- mediación innecesaria de terceros en diferentes procesos de negociación y el desperdicio de espacio f́ısico en documentos son algunas de las razones por las cuales se debe empezar a adoptar estos enfoques de manera global. Con la adopción masiva de este tipo de tecnoloǵıas, viene siendo crucial encontrar maneras de recopilar datos que pueden de ser vital importancia para estudios futuros, ya que un vez que la forma de almacenar los datos está cambiando, también cambia la forma en la se obtienen esos datos debido a que se vuelven masivos muy rápidamente y la eficiencia es un factor fundamental en la recopilación. La vialidad, es uno de los factores más importantes a la hora de pensar en cualquier solución tecnológica, el presente TEG también plantea evaluar qué tan viables son estos nuevos enfo- ques y desarrollos, qué tanta complejidad se despliega de este tipo de soluciones y finalmente, observar que tan eficientes y eficaces son con respecto al caso de uso seleccionado. Adicionalmente, de cara a estudios futuros que se pueden realizar mediante técnicas como la anaĺıtica predictiva y la inteligencia artificial, junto con, la proyección que este tipo tecno- loǵıas tienen hacia el futuro debido a su transparencia y eficiencia, la tarea de recopilación de datos para ser analizados posteriormente y detectar patrones de comportamiento se vuelve fundamental para brindar una solución completa en todos los aspectos. La posibilidad de generar estos datos estructurados de una manera eficiente para que los expertos en el área de análisis de datos puedan realizar la tarea de analizar apropiadamente dichos datos es una caracteŕıstica innovadora y de vital importancia para este tipo de soluciones. 2.3. Objetivo general: Desarrollar una aplicación basada en un caso de uso previamente seleccionado, sobre la tecnoloǵıa de cadena de bloques (Blockchain) utilizando la plataforma Ethereum y sus con- tratos inteligentes y adicionalmente capturar las iteracciones de los usuarios con la cadena de bloques para ser almacenadas en una base de datos NoSQL. 6 2 Caṕıtulo 2 - Planteamiento del problema 2.4. Objetivos espećıficos: 1. Seleccionar Caso de Uso: Seleccionar una problemática existente a la cual sea viable la aplicación de las herramientas investigadas para dar con soluciones eficientes. 2. Seleccionar una metodoloǵıa de desarrollo: Seleccionar la metodoloǵıa de desarrollo que proponga una estructura de trabajo eficiente para desarrollar una solución eficaz al caso de uso planteado. 3. Preparar el ambiente de desarrollo de la plataforma Ethereum: Preparar las cuentas a utilizar en el ambiente Ethereum para solventar la problemática y proponer una implementación de contrato inteligente. 4. Recopilación de datos: Recopilar las interacciones de los usuarios finales con la cadena de bloques para brindar un conjunto de datos útiles para análisis futuros. 5. Seleccionar almacén de datos: Seleccionar un almacén de datos eficiente para que pue- dan aplicarse algoritmos de anaĺıtica predictiva e inteligencia artificial en el futuro. 6. Implementar la aplicación sobre la base tecnológica de cadena de bloques y contratos inteligentes: Implementar la aplicación de interacción con la cadena de bloques utili- zando Solidity como herramienta desarrollo para resolver la problemática seleccionada. 7. Realizar pruebas de funcionamiento: Realizar pruebas a la aplicación en interacción con la Máquina Virtual de Ethereum en una red local, para verificar su funcionamiento y capacidad para resolver la problemática seleccionada. 8. Poner en marcha: Poner en marcha en un ambiente de producción la aplicación desa- rrollada para validar sus funcionalidades. 2.5. Arquitectura Propuesta para TEG La presente arquitectura (Figura 2-1) presenta una estructura de tres capas principales. La primera capa se encarga de la interacción directa con la cadena de bloques de Ethereum mediante contratos inteligentes, en esta capa ocurre la recopilación de datos a los cuales les serán aplicados los diferentes métodos análiticos y predictivos. 2.5 Arquitectura Propuesta para TEG 7 Figura 2-1: Representación gráfica de la arquitectura propuesta para el TEG. 8 2 Caṕıtulo 2 - Planteamiento del problema En la segunda capa se realiza el preprocesamiento de los datos recopilados y los diferentes algoritmos de anaĺıtica predictiva e inteligecia artifial utilizando una plataforma Big Data. Es la capa intermedia entre la recopilación de los datos y la interfaz de usuario el cual se encarga de mostrar los resultados obtenidos. Finalmente se encuentra la capa de visualización la cual mostrará los resultados obtenidos al usuario final desde la segunda capa. Esta tercera capa está provista de distintos métodos de visualización dependiendo del tipo de indicador que se especifique. 2.6. Alcance del TEG El TEG pretende implementar sólo algunos módulos de la arquitectura planteada, los cuales serán definidos sobre la marcha a medida que se desarrolle el TEG, el resto de los módulos, debido a su amplio espectro de alcance, podŕıan ser implementados en otros TEG en el futuro. La presente investigación se centra en la creación de módulos en la primera capa, con respecto al conector de Ethereum para la recopilación de datos, la definición y llenado del almacén de datos NoSQL contemplado en la segunda capa y posiblemente un elemento de presentación de la capa de visualización 3 Caṕıtulo 3 - Marco teórico 3.1. Cadena de bloques (Blockchain) 3.1.1. Definición Es un libro mayor digital, el cual lleva un registro permanente e incorruptible que facilita el proceso de registro de transacciones que involucran cualquier tipo de bienes (virtuales o no) en una red[35]. Ampliando un poco más este concepto, una cadena de bloques está compuesta por una serie de bloques enlazados cronológicamente y que contienen transacciones que no pueden modificarse una vez insertadas en la cadena. Esta herramienta se vale de la combinación de diferentes tecnoloǵıas tales como la criptograf́ıa, los Árboles Merkle, llaves asimétricas y firmas digitales para lograr la continuidad en el tiempo y la inmutabilidad. La cadena comienza con un bloque génesis, con una marca de tiempo, de este bloque inicial nacen todos los demás bloques de la cadena, cuando se cree un nuevo bloque (el segundo bloque en este caso) este estará enlazado con el bloque génesis a través de un apuntador que tendra direccón al código SHA-256 del primer bloque, cuando un tercer bloque sea creado, se enlazará con el código SHA-256 del anterior y aśı sucesivamente (con sus respectivas marcas de tiempo). De esta forma, el protocolo se apoya en la criptograf́ıa para crear un sistema incorruptible, ya que, si alguien quisiera modificar algún bloque en el pasado de la cadena, esto modificaŕıa su hash, lo cual ocasionaŕıa que todos los demás bloques tuvieran apuntadores incorrectos, lo que disparaŕıa un error inmediatamente en la red. Los bloques pueden tener apuntadores a los códigos hash de las ráıces de Árboles Merkle los cuales almacenan transacciones de una manera eficiente para poder tener un rápido acceso a ellas en caso de requerir alguna consulta, si bien esta implementación no es necesaria, se ha vuelto muy popular a través de diferentes cadenas de bloques. Una cadena de bloques puede ser privada o pública, lo cual puede dar acceso a los bloques a nodos espećıficos de la red, lo cual puede asegurar la privacidad de la cadena en caso de poseer datos sensibles a todos los usuarios, se utilizan firmas digitales para firmar cada bloque, valiéndose de llaves públicas y privadas para firmar los bloques y que puedan ser verificados sólo por los nodos seleccionados. La Figura 3-1 muestra la estructura de una cadena de bloques. 10 3 Caṕıtulo 3 - Marco teórico Figura 3-1: Representación gráfica de una cadena de bloques. Recuperado y traducido de: https : //bitcoin.org/en/developer � guide 3.2. Propiedades deseables Para construir un libro mayor digital para uso en un ambiente como la red internet y donde los participantes no tienen relaciones de confianza, la estructura de datos (cadena de blo- ques), debe contar con algunas propiedades deseables[40]: 1. El libro mayor debe ser inmutable, y de manera más precisa, la estructura de datos úni- camente debe permitir agregar datos (append-only), no es posible modificar, remover o reordenar datos existentes. 2. Debe haber una manera de obtener un resumen criptográfico del estado de la estructura en cualquier momento. 3. Un resumen criptográfico es un dato de tipo string, corto, que evita tener que almacenar la estructura de datos completa. Si la estructura de datos fue manipulada de alguna manera, el resumen criptográfico resultante cambiaŕıa, por lo tanto se detectaŕıa la manipulación. La justificación de estas propiedades, es que a diferencia de una estructura de datos regular que está almacenada en una única máquina, el libro mayor digital es una estructura de datos global mantenida colectivamente por un conjunto de participantes sin relaciones mutuas de confianza. Este funcionamiento contrasta con otro enfoque para decentralizar libros mayores digitales, en donde muchos participantes mantienen libros mayores locales y es responsabilidad del 3.3 Antecedentes académicos 11 usuario hacer consultas en el conjunto de libros mayores para resolver cualquier conflicto. 3.3. Antecedentes académicos La estructura de la cadena de bloques de la criptomoneda Bitcoin, es tomada prestada con unas mı́nimas modificaciones, de una serie de art́ıculos de Stuart Haber y Scott Stornetta, escritos entre 1990 y 1997[44]. El trabajo de Haber y Stornetta está relacionado con los problemas del marcado de tiempo (timestamp) de documentos, orientados a construir un servicio de tipo ”notaria digital”. Para patentes, contratos de negocios y otros documentos de valor, es deseable registrar el tiempo de creación de un documento en un momento dado y no más tarde. La noción de documento en el trabajo de Haber y Stornetta es bastante general y podŕıa ser de cualquier tipo de dato; aunque mencionan transacciones financieras como una potencial aplicación, no era el foco de la publicación. En una versión simplificada de la propuesta de Haber y Stornetta, los documentos están constantemente siendo creados y transmitidos. El creador de cada documento establece un tiempo de creación, firma el documento, coloca la marca de tiempo y un apuntador al do- cumento previamente transmitido. Este documento previo, a su vez, apunta a su predecesor, de manera que los documentos forman una cadena con apuntadores en sentido inverso al tiempo. Un usuario externo no puede alterar el mensaje con su marcado de tiempo ya que está firmado por el creador, y el creador no puede alterar el mensaje sin también alterar la cadena entera de mensajes que le suceden. Si se obtiene un único item de la cadena a través de una fuente confiable (otro usuario o un servicio especializado de marcado de tiempo), la cadena entera hasta ese punto está blo- queada, es inmutable y está temporalmente ordenada. En art́ıculos sucesivos, Haber y Stornetta introducen otras ideas que hacen que esta estruc- tura de datos sea mas efectiva y eficiente: 1. Los enlaces entre documentos pueden ser creados usando hashes en vez de firmas; el hash es mas simple y fácil de procesar, estos enlaces son denominados apuntadores hash. 12 3 Caṕıtulo 3 - Marco teórico 2. En vez de indexar documentos individualmente, lo cual puede ser ineficiente si muchos documentos son creados aproximadamente al mismo tiempo. La propuesta es agrupar los documentos en grupos o bloques, donde los documentos en cada bloque tienen esencialmente la misma marca de tiempo. 3. En cada bloque, los documentos pueden ser enlazados entre ellos con apuntadores hash en un árbol binario, denominado árbol Merkle, en vez de una cadena lineal. De manera casual, Josh Benaloh y Michael de Mare independientemente introducen estas tres ideas en 1993[36], poco después del primer art́ıculo de Haber y Stornetta. 3.4. Bitcoin Blockchain La criptomoneda Bitcoin usa esencialmente la estructura de datos en los art́ıculos de Haber y Stornetta de los años 1991 y 1997, y hacen reingenieŕıa de sus propiedades de seguridad anadiendo el esquema de comprobación de trabajo (proof-of-work, en inglés). Bitcoin y su cadena de bloques, puede ser la mejor instanciación conocida de las estructuras de datos de Haber y Stornetta. Sin embargo, no es la primera implementación, al menos dos empresas hab́ıan tenido una aproximación. A mediado de la década de 1990, la empresa Surety y en el año 2007, la empresa Guardtime ofrecen servicios de marcado de tiempo de documentos. 3.5. Árboles Merkle Es una estructura de datos, que recibe el nombre por Ralph Merkle, un pionero de la crip- tograf́ıa asimétrica que propuso la idea en un art́ıculo en el año 1980[39]. El objetivo era producir un resumen para un directorio público de certificados digitales. La Figura 3-2 ilustra de manera simplificada la estructura de datos propuesta por Haber y Stornetta, que enlaza los bloques marcados de tiempo usando apuntadores hash. 3.5 Árboles Merkle 13 Figura 3-2: Representación simplificada de la estructura de datos que enlaza bloques mar- cados de tiempo. 14 3 Caṕıtulo 3 - Marco teórico El árbol Merkle es un árbol (Generalmente binario, pero no necesariamente) que almacena datos en sus nodos hoja, por cada nodo hoja que contiene datos es generado su código hash y se concatena con el código hash de su nodo hermano, a la concatenación de estos dos hash, se le vuelve a aplicar la misma función criptográfica, la cual se convierte en el nodo padre de dichos nodos hojas, este proceso se repite sucesivamente hasta llegar a la ráız del árbol. Esta estructura es utilizada debido a que el orden de acceso de un árbol es menor que usar una estructura secuencial. Las transacciones de Bitcoin toman la forma de documentos. En el árbol Merkle de cada blo- que, los nodos hoja son transacciones, y cada nodo internamente consiste de dos apuntadores. Esta estrucutra de datos tiene dos propiedades importantes. Primero, el hash del último blo- que es un resumen. Algún cambio a cualquiera de las transacciones (nodos hoja) requerirá propagar los cambios hasta la ráız del bloque, y las ráıces de todos los bloques.Por lo tanto, si se conoce el último hash, es posible obtener el resto del libro mayor desde una fuente no confiable y verificar que no ha cambiado. Un argumento similar establece otra propiedad importante de la estructura de datos, se puede probar eficientemente que una transacción particular está incluida en el libro mayor. El usuario tendŕıa que enviar un pequeño número de nodos en ese bloque de la transacción (este es el objetivo del árbol Merkle), aśı como una pequeña cantidad de información para cada siguiente bloque. La habilidad para probar inclusión de transacciones eficientemente es altamente deseable por rendimiento y escalabilidad. La figura 3-3 ilustra en detalle el árbol Merkle en un bloque de la cadena de bloques. 3.5 Árboles Merkle 15 Figura 3-3: Cadena de bloques y el árbol Merkle. Recuperado y traducido de: https : //bitcoin.org/bitcoin.pdf 16 3 Caṕıtulo 3 - Marco teórico 3.6. Prueba de trabajo (Proof-Of-Work) Es un método de consenso que se popularizó mediante su uso en la plataforma de Bitcoin[40], pero en realidad tiene sus ráıces en el sistema Hashcash propuesto por Adam Back para com- batir los ataques DDOS y correo spam[31]. Se fundamenta en el hecho de que el emisor de un mensaje debe realizar tareas que tengan cierto tipo de valor (computacional en este caso) para poder enviar su mensaje, de esa manera, un ataque DDOS podŕıa llegar a ser excesi- vamente caro y si bien no puede neutralizarlo per se, al menos haŕıa que al atacante tuviera que invertir considerables cantidades de poder computacional para saturar algún servidor mediante volumenes masivos de solicitudes, lo mismo ocurre con el correo spam, un emisor de correo spam podŕıa pensárselo dos veces antes enviar miles de correos a distintas direcciones de correo. Dado el enfoque anterior y orientando esta idea a la cadena de bloques, el proceso involucra resolver un problema computacional, el cual requiere una gran cantidad de poder para resol- ver, pero un mı́nimo de poder para validar si la solución encontrada es la correcta. Una vez que se ha invertido el poder computacional para resolver dicho problema, toda la red de la cadena de bloques puede invertir un mı́nimo esfuerzo para comprobar si el esfuerzo inverti- do para validar el bloque resolvió el acertijo computacional planteado para validar un bloque. La resolución del acertijo computacional se relaciona con la obtención de un hash de la solución el cual tenga una estructura definida (Puede ser una cantidad de bits en cero al inicio del hash) por el protocolo, la cual puede variar según la cadena de bloques en la cual se desarrolle esta prueba de trabajo. 3.7. Casos de uso de las cadenas de bloques Ya establecidas las bondades que pueden facilitar las cadenas de bloques, los escenarios en los cuales puede aplicarse son muy diversos[35]. A continuación se analizan los casos de uso más importantes dónde la cadena de bloques destaca por los beneficios que ofrece: 3.7.0.1. Criptomonedas Probablemente el caso de uso más famoso de la cadena de bloques. Las criptomonedas, según Usman[33] pueden definirse como bienes digitales que pueden ser intercambiados entre dis- tintos entes. Dichos bienes estan sustentados bajo principios critpográficos que aseguran el flujo transaccional que genera el intercambio de estas monedas digitales, ademas de controlar la creación de bienes adicionales con respecto a las mismas. Existen una gran cantidad de criptomonedas hoy en d́ıa las cuales han logrado gran aceptación a nivel mundial y, hasta la 3.7 Casos de uso de las cadenas de bloques 17 fecha, siguen aumentando su valor. 3.7.0.2. Servicios financieros Las empresas siempre necesitan hacer compras de grandes cantidades de elementos a crédito para, por ejemplo, conseguir materia prima que se procesa y se vende a otra empresa. Los pagos que se realizan pueden pasar por varios intermediarios antes de que el dinero pueda llegar a su destino final, y por cada intermediario que forma parte de la transacción este gana un pequeño porcentaje. Con la cadena de bloques se forma una ĺınea de tiempo donde puede verse la traza que van dejando los fondos a medida que pasan por los diferentes inter- mediarios, de manera que una disputa con respecto a una transaccón puede ser fácilmente resuelta observando la cadena de bloques y verificando cada bloque que puede auditarse y resolver cualquier malentendido que pueda presentarse de manera transparente. Además de la ventaja anteriormente mencionada, si varias empresas deciden implementar su propia cadena de bloques pueden librarse de los intermediarios que manejan sus fondos y aśı ahorrar grandes cantidades de dinero en impuestos de transacciones que imponen estas organizaciones intermediarias. Una cadena de bloques semi-privada puede implementarse donde sólo las empresas que for- marán parte de la red pueden observar el flujo de los fondos que van desde una organización a otra y auditarlas en caso de algún inconveniente, todo esto ligado también al hecho de que pueden generarse contratos inteligentes entre las empresas que forman parte de la cadena de bloques para que las transacciones de realicen de manera automática y además, de una manera incorruptible y transparente. 3.7.0.3. Servicios de pólizas de seguros Las empresas aseguradoras necesitan una plataforma que brinde velocidad para solicitudes, verifique pólizas, procese eventos cubiertos por dicha póliza y además, ofrezca una rápida respuesta a los usuarios miembros con el fin de cumplir sus obligaciones a cabalidad. La cadena de bloques ofrece la capacidad de realizar un procesamiento de pólizas automático mediante la implementación de contratos inteligentes en la cadena de bloques, de esta ma- nera, cuando ocurre un evento asegurado, y este proviene de una fuente confiable, la poĺıtica de seguro es automáticamente activada y realiza el pago según las tarifas especificadas en el contrato inteligente. Este enfoque no sólo brinda una plataforma estable y confiable, sino que también brinda rápida respuesta al usuario lo cual aumenta su satifacción con la empresa. 18 3 Caṕıtulo 3 - Marco teórico 3.7.0.4. Servicios Gubernamentales Una considerable parte de las instituciones gubernamentales deben realizar o supervisar grandes cantidades de transacciones las cuales implican grandes volumenes de fondos y podŕıa ser necesario verificar su procedencia y destino. La cadena de bloques puede ser utilizada para formar una red de entidades gubernamen- tales confiables las cuales pueden verificar todo tipo de transacciones y además, llevar un seguimiento acertado de todos los eventos que pueden emerger de manera imprevista, mu- chos ciudadanos pierden sus identificaciones a diario, la identidad de los ciudadanos puede fácilmente representarse en una cadena de bloques y en caso de que un ciudadano pierda su identificación, puede ubicarse rápidamente su identidad siguiendo su traza en la cadena de bloques obteniendo toda la información necesaria para comprobar que dicho ciudadano es quien dice ser. Cada vez que un ciudadano compra una propiedad y necesita registrarla localmente o re- gionalmente, puede asociarse este nuevo bien a la cadena de bloques de dicho ciudadano, siempre pudiendo verificar el origen de los fondos con los que lo obtuvo, si realizó un cambio de nombre de alguna de sus empresas o si quiere agregar un socio a un contrato inteligente dentro de la misma cadena. El mismo principio puede aplicarse para certificados de residencia, partidas de nacimiento, estudios realizados y t́ıtulos de propiedad, cada uno de estos valores con su marca de tiempo que le da veracidad a toda esta información. 3.7.0.5. Cadena de Suministros Las cadenas de suministros en general, son parte de un gran sistema de sistemas, cuando ocurre alguna falla en alguno de estos sistemas a veces puede ser engorroso encontrar el elemento que ocasionó la falla y rectificar se convierte en una tarea complicada. Una cadena de bloques puede brindar detalles de cada etapa de la cadena de suministros junto con marcas de tiempo certeras para ayudar a encontrar fallas en complejas cadenas de suministros, además aporta: Confianza incrementada alrededor de toda la cadena de suministros, dado que cada elemento de la red es parte del sistema y no existe un ”propietario”de toda la cadena de bloques. Optimización del tiempo utilizado para realizar diagnóstico y solucionar fallas en la cadena de suministros. 3.7.0.6. Salud Púbica/Privada La industria médica necesita sistemas más certeros y eficientes para mantener los registros de sus pacientes, pre-aprobar pagos realizados para intervenciones quirurǵıcas y realizar compras 3.8 Contratos inteligentes y Ethereum 19 de medicamentos vitales para su funcionamiento, la cadena de bloques provee soluciones eficientes para cada uno de estos aspectos. Los registros médicos electrónicos generalmente se almacenan en sistemas centralizados y su acceso suele ser limitado a la misma red hospitalaria o a agencias de seguros. La cadena de bloques brinda la historia médica entera de un paciente con una granularidad personilazada según la cadena de bloques implementada a la que pod́ıa acceder cualquier hospital que se encuentre dentro de la red, ahorrando aśı recursos a la hora de que un pa- ciente requiera ser atendido no importa el lugar donde se encuentre, de igual forma puede observarse la evolución de cierto tipo de enfermedades, e incluso actualizar contratos inteli- gentes para la compra de medicinas imprescindibles para la recuperación de los pacientes de manera inmediata. 3.7.0.7. Internet de las cosas (Internet of things) Los dispositivos actuales interactúan entre ellos mucho más de lo que suced́ıa hasta hace unos pocos años, cualquier interacción importante puede ser almacenada en una cadena de bloques privada lo cual facilitaŕıa el monitoreo de estos dispositivos y haŕıa mucho más sencilla la tarea de encontrar fallas en estos sistemas que cada d́ıa se vuelven más complejos. 3.8. Contratos inteligentes y Ethereum 3.8.1. Aplicaciones distribuidas (DAPP) David Johnston y su equipo[28] de desarrollo presentan la siguiente estructura que define una DAPP y sus caracteŕısticas: 3.8.1.1. El nacimiento de las DAPPs Una nueva aproximación está surgiendo para desarrollar aplicaciones altamente escalables y potentes. Bitcoin fue el pionero en esta nueva tendencia, con su caracteŕısticas relacionadas a código abierto, conectividad P2P (Red entre iguales o red entre pares, por sus siglas en inglés[43] ), criptograf́ıa e integración con las cadenas de bloques. Un considerable número de aplicaciones está adaptando este esquema, siendo Ethereum una de las más notables, la cual implementa su propia cadena de bloques para operar en su plataforma. 3.8.1.2. Definición de DAPP Para que una aplicación pueda considerarse DAPP, debe seguir el siguiente criterio: La aplicación debe ser en su totalidad código abierto, debe operar de manera autónoma y sin ningún tipo de control por parte de cualquier organizacón. La aplicación puede 20 3 Caṕıtulo 3 - Marco teórico adaptarse a protocolos propuestos en respuesta a las necesidades dinámicas que se presentan a lo largo de su evolución, pero todos los cambios deben realizarse en consenso con sus usuarios. Los registros y data de la aplicación deben ser almacenados mediante el uso de cripto- graf́ıa, en una cadena de bloques pública y descentralizada para evitar puntos centrales de fallo. La aplicación debe hacer uso de un token criptográfico el cual es necesario para ac- ceder a la aplicación y todas las contribuciones (a mineros) de recompensa deben ser asignadas en dichos tokens. La aplicación debe generar tokens acorde a un algoritmo criptográfico estándar que actúa como una prueba de contribución de los nodos a la plataforma de la aplicación (Ya sea Prueba de trabajo u otro algortimo). 3.8.1.3. Bitcoin como DAPP Bitcoin ha demostrado ser una solución eficiente a los problemas que surgen al momento de implementar una red autónoma puerto a puerto utilizando su propia cadena de bloques. Lo más importante con respecto al tema de interés de la presente investigación, es que Bitcoin se considera una DAPP, por las siguientes razones: La plataforma y software de Bitcoin es en su totalidad código abierto, no es controlada por ninguna entidad u organización y todos los datos y registros son públicos a toda el ecosistema. Bitcoin genera sus tokens (bitcoins), con un algoritmo predeterminado que no pue- de ser cambiado, y dichos tokens son necesarios para el funcionamiento de Bitcoin. Los mineros de Bitcoin son recompensados con bitcoins por su trabajo asegurando la integridad de la red. Todos los cambios en Bitcoin deben ser aprobados mayoritariamente en un consenso utilizando el mecanismo de Prueba de trabajo. 3.8.1.4. Clasificación de las DAPP’s Existen varias caracteŕısticas que definen la clasificación de una DAPP, la clasificación de- penderá mayormente de si la aplicación utiliza su propia cadena de bloques o utiliza una cadena de bloques de otra DAPP para lograr sus funciones, en base a lo anterior: Tipo I : Aplicaciones descentralizadas las cuales implementan su propia cadena de bloques, el ejemplo primordial de este tipo de DAPP es Bitcoin, también todas las criptomonedas nativas (Lite-coin, Binance-coin, etc.) participan en esta clasificación. 3.8 Contratos inteligentes y Ethereum 21 Tipo II : Aplicaciones descentralizadas que hacen uso de las cadenas de bloques de las aplica- ciones Tipo I para lograr sus funciones. Son protocolos que tienen acceso a tokens para poder desenvolverse en el ecosistema de la aplicación Tipo I. Tipo III : Aplicaciones descentralizadas que hacen uso de las cadenas de bloques de las aplica- ciones Tipo II para lograr sus funciones. Al igual que las Tipo II, aplican protocolos que se desenvuelven en plataformas de aplicaciones de clasificación Tipo II. Una analoǵıa apropiada para entender las clasificaciones de DAPP’s, es la siguiente, la clasi- ficación Tipo I equivale a un sistema operativo tal como Windows, Linux, Mac, etc. Mientras que las Tipo II podŕıan equivaler a un procesador de texto, o sistema de sincronización de archivos, como Dropbox. Un ejemplo de una DAPP Tipo III seŕıa un software especializado tal como una aplicación que una varios correos electrónicos o una plataforma de blogs que se sincronize con algún editor de texto. Utilizando la analoǵıa anterior, es altamente probable que existan muy pocas aplicaciones de Tipo I, una cantidad superior de DAPP Tipo II y aún más del Tipo III. 3.8.2. Ethereum Ethereum es una plataforma para la creación de DAPPs, la misma se presenta como una red puerto-a-puerto(P2P)[43] que tiene integrada su propia cadena de bloques, esta interactúa con la máquina virtual de Ethereum con el fin de proveer un ambiente seguro, integral, transparente y eficiente para construir aplicaciones que dejen registro de sus actividades en dicha cadena de bloques[32]. 3.8.3. Ethereum Blockchain Según Vitalik, principal contribuyente de Ethereum [32], la cadena de bloques de Ethereum es muy similar a la implementada en Bitcoin. La diferencia principal entre Ethereum y Bitcoin con respecto a la arquitectura de su cadena de bloques, es que, a diferencia de Bitcoin, los bloques de Ethereum poseen una copia tanto de la lista de transacciones como del estado más reciente de la cadena. Adicional a lo descrito anteriormente, dos valores que corresponden al número de bloque y la dificultad, respectivamente, los cuales son almacenados también en el bloque. El algoritmo de validación básica de bloques obedece el siguiente flujo: Validar si el apuntador al bloque anterior existe y además, es válido. Verificar si la marca de tiempo es mayor a la marca de tiempo del bloque referenciado anterior y menor a 15 minutos en el futuro. Verificar si el número del bloque, dificultad, ráız de la transacción, ráız del bloque huérfano más cercano y ĺımite de GAS(Ver Sección 3.8.7), son válidos 22 3 Caṕıtulo 3 - Marco teórico Verificar si la Prueba de trabajo del bloque es válida Sea S[0] el estado final del bloque anterior. Sea Tx la lista de transacciones del bloque, con n transacciones: 8i 2 {0, 1, 2,...,n} ! S[i+ 1] = APLICAR(S[i], Tx[i]) Si alguna aplicación resulta en error, o si el GAS total consumido hasta el momento en el bloque excede el ĺımite de GAS establecido, retornar un error. Sea S FINAL = S[n], ahora agregando la recompensa del bloque pagada al minero. Validar si la ráız del Árbol Merkle del estado S FINAL es igual al estado final encon- trado en la cabecera del bloque. Si esto ocurre, el bloque es válido, de lo contrario, no es válido. En la Figura 3-4 se observa una representación de la cadena de bloques de Ethereum. Figura 3-4: Representación gráfica de la cadena de bloques de Ethereum. Con respecto a Ethereum y su cadena de bloques, para los efectos dentro de esta inves- tigación, se pueden ubicar estos elementos como las bases que darán forma al resto de la herramienta, se puede apreciar la representación de estos elementos en la parte baja de la arquitectura (Figura 3-5). 3.8.4. Máquina Virtual de Ethereum En el corazón de Ethereum reside la Máquina Virtual de Ethereum, que puede ejecutar algoritmos arbitrariamente complejos. En Ciencias de la Computación se conoce como un sistema Turing completo, un sistema Turing completo es aquel que tiene un poder compu- tacional equivalente a la máquina de Turing universal[8]. Los desarrolladores pueden crear aplicaciones distribuidas que se ejecutan en la Máquina Virtual de Ethereum utilizando lenguajes de alto nivel como JavaScript y Python. Cada nodo perteneciente a la red de Ethereum utiliza la Máquina Virtual de Ethereum para realizar las interacciones con la cadena de bloques. 3.8 Contratos inteligentes y Ethereum 23 Figura 3-5: Ethereum y su cadena de bloques en la arquitectura planteada. 3.8.5. Tipos de cuentas en Ethereum Las interacciones entre usuarios dentro de la red Ethereum se realizan a través de dos tipos de cuentas soportadas por la plataforma, las primeras son las cuentas externas (External Owned Accounts, en inglés) y las cuentas de contrato (Contract accounts)[1]. Las cuentas externas, son cuentas controladas externamente, las mismas presentan las si- guientes caracteŕısticas: 1. Tienen balance en ether. 2. Enviar transacciones (Transmitir ether o activar el código de un contrato inteligente). 3. Es controlada por llaves privadas. 4. No tienen código asociado. Las cuentas contrato cuentan con estas caracteŕısticas: 1. Tienen balance en ether. 2. Posee un código asociado. 3. La ejecución del código es disparada por transacciones o llamadas desde otros contratos 24 3 Caṕıtulo 3 - Marco teórico 4. Pueden llamar a otros contratos. Todas las acciones en la cadena de bloques de Ethereum es puesta en marcha por transac- ciones realizadas por cuentas externas. Cada vez que un contrato recibe una transacción, el código es ejecutado e instruido por la entrada recibida en la transacción, el código es ejecu- tado por la máquina virtual de Ethereum en cada nodo participante en la transacción como parte de la verificación de nuevos bloques. 3.8.6. Transacciones La documentación oficial de Ethereum[32] describe una transacción como un paquete de datos seguro que almacena un mensaje a ser enviado por una cuenta externa de Ethereum. Las transacciones contienen 1. Nonce del emisor de la transacción. 2. Dirección de destino. 3. Firma que identifica al emisor del mensaje. 4. El monto de ether que se transfiere desde el emisor del mensaje a la dirección destino. 5. Un campo opcional para datos. 6. Un valor denominado STARTGAS o GASLIMIT (Definido por el emisor), que re- presenta la capacidad máxima de cómputo (medido en instrucciones) que la ejecución de la transacción puede realizar. 7. Un valor denominado GASPRICE (Definido por el emisor), que representa la cuota (en wei) que paga el emisor por instrucción ejecutada Los primeros cuatro elementos de la transacción estan impĺıcitos en cualquier criptomoneda el campo opcional de datos no tiene una función esperada por defecto, sin embargo, gracias a la máquina virtual de Ethereum el campo de datos de una transacción puede utilizarse como entrada en la ejecución de un contrato inteligente. En la Figura 3-6 se observa una representación de una transacción en Ethereum. Los campos STARTGAS y GASPRICE son fundamentales para el modelo anti-DDOS de Ethereum. Para poder blindarse contra accidentes o ataques hostiles contra la red, cada transacción debe especificar una cantidad finita de cómputo que será realizado por la máquina virtual. La unidad mı́nima de cómputo utilizada por un contrato es conocida como GAS. 3.8 Contratos inteligentes y Ethereum 25 Figura 3-6: Representación gráfica de una transacción en Ethereum. 3.8.7. Gas - Wei El GAS puede representarse como el ’combustile’ de una transacción en Ethereum, usual- mente, una instrucción computacional cuesta 1 GAS, pero algunas operaciones tienen un costo más elevado de GAS que otras, debido a su complejidad y necesidad de consumir más poder de cómputo para ser realizadas o por la necesidad de almacenar mayores cantidades de datos en la cadena de bloques. Existe una tasa adicional de 5 GAS por byte en los de datos de la transacción. La intención de este sistema de tasas, es que un atacante tendrá que invertir una cantidad de GAS proporcional a los recursos que utilizará en la red, incluyendo, cómputo, almacenamiento e iteraciones. Wei representa una notación de Ether (1 wei = 0.000000000000000001 ether), las tasas mencionadas son pagadas por el emisor de la transacción. 26 3 Caṕıtulo 3 - Marco teórico La Figura 3-7 representa un ejemplo del uso de GAS. Figura 3-7: Ejemplo de costos de GAS. La Figura 3-8 representa el costo total de una transacción. Figura 3-8: Ejemplo de costo final de una transacción 3.8.8. Minado Una vez una transacción ha sido validada por la red, pasa a un estado ”pendiente”, cuando una transacción está en este estado, reside en una piscina de transacciones las cuales son seleccionadas por los nodos conocidos como mineros (miners, en inglés), estos nodos, se en- cargan de ejecutar estas transacciones con la finalidad de ganar las tasas establecidas por el cómputo proporcionado. Cuando una transacción es seleccionada para ser minada, se le asigna un nonce (No debe confundirse con el nonce de la transacción), este nonce, es el valor a ser iterado para generar un hash válido que cumpla con el requisito de la red. 3.8 Contratos inteligentes y Ethereum 27 3.8.9. Tiempo de minado y dificultad del bloque El tiempo de minado establecido por la red para una transacción es de 15 segundos aproxi- madamente, este tiempo depende de la dificultad actual del bloque, la dificultad del bloque es la cota del hash generado por el nonce del bloque, en caso de que el tiempo sea mayor a 15 segundos, la dificultad del bloque baja, en caso de que sea menor a 15 segundos, la dificultad aumenta. La Figura 3-9 muestra un ejemplo de minado de una transacción con dificultad 100. Figura 3-9: Ejemplo minado de una transacción con dificultad 100 Una vez que se encontró el nonce que valida la transacción, el nodo minero realiza un anuncio a toda la red anunciando que la transacción fue ’minada’ y se procede a almacenarla en la cadena de bloques de Ethereum. 3.8.10. Ether Según la organización oficial de Ethereum [30], el Ether se define como un elemento necesario para poder realizar operaciones de aplicaciones distribuidas en la plataforma Ethereum. Es la forma de pago realizada por los clientes de la plataforma a las máquinas que ejecutan las operaciones solicitadas. La primera emisión de Ether fue realizada en el año 2014, arrojando los siguientes resultados: 60 millones de Ether emitidos a los contribuyentes de la primera preventa. 12 millones de Ether del punto anterior, fueron destinados al fondo de desarrollo, la mayoŕıa siendo asignado a los primeros desarrolladores de la plataforma y el resto a la fundación Ethereum. Consenso en el que se generan 5 Ether por bloque, asignados al que minó dicho bloque. 28 3 Caṕıtulo 3 - Marco teórico Entre 2 y 3 Ether son asignados a los mineros que también minaron dicho bloque, pero que su solución no fue incluida en la cadena de bloques (Conocidos como bloques huérfanos o aunt/uncle� blocks). El punto anterior no implica que el Ether sea un recurso infinito, según el acuerdo entre todos los entes participantes en el desarrollo de la plataforma, la emisión de Ether está aco- tada por 18 millones de Ether al año. Esto significa que, mientras la emisión máxima está acotada, la inflación relativa se disminuye cada año. En teoŕıa, si esta emisión se mantiene de forma indefinida, en algún punto el rango de generación de nuevos tokens creados cada año alcanzaŕıa el monto promedio de tokens perdidos anualmente (Por falta de uso, pérdida accidental, muerte del propietario, etc.) y finalmente, se alcanzŕıa un equilibrio. El Ether está destinado a ser utilizado por todos los usuarios que quieran construir apli- caciones que interactuen con la cadena de bloques de Ethereum y además, por todos los usuarios que quieran acceder e interactuar con contratos inteligentes en la cadena de bloques de Ethereum. 3.8.11. Contratos Inteligentes(Smart Contracts) De todos los datos que pueden guardarse en una cadena de bloques, los contratos inteligentes vienen siendo una de las adiciones más atractivas para lo mayoŕıa de los casos de uso. Un contrato inteligente, haciéndo una analoǵıa con su contraparte f́ısica, es un acuerdo automatizado y ejecutable[34]. Son una serie de promesas que son especificadas de manera digital, que incluye los protoco- los mediante los cuales las partes involucradas deben realizar dichas promesas. Mientras que es automatizado por algún elemento computacional, puede o no requerir la intervención de control humano. Dicho contrato representa una relación entre dos o más entes que se realiza bajo ciertas condiciones, la ventaja en el uso de contratos inteligentes, radica en que estan enteramente supervisados tanto por entidades legales que los construyen, aśı como cuerpos computacionales que los ejecutan, haciéndolos a prueba de fraudes. En lo que a Ethereum se refiere, un contrato inteligente, habita en el ecosistema de su cadena de bloques, el mismo posee una serie de instrucciones que deben ejecutarse a medida que se cumplen las condiciones establecidas en él, cada una de estas instrucciones tiene un costo en Ether, es decir, un contrato elaborado bajo una mala praxis en términos de programación podŕıa ser excesivamente costoso en términos de Ether, por ejemplo, aplicar una función de adición de dos números enteros, es mucho menos costosa en Ether que aplicar una función criptográfica que calcule el hash de un serial de identificación. Es de notoria importancia señalar que las transacciones poseen una cantidad máxima de Ether (GASLIMIT ) que no debe ser superada por la suma de Ether de todas las intrucciones del contrato inteligente, en caso de superar el ĺımite, se hace un rollback de toda la transacción y el emisor de la misma 3.8 Contratos inteligentes y Ethereum 29 no recibe el Ether invertido de regreso, en caso de que el Ether invertido en la transacción sea menor al GASLIMIT , pero logró cubrir los costos de todas las operaciones, el exceso de Ether es devuelto al emisor de la transacción. 3.8.12. Contratos Inteligentes: Casos de uso La Cámara Digital de Comercio ya se encuentra trabajando en el uso de contratos inteligen- tes, la misma, comenta lo siguiente [25]: ’Los contratos inteligentes permiten a individuos poseer y controlar su identidad digital, conteniendo reputación, datos y bienes digitales. Esto permite a los individuos decidir qué datos compartir a sus contrapartes, dando a las empresas la oportunidad de utilizar únicamente los datos necesarios.’ Tomando en cuenta lo mencionado anteriormente, algunos de los casos de uso de los contratos inteligentes más innovadores son: 3.8.12.1. Contratos inteligentes para Seguridad Financiera Los contratos inteligentes pueden manejar automáticamente el pago de dividendos, divisiones de acciones y gestión de pasivos, mientras que reduce los riesgos operacionales de confiar operaciones a terceros. Entre las bondades que brindan podemos nombrar: Digitalizar flujos de trabajo debido a la confianza del almacenamiento en una cadena de bloques. Reducir el riesgo de intromisión de terceros en manejo de capital. Ciclos de pagos asegurados gracias a las marcas de tiempo. 3.8.12.2. Contratos inteligentes para Procesos Derivados Los procesos de post-negociación, pueden ser manejados v́ıa contratos inteligentes, elimi- nando procesos duplicativos de recursos en ambas entidades luego de realizar un acuerdo comercial. Basta con observar los beneficios: Asignación de obligaciones de manera automática, mientras que se ejecutan eventos repetitivos una vez terminada una negociacióm (Por ejemplo, ciclos de pago periodicos). Procesamiento de eventos externos o de sucesión (Aprobación de un crédito, por ejem- plo). Permite la evalución de movimientos financieros en tiempo real, el cual aumenta el nivel de seguridad y confianza, mientras que minimiza errores y disputas. 30 3 Caṕıtulo 3 - Marco teórico 3.8.12.3. Contratos inteligentes para la Captación de Datos Organizaciones financieras pueden hacer uso de contratos inteligentes para la recopilación de datos de manera eficaz, eficiente y transparente. Reducción de procesos de auditoŕıa, datos uniformes entre organizaciones y máximos niveles de trasparencia son algunas de las bondades a explotar, algunas otras se enumeran como: Integridad de los datos y transparecia, lo cual genera un mercado con más confianza y estabilidad. Al ser almacenados en una cadena de bloques, los datos son almacenados en estructuras accesibles para todos los entes que vayan a utilizar estos datos. 3.8.12.4. Contratos inteligentes para Hipotecas Los contratos inteligentes pueden automatizar los procesos manuales y tediosos que ocurren tras un contrato hipotecario. En este caso el contrato inteligente brinda una conexión entre todas las entidades relacionadas con la hipoteca, lo cual puede generar un proceso a prueba de errores que sea confiable y transparente. Entre otras ventajas se observan: Liberación de contratos a compradores una vez que haya pagado la deuda hipotecaria de manera automática. Costos y errores minimizados debido a la eliminación de procesos manuales. Verificación de pagos y seguimiento de crédito tanto al comprador como al arrendador. 3.8.12.5. Contratos inteligentes en el Ámbito de Seguros Actualmente, el proceso de asegurar cualquier bien, está sujeto a muchos procesos manuales y tediosos, los cuales pueden agilizarse de una manera óptima mediante el uso de contratos inteligentes. El contrato inteligente, puede guardar los registro de cada póliza, riesgos cubier- tos y, combinado con herramientas del tipo Internet de las cosas, puede emitirse una señal de manera autática cuando ocurren algún tipo de accidente, además ofrece: Almecenamiento de historia de un asegurado, conteniendo bienes, pólizas, accidentes cubiertos y tipo de bien asegurado. Ahorro de recursos debido a la automatización de procesos de verificación. 3.8.12.6. Contratos inteligentes en el Ámbito Médico El manejo del historial de un paciente, el cual puede ser almacenado en una cadena de bloques y ser léıdo por cualquier instirución médica con acceso al contrato inteligente para realizar sus pagos de manera automática es un aditivo atractivo a todos los hospitales o organizaciones médicas del planeta, adicionalmente: 3.8 Contratos inteligentes y Ethereum 31 Reducción de costos debido al ahorro de recursos invertidos en instituciones médicas en mantener el historial de un paciente. Acceso a datos ı́ntegros de pacientes los cuales al ser almacenados en una cadena de bloques se vuelven confiables, transparentes y seguros. Al estar en la cadena de bloques del paciente, su privacidad aumenta de manera con- siderable. 3.8.12.7. Contratos inteligentes junto a Internet de las cosas Probablemente uno de los casos más atractivos. La conexión que puede establecerse entre un dispositivo IOT y un contrato inteligente puede disparar alertas, pagos de consumo y monitoreo en tiempo real de dispositivos de una manera segura, confiable y transparente. Entre otras caracteŕısticas, también puede evaluarse: Integridad en los datos de consumo, asegurando siempre un registro actualizado en caso de que se haya presentado una falla en algún dispositivo IOT conectado al contrato inteligente. Previsión de diferentes escenarios que podŕıan presentarse dependiente del dispositivo, siempre que esté contemplado en contrato inteligente (por ejemplo, qué hacer si un hogar está produciendo exceso de eletricidad). Un historial confiable, transparente y seguro de las actividades de diferentes dispositi- vos pueden quedar almacenadas mediante la vigilacia del contrato inteligente. 4 Caṕıtulo 4 - Tecnoloǵıas utilizadas El presente caṕıtulo describe las tecnoloǵıas utilizadas para la construcción de la herramienta desarrollada. 4.1. Lenguajes de Programación En computación, un lenguaje de programación es cualquier lenguaje artificial que intenta conservar una similitud con el lenguaje humano, el cual, se utiliza para definir adecuada- mente una secuencia de instrucciones que puedan ser interpretadas y ejecutadas en una computadora. [14] Establecen un conjunto de śımbolos, reglas sintácticas y semánticas, las cuales rigen la es- tructura y el significado del programa, junto con sus elementos y expresiones. De esta forma, permiten a los programadores o desarrolladores, poder especificar de forma precisa los datos sobre los que se va a actuar, su almacenamiento, transmisión y demás acciones a realizar bajo las distintas circunstancias consideradas. Usualmente se clasifican en interpretados y compila- dos, en el cual los compilados tienen un compilador espećıfico que obtiene como entrada un programa y traduce las instrucciones las cuales pueden servir de entrada para otro intérprete o compilado y los interpretados tienen un intérprete espećıfico que obtiene como entrada un programa y ejecuta las acciones escritas a medida que las va procesando. 4.1.1. JavaScript Según la fundación Mozilla[13], JavaScript es un lenguaje ligero, interpretado, orientado a objetos con funciones de primera clase, más conocido como el lenguaje de script de páginas web, pero también, utilizado en muchos entornos tales como NodeJS. 4.1.2. Solidity Solidity es un lenguaje de programación de alto nivel orientado a contratos, su creación fue influenciada por C++, Python y JavsScript, está diseñado para funcionar sobre la Máquina Virtual de Ethereum[27]. Solidity es fuertemente tipado, hace uso de herencia, bibliotecas y tipos complejos creados por el usuario. 4.2 Remix 33 4.2. Remix Remix es un ambiente de desarrollo para crear código escrito en Solidity, el mismo se vale del navegador para brindar una interfaz al usuario programador para que puedra realizar prototipos de contratos sin la necesidad de hacer un despliegue en alguna red local o de producción[22]. 4.3. Infura Infura[12] es un servicio el cual simplifica la tarea de desplegar contratos en redes de Et- hereum sin la necesidad de configurar un nodo propio, tarea que es bastante compleja de realizar y no es el punto central de la presente investigación. 4.4. MetaMask MetaMask es un plug � in de código abierto[15] que permite al navegador conectarse, en el caso de esta investigación a la red Ethereum sin tener que pasar por todo el proceso de creación de un nodo Ethereum. Está principalmente diseñado para usuarios finales, debido a que permitirá la confirmación o rechazo de la salida de transacciones desde un cliente web a la red. La misma provee una plataforma de autenticación basada en Mneumonics para el manejo de direcciones de Ethereum y adicionalmente, provee la posibilidad de conectarse a las redes de prueba de Ethereum (Rinkedby, Ropsten y Kovan) para realizar pruebas en ambientes de producción sin tener que invertir fondos en adquirir ether para realizar pruebas. 4.5. NodeJS Es un entorno de ejecución para JavaScript, está diseñado para construir aplicaciones de red escalables. Fue creado con el enfoque de ser útil en la creación de programas de red altamente escalables, como por ejemplo, servidores web 2.0. Fue creado por Ryan Dahl en 2009. 4.5.1. Web3 Web3 es una biblioteca de código abierto[29] compatible con el ambiente de desarrollo NodeJS la cual permite enlazar direcciones de Ethereum (Mediante MetaMask) con instancias de contratos inteligentes que estén instanciados en una red Ethereum desde el código de un cliente web. 34 4 Caṕıtulo 4 - Tecnoloǵıas utilizadas 4.5.2. SolC SolC es una biblioteca de código abierto[26] compatible con el ambiente de desarrollo NodeJS la cual compila códigos escritos en Solidity, y genera los archivos necesarios (ABI y Bytecode) para poder acceder a los mismos desde el cliente web e interactuar con las instancias obtenidas mediante las llamadas realizadas con Web3. 4.5.3. Ganache Ganache es un proveedor de código abierto[9] compatible con el ambiente de desarrollo NodeJS, la cual permite emular una red Ethereum de manera local, esto permite realizar pruebas de funcionamiento sin tener que acceder a una red real de Ethereum. 4.5.4. Mocha Mocha es un framework de NodeJS el cual permite realizar pruebas aśıncronas de manera rápida y segura[16]. 4.6. React React es un framework del lado del cliente construido para poder utilizar JavaScript en la tarea de elaborar interfaces de usuario[20]. Fue creada por Facebook en el año 2013 y está basado en componentes recicables que manejan su propio estado con variables independientes que interactúan con el DOM[6] de una manera dinámica para poder crear interfaces de una manera rápida y utilizando un lenguaje familiar para la mayoŕıa de los desarrolladores. 4.6.1. NextJS NextJS es una biblioteca que complementa las funciones de React, ya que brinda una lógica conocida como ’server side rendering’[19] lo cual significa, que antes de mostrar cualquier elemento en el navegador del usuario, el servidor se encarga de primero renderizar todos los elementos de la interfaz, y una vez que este proceso se completó, se muestra la interfaz completa al cliente mediante el navegador 4.6.2. Semantic UI React Biblioteca que brinda una serie de elementos visuales estructurados los cuales ayudan a la creación de interfaces atractivas y versátiles para los usuarios[24]. Estas pueden ser configu- rables mediante JavaScript para brindar experiencias de usuario más cómodas y amigables. 4.7 Justificación de tecnoloǵıas 35 4.7. Justificación de tecnoloǵıas 4.7.1. MetaMask MetaMask se posicionó rápidamente como la opción estándar para la interacción con Et- hereum debido a que fue la primera herramienta que permitió dicha interacción de manera segura y sin muchas configuraciones adicionales. Adicionalmente, se mantiene al d́ıa con actualizaciones regulares. 4.7.2. NodeJS + Web3 El equipo desarrollador de Web3 buscaba brindar una plataforma que se adaptara a las ne- cesidades actuales del mercado y tuviera una proyección positiva hacia el futuro de Ethereum. En vista de la gran popularidad de NodeJS en los últimos años, debido a su poĺıtica de código abierto y además, junto a su integración con el gestos de paquetes NPM , permiten a los usuarios crear sus propias bibliotecas que se valieran de Web3 para hacer la herramienta lo más versátil posible. Siguiendo esta ĺınea de pensamiento, las bibliotecas Solc, Ganache y Mocha vienen siendo convenciones que permiten la muy fácil integración de elementos vitales que son necesarios para lograr crear un sistema robusto que pueda interactuar con Ethereum. Dada la arquitectura planteada, el uso de estos elementos vendŕıan siendo la parte intermedia de la arquitectura, el puente que une la base de la red de Ethereum con la interfaz de usuario final, como se puede apreciar en la Figura 4-1. 4.7.3. React + NextJS + Semantic UI React La justificación para el uso de React como framework del lado del cliente, sobre otras op- ciones como AngularJS y otros, viene dada por el rol que juega Ethereum y su máquina virtual dentro de la presente solución. De cierta forma, Ethererum vendŕıa a reemplazar a lo que seŕıa un servidor en una aplicación web convencional, en vista de este cambio de paradigma, React, que es exclusivamente un framework del lado del cliente, viene siendo una solución que cubre todas las necesidades que puede presentar esta versión de cliente web. Adicionalmente, su fácil integración con NodeJS brinda todas las herramientas necesarias para plantear con éxito una solución completa al caso de uso seleccionado. 36 4 Caṕıtulo 4 - Tecnoloǵıas utilizadas Figura 4-1: Capa intermedia planteada en la arquitectura. El uso de NextJS nace gracias a la bondad que brinda su ’server side rendering’ la cual se ajusta perfectamente a las necesidades que nacen de la integración con Ethereum. Pedir todos los datos desde la red, crear el DOM, esperar el proceso de minado, realizar consultas aśıncronas y luego mostrar el resultado v́ıa el navegador viene siendo el flujo perfecto para este tipo de soluciones. Finalmente, una vista atractiva al usuario viene siendo tarea fácil gracias a Semantic UI React y todas las bondades que brinda para armar interfaces utilizando React y NextJS. Todo el trabajo de crear la interfaz de usuario, habilitar el intercambio de información con Ethereum mediante un cliente web y la interacción final del usuario final con la herramienta correponde a la capa superior a la arquitectura planteada (Figura 4-2). 4.7 Justificación de tecnoloǵıas 37 Figura 4-2: Capa final planteada en la arquitectura. 38 4 Caṕıtulo 4 - Tecnoloǵıas utilizadas 4.8. Almacenamiento Una de las tareas planteadas para el presente TEG es el de almacenar las interacciones de los usuarios con la cadena de bloques, para ello, es necesario definir las propiedades de algunas bases de datos que puedan ser de utilidad para realizar dicha tarea de forma eficiente. 4.9. Bases de Datos NoSQL Son un enfoque hacia la gestión de datos y el diseño de base de datos que es útil para grandes conjuntos de datos distribuidos. Los datos almacenados no requieren estructuras fijas como tablas, normalmente no soportan operaciones JOIN, ni garantizan completamente ACID (atomicidad, consistencia, aislamiento y durabilidad). Son especialmente útiles cuando se necesita acceder y analizar grandes cantidades de datos no estructurados o datos que se almacenan de forma remota en varios servidores virtuales en la nube.[3] 4.9.1. Tipos de Bases de Datos NoSQL Orientada a Columnas: Este tipo de bases de datos están pensadas para realizar consul- tas y agregaciones sobre grandes cantidades de datos. Funcionan de forma parecida a las bases de datos relacionales, pero almacenando columnas de datos en lugar de registros. Algunos ejemplos de base de datos orientada a columnas: Cassandra[4], HBase[10]. Orientadas a Clave-Valor: Son sencillas de entender. Simplemente guardan tuplas que contienen una clave y su valor. Cuándo se quiere recuperar un dato, simplemente se busca por su clave y se recupera el valor. Algunos ejemplos de base de datos clave/valor: DynamoDB[7], Redis[21]. Orientadas a Documentos: Son aquellas que gestionan datos semi estructurados. Es decir documentos. Estos datos son almacenados en algún formato estándar como pue- de ser XML, JSON o BSON. Son las bases de datos NoSQL más versátiles. Se pueden utilizar en gran cantidad de proyectos, incluyendo muchos que tradicionalmente funcio- naŕıan sobre bases de datos relacionales. Algunos ejemplos de base de datos orientada a documentos: MongoDB[17], CouchDB[5]. Orientada a Grafos: Basadas en la teoŕıa de grafos utilizan nodos y aristas para re- presentar los datos almacenados. Son muy útiles para guardar información en modelos con muchas relaciones, como redes y conexiones sociales. Algunos ejemplos de base de datos orientada a grafos: Infinite Graph[11], Neo4j[18]. 4.10 Inteligencia Artificial 39 4.9.2. MongoDB Es una base de datos ágil que permite a los esquemas cambiar rápidamente a medida que las aplicaciones evolucionan, proporcionando siempre la funcionalidad que los desarrolladores esperan de las bases de datos tradicionales, tales como ı́ndices secundarios, un lenguaje completo de búsquedas y consistencia estricta[17]. La misma pertenece a la familia de las bases de datos NoSQL orientadas a documentos, donde se pueden almacenar archivos en formato JSON donde se permite la anidación de los mismos. Posee un lenguaje de consulta propio del sistema manejador de base de datos, el cual permite realizar cualquier tipo de consulta sin importar el esquema del documento almacenado. Entre las bondades que brinda MongoDB destacan: 1. MongoDB almacena sus documentos en formatos JSON flexibles, haciéndo que los documentos puedan variar a dependiendo de lo que se quiera almacenar. 2. Trabaja con modelos definidos dentro de la aplicación, lo que permite simpleza al momento de modelos los datos a almacenar. 3. Consultas a la medida (Ad hoc), indexación y agregaciones en tiempo real proveen de herramientas flexibles y potentes para analizar los datos. 4. Es código abierto lo que viene siendo una parte fundamental en la creación de DAPP’s. 4.9.3. Justificación de uso MongoDB MongoDB al ser una base de datos orientada a documentos, que además, se vale del formato JSON para manejar los modelos, viene siendo la convención perfecta para trabajar junto a tecnoloǵıas como NodeJS, gracias a su base en JavaScript, el manejo de objetos no tiene variación alguna con respecto a trabajar con los objetos del lenguaje, y luego almacenar dichos objetos en la base de datos. Adicionalmente, la flexibilidad con la que se almecenan los datos, resulta extremadamente ventajoso, a la hora de cambiar el modelo de los datos que se desean almacenar, si a partir de cierto momento, un tipo de dato no contemplado resulta ser bastante útil, puede realizarse una m ı́nima modificación en el modelo de datos sin romper la integración del sistema. 4.10. Inteligencia Artificial 4.10.1. Anaĺıtica Predictiva La anaĺıtica predictiva es una forma de análisis avanzado que utiliza datos nuevos e históricos para predecir la actividad futura, el comportamiento y las tendencias. Implica la aplicación de 40 4 Caṕıtulo 4 - Tecnoloǵıas utilizadas técnicas de análisis estad́ıstico, consultas anaĺıticas y algoritmos automáticos de aprendizaje automático a conjuntos de datos para crear modelos predictivos que sitúen un valor numérico o puntuación en la probabilidad de que ocurra un evento particular. Las aplicaciones de software de análisis predictivo utilizan variables que pueden medirse y analizarse para predecir el comportamiento probable de individuos, maquinaria u otras entidades[41]. 4.10.2. Aprendizaje Automático (Machine Learning) El aprendizaje automático (Machine Learning, en inglés) es una rama de las ciencias de la Computación que es usada para describir algoritmos tanto de aprendizaje supervisado (Predicción y clasificación) como aprendizaje no supervisado (Clusterizar y detección de comportamiento). Es una rama derivada de la Inteligencia Artificial, que busca desarrollar en las computadoras habilidades de aprendizaje sin ser expĺıcitamente programadas para ello[42]. El aprendizaje automático no es un dominio espećıfico sino un conjunto de dominios que ofre- cen diferentes enfoques para resolver problemas complejos. El propósito general del apren- dizaje automático es el desarrollo de algoritmos. Junto a la inteligencia artificial, se enfocan en el desarrollo de algoritmos que pueden en- señarse a śı mismos para adaptarse iterativamente al momento de exponerse a nuevos datos y continuamente mejorar sus resultados. 4.10.3. Aprendizaje profundo (Deep Learning) El aprendizaje profundo (Deep Learning, en inglés), es una sub-rama del aprendizaje au- tomático que está basado en aprender en diferentes niveles de representación correspondien- tes a una jerarqúıa con respecto a caracteŕısticas o conceptos, donde los conceptos de alto nivel son definidos en base a los conceptos de bajo nivel y los mismos conceptos de bajo nivel ayudan a construir conceptos de alto nivel. El aprendizaje profundo es una parte mas amplia de los métodos de aprendizaje automático basado en aprender representaciones. Una observación (por ejemplo, una imagen) puede ser representada de varias maneras (Como un vector de ṕıxeles), pero algunas representacio- nes pueden hacer mas sencillas algunas tareas de interés (Como el reconocimiento facial en imágenes). Esta rama del aprendizaje automático se encarga de definir que representaciones son mejores para cierta tarea y como aprender a interpretarla[38]. 4.11 Alcance de la Investigación 41 4.10.4. Mineŕıa de Datos (Data Mining) Surgió como una tecnoloǵıa que busca ayudar a comprender el contenido de una base de datos, resaltando la importancia de la manipulación de los datos, debido al valor que éstos pueden aportar. En el momento en que el usuario les atribuye algún significado especial, pasan a convertirse en información. Cuando los especialistas elaboran o encuentran un modelo, haciendo que la interpretación obtenida entre la información y ese modelo represente un valor agregado, es cuando se obtiene el conocimiento. La mineŕıa de datos busca patrones, comportamientos, agrupaciones, secuencias, tendencias o asociaciones, que puedan generar algún modelo que permita comprender mejor el dominio para ayudar en una posible toma de decisión. Con respecto a un problema [37]. 4.11. Alcance de la Investigación Definiciones más especificas de los elementos anteriormente descritos se escapan del alcance de la presente investigación debido a que el tema principal es la implementación de una aplicación distribuida que pueda desenvolverse en el ambiente de Ethereum y la tarea de obtener datos de interés de la misma. La metodoloǵıa con respecto al procesamiento e interpretación de los datos que puedan ser obtenidos a partir del contenido de las cadenas de bloques queda en responsabilidad de futuras investigaciones con respecto a los datos una vez que ya han sido extráıdos de la cadena de bloques. 5 Caṕıtulo 5 - Marco metodológico 5.1. Metodoloǵıa de desarrollo y justificación La selección de una metodoloǵıa de desarrollo viene siendo una tarea fundamental a la hora de crear cualquier solución de la ı́ndole de la presente investigación. En un mundo tan cambiante, dónde las tecnoloǵıas son cada vez más diversas y especializa- das, las metodoloǵıas ágiles brillan por su rápida adaptación a los diferentes paradigmas que nacen a diario en el mundo tecnológico. Sin embargo, el enfoque tradicional, brinda muchas herramientas ya establecidas las cuales gozan de validación a nivel mundial, permitiendo crear soluciones de una manera eficiente. Con el objetivo de explotar lo mejor de ambos mundos, la adaptabilidad de las metodoloǵıas ágiles, y lo certero de metodoloǵıas tradicionales, la propuesta para la presente investigación es la metodoloǵıa Proceso Ágil Unificado[2]. 5.2. Proceso Ágil Unificado Los primeros pasos que concibieron el nacimiento de esta metodoloǵıa fueron en el año 1999 por Scott W Ambler, como una solución para mejorar la metodolǵıa RUP. La idea principal, era actualizar RUP[2] para que fuera más ágil debido a todos los cambios tecnológicos que naćıan en la época. En esencia, es una versión simplificada de RUP. Describe de una manera simple los acerca- mientos para crear software orientado a las soluciones de negocios utilizando herramientas ágiles, pero, basándose en conceptos utilizados en RUP[23]. Se siguen conservando elementos de RUP tales como los modelos, pero ahora no de una manera tan dominante, está más enfocado a práticas ágiles, como por ejemplo: El uso de modelos sigue siendo fundamental para simular las soluciones, pero ahora el desarrollo se divide en iteraciones ’Lo suficientemente buenas’, según Ambler. 5.2 Proceso Ágil Unificado 43 5.2.1. Fases 1. Inicio (Inception): La meta de esta fase, es definir el alcance del proyecto, potenciales arquitecturas para una solución viable y definir los costos asociados a la solución y su vialidad. 2. Elaboración (Elaboration): Definir la arquitectura de la solución. 3. Construcción (Construction): La meta de esta fase es construir software de una manera simple, pero incremental, que solucione las problemáticas bases planteadas en la fase de Comienzo y luego, mediante iteraciones ágiles, ir puliendo problemáticas secundarias. 4. Transición (Transition): Esta fase representa la validación del sistema en un ambiente de producción. 5.2.2. Disciplinas y actividades Las disciplinas son desarrolladas de una manera iterativa, definiendo al equipo de desarrollo actividades que ayuden a valiar, probar y entregar software que satisfaga la necesidad de la solución planteada, las disciplinas son: Modelado: La meta de esta disciplina es entender el negocio de la organización, el dominio del problema e identificar potenciales soluciones. Implementación: La meta es transformar el modelado anteriormente concebido en códi- go que pueda ser probado y mejorado mediante iteraciones. Pruebas: Definir pruebas que aprueben o rechacen el software implementado, asegu- rando estándares de calidad. Esto incluye encontrar defectos, y verificar cumplimiento de requerimientos. Despliegue: Planear la entrega del sistema y ejecutar un plan para que los usuarios finales puedan acceder a la solución. Gestión de configuración: La meta de esta disciplina es controlar el acceso a los arte- factos de la solución, sólo el manejo de versiones. Gestión de proyectos: Dirigir las actividades que tomarán acción dentro del proyecto, esto incluye la interacción con entes externos para asegurar una entrega del producto a tiempo y dentro del presupuesto acordado. Ambiente: La tarea de esta disciplina es asegurar un ambiente adecuado para maximi- zar las tareas de desarrollo de la solución. 44 5 Caṕıtulo 5 - Marco metodológico Figura 5-1: Ciclo de vida del Proceso Ágil Unificado. 5.2.3. Iteraciones alrededor del tiempo En lugar de entregar un sólo proyecto final, se realizan entregas en porciones también cono- cidas como versiones de prueba, las cuales van evaluando partes del problema que van siendo resueltas, una vez que una versión de prueba es liberada, va a una área de prueba (Conocida también como ambiente de calidad). La idea de este acercamiento, es ir realizando pre-entregas en intervalos de tiempo cada vez más cortos, con el fin de crear un hábito en el equipo que garantice la agilidad y la robustez del desarrollo a medida que se refinan las pre-entregas, luego de cada cierto número de pre-entregas, se lanza una versión de producción, la cual servirá de base para las siguientes pre-entregas, se puede apreciar un flujo de trabajo en la Figura 5-2 . 5.2 Proceso Ágil Unificado 45 Figura 5-2: Iteraciones de liberación de versiones. 46 5 Caṕıtulo 5 - Marco metodológico 5.2.4. Filosof́ıa del Agile Unified Process 1. El equipo sabe lo que está haciendo: El equipo no requiere una documentación detallada todos los d́ıas, realizar gúıas concretas y cortas es suficiente para asegurar que el equipo vaya en la dirección correcta. 2. Simplicidad: Todos los requerimientos y documentaciones están descritas en páginas cortas al alcance de la mano. 3. Agilidad: Mantener los principios ágiles, pero conservando conceptos básicos de RUP. 4. Mantener el foco en actividades de alto valor: Enforcarse principalmente en actividades que cuentan y son importantes para llegar a la solución. 5. Independencia de herramientas: Dentro de lo necesario para el desarrollo, permitir que el equipo trabaje con las herramientas con las que más se sientan a gusto. Sin nada más que agregar, el marco aplicativo (Caṕıtulo 6) describirá cómo fue la imple- mentación de esta metodoloǵıa en la solución a una problemática concreta. 6 Caṕıtulo 6 - Marco aplicativo 6.1. Inicio (Inception) 6.1.1. Propuesta de caso de uso para el TEG 6.1.1.1. Solución para evitar malversación de bienes y lavado de dinero en recaudaciones masivas 6.1.1.2. ¿Qué es una recaudación masiva? Para el presente caso de estudio, una recadación masiva (crowdfunding en inglés), se refiere a una campaña colectiva en la cual un gerente propone una idea o modelo de negocios, y luego el público en general puede donar fondos para financiar dicha idea y hacerla realidad. 6.1.1.3. ¿Qué problemas presentan actualmente las recaudaciones masivas? Algunos de los problemas actuales que presentan las recaudaciones masivas, son la falta de garant́ıas con respecto a los fondos retirados de la campaña, en muchas de ellas se desconoce el destino de los mismos, dejando abiertas sospechas de lavado de dinero. Otro de los pro- blemas que se presentan en este tipo de iniciativas, suele ser que el gerente de una campaña simplemente desaparece con los fondos sin dejar rastro. 6.1.1.4. ¿Cómo pueden Ethereum y los contratos inteligentes atacar estos problemas? Apoyar este tipo de iniciativas en plataformas como Ethereum le agregan confianza y trans- parencia, el uso de cadenas de bloques para registrar transacciones, complementado con el pago automático y supervisado mediante contratos inteligentes provee herramientas que re- ducen eficazmente las problemáticas mencionadas anteriormente. Adicionalmente, es posible guardar registro de todas las interacciones que se realizan con la cadena de bloques en bases de datos, la finalidad de esta práctica es detectar patrones de comportamiento en este tipo de emprendimientos, mediante el estudio de las campañas, contribuciones, solicitudes, aprobaciones y rechazos. 48 6 Caṕıtulo 6 - Marco aplicativo 6.1.1.5. Solución La propuesta plantea crear una aplicación web que se apoya en el uso de Ethereum y con- tratos inteligentes para hacer más transparentes y confiables las donaciones y uso de dichas donaciones en campañas de requerimientos de fondos. En un primer acercamiento, un gerente, se encarga de crear una instancia del contrato inteligente mediante el cliente web. Figura 6-1: Gerente crea una instancia de contrato inteligente mediante un cliente web. En el cliente web, en la ventana de creación de campañas, el gerente puede parametrizar su campaña y establecer ĺımites o parámetros para su campaña: Donación mı́nima. Donación máxima. Máximo número de contribuyentes. Tasa (%) para aprobar una solicitud. Tasa (%) para rechazar una solicitud. Una vez creada la campaña, los contribuyentes a la misma pueden acceder al cliente web y seleccionar a la campaña a la que desean contribuir y seguidamente, ingresar un monto de ether con el cual quieren contribuir a la campaña, la dirección de los contribuyentes es almacenada en el contrato con el fin de que formen parte ahora de la lista especial de contribuyentes a dicha campaña. 6.1 Inicio (Inception) 49 Figura 6-2: Contribuyentes ingresan ether a la campaña mediante el cliente web. 50 6 Caṕıtulo 6 - Marco aplicativo Una vez que una campaña haya recibido fondos de contribuyentes, el gerente se vale del cliente web para crear una solicitud de gasto de la campaña, en la misma debe especificar una descripción de la solicitud, la cantidad de ether que serán enviados, y la dirección destino de los fondos. En la Figura 6-3 se aprecia la morfoloǵıa de una solicitud: ’Comprar bateŕıas’ responde a la descripción que debe dar el gerente de la campaña al uso de los fondes que desea retirar. 0.5 es el monto especificado que será retirado de la campaña ’0xnj34...’ es la direccón a la cual serán enviados los fondos. Figura 6-3: Gerente se vale del cliente web para crear una solicitud de gasto. Una vez creada la solicitud, esta recibe una marca de tiempo, la cual indica la hora exacta en la que fue creada, a partir de ese momento, se calculan 7 d́ıas en adelante que representan la vigencia de la solicitud. Los contribuyentes podrán visualizar mediante el cliente web la solicitud creada por el gerente aśı como visualizar su descripción, costo, dirección de destino, fecha de creación y expiración. Los contribuyentes pueden aprobar o rechazar que se proceda con ese gasto votando mediante el cliente web. Todo lo anteriormente ocurre siempre y cuando la solicitud se encuentre en vigencia, es decir, que la fecha actual del rechazo o aprobación esté comprendida entre el intervalo de creación y de expiración de una solicitud. 6.1 Inicio (Inception) 51 Figura 6-4: Los clientes se valen del cliente web para aprobar o rechazar una solicitud de gasto de una campaña. 52 6 Caṕıtulo 6 - Marco aplicativo Una vez que una solicitud ha obtenido la cantidad de votos de aprobación o rechazo necesa- rios (Esta tasa es asignada por el gerente al momento de crear la campaña), el gerente de la campaña puede finalizar la solicitud, aprobando o rechazando, dependiendo de cómo haya resultado la votación de la solicitud, si una solicitud cumple con la tasa de aprobación y es finalizada, los fondos son retirados del balance del contrato y son enviados a la dirección destino. Si la solicitud cumple con la tasa de rechazo y es finalizada, simplemente no se realiza la transacción que va desde el contrato a la dirección destino. El caso de expiración de una solicitud se presenta cuando una solicitud no logró cumplir con la tasa de aprobación o rechazo (El margen de votación es de 7 d́ıas), puede ocurrir en casos donde se presenta abstinencia de votos o simplemente las tasas no fueron alcanzadas. Con el fin de no crear puntos muertos en el emprendimiento, si una solicitud expira y es finalizada, se tomará como aprobada y los fondos serán enviados a la dirección destino de la solicitud. Figura 6-5: Cuando se haya alcanzado la cantidad necesaria de votos, el gerente puede finalizar la solicitud. Adicionalmente, con el fin de detectar patrones de comportamiento y encontrar datos rele- vantes en este tipo de emprendimientos, todas las interacciones que se realicen con la cadena de bloques (Crear campaña, contribución, creación de solicitudes, aprobar y rechazar soli- citudes) quedan registradas en una instancia de MongoDB con el fin de llevar un registro detallado de las direcciones que interactúan con el contrato inteligente y cómo son dichas interacciones. 6.1 Inicio (Inception) 53 Figura 6-6: Todas las interacciones de parte de contribuyentes y el gerente con la campaña son registradas en una instancia de MongoDB. 54 6 Caṕıtulo 6 - Marco aplicativo Finalmente, se presentan los diagramas de casos de uso tanto como para el gerente como para un contribuyente. Figura 6-7: Diagrama de caso de uso para el gerente de una campaña. 6.1 Inicio (Inception) 55 Figura 6-8: Diagrama de caso de uso para contribuyentes de una campaña. 56 6 Caṕıtulo 6 - Marco aplicativo 6.2. Elaboración (Elaboration) La arquitectura planteada para solución del caso de uso fue planteada en la introducción del presente trabajo y a sus componentes fueron identificados en los caṕıtulos 3 y 4, respectiva- mente. 6.3. Construcción (Construction) En esta sección se definirán las iteraciones que darán forma a la solución, 6.3.1. Iteración 0: Acercamiento inicial En esta primera iteración se realizó el primer prototipo del código fuente, el mismo fue es- crito en Solidity, este primer prototipo ataca las problemáticas fundamentales descritas en el caso de uso, pero deja algunas funcionalidades sin implementar, debido al enfoque ágil de la metodoloǵıa, el enfoque es, por ahora sólo en lo estrictamente necesario. Esta primera versión contempla, la creación de campañas mediante un contrato intermedio, llamado ’CampaignFactory’ el cual se encarga de generar instancias de las campañas, la razón del uso de este enfoque, es que desde el cliente web se llame a este primer contrato que se encargue de construir las instancias de ’Campaign’, que representan las campañas. 1 //Vers ion de S o l i d i t y a u t i l i z a r 2 pragma s o l i d i t y ˆ 0 . 4 . 1 7 ; 3 4 cont rac t CampaignFactory{ 5 //Unico a t r i bu to de l cont rato generador de campanas e l p r e s en te a t r i bu to se u t i l i z a para devo lve r todas l a s d i r e c c i o n e s i n s t a n c i a s generadas 6 address [ ] pub l i c deployedCampaigns ; 7 8 //Funcion que genera i n s t a n c i a s de l contrato Campaign , r e c i b e un monto minimo de cont r ibuc i on 9 f unc t i on createCampaign ( u int minimum) pub l i c { 10 address newCampaign = new Campaign (minimum , msg . sender ) ; 11 12 //Una vez creada l a i n s t anc i a , se agrega a l a r r e g l o de d i r e c c i o n e s de i n s t a n c i a s de Campaigns 13 deployedCampaigns . push (newCampaign ) ; 14 } 15 16 //Funcion que re to rna un a r r e g l o de d i r e c c i o n e s con todas l a s i n t an c i a s de Campaigns 17 f unc t i on getDeployedCampaigns ( ) pub l i c view re tu rn s ( address [ ] ) { 18 r e turn deployedCampaigns ; 19 } 6.3 Construcción (Construction) 57 20 21 } 22 23 //Contrato p r i n c i pa l , en e s t e cont rato se implementa toda l a l o g i c a y func i ona l i dad de l a s campanas 24 cont rac t Campaign{ 25 26 // Estructura Request que r ep r e s en ta una s o l i c i t u d creada por e l ge r ente de l contrato 27 s t r u c t Request{ 28 29 // St r ing que r ep r e s en ta l a d e s c r i p c i on de l a s o l i c i t u d 30 s t r i n g d e s c r i p t i o n ; 31 32 //Entero p o s i t i v o que r ep r e s en ta e l va l o r que desea r e t i r a r l a s o l i c i t u d de l a campana 33 uint va lue ; 34 35 // Di r ecc i on que r e c i b i r a l o s fondos de l a s o l i c i t u d 36 address r e c i p i e n t ; 37 38 // Var iab le booleana que r ep r e s en ta s i l a s o l i c i t u d ha s ido completada o no 39 bool complete ; 40 41 //Entero p o s i t i v o que r ep r e s en ta l a cant idad de votos aprobados de l a s o l i c i t u d 42 uint approvalCount ; 43 44 //Tipo de dato mapping , que r e a l i z a l a cor r e spondenc ia de una d i r e c c i o n con un va l o r booleano , en cuanto se r e a l i c e una votac ion , e l mapeo de l a d i r e c c i o n de e s t a va r i ab l e s e ra as ignado a True 45 mapping ( address => bool ) approva l s ; 46 } 47 48 // L i s t a de a t r i bu t o s de l cont rato 49 50 //Arreg lo de s o l i c i t u d e s que posee e l cont rato 51 Request [ ] pub l i c r eque s t s ; 52 53 // Di r ecc i on de l ge r ente de l cont rato 54 address pub l i c manager ; 55 56 //Contr ibuc ion minima 57 uint pub l i c minimumContribution ; 58 59 //Mapeo de d i r e c c i o n e s a va l o r e s boo leanos que repre sentan l a l i s t a de cont r ibuyente s votantes 58 6 Caṕıtulo 6 - Marco aplicativo 60 mapping ( address => bool ) pub l i c approvers ; 61 62 //Contador de votantes 63 uint pub l i c approversCount ; 64 65 66 //Funcion que r e s t r i n g e l a p o s i b i l i d a d de una func ion a s e r llamada , en e s t e caso , r e t r i n g e a l a func ion a s e r l lamada por a l gu i en que no sea e l ge r ente de l a campana 67 mod i f i e r r e s t r i c t e d ( ) { 68 r e qu i r e (msg . sender == manager ) ; 69 ; 70 } 71 72 //Constructor de l contrato , r e c i b e sus parametros desde l a func ion createCampaign de CampaignFactory 73 f unc t i on Campaign ( u int minimum , address c r e a t o r ) pub l i c { 74 manager = c r ea t o r ; 75 minimumContribution = minimum ; 76 } 77 78 //Funcion que permite a una d i r e c c i o n c on t r i b u i r a l a campana , l a palabra re se rvada ’ payable ’ i nd i c a que l a func ion debe r e c i b i r un va l o r en wei , e l cua l s e ra agregado a l a i n s t an c i a de l cont rato 79 f unc t i on con t r i bu t e ( ) pub l i c payable { 80 //El va l o r con e l que se l lama a l a func ion debe s e r mayor a l a minima cont r ibuc i on e s t ab l e c i d a 81 r e qu i r e (msg . va lue > minimumContribution ) ; 82 83 //Se mapea su va l o r a true , y se aumenta e l contador de votantes 84 approvers [ msg . sender ] = true ; 85 approversCount++; 86 87 } 88 89 //Funcion que crea una s o l i c i t u d , r e c i b e una de s c r i p c i on , un va lo r y una d i r e c c i o n de s t i no ( Notese e l a t r i bu to r e s t r i c t e d : s o l o puede s e r l lamada por e l ge r ente de l a campana ) 90 f unc t i on createRequest ( s t r i n g de s c r i p t i on , u int value , address r e c i p i e n t ) pub l i c r e s t r i c t e d { 91 92 //Se crea l a nueva e s t ru c tu r a con l o s parametros r e c i b i d o s 93 Request memory newRequest = Request ({ 94 d e s c r i p t i o n : d e s c r i p t i on , 95 value : value , 96 r e c i p i e n t : r e c i p i e n t , 97 //Se i n i c i a l i z a en f a l s o , puesto que se acaba de c r ea r dicha s o l i c i t u d y aun no se ha completado 6.3 Construcción (Construction) 59 98 complete : f a l s e , 99 //Se i n i c i a l i z a e l contador de aprobados en cero . 100 approvalCount : 0 101 }) ; 102 103 //Se agrega l a s o l i c i t u d r e c i e n creada a l a r r e g l o de s o l i c i t u d e s de l contrato 104 r eque s t s . push ( newRequest ) ; 105 106 } 107 108 //Funcion llamada por l o s cont r ibuyente s de l a campana , para aprobar una s o l i c i t u d , r e c i b e un i nd i c e de l a r r e g l o de s o l i c i t u d e s para conocer cua l s o l i c i t u d desea votar para su aprobacion 109 f unc t i on approveRequest ( u int index ) pub l i c { 110 111 // Loca l i z a r l a s o l i c i t u d segun e l i n d i c e 112 Request s t o rage r eque s t = r eque s t s [ index ] ; 113 114 //Para que l a func ion cont inue su curso natura l , e s r eque r ido que l a d i r e c c i o n que l lama l a func ion sea un cont r ibyent e 115 r e qu i r e ( approvers [ msg . sender ] ) ; 116 117 //Tambien es n e c e s a r i o que l a d i r e c c i o n que l lama a l a func ion NO haya votado anter iormente 118 r e qu i r e ( ! r eque s t . approva l s [ msg . sender ] ) ; 119 120 //La d i r e c c i o n aprobo l a s o l i c i t u d 121 r eque s t . approva l s [ msg . sender ] = true ; 122 123 //Se incrementa l a cuenta de votos 124 r eque s t . approvalCount++; 125 126 } 127 128 //Funcion llamada para dar por f i n a l i z a d a una s o l i c i t u d , r e c i b e un i nd i c e para i d e n t i f i c a r l a s o l i c i t u d a f i n a l i z a r , notese e l a t r i bu to r e s t r i c t e d , s o l o puede s e r l lamada por e l ge r ente 129 f unc t i on f i n a l i z eRequ e s t ( u int index ) pub l i c r e s t r i c t e d { 130 // I d en t i f i c a ndo l a s o l i c i t u d 131 Request s t o rage r eque s t = r eque s t s [ index ] ; 132 //Es reque r ido que hayan votado pos i t ivamente l a mitad de l o s cont r ibuyente s 133 r e qu i r e ( r eque s t . approvalCount > ( approversCount / 2) ) ; 134 135 //Es requer ido , ademas , que l a s o l i c i t u d no haya s ido marcada como completada 136 r e qu i r e ( ! r eque s t . complete ) ; 60 6 Caṕıtulo 6 - Marco aplicativo 137 138 //Se t r a n s f i e r e n l o s fondos a l a d i r e c c i o n de s t i no 139 r eque s t . r e c i p i e n t . t r a n s f e r ( r eque s t . va lue ) ; 140 141 //Se marca l a s o l i c i t u d como completada 142 r eque s t . complete = true ; 143 } 144 } Algoritmo 6.1: Versión 0.1 de solución para el caso de uso Algunos detalles que se deben hacer notar en esta primera versión del código son: No está contemplado la parametrización por parte del gerente de la campaña. Hacen falta la mitad de los votos de los contribuyentes para aprobar una solicitud No está implementada la funcionalidad de rechazar una solicitud 6.3.1.1. Prueba 0.1 Debido a este temprano enfoque para una solución, las pruebas se realizaron de manera manual mediante la herramienta Remix Tipo de prueba Funcional Entorno de ejecución Navegador Web Chrome Ejecutante Desarrollador de la herramienta Herramienta usada Remix Veces ejecutada 1 Resultados 100% de éxito Tabla 6-1: Especificaciones de la prueba para la versión 0.1 6.3 Construcción (Construction) 61 Figura 6-9: IDE de Remix, compilador de Solidity en en navegador web. 62 6 Caṕıtulo 6 - Marco aplicativo Sin embargo, en iteraciones futuras se contempló la implementación de pruebas de manera automática para asegurar que el código producido cumpla con los requerimientos solicitados. 6.3.2. Iteración 1: Compilación y primera prueba automática La presente iteración presenta la compilación y despliegue del contrato en redes locales para realizar pruebas automáticas que garanticen su correcto funcionamiento. Para lograr esta tarea, se maneja la primera versión del contrato contrúıda en la iteración 0, luego, se contruye el siguiente código que se encarga de crear, a partir del contrato creado, el ABI y Bytecode del contrato: 1 //Dependencias n e c e s a r i a s 2 const path = r equ i r e ( ’ path ’ ) ; 3 const s o l c = r equ i r e ( ’ s o l c ’ ) ; 4 const f s = r equ i r e ( ’ f s�ext ra ’ ) ; 5 6 //Contruir l a ruta donde se guardaran e l ABI y e l Bytecode de l cont rato compilado 7 const bui ldPath = path . r e s o l v e ( dirname , ” bu i ld ” ) ; 8 9 //Se vac ia e l conten ido de l d i r e c t o r i o 10 f s . removeSync ( bui ldPath ) ; 11 12 //Se obt i ene l a ruta de l cont rato 13 const campaignPath = path . r e s o l v e ( dirname , ’ c on t r a c t s ’ , ’Campaign . s o l ’ ) ; 14 15 // Lectura de l d i r e c t o r i o dada su ruta 16 const source = f s . readFi l eSync ( campaignPath , ’ u t f 8 ’ ) ; 17 18 //Compilacion , se u t i l i z a l a b i b l i o t e c a ’ s o l c ’ 19 const output = s o l c . compi le ( source , 1) . c on t r a c t s ; 20 21 // Ve r i f i c a c i o n de que e l d i r e c t o r i o ex i s t e , s i no ex i s t e , e s creado 22 f s . ensureDirSync ( bui ldPath ) ; 23 24 // I t e r a c i o n sobre ’ output ’ , s e c rea un elemento JSON por cada ob j e to de l ’ output ’ . 25 f o r ( l e t cont rac t in output ) { 26 f s . outputJsonSync ( 27 path . r e s o l v e ( buildPath , cont rac t . r ep l a c e ( ’ : ’ , ’ ’ ) + ’ . j s on ’ ) , 28 output [ cont rac t ] 29 ) ; 30 } Algoritmo 6.2: Código que genera el ABI y Bytecode de un contrato dado 6.3 Construcción (Construction) 63 El código anterior crea dos objetos JSON, los cuales corresponden a los dos contratos que son parte del contrato global, ambos objetos JSON contienen el ABI y Bytecode de ambos contratos, a continuación se definen ambos términos: Aplicación de Interfaz binaria (ABI Application Binary Interface, en inglés): interfaz que es integrada con Web3 con la finalidad de que sea interpretado por JavaScript para poder interactuar con las funciones establecidas en los contratos mediante dicho lenguaje. Bytecode: Es la traducción del lenguaje Solidity a instrucciones que pueda entender la máquina virtual de Ethereum, es el archivo que se enviará a la cadena de bloques de Ethereum y a su máquina virtual. Una vez que ambos archivos han sido generados, se procede a construir el código que reali- zará las pruebas automáticas. Para construir las pruebas, se utiliza la biblioteca Mocha descrita en las tecnoloǵıas a utilizar, también se utilizan instancias de Web3 y Ganache para simular la red local de Ethereum sobre la cual se realizan las pruebas. 1 //Dependencias n e c e s a r i a s 2 const a s s e r t = r equ i r e ( ’ a s s e r t ’ ) ; 3 4 //Ganache permite c r ea r nuest ro propio ambiente Ethereum loca lmente 5 const ganache = r equ i r e ( ’ ganache�c l i ’ ) ; 6 const Web3 = r equ i r e ( ’web3 ’ ) ; 7 const web3 = new Web3( ganache . p rov ide r ( ) ) ; 8 9 //Contratos a u t i l i z a r 10 const compiledFactory = r equ i r e ( ’ . . / ethereum/ bu i ld /CampaignFactory . j son ’ ) ; 11 const compiledCampaign = r equ i r e ( ’ . . / ethereum/ bu i ld /Campaign . j son ’ ) ; 12 13 // L i s t a de v a r i a b l e s n e c e s a r i a s para e l d e sp l i gu e 14 l e t accounts ; 15 l e t f a c t o r y ; 16 l e t campaignAddress ; 17 l e t campaign ; 18 19 //Metodo llamado antes de r e a l i z a r cada una de l a s pruebas , e l metodo crea campanas automaticamente para r e a l i z a r pruebas 20 beforeEach ( async ( ) => { 21 22 //Se obt i ene una cuenta que hara e l d e sp l i e gu e de l cont rato ’ CampaignFactory ’ 23 accounts = await web3 . eth . getAccounts ( ) ; 24 64 6 Caṕıtulo 6 - Marco aplicativo 25 //Se crea l a i n s t an c i a de l cont rato ’ CampaignFactory ’ 26 f a c t o r y = await new web3 . eth . Contract (JSON. parse ( compi ledFactory . i n t e r f a c e ) ) . 27 deploy ({ data : compiledFactory . bytecode }) . 28 send ({ from : accounts [ 0 ] , gas : ’ 2000000 ’ }) ; 29 30 //Se crea una campana u t i l i z a ndo l a i n s t an c i a r e c i e n creada 31 await f a c t o r y . methods . createCampaign ( ’ 100 ’ , ’ 0 ’ , ’ 0 ’ ) . send ({ 32 from : accounts [ 0 ] , 33 gas : ’ 2000000 ’ 34 }) ; 35 36 //Se obt ienen l a s d i r e c c i o n e s de todas l a s campanas creadas 37 const addre s s e s = await f a c t o r y . methods . getDeployedCampaigns ( ) . c a l l ( ) ; 38 campaignAddress = addre s s e s [ 0 ] ; 39 40 //Se crea una i n s t an c i a de l cont rato a p a r t i r de l a d i r e c c i o n 41 campaign = await new web3 . eth . Contract (JSON. parse ( compiledCampaign . i n t e r f a c e ) , campaignAddress ) ; 42 43 }) ; 44 45 // Desc r ipc i on de l a s pruebas 46 de s c r i b e ( ’ Pruebas a campanas ’ , ( ) => { 47 48 //Prueba que In s t an c i a una CampaignFactory y una Campana 49 i t ( ’ I n s t an c i a una CampaignFactory y una Campana ’ , ( ) => { 50 51 //Se v e r i f i c a que ambas d i r e c c i o n e s no sean NULL, asegurando su co r r e c t o de sp l i gu e en l a red l o c a l 52 a s s e r t . ok ( f a c t o r y . opt i ons . address ) ; 53 a s s e r t . ok ( campaign . opt i ons . address ) ; 54 }) ; 55 56 //Prueba que Marca a l que l lama a l a campana como gerente 57 i t ( ’Marca a l que l lama a l a campana como gerente ’ , async ( ) => { 58 59 //Se l lama a l a t r i bu to ’manager ’ de l a i n s t an c i a de l cont rato y se compara con l a d i r e c c i o n ac tua l que presenta l a red l o c a l 60 const manager = await campaign . methods . manager ( ) . c a l l ( ) ; 61 a s s e r t . equal ( accounts [ 0 ] , manager ) ; 62 }) ; 63 64 //Prueba que Permite a l o s u sua r i o s c on t r i b u i r y marcar los como cont r ibuyente s 65 i t ( ’ Permite a l o s u sua r i o s c on t r i b u i r y marcar los como cont r ibuyente s ’ , async ( ) => { 66 6.3 Construcción (Construction) 65 67 //Se r e a l i z a una cont r ibuc i on a l a campana 68 await campaign . methods . c on t r i bu t e ( ) . send ({ 69 value : ’ 200 ’ , 70 from : accounts [ 1 ] 71 }) ; 72 73 //Se l lama a l a t r i bu to approvers con l a d i r e c c i o n que acaba de r e a l i z a r l a con t r ibuc i on 74 const i sCont r i bu to r = await campaign . methods . approvers ( accounts [ 1 ] ) . c a l l ( ) ; 75 76 //El va l o r debe s e r t rue 77 a s s e r t ( i sCont r i bu to r ) ; 78 79 }) ; 80 81 //Prueba que asegura de r e qu e r i r una cont r ibuc i on minima 82 i t ( ’ Asegura de r e qu e r i r una cont r ibuc i on minima ’ , async ( ) => { 83 84 //Se r e a l i z a r una cont r ibuc i on menor a l monto minimo e s t ab l e c i d o (100) 85 t ry { 86 await campaign . methods . con t r i bu t e ( ) . send ({ 87 value : ’ 5 ’ , 88 from : accounts [ 1 ] 89 }) ; 90 // S i se l l e g a a e s t e punto de l a prueba , es que a lgo malo ocur r i o , l a idea es que e l catch se e j e c u t e 91 a s s e r t ( f a l s e ) ; 92 } catch ( e r r ) { 93 94 // S i e l catch se e j ecuta , hubo un f a l l o , l o cua l es e l comportamiento esperado 95 a s s e r t ( e r r ) ; 96 } 97 }) ; 98 99 //Prueba que permite a l ge r ente c r ea r s o l i c i t u d e s 100 i t ( ’ Permite a l ge r ente c r ea r s o l i c i t u d e s ’ , async ( ) => { 101 102 //Se l lama a l metodo ’ createRequest ’ 103 await campaign . methods . c reateRequest ( ’Comprar b a t e r i a s ’ , ’ 100 ’ , accounts [ 1 ] ) . send ({ 104 from : accounts [ 0 ] , 105 gas : ’ 1000000 ’ 106 }) ; 107 108 //Se obt i ene l a s o l i c i t u d r e c i e n creada 109 const r eque s t = await campaign . methods . r eque s t s (0 ) . c a l l ( ) ; 66 6 Caṕıtulo 6 - Marco aplicativo 110 111 //Se v e r i f i c a que l a d e s c r i p c i on de l a s o l i c i t u d sea ’Comprar b a t e r i a s ’ 112 a s s e r t . equal ( ’Comprar b a t e r i a s ’ , r eque s t . d e s c r i p t i o n ) ; 113 }) ; 114 115 //Prueba que permite proce sa r s o l i c i t u d e s 116 i t ( ’ Procesar s o l i c i t u d e s ’ , async ( ) => { 117 118 //Primero se r e a l i z a una cont r ibuc i on 119 await campaign . methods . c on t r i bu t e ( ) . send ({ 120 from : accounts [ 0 ] , 121 value : web3 . u t i l s . toWei ( ’ 10 ’ , ’ e the r ’ ) 122 }) ; 123 124 //Se crea una s o l i c i t u d 125 await campaign . methods . c reateRequest ( ’A ’ , web3 . u t i l s . toWei ( ’ 5 ’ , ’ e the r ’ ) , accounts [ 1 ] ) . send ({ 126 from : accounts [ 0 ] , 127 gas : ’ 1000000 ’ 128 }) ; 129 130 //Se aprueba l a s o l i c i t u d r e c i e n creada 131 await campaign . methods . approveRequest (0 ) . send ({ 132 from : accounts [ 0 ] , 133 gas : ’ 1000000 ’ 134 }) ; 135 136 //Se f i n a l i z a l a s o l i c i t u d r e c i e n aprobada 137 await campaign . methods . f i n a l i z eRequ e s t (0 ) . send ({ 138 from : accounts [ 0 ] , 139 gas : ’ 1000000 ’ 140 }) ; 141 142 //Se obt i ene e l ba lance de l a cuenta de s t i no 143 l e t ba lance = await web3 . eth . getBalance ( accounts [ 1 ] ) ; 144 145 //El balance se pasa de wei a e the r 146 balance = web3 . u t i l s . fromWei ( balance , ’ e the r ’ ) ; 147 balance = parseF loat ( ba lance ) ; 148 149 conso l e . l og ( balance ) ; 150 151 //Se v e r i f i c a que e l ba lance sea mayor a l o que t en i a en un p r i n c i p i o 152 a s s e r t ( ba lance > 104) ; 153 }) ; 6.3 Construcción (Construction) 67 154 }) ; Algoritmo 6.3: Código que realiza pruebas automáticas de despliegue de un contrato y funcionalidades 68 6 Caṕıtulo 6 - Marco aplicativo Tipo de prueba Funcional Entorno de ejecución Ubuntu 16.04 LTS Ejecutante Desarrollador de la herramienta Herramienta usada Mocha Veces ejecutada 1 Resultados 100% de los requerimientos estipulados Tabla 6-2: Especificaciones de la prueba automática para la versión 0.1 Es importante acotar la información con respecto al equipo de hardware utilizado para realizar dicha prueba, el cual es: Componente Especificación Sistema Operativo Ubuntu 16.04 LTS Memoria 2GB Procesador Intel Core i5-3470 CPU @ 3.20GHz x 4 Disco Duro 500GB Tabla 6-3: Especificaciones de hardware para pruebas en Mocha Una vez definidas las pruebas para la campaña, se hace uso del comando ’npm run test’, provisto por Mocha en el terminal para ejecutar el código anterior y que se realicen las pruebas de manera automática: 6.3 Construcción (Construction) 69 Figura 6-10: Ejecución de pruebas automáticas mediante el uso de la biblioteca Mocha. 70 6 Caṕıtulo 6 - Marco aplicativo Como se pude observar en la Figura 6-10, las pruebas se realizaron de manera exitosa, se logró hacer el despligue del ABI y el Bytecode en una red local Ethereum y se validó el correcto funcionamiento. 6.3.3. Iteración 2: Segundo acercamiento, reestructuración de pruebas En vista de las pruebas exitosas con respecto a un primer prototipo de contrato construido, en la presente iteración se tomarán en cuenta algunos aspectos dejados de lado en la iteración 0. El siguiente código representa una siguiente versión del contrato el cual maneja una confi- guración más amplia de parte del gerente a la hora de definir los parámetros de su instancia de campaña: 1 //Vers ion de S o l i d i t y a u t i l i z a r 2 pragma s o l i d i t y ˆ 0 . 4 . 1 7 ; 3 4 cont rac t CampaignFactory{ 5 //Unico a t r i bu to de l cont rato generador de campanas e l p r e s en te a t r i bu to se u t i l i z a para devo lve r todas l a s d i r e c c i o n e s i n s t a n c i a s generadas 6 address [ ] pub l i c deployedCampaigns ; 7 8 //Funcion que genera i n s t a n c i a s de l contrato Campaign , r e c i b e un monto minimo de contr ibuc ion , un monto maximo de cont r ibuc i on y un numero maximo de cont r ibuyente s 9 f unc t i on createCampaign ( u int minimum , u int maximum, u int maxCont , ) pub l i c { 10 address newCampaign = new Campaign (minimum , maximum, maxCont , msg . sender ) ; 11 12 //Una vez creada l a i n s t anc i a , se agrega a l a r r e g l o de d i r e c c i o n e s de i n s t a n c i a s de Campaigns 13 deployedCampaigns . push (newCampaign ) ; 14 } 15 16 //Funcion que re to rna un a r r e g l o de d i r e c c i o n e s con todas l a s i n t an c i a s de Campaigns 17 f unc t i on getDeployedCampaigns ( ) pub l i c view re tu rn s ( address [ ] ) { 18 r e turn deployedCampaigns ; 19 } 20 21 } 22 23 //Contrato p r i n c i pa l , en e s t e cont rato se implementa toda l a l o g i c a y func i ona l i dad de l a s campanas 24 cont rac t Campaign{ 25 6.3 Construcción (Construction) 71 26 // Estructura Request que r ep r e s en ta una s o l i c i t u d creada por e l ge r ente de l contrato 27 s t r u c t Request{ 28 29 // St r ing que r ep r e s en ta l a d e s c r i p c i on de l a s o l i c i t u d 30 s t r i n g d e s c r i p t i o n ; 31 32 //Entero p o s i t i v o que r ep r e s en ta e l va l o r que desea r e t i r a r l a s o l i c i t u d de l a campana 33 uint va lue ; 34 35 // Di r ecc i on que r e c i b i r a l o s fondos de l a s o l i c i t u d 36 address r e c i p i e n t ; 37 38 // Var iab le booleana que r ep r e s en ta s i l a s o l i c i t u d ha s ido completada o no 39 bool complete ; 40 41 //Entero p o s i t i v o que r ep r e s en ta l a cant idad de votos aprobados de l a s o l i c i t u d 42 uint approvalCount ; 43 44 //Tipo de dato mapping , que r e a l i z a l a cor r e spondenc ia de una d i r e c c i o n con un va l o r booleano , en cuanto se r e a l i c e una votac ion , e l mapeo de l a d i r e c c i o n de e s t a va r i ab l e s e ra as ignado a True 45 mapping ( address => bool ) approva l s ; 46 } 47 48 // L i s t a de a t r i bu t o s de l cont rato 49 50 //Arreg lo de s o l i c i t u d e s que posee e l cont rato 51 Request [ ] pub l i c r eque s t s ; 52 53 // Di r ecc i on de l ge r ente de l cont rato 54 address pub l i c manager ; 55 56 //Contr ibuc ion minima 57 uint pub l i c minimumContribution ; 58 59 //Contr ibuc ion maxima 60 uint pub l i c maximumContribution ; 61 62 //Numero maximo de cont r ibuyente s 63 uint pub l i c maxContributors ; 64 65 //Mapeo de d i r e c c i o n e s a va l o r e s boo leanos que repre sentan l a l i s t a de cont r ibuyente s votantes 66 mapping ( address => bool ) pub l i c approvers ; 72 6 Caṕıtulo 6 - Marco aplicativo 67 68 //Contador de votantes 69 uint pub l i c approversCount ; 70 71 72 //Funcion que r e s t r i n g e l a p o s i b i l i d a d de una func ion a s e r llamada , en e s t e caso , r e t r i n g e a l a func ion a s e r l lamada por a l gu i en que no sea e l ge r ente de l a campana 73 mod i f i e r r e s t r i c t e d ( ) { 74 r e qu i r e (msg . sender == manager ) ; 75 ; 76 } 77 78 //Constructor de l contrato , r e c i b e sus parametros desde l a func ion createCampaign de CampaignFactory 79 f unc t i on Campaign ( u int minimum , address c r e a t o r ) pub l i c { 80 81 //Es reque r ido que e l monto minimo de aprobacion sea mayor a cero 82 r e qu i r e (minimum > 0) ; 83 manager = c r ea t o r ; 84 minimumContribution = minimum ; 85 maximumContribution = maximum; 86 maxContributors = maxCont ; 87 } 88 89 //Funcion que permite a una d i r e c c i o n c on t r i b u i r a l a campana , l a palabra re se rvada ’ payable ’ i nd i c a que l a func ion debe r e c i b i r un va l o r en wei , e l cua l s e ra agregado a l a i n s t an c i a de l cont rato 90 f unc t i on con t r i bu t e ( ) pub l i c payable { 91 //Requer imientos ba s i c o s para que l a func ion pueda s e gu i r su curso natura l : 92 //�El va l o r con e l que se l lama a l a func ion debe s e r mayor a l a minima cont r ibuc i on e s t ab l e c i d a 93 //�El va l o r con e l que se l lama a l a func ion debe s e r menor a l a maxima cont r ibuc i on e s t ab l e c i da , o s e r cero , para que no haya l im i t e en l a con t r ibuc i on 94 //�El numero de d i r e c c i o n e s que aprueban una s o l i c i t u d no puede s e r mayor a l numero maximo de contr ibuyentes , o debe s e r 0 , en caso de que no haya l im i t e 95 r e qu i r e (msg . va lue > minimumContribution ) ; 96 r e qu i r e (msg . va lue > minimumContribution && (msg . va lue < maximumContribution | | maximumContribution == 0 )&& ( approversCount < maxContributors | | maxContributors == 0) ) ; 97 98 99 //Este c ond i c i ona l permite a una d i r e c c i o n c on t r i b u i r v a r i a s veces a una misma campama 100 i f ( approvers [ msg . sender ] == f a l s e ) { 6.3 Construcción (Construction) 73 101 102 //Se mapea su va lo r a true , y se aumenta e l contador de votantes 103 approvers [ msg . sender ] = true ; 104 approversCount++; 105 } 106 107 } 108 109 //Funcion que crea una s o l i c i t u d , r e c i b e una de s c r i p c i on , un va lo r y una d i r e c c i o n de s t i no ( Notese e l a t r i bu to r e s t r i c t e d : s o l o puede s e r l lamada por e l ge r ente de l a campana ) 110 f unc t i on createRequest ( s t r i n g de s c r i p t i on , u int value , address r e c i p i e n t ) pub l i c r e s t r i c t e d { 111 112 //Se crea l a nueva e s t ru c tu r a con l o s parametros r e c i b i d o s 113 Request memory newRequest = Request ({ 114 d e s c r i p t i o n : d e s c r i p t i on , 115 value : value , 116 r e c i p i e n t : r e c i p i e n t , 117 //Se i n i c i a l i z a en f a l s o , puesto que se acaba de c r ea r dicha s o l i c i t u d y aun no se ha completado 118 complete : f a l s e , 119 //Se i n i c i a l i z a e l contador de aprobados en cero . 120 approvalCount : 0 121 }) ; 122 123 //Se agrega l a s o l i c i t u d r e c i e n creada a l a r r e g l o de s o l i c i t u d e s de l contrato 124 r eque s t s . push ( newRequest ) ; 125 126 } 127 128 //Funcion llamada por l o s cont r ibuyente s de l a campana , para aprobar una s o l i c i t u d , r e c i b e un i nd i c e de l a r r e g l o de s o l i c i t u d e s para conocer cua l s o l i c i t u d desea votar para su aprobacion 129 f unc t i on approveRequest ( u int index ) pub l i c { 130 131 // Loca l i z a r l a s o l i c i t u d segun e l i n d i c e 132 Request s t o rage r eque s t = r eque s t s [ index ] ; 133 134 //Para que l a func ion cont inue su curso natura l , e s r eque r ido que l a d i r e c c i o n que l lama l a func ion sea un cont r ibyent e 135 r e qu i r e ( approvers [ msg . sender ] ) ; 136 137 //Tambien es n e c e s a r i o que l a d i r e c c i o n que l lama a l a func ion NO haya votado anter iormente 138 r e qu i r e ( ! r eque s t . approva l s [ msg . sender ] ) ; 139 74 6 Caṕıtulo 6 - Marco aplicativo 140 //La d i r e c c i o n aprobo l a s o l i c i t u d 141 r eque s t . approva l s [ msg . sender ] = true ; 142 143 //Se incrementa l a cuenta de votos 144 r eque s t . approvalCount++; 145 146 } 147 148 //Funcion llamada para dar por f i n a l i z a d a una s o l i c i t u d , r e c i b e un i nd i c e para i d e n t i f i c a r l a s o l i c i t u d a f i n a l i z a r , notese e l a t r i bu to r e s t r i c t e d , s o l o puede s e r l lamada por e l ge r ente 149 f unc t i on f i n a l i z eRequ e s t ( u int index ) pub l i c r e s t r i c t e d { 150 // I d en t i f i c a ndo l a s o l i c i t u d 151 Request s t o rage r eques t = r eque s t s [ index ] ; 152 //Es reque r ido que hayan votado pos i t ivamente l a mitad de l o s cont r ibuyente s 153 r e qu i r e ( r eque s t . approvalCount > ( approversCount / 2) ) ; 154 155 //Es requer ido , ademas , que l a s o l i c i t u d no haya s ido marcada como completada 156 r e qu i r e ( ! r eque s t . complete ) ; 157 158 //Se t r a n s f i e r e n l o s fondos a l a d i r e c c i o n de s t i no 159 r eque s t . r e c i p i e n t . t r a n s f e r ( r eque s t . va lue ) ; 160 161 //Se marca l a s o l i c i t u d como completada 162 r eque s t . complete = true ; 163 } 164 165 //Funcion que re to rna un resumen de l a campana 166 f unc t i on getSummary ( ) pub l i c view re tu rn s ( uint , uint , uint , uint , uint , uint , address ) { 167 168 //Retornar todos l o s a t r i bu t o s de l a campana 169 r e turn ( 170 minimumContribution , 171 maximumContribution , 172 maxContributors , 173 t h i s . balance , 174 r eque s t s . length , 175 approversCount , 176 manager 177 ) ; 178 } 179 180 //Funcion que re to rna e l numero de s o l i c i t u d e s 181 f unc t i on getRequestCount ( ) pub l i c view re tu rn s ( u int ) { 182 r e turn r eque s t s . l ength ; 6.3 Construcción (Construction) 75 183 } 184 } Algoritmo 6.4: Versión 0.2 de solución para el caso de uso La versión 0.2 de la solución del caso de uso presenta las siguientes evoluciones: Permite al gerente ingresar una contribución máxima. Permite al gerente ingresar un número máximo de contribuyentes. Valida que la contribución mı́nima debe ser mayor a 0. Si la contribución máxima o el número de contribuyentes es 0, se toma como si no hubiera ĺımite. Se puede obtener un objeto que contiene el resumen de una campaña. Se puede hacer una llamada al contrato para conocer el número de solicitudes. Muchas de estas nuevas adiciones son útiles a la hora de implementar el cliente web, puesto que mientras más detalles se puedan mostrar de una campaña, se mostrará más confianza al usuario final a la hora de contribuir a una campaña. 6.3.3.1. Prueba versión 0.2 Una vez construida la evolución de un primer contrato, también debe modificarse el código que realiza las pruebas, puesto que ahora, el constructor recibe nuevos parámetros y existen nuevas validaciones que podŕıan ocasionar errores en el comportamiento esperado. Tipo de prueba Funcional Entorno de ejecución MAc OS Sierra Ejecutante Desarrollador de la herramienta Herramienta usada Mocha Veces ejecutada 5 Resultados 100% de los requerimientos estipulados Tabla 6-4: Especificaciones de la prueba para la versión 0.2 Para esta prueba, se realizó el despliegue mediante otro equipo de hardware con la finalidad de descartar el funcionamiento exclusivo de la prueba en un sistema operativo determinado, el nuevo hardware que realiza la prueba se describe a continuación: 76 6 Caṕıtulo 6 - Marco aplicativo Componente Especificación Sistema Operativo Mac OS Sierra Memoria 4GB Procesador Mac Mini 2.3 GHz Core i5 (I5-2415M) Disco Duro 1TB Tabla 6-5: Especificaciones de hardware para pruebas en Mocha. Ambiente MacOS 6.3 Construcción (Construction) 77 Se presenta el código que realiza las pruebas anteriores, asegurando que todas las funciona- lidades anteriores siguen cumpliendo sus tareas, y además se agrega una nueva prueba de funcionamiento. 1 //Dependencias n e c e s a r i a s 2 const a s s e r t = r equ i r e ( ’ a s s e r t ’ ) ; 3 4 //Ganache permite c r ea r nuest ro propio ambiente Ethereum loca lmente 5 const ganache = r equ i r e ( ’ ganache�c l i ’ ) ; 6 const Web3 = r equ i r e ( ’web3 ’ ) ; 7 const web3 = new Web3( ganache . p rov ide r ( ) ) ; 8 9 //Contratos a u t i l i z a r 10 const compiledFactory = r equ i r e ( ’ . . / ethereum/ bu i ld /CampaignFactory . j son ’ ) ; 11 const compiledCampaign = r equ i r e ( ’ . . / ethereum/ bu i ld /Campaign . j son ’ ) ; 12 13 // L i s t a de v a r i a b l e s n e c e s a r i a s para e l d e sp l i gu e 14 l e t accounts ; 15 l e t f a c t o r y ; 16 l e t campaignAddress ; 17 l e t campaign ; 18 19 //Metodo llamado antes de r e a l i z a r cada una de l a s pruebas , e l metodo crea campanas automaticamente para r e a l i z a r pruebas 20 beforeEach ( async ( ) => { 21 22 //Se obt i ene una cuenta que hara e l d e sp l i e gu e de l cont rato ’ CampaignFactory ’ 23 accounts = await web3 . eth . getAccounts ( ) ; 24 25 //Se crea l a i n s t an c i a de l cont rato ’ CampaignFactory ’ 26 f a c t o r y = await new web3 . eth . Contract (JSON. parse ( compi ledFactory . i n t e r f a c e ) ) . 27 deploy ({ data : compiledFactory . bytecode }) . 28 send ({ from : accounts [ 0 ] , gas : ’ 2000000 ’ }) ; 29 30 //Se crea una campana u t i l i z a ndo l a i n s t an c i a r e c i e n creada 31 await f a c t o r y . methods . createCampaign ( ’ 100 ’ ,web3 . u t i l s . toWei ( ’ 12 ’ , ’ e the r ’ ) , ’ 0 ’ , ’ 50 ’ , ’ 50 ’ ) . send ({ 32 from : accounts [ 0 ] , 33 gas : ’ 2000000 ’ 34 }) ; 35 36 //Se obt ienen l a s d i r e c c i o n e s de todas l a s campanas creadas 37 const addre s s e s = await f a c t o r y . methods . getDeployedCampaigns ( ) . c a l l ( ) ; 38 campaignAddress = addre s s e s [ 0 ] ; 39 40 //Se crea una i n s t an c i a de l cont rato a p a r t i r de l a d i r e c c i o n 78 6 Caṕıtulo 6 - Marco aplicativo 41 campaign = await new web3 . eth . Contract (JSON. parse ( compiledCampaign . i n t e r f a c e ) , campaignAddress ) ; 42 43 }) ; 44 45 // Desc r ipc i on de l a s pruebas 46 de s c r i b e ( ’ Pruebas a campanas ’ , ( ) => { 47 48 //Prueba que In s t an c i a una CampaignFactory y una Campana 49 i t ( ’ I n s t an c i a una CampaignFactory y una Campana ’ , ( ) => { 50 51 //Se v e r i f i c a que ambas d i r e c c i o n e s no sean NULL, asegurando su co r r e c t o de sp l i gu e en l a red l o c a l 52 a s s e r t . ok ( f a c t o r y . opt i ons . address ) ; 53 a s s e r t . ok ( campaign . opt i ons . address ) ; 54 }) ; 55 56 //Prueba que Marca a l que l lama a l a campana como gerente 57 i t ( ’Marca a l que l lama a l a campana como gerente ’ , async ( ) => { 58 59 //Se l lama a l a t r i bu to ’manager ’ de l a i n s t an c i a de l cont rato y se compara con l a d i r e c c i o n ac tua l que presenta l a red l o c a l 60 const manager = await campaign . methods . manager ( ) . c a l l ( ) ; 61 a s s e r t . equal ( accounts [ 0 ] , manager ) ; 62 }) ; 63 64 //Prueba que Permite a l o s u sua r i o s c on t r i b u i r y marcar los como cont r ibuyente s 65 i t ( ’ Permite a l o s u sua r i o s c on t r i b u i r y marcar los como cont r ibuyente s ’ , async ( ) => { 66 67 //Se r e a l i z a una cont r ibuc i on a l a campana 68 await campaign . methods . c on t r i bu t e ( ) . send ({ 69 value : ’ 200 ’ , 70 from : accounts [ 1 ] 71 }) ; 72 73 //Se l lama a l a t r i bu to approvers con l a d i r e c c i o n que acaba de r e a l i z a r l a con t r ibuc i on 74 const i sCont r i bu to r = await campaign . methods . approvers ( accounts [ 1 ] ) . c a l l ( ) ; 75 76 //El va l o r debe s e r t rue 77 a s s e r t ( i sCont r i bu to r ) ; 78 79 }) ; 80 81 //Prueba que asegura de r e qu e r i r una cont r ibuc i on minima 6.3 Construcción (Construction) 79 82 i t ( ’ Asegura de r e qu e r i r una cont r ibuc i on minima ’ , async ( ) => { 83 84 //Se r e a l i z a r una cont r ibuc i on menor a l monto minimo e s t ab l e c i d o (100) 85 t ry { 86 await campaign . methods . con t r i bu t e ( ) . send ({ 87 value : ’ 5 ’ , 88 from : accounts [ 1 ] 89 }) ; 90 // S i se l l e g a a e s t e punto de l a prueba , es que a lgo malo ocur r i o , l a idea es que e l catch se e j e c u t e 91 a s s e r t ( f a l s e ) ; 92 } catch ( e r r ) { 93 94 // S i e l catch se e j ecuta , hubo un f a l l o , l o cua l es e l comportamiento esperado 95 a s s e r t ( e r r ) ; 96 } 97 }) ; 98 99 //Prueba que asegura que una cont r ibuc i on minima no puede s e r 0 100 i t ( ’ Asegura que una cont r ibuc i on minima no puede s e r 0 ’ , async ( ) => { 101 102 //Se r e a l i z a r una cont r ibuc i on de 0 103 t ry { 104 await campaign . methods . con t r i bu t e ( ) . send ({ 105 value : ’ 0 ’ , 106 from : accounts [ 1 ] 107 }) ; 108 // S i se l l e g a a e s t e punto de l a prueba , es que a lgo malo ocur r i o , l a idea es que e l catch se e j e c u t e 109 a s s e r t ( f a l s e ) ; 110 } catch ( e r r ) { 111 112 // S i e l catch se e j ecuta , hubo un f a l l o , l o cua l es e l comportamiento esperado 113 a s s e r t ( e r r ) ; 114 } 115 }) ; 116 117 //Prueba que asegura de no sobrepasar l a con t r ibuc i on maxima 118 i t ( ’ Asegura de no sobrepasar l a con t r ibuc i on maxima ’ , async ( ) => { 119 120 //Se r e a l i z a r una cont r ibuc i on mayor a l monto maximo e s t a b l e c i d o (10 e the r ) 121 t ry { 122 await campaign . methods . con t r i bu t e ( ) . send ({ 123 value : web3 . u t i l s . toWei ( ’ 15 ’ , ’ e the r ’ ) , 124 from : accounts [ 1 ] 80 6 Caṕıtulo 6 - Marco aplicativo 125 }) ; 126 // S i se l l e g a a e s t e punto de l a prueba , es que a lgo malo ocur r i o , l a idea es que e l catch se e j e c u t e 127 a s s e r t ( f a l s e ) ; 128 } catch ( e r r ) { 129 130 // S i e l catch se e j ecuta , hubo un f a l l o , l o cua l es e l comportamiento esperado 131 a s s e r t ( e r r ) ; 132 } 133 }) ; 134 135 //Prueba que permite a l ge r ente c r ea r s o l i c i t u d e s 136 i t ( ’ Permite a l ge r ente c r ea r s o l i c i t u d e s ’ , async ( ) => { 137 138 //Se l lama a l metodo ’ createRequest ’ 139 await campaign . methods . c reateRequest ( ’Comprar b a t e r i a s ’ , ’ 100 ’ , accounts [ 1 ] ) . send ({ 140 from : accounts [ 0 ] , 141 gas : ’ 1000000 ’ 142 }) ; 143 144 //Se obt i ene l a s o l i c i t u d r e c i e n creada 145 const r eque s t = await campaign . methods . r eque s t s (0 ) . c a l l ( ) ; 146 147 //Se v e r i f i c a que l a d e s c r i p c i on de l a s o l i c i t u d sea ’Comprar b a t e r i a s ’ 148 a s s e r t . equal ( ’Comprar b a t e r i a s ’ , r eque s t . d e s c r i p t i o n ) ; 149 }) ; 150 151 //Prueba que permite proce sa r s o l i c i t u d e s 152 i t ( ’ Procesar s o l i c i t u d e s ’ , async ( ) => { 153 154 //Primero se r e a l i z a una cont r ibuc i on 155 await campaign . methods . c on t r i bu t e ( ) . send ({ 156 from : accounts [ 0 ] , 157 value : web3 . u t i l s . toWei ( ’ 10 ’ , ’ e the r ’ ) 158 }) ; 159 160 //Se crea una s o l i c i t u d 161 await campaign . methods . c reateRequest ( ’A ’ , web3 . u t i l s . toWei ( ’ 5 ’ , ’ e the r ’ ) , accounts [ 1 ] ) . send ({ 162 from : accounts [ 0 ] , 163 gas : ’ 1000000 ’ 164 }) ; 165 166 //Se aprueba l a s o l i c i t u d r e c i e n creada 167 await campaign . methods . approveRequest (0 ) . send ({ 168 from : accounts [ 0 ] , 6.3 Construcción (Construction) 81 169 gas : ’ 1000000 ’ 170 }) ; 171 172 //Se f i n a l i z a l a s o l i c i t u d r e c i e n aprobada 173 await campaign . methods . f i n a l i z eRequ e s t (0 ) . send ({ 174 from : accounts [ 0 ] , 175 gas : ’ 1000000 ’ 176 }) ; 177 178 //Se obt i ene e l ba lance de l a cuenta de s t i no 179 l e t ba lance = await web3 . eth . getBalance ( accounts [ 1 ] ) ; 180 181 //El balance se pasa de wei a e the r 182 balance = web3 . u t i l s . fromWei ( balance , ’ e the r ’ ) ; 183 balance = parseF loat ( ba lance ) ; 184 185 conso l e . l og ( balance ) ; 186 187 //Se v e r i f i c a que e l ba lance sea mayor a l o que t en i a en un p r i n c i p i o 188 a s s e r t ( ba lance > 104) ; 189 190 }) ; 191 192 }) ; Algoritmo 6.5: Código que realiza pruebas automáticas de despliegue de un contrato y funcionalidades. Versión 0.2 82 6 Caṕıtulo 6 - Marco aplicativo La prueba ahora contempla el hecho de que existe una contribución máxima, y que no una contribución no debe sobrepasar ese monto. El comando que ejecuta las pruebas vuelve a ejecutarse para realizar dichas pruebas modificadas: Figura 6-11: Ejecución de pruebas automáticas mediante el uso de la biblioteca Mocha para la versioón 0.2 de la solución. Sin embargo, aún quedan piezas importantes de la problemática por resolver: Lógica para rechazar una solicitud. Tasas de aprobación y rechazo de una solicitud. Expiración de una solicitud. 6.3.4. Iteración 3: Rechazo de solicitudes y tasas Esta iteración presenta la implementación del rechazo de solicitudes aśı como también los atributos de tasa de rechazo y tasa de aprobación de una solicitud. Esto representa un nivel más alto aún de personalización de la campaña. Este tipo de adiciones al código lo hacen mucho más versátil y manejable tanto como para el gerente de la campaña, como a los usuarios a la hora de contribuir a una campaña, mientras más información se les pueda brindar, más confianza tendrán y serán más propensos a realizar contribuciones. A continuación se presenta la versión 0.3 de la solución: 6.3 Construcción (Construction) 83 1 //Vers ion de S o l i d i t y a u t i l i z a r 2 pragma s o l i d i t y ˆ 0 . 4 . 1 7 ; 3 4 cont rac t CampaignFactory{ 5 //Unico a t r i bu to de l contrato generador de campanas e l p r e s en te a t r i bu to se u t i l i z a para devo lve r todas l a s d i r e c c i o n e s i n s t a n c i a s generadas 6 address [ ] pub l i c deployedCampaigns ; 7 8 //Funcion que genera i n s t a n c i a s de l cont rato Campaign , r e c i b e un monto minimo de contr ibuc ion , un monto maximo de contr ibuc ion , una cant idad maxima de contr ibuyentes , una tasa de aprobacion y una tasa de rechazo 9 f unc t i on createCampaign ( u int minimum , u int maximum, u int maxCont , u int approveRate , u int r e j e c tRat e ) pub l i c { 10 address newCampaign = new Campaign (minimum , maximum, maxCont , msg . sender , approveRate , r e j e c tRat e ) ; 11 12 //Una vez creada l a i n s t anc i a , se agrega a l a r r e g l o de d i r e c c i o n e s de i n s t a n c i a s de Campaigns 13 deployedCampaigns . push (newCampaign ) ; 14 } 15 16 //Funcion que re to rna un a r r e g l o de d i r e c c i o n e s con todas l a s i n t an c i a s de Campaigns 17 f unc t i on getDeployedCampaigns ( ) pub l i c view re tu rn s ( address [ ] ) { 18 r e turn deployedCampaigns ; 19 } 20 21 } 22 23 //Contrato p r i n c i pa l , en e s t e cont rato se implementa toda l a l o g i c a y func i ona l i dad de l a s campanas 24 cont rac t Campaign{ 25 26 // Estructura Request que r ep r e s en ta una s o l i c i t u d creada por e l ge r ente de l contrato 27 s t r u c t Request{ 28 29 // St r ing que r ep r e s en ta l a d e s c r i p c i on de l a s o l i c i t u d 30 s t r i n g d e s c r i p t i o n ; 31 32 //Entero p o s i t i v o que r ep r e s en ta e l va l o r que desea r e t i r a r l a s o l i c i t u d de l a campana 33 uint va lue ; 34 35 // Di r ecc i on que r e c i b i r a l o s fondos de l a s o l i c i t u d 36 address r e c i p i e n t ; 37 38 // Var iab le booleana que r ep r e s en ta s i l a s o l i c i t u d ha s ido completada 84 6 Caṕıtulo 6 - Marco aplicativo o no 39 bool complete ; 40 41 //Entero p o s i t i v o que r ep r e s en ta l a cant idad de votos aprobados de l a s o l i c i t u d 42 uint approvalCount ; 43 44 //Entero p o s i t i v o que r ep r e s en ta l a cant idad de votos rechazados de l a s o l i c i t u d 45 uint re j e c t sCount ; 46 47 //Tipo de dato mapping , que r e a l i z a l a cor r e spondenc ia de una d i r e c c i o n con un va l o r booleano , en cuanto se r e a l i c e una votac ion , e l mapeo de l a d i r e c c i o n de e s ta va r i ab l e s e ra as ignado a True 48 mapping ( address => bool ) approva l s ; 49 } 50 51 // L i s t a de a t r i bu t o s de l cont rato 52 53 //Arreg lo de s o l i c i t u d e s que posee e l cont rato 54 Request [ ] pub l i c r eque s t s ; 55 56 // Di r ecc i on de l ge r ente de l cont rato 57 address pub l i c manager ; 58 59 //Contr ibuc ion minima 60 uint pub l i c minimumContribution ; 61 62 //Contr ibuc ion maxima 63 uint pub l i c maximumContribution ; 64 65 //Numero maximo de cont r ibuyente s 66 uint pub l i c maxContributors ; 67 68 // Porcenta je para e l po r c en ta j e de aprobacion 69 uint pub l i c approvalRate ; 70 71 // Porcenta je para e l po r c en ta j e de rechazo 72 uint pub l i c r e j e c t edRate ; 73 74 //Mapeo de d i r e c c i o n e s a va l o r e s boo leanos que repre sentan l a l i s t a de cont r ibuyente s votantes 75 mapping ( address => bool ) pub l i c approvers ; 76 77 //Contador de votantes 78 uint pub l i c approversCount ; 79 80 6.3 Construcción (Construction) 85 81 //Funcion que r e s t r i n g e l a p o s i b i l i d a d de una func ion a s e r llamada , en e s t e caso , r e t r i n g e a l a func ion a s e r l lamada por a l gu i en que no sea e l ge r ente de l a campana 82 mod i f i e r r e s t r i c t e d ( ) { 83 r e qu i r e (msg . sender == manager ) ; 84 ; 85 } 86 87 //Constructor de l contrato , r e c i b e sus parametros desde l a func ion createCampaign de CampaignFactory 88 f unc t i on Campaign ( u int minimum , u int maximum, u int maxCont , address c reator , u int approveRate , u int r e j e c tRat e ) pub l i c { 89 90 //Es reque r ido que e l monto minimo de aprobacion sea mayor a cero 91 r e qu i r e (minimum > 0) ; 92 manager = c r ea t o r ; 93 minimumContribution = minimum ; 94 maximumContribution = maximum; 95 maxContributors = maxCont ; 96 approvalRate = approveRate ; 97 r e j e c t edRate = re j e c tRat e ; 98 } 99 100 //Funcion que permite a una d i r e c c i o n c on t r i b u i r a l a campana , l a palabra re se rvada ’ payable ’ i nd i c a que l a func ion debe r e c i b i r un va l o r en wei , e l cua l s e ra agregado a l a i n s t an c i a de l cont rato 101 f unc t i on con t r i bu t e ( ) pub l i c payable { 102 //Requer imientos ba s i c o s para que l a func ion pueda s e gu i r su curso natura l : 103 //�El va l o r con e l que se l lama a l a func ion debe s e r mayor a l a minima cont r ibuc i on e s t ab l e c i d a 104 //�El va l o r con e l que se l lama a l a func ion debe s e r menor a l a maxima cont r ibuc i on e s t ab l e c i da , o s e r cero , para que no haya l im i t e en l a con t r ibuc i on 105 //�El numero de d i r e c c i o n e s que aprueban una s o l i c i t u d no puede s e r mayor a l numero maximo de contr ibuyentes , o debe s e r 0 , en caso de que no haya l im i t e 106 r e qu i r e (msg . va lue > minimumContribution ) ; 107 r e qu i r e (msg . va lue > minimumContribution && (msg . va lue < maximumContribution | | maximumContribution == 0 )&& ( approversCount < maxContributors | | maxContributors == 0) ) ; 108 109 110 //Este c ond i c i ona l permite a una d i r e c c i o n c on t r i b u i r v a r i a s veces a una misma campama 111 i f ( approvers [ msg . sender ] == f a l s e ) { 112 113 //Se mapea su va lo r a true , y se aumenta e l contador de votantes 86 6 Caṕıtulo 6 - Marco aplicativo 114 approvers [ msg . sender ] = true ; 115 approversCount++; 116 } 117 118 } 119 120 //Funcion que crea una s o l i c i t u d , r e c i b e una de s c r i p c i on , un va lo r y una d i r e c c i o n de s t i no ( Notese e l a t r i bu to r e s t r i c t e d : s o l o puede s e r l lamada por e l ge r ente de l a campana ) 121 f unc t i on createRequest ( s t r i n g de s c r i p t i on , u int value , address r e c i p i e n t ) pub l i c r e s t r i c t e d { 122 123 //Se crea l a nueva e s t ru c tu r a con l o s parametros r e c i b i d o s 124 Request memory newRequest = Request ({ 125 d e s c r i p t i o n : d e s c r i p t i on , 126 value : value , 127 r e c i p i e n t : r e c i p i e n t , 128 //Se i n i c i a l i z a en f a l s o , puesto que se acaba de c r ea r dicha s o l i c i t u d y aun no se ha completado 129 complete : f a l s e , 130 //Se i n i c i a l i z a e l contador de aprobados en cero . 131 approvalCount : 0 132 //Se i n i c i a l i z a e l contador de rechazados en cero . 133 r e j e c t sCount : 0 134 }) ; 135 136 //Se agrega l a s o l i c i t u d r e c i e n creada a l a r r e g l o de s o l i c i t u d e s de l contrato 137 r eque s t s . push ( newRequest ) ; 138 139 } 140 141 //Funcion llamada por l o s cont r ibuyente s de l a campana , para aprobar una s o l i c i t u d , r e c i b e un i nd i c e de l a r r e g l o de s o l i c i t u d e s para conocer cua l s o l i c i t u d desea votar para su aprobacion 142 f unc t i on approveRequest ( u int index ) pub l i c { 143 144 // Loca l i z a r l a s o l i c i t u d segun e l i n d i c e 145 Request s t o rage r eques t = r eque s t s [ index ] ; 146 147 //Para que l a func ion cont inue su curso natura l , e s r eque r ido que l a d i r e c c i o n que l lama l a func ion sea un cont r ibyent e 148 r e qu i r e ( approvers [ msg . sender ] ) ; 149 150 //Tambien es n e c e s a r i o que l a d i r e c c i o n que l lama a l a func ion NO haya votado anter iormente 151 r e qu i r e ( ! r eque s t . approva l s [ msg . sender ] ) ; 152 6.3 Construcción (Construction) 87 153 //La d i r e c c i o n aprobo l a s o l i c i t u d 154 r eque s t . approva l s [ msg . sender ] = true ; 155 156 //Se incrementa l a cuenta de votos 157 r eque s t . approvalCount++; 158 159 } 160 161 //Funcion llamada por l o s cont r ibuyente s de l a campana , para rechazar una s o l i c i t u d , r e c i b e un i nd i c e de l a r r e g l o de s o l i c i t u d e s para conocer cua l s o l i c i t u d desea votar para su rechazo 162 f unc t i on r e j e c tReque s t ( u int index ) pub l i c { 163 164 // Loca l i z a r l a s o l i c i t u d segun e l i n d i c e 165 Request s t o rage r eque s t = r eque s t s [ index ] ; 166 167 //Para que l a func ion cont inue su curso natura l , e s r eque r ido que l a d i r e c c i o n que l lama l a func ion sea un cont r ibyent e 168 r e qu i r e ( approvers [ msg . sender ] ) ; 169 170 //Tambien es n e c e s a r i o que l a d i r e c c i o n que l lama a l a func ion NO haya votado anter iormente 171 r e qu i r e ( ! r eque s t . approva l s [ msg . sender ] ) ; 172 173 //La d i r e c c i o n rechazo l a s o l i c i t u d 174 r eque s t . approva l s [ msg . sender ] = true ; 175 176 //Se incrementa l a cuenta de votos 177 r eque s t . r e j e c t sCount++; 178 179 } 180 181 //Funcion llamada para dar por f i n a l i z a d a una s o l i c i t u d , r e c i b e un i nd i c e para i d e n t i f i c a r l a s o l i c i t u d a f i n a l i z a r , notese e l a t r i bu to r e s t r i c t e d , s o l o puede s e r l lamada por e l ge r ente 182 f unc t i on f i n a l i z eRequ e s t ( u int index ) pub l i c r e s t r i c t e d { 183 // I d en t i f i c a ndo l a s o l i c i t u d 184 Request s t o rage r eque s t = r eque s t s [ index ] ; 185 186 //Es requer ido , ademas , que l a s o l i c i t u d no haya s ido marcada como completada 187 r e qu i r e ( ! r eque s t . complete ) ; 188 189 // S i es e l caso de aprobacion , se t ra spasa e l d inero 190 i f ( r eque s t . approvalCount > ( approversCount ⇤( approvalRate ) ) /100) { 191 192 //Se t r a n s f i e r e n l o s fondos a l a d i r e c c i o n de s t i no 193 r eque s t . r e c i p i e n t . t r a n s f e r ( r eque s t . va lue ) ; 88 6 Caṕıtulo 6 - Marco aplicativo 194 195 //Se marca l a s o l i c i t u d como completada 196 r eque s t . complete = true ; 197 } 198 199 //En caso que haya s ido rechazo , se f i n a l i z a l a s o l i c i t u d s i n env ia r fondos 200 i f ( r eque s t . r e j e c t sCount > ( approversCount ⇤( r e j e c t edRate ) ) /100) { 201 202 //Se marca l a s o l i c i t u d como completada 203 r eque s t . complete = true ; 204 } 205 } 206 207 //Funcion que re to rna un resumen de l a campana 208 f unc t i on getSummary ( ) pub l i c view re tu rn s ( uint , uint , uint , uint , uint , uint , uint , uint , address ) { 209 210 //Retornar todos l o s a t r i bu t o s de l a campana 211 r e turn ( 212 minimumContribution , 213 maximumContribution , 214 maxContributors , 215 t h i s . balance , 216 r eque s t s . length , 217 approversCount , 218 approvalRate , 219 re j ec tedRate , 220 manager 221 ) ; 222 } 223 224 //Funcion que re to rna e l numero de s o l i c i t u d e s 225 f unc t i on getRequestCount ( ) pub l i c view re tu rn s ( u int ) { 226 r e turn r eque s t s . l ength ; 227 } 228 } Algoritmo 6.6: Versión 0.3 de solución para el caso de uso Con las modificaciones realizadas al código de la solución, se implementó satisfactoriamente la lógica que permite rechazar solicitudes, definir tasas de aprobación y rechazo de solicitu- des, esto agrega un valor importante a la versatilidad de la solución y se acerca cada vez más a cubrir todas las necesidades planteadas en el caso de uso. 6.3 Construcción (Construction) 89 6.3.4.1. Prueba versión 0.3 Las pruebas a realizar a esta nueva versión deben también ser modificadas para asegurar dos cosas, la primera, que funcionalidades anteriores sigan cumpliendo a cabalidad las funciones para las cuales fueron constrúıdas, y segunda, asegurar la calidad y eficacia de las nuevas funcionalidades incorporadas, a continuación se presenta el código de prueba adaptado a la nueva versión: Tipo de prueba Funcional Entorno de ejecución Ubuntu Linux 16.04 LTS Ejecutante Desarrollador de la herramienta Herramienta usada Mocha Veces ejecutada 3 Resultados 100% de los requerimientos estipulados Tabla 6-6: Especificaciones de la prueba para la versión 0.3 1 //Dependencias n e c e s a r i a s 2 const a s s e r t = r equ i r e ( ’ a s s e r t ’ ) ; 3 4 //Ganache permite c r ea r nuest ro propio ambiente Ethereum loca lmente 5 const ganache = r equ i r e ( ’ ganache�c l i ’ ) ; 6 const Web3 = r equ i r e ( ’web3 ’ ) ; 7 const web3 = new Web3( ganache . p rov ide r ( ) ) ; 8 9 //Contratos a u t i l i z a r 10 const compiledFactory = r equ i r e ( ’ . . / ethereum/ bu i ld /CampaignFactory . j son ’ ) ; 11 const compiledCampaign = r equ i r e ( ’ . . / ethereum/ bu i ld /Campaign . j son ’ ) ; 12 13 // L i s t a de v a r i a b l e s n e c e s a r i a s para e l d e sp l i gu e 14 l e t accounts ; 15 l e t f a c t o r y ; 16 l e t campaignAddress ; 17 l e t campaign ; 18 19 //Metodo llamado antes de r e a l i z a r cada una de l a s pruebas , e l metodo crea campanas automaticamente para r e a l i z a r pruebas 20 beforeEach ( async ( ) => { 21 22 //Se obt i ene una cuenta que hara e l d e sp l i e gu e de l cont rato ’ CampaignFactory ’ 23 accounts = await web3 . eth . getAccounts ( ) ; 24 25 //Se crea l a i n s t an c i a de l cont rato ’ CampaignFactory ’ 26 f a c t o r y = await new web3 . eth . Contract (JSON. parse ( compi ledFactory . i n t e r f a c e ) ) . 27 deploy ({ data : compiledFactory . bytecode }) . 90 6 Caṕıtulo 6 - Marco aplicativo 28 send ({ from : accounts [ 0 ] , gas : ’ 2000000 ’ }) ; 29 30 //Se crea una campana u t i l i z a ndo l a i n s t an c i a r e c i e n creada 31 await f a c t o r y . methods . createCampaign ( ’ 100 ’ ,web3 . u t i l s . toWei ( ’ 12 ’ , ’ e the r ’ ) , ’ 0 ’ , ’ 50 ’ , ’ 50 ’ ) . send ({ 32 from : accounts [ 0 ] , 33 gas : ’ 2000000 ’ 34 }) ; 35 36 //Se obt ienen l a s d i r e c c i o n e s de todas l a s campanas creadas 37 const addre s s e s = await f a c t o r y . methods . getDeployedCampaigns ( ) . c a l l ( ) ; 38 campaignAddress = addre s s e s [ 0 ] ; 39 40 //Se crea una i n s t an c i a de l cont rato a p a r t i r de l a d i r e c c i o n 41 campaign = await new web3 . eth . Contract (JSON. parse ( compiledCampaign . i n t e r f a c e ) , campaignAddress ) ; 42 43 }) ; 44 45 // Desc r ipc i on de l a s pruebas 46 de s c r i b e ( ’ Pruebas a campanas ’ , ( ) => { 47 48 //Prueba que In s t an c i a una CampaignFactory y una Campana 49 i t ( ’ I n s t an c i a una CampaignFactory y una Campana ’ , ( ) => { 50 51 //Se v e r i f i c a que ambas d i r e c c i o n e s no sean NULL, asegurando su co r r e c t o de sp l i gu e en l a red l o c a l 52 a s s e r t . ok ( f a c t o r y . opt i ons . address ) ; 53 a s s e r t . ok ( campaign . opt i ons . address ) ; 54 }) ; 55 56 //Prueba que Marca a l que l lama a l a campana como gerente 57 i t ( ’Marca a l que l lama a l a campana como gerente ’ , async ( ) => { 58 59 //Se l lama a l a t r i bu to ’manager ’ de l a i n s t an c i a de l cont rato y se compara con l a d i r e c c i o n ac tua l que presenta l a red l o c a l 60 const manager = await campaign . methods . manager ( ) . c a l l ( ) ; 61 a s s e r t . equal ( accounts [ 0 ] , manager ) ; 62 }) ; 63 64 //Prueba que Permite a l o s u sua r i o s c on t r i b u i r y marcar los como cont r ibuyente s 65 i t ( ’ Permite a l o s u sua r i o s c on t r i b u i r y marcar los como cont r ibuyente s ’ , async ( ) => { 66 67 //Se r e a l i z a una cont r ibuc i on a l a campana 68 await campaign . methods . c on t r i bu t e ( ) . send ({ 69 value : ’ 200 ’ , 6.3 Construcción (Construction) 91 70 from : accounts [ 1 ] 71 }) ; 72 73 //Se l lama a l a t r i bu to approvers con l a d i r e c c i o n que acaba de r e a l i z a r l a con t r ibuc i on 74 const i sCont r i bu to r = await campaign . methods . approvers ( accounts [ 1 ] ) . c a l l ( ) ; 75 76 //El va l o r debe s e r t rue 77 a s s e r t ( i sCont r i bu to r ) ; 78 79 }) ; 80 81 //Prueba que asegura de r e qu e r i r una cont r ibuc i on minima 82 i t ( ’ Asegura de r e qu e r i r una cont r ibuc i on minima ’ , async ( ) => { 83 84 //Se r e a l i z a r una cont r ibuc i on menor a l monto minimo e s t ab l e c i d o (100) 85 t ry { 86 await campaign . methods . con t r i bu t e ( ) . send ({ 87 value : ’ 5 ’ , 88 from : accounts [ 1 ] 89 }) ; 90 // S i se l l e g a a e s t e punto de l a prueba , es que a lgo malo ocur r i o , l a idea es que e l catch se e j e c u t e 91 a s s e r t ( f a l s e ) ; 92 } catch ( e r r ) { 93 94 // S i e l catch se e j ecuta , hubo un f a l l o , l o cua l es e l comportamiento esperado 95 a s s e r t ( e r r ) ; 96 } 97 }) ; 98 99 //Prueba que asegura que una cont r ibuc i on minima no puede s e r 0 100 i t ( ’ Asegura que una cont r ibuc i on minima no puede s e r 0 ’ , async ( ) => { 101 102 //Se r e a l i z a r una cont r ibuc i on de 0 103 t ry { 104 await campaign . methods . con t r i bu t e ( ) . send ({ 105 value : ’ 0 ’ , 106 from : accounts [ 1 ] 107 }) ; 108 // S i se l l e g a a e s t e punto de l a prueba , es que a lgo malo ocur r i o , l a idea es que e l catch se e j e c u t e 109 a s s e r t ( f a l s e ) ; 110 } catch ( e r r ) { 111 92 6 Caṕıtulo 6 - Marco aplicativo 112 // S i e l catch se e j ecuta , hubo un f a l l o , l o cua l es e l comportamiento esperado 113 a s s e r t ( e r r ) ; 114 } 115 }) ; 116 117 //Prueba que asegura de no sobrepasar l a con t r ibuc i on maxima 118 i t ( ’ Asegura de no sobrepasar l a con t r ibuc i on maxima ’ , async ( ) => { 119 120 //Se r e a l i z a r una cont r ibuc i on mayor a l monto maximo e s t a b l e c i d o (10 e the r ) 121 t ry { 122 await campaign . methods . c on t r i bu t e ( ) . send ({ 123 value : web3 . u t i l s . toWei ( ’ 15 ’ , ’ e the r ’ ) , 124 from : accounts [ 1 ] 125 }) ; 126 // S i se l l e g a a e s t e punto de l a prueba , es que a lgo malo ocur r i o , l a idea es que e l catch se e j e c u t e 127 a s s e r t ( f a l s e ) ; 128 } catch ( e r r ) { 129 130 // S i e l catch se e j ecuta , hubo un f a l l o , l o cua l es e l comportamiento esperado 131 a s s e r t ( e r r ) ; 132 } 133 }) ; 134 135 //Prueba que permite a l ge r ente c r ea r s o l i c i t u d e s 136 i t ( ’ Permite a l ge r ente c r ea r s o l i c i t u d e s ’ , async ( ) => { 137 138 //Se l lama a l metodo ’ createRequest ’ 139 await campaign . methods . c reateRequest ( ’Comprar b a t e r i a s ’ , ’ 100 ’ , accounts [ 1 ] ) . send ({ 140 from : accounts [ 0 ] , 141 gas : ’ 1000000 ’ 142 }) ; 143 144 //Se obt i ene l a s o l i c i t u d r e c i e n creada 145 const r eque s t = await campaign . methods . r eque s t s (0 ) . c a l l ( ) ; 146 147 //Se v e r i f i c a que l a d e s c r i p c i on de l a s o l i c i t u d sea ’Comprar b a t e r i a s ’ 148 a s s e r t . equal ( ’Comprar b a t e r i a s ’ , r eque s t . d e s c r i p t i o n ) ; 149 }) ; 150 151 //Prueba que permite proce sa r s o l i c i t u d e s 152 i t ( ’ Procesar s o l i c i t u d e s ’ , async ( ) => { 153 154 //Primero se r e a l i z a una cont r ibuc i on 6.3 Construcción (Construction) 93 155 await campaign . methods . c on t r i bu t e ( ) . send ({ 156 from : accounts [ 0 ] , 157 value : web3 . u t i l s . toWei ( ’ 10 ’ , ’ e the r ’ ) 158 }) ; 159 160 //Se crea una s o l i c i t u d 161 await campaign . methods . c reateRequest ( ’A ’ , web3 . u t i l s . toWei ( ’ 5 ’ , ’ e the r ’ ) , accounts [ 1 ] ) . send ({ 162 from : accounts [ 0 ] , 163 gas : ’ 1000000 ’ 164 }) ; 165 166 //Se aprueba l a s o l i c i t u d r e c i e n creada 167 await campaign . methods . approveRequest (0 ) . send ({ 168 from : accounts [ 0 ] , 169 gas : ’ 1000000 ’ 170 }) ; 171 172 //Se f i n a l i z a l a s o l i c i t u d r e c i e n aprobada 173 await campaign . methods . f i n a l i z eRequ e s t (0 ) . send ({ 174 from : accounts [ 0 ] , 175 gas : ’ 1000000 ’ 176 }) ; 177 178 //Se obt i ene e l ba lance de l a cuenta de s t i no 179 l e t ba lance = await web3 . eth . getBalance ( accounts [ 1 ] ) ; 180 181 //El balance se pasa de wei a e the r 182 balance = web3 . u t i l s . fromWei ( balance , ’ e the r ’ ) ; 183 balance = parseF loat ( ba lance ) ; 184 185 conso l e . l og ( balance ) ; 186 187 //Se v e r i f i c a que e l ba lance sea mayor a l o que t en i a en un p r i n c i p i o 188 a s s e r t ( ba lance > 104) ; 189 190 }) ; 191 192 //Prueba que permite proce sa r s o l i c i t u d e s rechazadas 193 i t ( ’ Procesar s o l i c i t u d e s rechazadas ’ , async ( ) => { 194 195 //Primero se r e a l i z a una cont r ibuc i on 196 await campaign . methods . c on t r i bu t e ( ) . send ({ 197 from : accounts [ 0 ] , 198 value : web3 . u t i l s . toWei ( ’ 10 ’ , ’ e the r ’ ) 199 }) ; 200 201 //Se crea una s o l i c i t u d 94 6 Caṕıtulo 6 - Marco aplicativo 202 await campaign . methods . c reateRequest ( ’A ’ , web3 . u t i l s . toWei ( ’ 5 ’ , ’ e the r ’ ) , accounts [ 1 ] ) . send ({ 203 from : accounts [ 0 ] , 204 gas : ’ 1000000 ’ 205 }) ; 206 207 //Se rechaza l a s o l i c i t u d r e c i e n creada 208 await campaign . methods . r e j e c tReque s t (0 ) . send ({ 209 from : accounts [ 0 ] , 210 gas : ’ 1000000 ’ 211 }) ; 212 213 //Se f i n a l i z a l a s o l i c i t u d r e c i e n rechazada 214 await campaign . methods . f i n a l i z eRequ e s t (0 ) . send ({ 215 from : accounts [ 0 ] , 216 gas : ’ 1000000 ’ 217 }) ; 218 219 //Se obt i ene e l ba lance de l a campana 220 l e t ba lance = await web3 . eth . getBalance ( campaignAddress ) ; 221 222 //El balance se pasa de wei a e the r 223 balance = web3 . u t i l s . fromWei ( balance , ’ e the r ’ ) ; 224 balance = parseF loat ( ba lance ) ; 225 226 conso l e . l og ( balance ) ; 227 228 //Se v e r i f i c a que l o s fondos cont ru ibu ido s s i gan en l a cuenta 229 a s s e r t ( ba lance < 11 && balance > 0) ; 230 231 }) ; 232 233 }) ; Algoritmo 6.7: Código que realiza pruebas automáticas de despliegue de un contrato y funcionalidades. Versión 0.3 La prueba anterior verifica que una transacción rechazada no env́ıe los fondos desde el balance de la cuenta de la campaña. Se anexan especificaciones de hardware realizadas para esta prueba y los resultados de la misma: 6.3 Construcción (Construction) 95 Componente Especificación Sistema Operativo Mac OS Sierra Memoria 4GB Procesador Mac Mini 2.3 GHz Core i5 (I5-2415M) Disco Duro 1TB Tabla 6-7: Especificaciones de hardware para pruebas en Mocha, versión 0.3. Ambiente MacOS 96 6 Caṕıtulo 6 - Marco aplicativo Figura 6-12: Ejecución de pruebas automáticas mediante el uso de la biblioteca Mocha para la versioón 0.3 de la solución.. Luego de verificar que las pruebas son exitosas, la versioón 0.3 del código presenta una estructura bastante avanzada con respecto a la resolución de problemáticas planteadas en el caso de uso de la presente investigación. Sin embargo, queda una lógica que será atacada en la próxima iteración, la expiración de solicitudes. 6.3.5. Iteración 4: Expiración de solicitudes La iteración 4 afronta el reto de manejar la expiración de solicitudes después de una semana de creadas, la finalidad de este modulo, es que no existan puntos muertos en la recaudación masiva y presionar a los contribuyentes a votar de manera positiva o negativa todas las solicitudes que genere el gerente de la campaña. A continuación se presenta la versión 1.0 del código, la cual cubre todas las problemáticas planteadas en el caso de uso, por lo cual se considera la primera versión que puede ser desplegada en un ambiente de producción, la estructura final del código en Solidity es: 1 //Vers ion de S o l i d i t y a u t i l i z a r 2 pragma s o l i d i t y ˆ 0 . 4 . 1 7 ; 3 4 // In s t an c i a de un primer contrato , e s t e primer contrato de encarga de generar i n s t a n c i a s de l cont rato Campaign 6.3 Construcción (Construction) 97 5 cont rac t CampaignFactory{ 6 7 // Ã šnico a t r i bu to de l cont rato generador de campanas , e l p r e s ente a t r i bu to se u t i l i z a para devo lver todas l a s d i r e c c i o n e s i n s t a n c i a s generadas 8 address [ ] pub l i c deployedCampaigns ; 9 10 //Funcion que genera i n s t a n c i a s de l contrato Campaign , r e c i b e un monto minimo de contr ibuc ion , un monto maximo , un numero maximo de contr ibuyentes , una tasa de aprobacion y una tasa de rechazo 11 f unc t i on createCampaign ( u int minimum , u int maximum, u int maxCont , u int approveRate , u int r e j e c tRat e ) pub l i c { 12 address newCampaign = new Campaign (minimum , maximum, maxCont , msg . sender , approveRate , r e j e c tRat e ) ; 13 14 //Una vez creada l a i n s t anc i a , se agrega a l a r r e g l o de d i r e c c i o n e s de i n s t a n c i a s de Campaigns 15 deployedCampaigns . push (newCampaign ) ; 16 } 17 18 //Funcion que re to rna un a r r e g l o de d i r e c c i o n e s con todas l a s i n t an c i a s de Campaigns 19 f unc t i on getDeployedCampaigns ( ) pub l i c view re tu rn s ( address [ ] ) { 20 r e turn deployedCampaigns ; 21 } 22 23 } 24 25 //Contrato p r i n c i pa l , en e s t e cont rato se implementa toda l a l o g i c a y func i ona l i dad de l a s campanas 26 cont rac t Campaign{ 27 28 // Estructura Request que r ep r e s en ta una s o l i c i t u d creada por e l ge r ente de l cont rato 29 s t r u c t Request{ 30 31 // St r ing que r ep r e s en ta l a d e s c r i p c i on de l a s o l i c i t u d 32 s t r i n g d e s c r i p t i o n ; 33 34 //Entero p o s i t i v o que r ep r e s en ta e l va l o r que desea r e t i r a r l a s o l i c i t u d de l a campana 35 uint va lue ; 36 37 // Di r ecc i on que r e c i b i r a l o s fondos de l a s o l i c i t u d 38 address r e c i p i e n t ; 39 40 // Var iab le booleana que r ep r e s en ta s i l a s o l i c i t u d ha s ido completada o no 41 bool complete ; 98 6 Caṕıtulo 6 - Marco aplicativo 42 43 //Entero p o s i t i v o que r ep r e s en ta l a cant idad de votos aprobados de l a s o l i c i t u d 44 uint approvalCount ; 45 46 //Entero p o s i t i v o que r ep r e s en ta l a cant idad de votos rechazados de l a s o l i c i t u d 47 uint re j e c t sCount ; 48 49 //Entero que r ep r e s en ta e l momento en que se creo l a s o l i c i t u d 50 uint c r ea ted ; 51 52 //Tipo de dato mapping , que r e a l i z a l a cor r e spondenc ia de una d i r e c c i o n con un va l o r booleano , en cuanto se r e a l i c e una votac ion , e l mapeo de l a d i r e c c i o n de e s ta va r i ab l e s e ra as ignado a True 53 mapping ( address => bool ) approva l s ; 54 } 55 56 // L i s t a de a t r i bu t o s de l cont rato 57 58 //Arreg lo de s o l i c i t u d e s que posee e l cont rato 59 Request [ ] pub l i c r eque s t s ; 60 61 // Di r ecc i on de l ge r ente de l cont rato 62 address pub l i c manager ; 63 64 //Contr ibuc ion minima 65 uint pub l i c minimumContribution ; 66 67 //Contr ibuc ion maxima 68 uint pub l i c maximumContribution ; 69 70 //Numero maximo de cont r ibuyente s 71 uint pub l i c maxContributors ; 72 73 // Porcenta je de aprobacion 74 uint pub l i c approvalRate ; 75 76 // Porcenta je de rechazo 77 uint pub l i c r e j e c t edRate ; 78 79 //Mapeo de d i r e c c i o n e s a va l o r e s boo leanos que repre sentan l a l i s t a de cont r ibuyente s votantes 80 mapping ( address => bool ) pub l i c approvers ; 81 82 //Contador de votantes 83 uint pub l i c approversCount ; 84 6.3 Construcción (Construction) 99 85 //Funcion que r e s t r i n g e l a p o s i b i l i d a d de una func ion a s e r llamada , en e s t e caso , r e s t r i n g e a l a func ion a s e r l lamada por a l gu i en que no sea e l ge r ente de l a campana 86 mod i f i e r r e s t r i c t e d ( ) { 87 r e qu i r e (msg . sender == manager ) ; 88 ; 89 } 90 91 //Constructor de l contrato , r e c i b e sus parametros desde l a func ion createCampaign de CampaignFactory 92 f unc t i on Campaign ( u int minimum , u int maximum, u int maxCont , address c reator , u int approveRate , u int r e j e c tRat e ) pub l i c { 93 94 //Es reque r ido que e l monto minimo de aprobacion sea mayor a cero 95 r e qu i r e (minimum > 0) ; 96 97 //Es reque r ido que l a tasa e s t e ent r e 0 y 100 (%) 98 r e qu i r e ( approveRate > 0 && approveRate < 100) ; 99 100 //Es reque r ido que l a tasa e s t e ent r e 0 y 100 (%) 101 r e qu i r e ( r e j e c tRat e > 0 && re j e c tRat e < 100) ; 102 103 manager = c r ea t o r ; 104 minimumContribution = minimum ; 105 maximumContribution = maximum; 106 maxContributors = maxCont ; 107 approvalRate = approveRate ; 108 r e j e c t edRate = re j e c tRat e ; 109 } 110 111 //Funcion que permite a una d i r e c c i o n c on t r i b u i r a l a campana , l a palabra re se rvada ’ payable ’ i nd i c a que l a func ion debe r e c i b i r un va l o r en wei , e l cua l s e ra agregado a l a i n s t an c i a de l cont rato 112 f unc t i on con t r i bu t e ( ) pub l i c payable { 113 //Requer imientos ba s i c o s para que l a func ion pueda s e gu i r su curso natura l : 114 //�El va l o r con e l que se l lama a l a func ion debe s e r mayor a l a minima cont r ibuc i on e s t ab l e c i d a 115 //�El va l o r con e l que se l lama a l a func ion debe s e r menor a l a maxima cont r ibuc i on e s t ab l e c i da , o s e r cero , para que no haya l im i t e en l a con t r ibuc i on 116 //�El nÃomero de d i r e c c i o n e s que aprueban una s o l i c i t u d no puede s e r mayor a l numero maximo de contr ibuyentes , o debe s e r 0 , en caso de que no haya l im i t e 117 r e qu i r e (msg . va lue > minimumContribution && 118 (msg . va lue < maximumContribution | | maximumContribution == 0 )&& 119 ( approversCount < maxContributors | | maxContributors == 0) ) ; 120 100 6 Caṕıtulo 6 - Marco aplicativo 121 //Este c ond i c i ona l permite a una d i r e c c i o n c on t r i b u i r v a r i a s veces a una misma campana 122 i f ( approvers [ msg . sender ] == f a l s e ) { 123 124 //Una vez que se v e r i f i q u e que l a d i r e c c i o n no ha cont r ibu ido antes , se mapea su va l o r a true , y se aumenta e l contador 125 approvers [ msg . sender ] = true ; 126 approversCount++; 127 } 128 } 129 130 //Funcion que crea una s o l i c i t u d , r e c i b e una de s c r i p c i on , un va lo r y una d i r e c c i o n de s t i no ( Notese e l a t r i bu to r e s t r i c t e d : s o l o puede s e r l lamada por e l ge r ente de l a campana ) 131 f unc t i on createRequest ( s t r i n g de s c r i p t i on , u int value , address r e c i p i e n t ) pub l i c r e s t r i c t e d { 132 133 //Se crea l a nueva e s t ru c tu r a con l o s parametros r e c i b i d o s 134 Request memory newRequest = Request ({ 135 d e s c r i p t i o n : d e s c r i p t i on , 136 value : value , 137 r e c i p i e n t : r e c i p i e n t , 138 139 //Se i n i c i a l i z a en f a l s o , puesto que se acaba de c r ea r dicha s o l i c i t u d y aÃon no se ha completado 140 complete : f a l s e , 141 142 //Se i n i c i a l i z a e l contador de aprobados en cero . 143 approvalCount : 0 , 144 145 //Se i n i c i a l i z a e l contador de rechazados en cero . 146 r e j e c t sCount : 0 , 147 148 //Momento de c r ea c i on de l a s o l i c i t u d 149 c r ea ted : now 150 }) ; 151 152 //Se agrega l a s o l i c i t u d r e c i e n creada a l a r r e g l o de s o l i c i t u d e s de l contrato 153 r eque s t s . push ( newRequest ) ; 154 155 } 156 157 //Funcion llamada por l o s cont r ibuyente s de l a campana , para aprobar una s o l i c i t u d , r e c i b e un i nd i c e de l a r r e g l o de s o l i c i t u d e s para conocer cua l s o l i c i t u d desea votar para su aprobacion 158 f unc t i on approveRequest ( u int index ) pub l i c { 159 6.3 Construcción (Construction) 101 160 // Loca l i z a r l a s o l i c i t u d segun e l i n d i c e 161 Request s t o rage r eque s t = r eque s t s [ index ] ; 162 163 //Para que l a func ion cont inue su curso natura l , e s r eque r ido que l a d i r e c c i o n que l lama l a func ion sea un cont r ibyent e 164 r e qu i r e ( approvers [ msg . sender ] ) ; 165 166 //Tambien es n e c e s a r i o que l a d i r e c c i o n que l lama a l a func ion NO haya votado anter iormente 167 r e qu i r e ( ! r eque s t . approva l s [ msg . sender ] ) ; 168 169 //La d i r e c c i o n aprobo l a s o l i c i t u d 170 r eque s t . approva l s [ msg . sender ] = true ; 171 172 //Se incrementa l a cuenta de votos 173 r eque s t . approvalCount++; 174 175 } 176 177 //Funcion llamada por l o s cont r ibuyente s de l a campana , para rechazar una s o l i c i t u d , r e c i b e un i nd i c e de l a r r e g l o de s o l i c i t u d e s para conocer cua l s o l i c i t u d desea votar para su rechazo 178 f unc t i on r e j e c tReque s t ( u int index ) pub l i c { 179 180 // Loca l i z a r l a s o l i c i t u d segun e l i n d i c e 181 Request s t o rage r eque s t = r eque s t s [ index ] ; 182 183 //Para que l a func ion cont inue su curso natura l , e s r eque r ido que l a d i r e c c i o n que l lama l a func ion sea un cont r ibyent e 184 r e qu i r e ( approvers [ msg . sender ] ) ; 185 186 //Tambien es n e c e s a r i o que l a d i r e c c i o n que l lama a l a func ion NO haya votado anter iormente 187 r e qu i r e ( ! r eque s t . approva l s [ msg . sender ] ) ; 188 189 //La d i r e c c i o n rechazo l a s o l i c i t u d 190 r eque s t . approva l s [ msg . sender ] = true ; 191 192 //Se incrementa l a cuenta de votos 193 r eque s t . r e j e c t sCount++; 194 195 } 196 197 //Funcion llamada para dar por f i n a l i z a d a una s o l i c i t u d , r e c i b e un i nd i c e para i d e n t i f i c a r l a s o l i c i t u d a f i n a l i z a r , notese e l a t r i bu to r e s t r i c t e d , s o l o puede s e r l lamada por e l ge r ente 198 f unc t i on f i n a l i z eRequ e s t ( u int index ) pub l i c r e s t r i c t e d { 199 // I d en t i f i c a ndo l a s o l i c i t u d 102 6 Caṕıtulo 6 - Marco aplicativo 200 Request s t o rage r eques t = r eque s t s [ index ] ; 201 202 //Momento en e l que se r e a l i z o l a f i n a l i z a c i o n 203 uint f inal izedMoment = now ; 204 205 // Var iab le que r e f l e j a l a v a l i d e z de l a t r an sa c c i on 206 bool va l i d ; 207 208 //Tiempo epoch que r ep r e s en ta una semana 209 i n t week = 604800; 210 211 // S i l a t r an sac c i on t i e n e mas de 1 semana se vue lve i nva l i d a 212 i n t transact ionTime = in t ( r eque s t . c r ea ted ) + week � i n t ( f inal izedMoment ) ; 213 214 i f ( t ransact ionTime < 0) { 215 va l i d = f a l s e ; 216 } e l s e { 217 va l i d = true ; 218 } 219 220 //Es reque r ido que hayan votado pos i t ivamente o negativamente l a cant idad e s t a b l e c i d a de cont r ibuyente s en e l c on s t ruc to r ( Var i ab l e s approvalRate y r e j e c t edRate ) 221 r e qu i r e ( ( r eque s t . approvalCount > ( approversCount ⇤( approvalRate ) ) /100) | | ( r eque s t . r e j e c t sCount > ( approversCount ⇤( r e j e c t edRate ) ) /100) ) ; 222 223 //Es requer ido , ademas , que l a s o l i c i t u d no haya s ido marcada como completada 224 r e qu i r e ( ! r eque s t . complete ) ; 225 226 // S i l a t r an sac c i on es va l ida , se e j e cu ta normalmente 227 i f ( v a l i d ) { 228 // S i es e l caso de aprobacion , se t ra spasa e l e the r 229 i f ( r eque s t . approvalCount > ( approversCount ⇤( approvalRate ) ) /100) { 230 231 //Se t r a n s f i e r e n l o s fondos a l a d i r e c c i o n de s t i no 232 r eque s t . r e c i p i e n t . t r a n s f e r ( r eque s t . va lue ) ; 233 234 //Se marca l a s o l i c i t u d como completada 235 r eque s t . complete = true ; 236 } 237 238 //En caso que haya s ido rechazada , se f i n a l i z a l a s o l i c i t u d s i n env ia r fondos 239 i f ( r eque s t . r e j e c t sCount > ( approversCount ⇤( r e j e c t edRate ) ) /100) { 240 241 //Se marca l a s o l i c i t u d como completada 6.3 Construcción (Construction) 103 242 r eque s t . complete = true ; 243 } 244 245 // S i no es va l ida , se envian l o s fondos a l a d i r e c c i o n de s t i no 246 } e l s e { 247 248 //Se t r a n s f i e r e n l o s fondos a l a d i r e c c i o n de s t i no 249 r eque s t . r e c i p i e n t . t r a n s f e r ( r eque s t . va lue ) ; 250 251 //Se marca l a s o l i c i t u d como completada 252 r eque s t . complete = true ; 253 } 254 255 256 } 257 258 //Funcion que re to rna un resumen de l a campana 259 f unc t i on getSummary ( ) pub l i c view re tu rn s ( uint , uint , uint , uint , uint , uint , uint , uint , address ) { 260 261 //Retornar todos l o s a t r i bu t o s de l a campana 262 r e turn ( 263 minimumContribution , 264 maximumContribution , 265 maxContributors , 266 t h i s . balance , 267 r eque s t s . length , 268 approversCount , 269 approvalRate , 270 re j ec tedRate , 271 manager 272 ) ; 273 } 274 275 //Funcion que re to rna e l numero de s o l i c i t u d e s 276 f unc t i on getRequestCount ( ) pub l i c view re tu rn s ( u int ) { 277 r e turn r eque s t s . l ength ; 278 } 279 } Algoritmo 6.8: Versión 1.0 de solución para el caso de uso La versión 1.0 de la solución involucra toda la lógica con respecto a la expiración de solici- tudes. Lamentablemente las pruebas con respecto a tiempos de expiración se vuelven complicadas debido a su ejecución automática, lo cual no permite la medición de paso de tiempo. Debido a lo anteriomente expuesto, las pruebas de expiración de solicitudes se realizarán 104 6 Caṕıtulo 6 - Marco aplicativo una vez que el cliente web haya sido desarrollado y se logre la interacción con el contrato mediante el mismo. 6.3.6. Iteración 5: Construcción cliente web La iteración 5 presenta el desarrollo que permite a un cliente web interactuar con diferentes instancias de un contrato inteligente, este desarrollo presenta una serie de pasos previos que serán explicados en detalle a medida que se vaya avanzando en el despliegue en la red, nótese que se hará uso de los archivos JSON obtenidos a partir del código que realiza la compilación (Algoritmo 6.2) El cliente web se encargará de generar los contratos en la red de Ethereum Rinkeby, la cual si bien no es la red real de Ethereum, es una red que simula un ambiente de producción de manera que se prueben todas las funcionalidades tal cual como si se estuviera en un ambiente de producción manejando fondos reales, sin el riesgo de perder capital real en la realización de dichas pruebas. 6.3.6.1. Modulo Web3 Una vez obtenido el ABI y Bytecode generado, debe generarse y exportarse el siguiente módulo para obtener una instancia de Web3 que interactúe con las cuentas generadas por MetaMask para interactuar con la red Rinkeby: 1 2 //Dependencias n e c e s a r i a s 3 import Web3 from ’web3 ’ ; 4 5 l e t web3 ; 6 7 i f ( typeo f window !== ’ undef ined ’ && window . web3 !== ’ undef ined ’ ) { 8 9 //Se e s ta haciendo uso de l navegador Y Metamask e s ta ac t i vo 10 web3 = new Web3(window . web3 . cur r entProv ide r ) ; 11 12 } e l s e { 13 14 //Esta s i endo llamado de l lado de l s e rv ido r , o Metamask NO es ta act ivado 15 const prov ide r = new Web3 . p rov ide r s . HttpProvider ( 16 17 //Nodo In fu ra a l que se conectara nuest ra i n s t an c i a de Metamask para i n t e r a c t ua r con l a red Rinkeby de Ethereum 18 ’ ht tps : // r inkeby . i n f u r a . i o /O9rDBBXPQ0LgMzdxly6I ’ 19 ) ; 20 21 web3 = new Web3( prov ide r ) ; 6.3 Construcción (Construction) 105 22 } 23 24 export d e f au l t web3 ; Algoritmo 6.9: Módulo que genera una instancia de Web3 conectada a la red Rinkeby(web3.js) Este módulo será uno de los componentes principales en todas las interacciones que se reali- cen con la red Rinkeby. 6.3.6.2. Despliegue del contrato en la red El siguiente código se encarga se realizar el despliegue de nuestro contrato en la red de Rinkeby, el resultado del mismo, será una dirección de Ethereum, esta dirección representa la instancia de nuestro contrato: 1 2 //Dependencias n e c e s a r i a s 3 const HDWalletProvider = r equ i r e ( ’ t r u f f l e �hdwal let�prov ide r ’ ) ; 4 const Web3 = r equ i r e ( ’web3 ’ ) ; 5 6 //Se obt i ene e l ABI y Bytecode 7 const compiledFactory = r equ i r e ( ’ . / bu i ld /CampaignFactory . j son ’ ) ; 8 9 //Proveedor que se conectara a l a red Ethereum para i n s t a n c i a r cont ra to s (En e s t e caso : In fu ra ) 10 const prov ide r = new HDWalletProvider ( 11 //”Mneumonic” que i d e n t i f i c a l a cuenta que se en laza ra con e l nodo In fu ra para c r ea r l a i n s t an c i a en l a red Ethereum 12 ’ s n i f f permit v e h i c l e mixed help wink amazing dash balance moment antenna u s e l e s s ’ , 13 ’ ht tps : // r inkeby . i n f u r a . i o /O9rDBBXPQ0LgMzdxly6I ’ 14 ) ; 15 16 // In s t an c i a de Web3, que r e c i b e ’ p rov ide r ’ 17 const web3 = new Web3( prov ide r ) ; 18 19 //Funcion que i n s t an c i a r a e l cont rato en l a red 20 const deploy = async ( ) => { 21 // L i s t a de cuentas a soc i adas a l ”Mneumonic” en ’ prov ide r ’ 22 accounts = await web3 . eth . getAccounts ( ) ; 23 24 //Se muestra por conso la , l a cuenta que hace de sp l i e gu e en l a red 25 conso l e . l og ( ’ Desplegando desde l a d i r e c c i o n : ’ , accounts [ 0 ] ) ; 26 27 //Creacion de l cont rato en l a red . 28 const r e s u l t = await new web3 . eth . Contract (JSON. parse ( compiledFactory . i n t e r f a c e ) ) 106 6 Caṕıtulo 6 - Marco aplicativo 29 . deploy ({ data : compiledFactory . bytecode }) 30 . send ({ gas : ’ 2000000 ’ , from : accounts [ 0 ] } ) ; 31 32 //Se muestra por pan ta l l a l a d i r e c c i o n donde e l cont rato fue creado . 33 conso l e . l og ( ’ Contrato desp legado en : ’ , r e s u l t . opt i ons . address ) ; 34 35 } ; 36 37 //Llamada a l a func ion 38 deploy ( ) ; Algoritmo 6.10: Módulo que realiza el despligue del contrato en la red Rinkeby (deploy.js) Se ejecuta el código mediante la consola, utilizando el comando ’node deploy.js’, la ejecución del código generará la dirección del contrato a la que haremos referencia más adelante para interactuar con un contrato, dada su dirección: Figura 6-13: Despliegue del contrato en la red Rinkeby, retorna una dirección del contrato desplegado 6.3.6.3. Referencias a contratos desplegados en la red Una vez obtenida la dirección del contrato que se acaba de desplegar en la red, el siguiente código tiene el objetivo de obtener una instancia con un contrato, dada una dirección: 1 //Dependencias n e c e s a r i a s 2 import web3 from ’ . / web3 ’ ; 3 import CampaignFactory from ’ . / bu i ld /CampaignFactory . j son ’ ; 4 5 //Obtenemos l a i n s t an c i a de l cont rato ”CampaignFactory” dada l a d i r e c c i o n obtenida en ”deploy . j s ” 6 const i n s t anc e = new web3 . eth . Contract ( 7 JSON. parse ( CampaignFactory . i n t e r f a c e ) , 8 ’ 0x85Cbb9066D9d18A48ADc93Dcc09165f75C604C02 ’ 9 10 ) ; 11 12 export d e f au l t i n s t anc e ; Algoritmo 6.11: Módulo que interactúa con un contrato dada una dirección y su ABI (factory.js) 6.3 Construcción (Construction) 107 También se podrán referenciar instancias de contratos mediante pase de parámetros, utili- zando el siguiente código: 1 //Dependencias n e c e s a r i a s 2 import web3 from ’ . / web3 ’ ; 3 import Campaign from ’ . / bu i ld /Campaign . j son ’ ; 4 5 //Codigo u t i l i z a d o para r e f e r i r n o s a una campana en e s p e c i f i c o , dado una d i r e c c i o n que es r e c i b i d a como parametro 6 export d e f au l t ( address ) => { 7 8 //Devuelve una i n s t an c i a de cont rato 9 r e turn new web3 . eth . Contract ( 10 JSON. parse (Campaign . i n t e r f a c e ) , 11 address 12 ) ; 13 } ; Algoritmo 6.12: Módulo que interactúa con un contrato dada una dirección pasada por parámetro y su ABI (campaign.js) Una vez creadas todas las herramientas para obtener instancias de contratos, se puede em- pezar a hacer referencias a dichas instancias mediante un cliente web. 6.3.6.4. Cliente web La construccón del cliente web se realiza utilizando el framework React, tal cual como fue especificado en el Caṕıtulo 4 de la presente investigacón. El mismo presenta una estructura de directorios integrada de la siguiente manera: 108 6 Caṕıtulo 6 - Marco aplicativo Figura 6-14: Estructura del cliente web 6.3 Construcción (Construction) 109 Los diferentes directorios están organizados de la siguiente manera: Components: Lista de componentes desarrollados en React para realizar tareas parti- culares de una manera modularizada. Ethereum: Directorio que contiene todos los módulos relaciones con Ethereum y sus interacciones. Node modules: Componentes utilizados por Node. Pages: Representan las vistas del cliente web, y además representan las rutas de la aplicación gracias al uso de NextJS. Server: Dentro de este directorio están definidos los modelos y controladores para el almacenamiento en la base de datos MongoDB. Test: Directorio que contiene todas las pruebas realizadas. Ip.js: Contiene la ip de la máquina, es utilizado para realizar las solicitudes HTTP para almacenar las interacciones con los contratos en la base de datos. Package.json: Lista de bibliotecas y dependencias que utiliza Node. Routes.js: Contiene la especificación de las rutas de la aplicación web. Server.js: Código a ejecutar para correr en una red local nuestro cliente web. Una vez descrita la estructura de los directorios de la aplicación web, se contruye el código que despliega la aplicación en una red local, el código tiene la siguiente estructura: 1 //Dependencias n e c e s a r i a s 2 const { c r e a t eS e rv e r } = requ i r e ( ’ http ’ ) ; 3 const next = r equ i r e ( ’ next ’ ) ; 4 const app = next ({ 5 dev : p roce s s . env .NODEENV !== ’ product ion ’ 6 }) ; 7 8 // L i s t a de modulos n e c e s a r i o s a l momento de i n i c i a r l a ap l i c a c i o n web 9 10 //Lado de l s e r v i d o r encargado de manejar e l s e r v i d o r donde se encuentra l a base datos MongoDB 11 const s e r v e r s i d e = r equ i r e ( ’ . / s e r v e r /app . j s ’ ) ; 12 13 //Rutas de l a ap l i c a c i o n 14 const route s = r equ i r e ( ’ . / route s ’ ) ; 15 16 //Manejo de p e t i c i o n e s 17 const handler = route s . getRequestHandler ( app ) ; 110 6 Caṕıtulo 6 - Marco aplicativo 18 19 //Puerto 3000 en e l que co r r e l a ap l i c a c i o n 20 app . prepare ( ) . then ( ( ) => { 21 c r e a t eS e rv e r ( handler ) . l i s t e n (3000 , ( e r r ) => { 22 i f ( e r r ) throw e r r ; 23 conso l e . l og ( ’Ready on l o c a l h o s t :3000 ’ ) ; 24 }) ; 25 }) ; Algoritmo 6.13: Módulo que inicia en una red local la aplicación web(server.js) Una vez corriendo el servidor, se configura el manejo de rutas mediante el siguiente módulo: 1 //Dependencias n e c e s a r i a s 2 const route s = r equ i r e ( ’ next�rout e s ’ ) ( ) ; 3 4 //Rutas de l a ap l i c a c i o n web 5 rout e s 6 // : address r ep r e s en ta l a parte dinamica de l a ruta , e l segundo parametro , r ep r e s en ta e l a rch ivo en e l d i r e c t o r i o ’ pages ’ que s e ra desp legado 7 . add ( ’ / campaigns/new ’ , ’ / campaigns/new ’ ) 8 . add ( ’ / campaigns / : address ’ , ’ / campaigns/show ’ ) 9 . add ( ’ / campaigns / : address / r eque s t s ’ , ’ / campaigns/ r eque s t s / index ’ ) 10 . add ( ’ / campaigns / : address / r eque s t s /new ’ , ’ / campaigns/ r eque s t s /new ’ ) ; 11 12 module . export s = route s ; Algoritmo 6.14: Módulo que configura las rutas del servidor web(routes.js) 6.3.6.5. Rutas de la aplicación web Una vez configuradas las rutas de la aplicación web, NextJS por defecto, asigna el directorio ’Pages’ como el directorio de rutas, y el archivo ’index.js’ como la ruta inicial cuando se accede a la dirección base (http://localhost:3000). En el archivo ’index.js’ podemos observar la lista de campaña desplegadas en la red Rinkeby, además de algunas funcionalidades para navegar dentro de la aplicación, tales como crear campaña o acceder a la información de una campaña. Posee la siguiente estructura: 1 //Dependencias de i n t e r f a z , ru tas y e lementos u t i l e s de l cont rato 2 import React , {Component} from ’ r ea c t ’ ; 3 import { Card , Button } from ’ semantic�ui�r e a c t ’ ; 4 import f a c t o r y from ’ . . / ethereum/ f a c t o r y ’ ; 5 import Layout from ’ . . / components/Layout ’ ; 6 import { Link } from ’ . . / route s ’ ; 7 8 //Componente p r i n c i p a l que r ende r i z a l a l i s t a de campanas 9 c l a s s CampaignIndex extends Component { 10 11 //Funcion que obt i ene l o s parametros i n i c i a l e s de l componente 6.3 Construcción (Construction) 111 12 s t a t i c async g e t I n i t i a l P r o p s ( ) { 13 14 //Llamada a l cont rato para obtener todas l a s d i r e c c i o n e s de l o s cont ra to s e x i s t e n t e s 15 const campaigns = await f a c t o r y . methods . getDeployedCampaigns ( ) . c a l l ( ) ; 16 17 //Se rotorna l a l i s t a de contratos , equ i va l e a : r e turn { campaigns : campaigns } ; 18 r e turn { campaigns } ; 19 } 20 21 //Metodo que i t e r a sobre l a l i s t a de campanas y l a s muestra en l a v i s t a 22 renderCampaigns ( ) { 23 24 //Se r e a l i z a un map en todas l a s d i r e c c i o n e s de l a s campanas obten idas 25 const i tems = th i s . props . campaigns .map( address => { 26 //Se re to rna una d i r e c c i o n y una ruta pe r sona l i z ada con dicha d i r e c c i o n 27 r e turn { 28 header : address , 29 d e s c r i p t i o n : ( 30 <Link route={ ‘/ campaigns/${ address } ‘}> 31 <a> Ver Campana </a> 32 </Link> 33 ) , 34 f l u i d : t rue 35 } 36 }) ; 37 38 //Card . Group es un elemento de Semantic�UI con v i s t a de t a r j e t a s , r e c i b e de parametro e l ob j e to ’ i tems ’ que cont i ene todas l a s campanas 39 r e turn <Card . Group items={ i tems } />; 40 } 41 42 render ( ) { 43 r e turn ( 44 <Layout> 45 <div> 46 <h3> Campanas ab i e r t a s </h3> 47 48 {/⇤ Boton de c r ea r campana ⇤/} 49 <Link route=’ /campaigns/new ’> 50 <a> 51 <Button 52 f l o a t e d = ” r i gh t ” 53 content= ”Crear campana” 54 i con = ”add c i r c l e ” 55 primary = { t rue } 56 /> 112 6 Caṕıtulo 6 - Marco aplicativo 57 </a> 58 </Link> 59 60 {/⇤ Renderizado de l a l i s t a de campanas ⇤/} 61 { t h i s . renderCampaigns ( ) } 62 </div> 63 </Layout> 64 ) 65 } 66 } 67 68 export d e f au l t CampaignIndex ; Algoritmo 6.15: Ruta que sirve como página base de la aplicación web. Muestra la lista de campañas desplegadas (index.js) Luego de acceder a la ruta base, se puede navegar hasta la vista de creación de campaña o acceder a los detalles de una campaña en particular. 6.3.6.6. Creación de campañas El módulo de creación de campañas provee un formulario que permite al usuario (Dicho usuario será el gerente de dicha campaña) ingresar las configuraciones (Monto mı́nimo de contribución, monto máximo de contribución, número máximo de contribuyentes, tasa de aprobación y tasa de rechazo) con respecto a la campaña que está por crear. El módulo está estructurado de la siguiente manera: 1 //Dependencias de i n t e r f a z , ru tas y e lementos u t i l e s de l cont rato 2 import React , { Component } from ’ r ea c t ’ ; 3 import { Form , Button , Input , Message } from ’ semantic�ui�r e a c t ’ ; 4 import Layout from ’ . . / . . / components/Layout ’ ; 5 import f a c t o r y from ’ . . / . . / ethereum/ f a c t o ry ’ ; 6 import web3 from ’ . . / . . / ethereum/web3 ’ ; 7 import { Router} from ’ . . / . . / route s ’ ; 8 import currentIP from ’ . . / . . / ip . j s ’ 9 10 //Componente p r i n c i p a l que r ende r i z a e l f o rmu la r i o para c r ea r una campana nueva 11 c l a s s CampaignNew extends Component { 12 13 // Var iab le ’ s t a t e ’ que guardara l o s datos desde e l f o rmu la r i o 14 s t a t e = { 15 minimumContribution : ’ ’ , 16 maximumContribution : ’ ’ , 17 maximumCont : ’ ’ , 18 approveRate : ’ ’ , 19 r e j e c tRat e : ’ ’ , 20 errorMessage : ’ ’ , 6.3 Construcción (Construction) 113 21 l oad ing : f a l s e 22 } 23 24 //Funcion llamada a l hacer c l i c k en e l boton ”Crear ” 25 onSubmit = async ( event ) => { 26 27 // El iminar e l comportamiento por de f e c t o de l a func ion 28 event . preventDefau l t ( ) ; 29 30 //Se ac t i va e l a t r i bu to ’ Loading ’ de l boton mientras que se procesa l a t r an sa c c i on en l a red 31 t h i s . s e t S t a t e ({ l oad ing : true , errorMessage : ’ ’ }) ; 32 33 // I n i c i o de l a t r an sac c i on 34 t ry { 35 36 //Se obt i ene l a cuenta ac tua l de Metamask 37 const accounts = await web3 . eth . getAccounts ( ) ; 38 39 //Se l lama a l metodo ’ createCampaign ’ de l cont rato ac tua l y se l e pasan l o s parametros obten idos desde e l f o rmu la r i o 40 await f a c t o r y . methods . createCampaign ( t h i s . s t a t e . minimumContribution , 41 t h i s . s t a t e . maximumContribution , 42 t h i s . s t a t e .maximumCont , 43 t h i s . s t a t e . approveRate , 44 t h i s . s t a t e . r e j ec tRate , 45 ) . send ({ 46 from : accounts [ 0 ] 47 }) ; 48 49 //Se obt i ene l a l i s t a de campanas creadas 50 const lastCampaing = await f a c t o r y . methods . getDeployedCampaigns ( ) . c a l l ( ) ; 51 52 //Se r e a l i z a l a s o l i c i t u d a l s e r v i d o r donde se encuentra l a base de datos MongoDB para que guarde l a in formac ion de l a campana r e c i e n creada 53 f e t ch ( ’ http :// ’ + currentIP + ’ :8000/ campaign ’ , { 54 method : ’POST ’ , 55 headers : { 56 ’ Accept ’ : ’ a pp l i c a t i o n / j son ’ , 57 ’ Content�Type ’ : ’ a pp l i c a t i o n / j son ’ , 58 } , 59 body : JSON. s t r i n g i f y ({ 60 campaignManager : accounts [ 0 ] , 61 campaignAddress : lastCampaing [ lastCampaing . l ength � 1 ] , 62 minimumContribution : t h i s . s t a t e . minimumContribution , 63 maximumContribution : t h i s . s t a t e . maximumContribution , 64 maximumCont : t h i s . s t a t e .maximumCont , 114 6 Caṕıtulo 6 - Marco aplicativo 65 approveRate : t h i s . s t a t e . approveRate , 66 r e j e c tRat e : t h i s . s t a t e . r e j e c tRat e 67 }) 68 }) ; 69 70 //Una vez creada l a campana , se r e d i r i g e a l u suar io a l a pagina i n i c i a l donde podra ver su campana r e c i e n creada 71 Router . pushRoute ( ’ / ’ ) ; 72 73 } catch ( e r r ) { 74 75 //En caso de que ocurra un er ror , se c r ea r e l mensaje de e r r o r que se mostrara a l u suar io 76 t h i s . s e t S t a t e ({ errorMessage : [ ’ AsegÃo rese de i n g r e s a r un nÃomero vÃ ¡ l i do de e the r o wei ( Sin l e t r a s ) ’ , ’En caso de s e r una l i s t a , no de j e e lementos en blanco ’ , ’ Ve r i f i qu e e s t a r usando su plug�in Metamask ’ , ’ Ve r i f i qu e su l i s t a de t r an s a c c i on e s pend iente s ’ ] }) ; 77 } 78 79 //Finalmente , termina e l proceso de ’ Loading ’ de l boton 80 t h i s . s e t S t a t e ({ l oad ing : f a l s e }) ; 81 } 82 83 render ( ) { 84 r e turn ( 85 <Layout> 86 <h3> Crear una campana </h3> 87 88 {/⇤ Formulario que r e l l e n a e l u suar io para c r ea r una campana , i n i c i a lmen t e no t i e n e mensaje de e r r o r ⇤/} 89 <Form onSubmit={ t h i s . onSubmit} e r r o r ={ ! ! t h i s . s t a t e . errorMessage}> 90 <Form . Fie ld> 91 <l abe l> Contr ibuc ion minima </l abe l> 92 93 {/⇤ I ng r e s a r l a con t r ibuc i on minima ⇤/} 94 <Input 95 p l a c eho ld e r=’ Cantidad minima de wei con l a que se puede c on t r i b u i r a l a campana ’ 96 l a b e lP o s i t i o n=’ r i g h t ’ 97 l a b e l=’ wei ’ 98 value={ t h i s . s t a t e . minimumContribution} 99 onChange={event => t h i s . s e t S t a t e ({ minimumContribution : event . t a r g e t . va lue }) } 100 /> 101 </Form . Fie ld> 102 103 <Form . Fie ld> 104 <l abe l> Contr ibuc ion maxima </l abe l> 6.3 Construcción (Construction) 115 105 106 {/⇤ I ng r e s a r l a con t r ibuc i on maxima ⇤/} 107 <Input 108 p l a c eho ld e r=’ Cantidad maxima de wei con l a que se puede c on t r i b u i r a l a campana , co loque 0 s i no desea e s t a b l e c e r un l im i t e maximo ’ 109 l a b e lP o s i t i o n=’ r i g h t ’ 110 l a b e l=’ wei ’ 111 value={ t h i s . s t a t e . maximumContribution} 112 onChange={event => t h i s . s e t S t a t e ({ maximumContribution : event . t a r g e t . va lue }) } 113 /> 114 </Form . Fie ld> 115 116 <Form . Fie ld> 117 <l abe l> Numero maximo de cont r ibuyente s </l abe l> 118 119 {/⇤ I ng r e s a r l a cant idad maxima de cont r ibuyente s ⇤/} 120 <Input 121 p l a c eho ld e r=’ Cantidad maxima de co t r i buyen t e s que desea en su campana , co loque 0 s i no desea e s t a b l e c e r un l im i t e de cont r ibuyente s ’ 122 value={ t h i s . s t a t e .maximumCont} 123 onChange={event => t h i s . s e t S t a t e ({ maximumCont : event . t a r g e t . va lue }) } 124 /> 125 </Form . Fie ld> 126 127 <Form . Fie ld> 128 <l abe l> Tasa de aprobacion </l abe l> 129 130 {/⇤ I ng r e s a r l a tasa de aprobacion ⇤/} 131 <Input 132 p l a c eho ld e r=’ Porcenta je de votos de aprobacion n e c e s a r i o s para aprobar una s o l i c i t u d , debe s e r un numero ent re 1 y 99 ’ 133 value={ t h i s . s t a t e . approveRate} 134 onChange={event => t h i s . s e t S t a t e ({ approveRate : event . t a r g e t . va lue }) } 135 /> 136 </Form . Fie ld> 137 138 <Form . Fie ld> 139 <l abe l> Tasa de rechazo </l abe l> 140 141 {/⇤ I ng r e s a r l a tasa de rechazo ⇤/} 142 <Input 143 p l a c eho ld e r=’ Porcenta je de votos de rechazo n e c e s a r i o s para rechazar una s o l i c i t u d , debe s e r un numero ent re 1 y 100 ’ 144 value={ t h i s . s t a t e . r e j e c tRat e } 116 6 Caṕıtulo 6 - Marco aplicativo 145 onChange={event => t h i s . s e t S t a t e ({ r e j e c tRat e : event . t a r g e t . va lue }) } 146 /> 147 </Form . Fie ld> 148 149 {/⇤ Mensaje de e r r o r que toma l a l i s t a de e r r o r e s desde l a func ion ’ onSubmit ’ ⇤/} 150 <Message e r r o r header=’Hubo un er ror , tome en cuenta l a s s i g u i e n t e s c on s i d e r a c i on e s ’ l i s t ={ t h i s . s t a t e . errorMessage } /> 151 152 {/⇤ Boton ’ Crear ’ ⇤/} 153 <Button load ing={ t h i s . s t a t e . l oad ing } primary >Â¡Crear !</Button> 154 </Form> 155 </Layout> 156 ) ; 157 } 158 159 } 160 161 export d e f au l t CampaignNew ; Algoritmo 6.16: Ruta que muestra el formulario para la creación de nuevas campañas (campaigns/new.js) 6.3.6.7. Visualizar los detalles de campañas Cada vez que se cree una nueva campaña, la lista de ’index.js’ automáticamente muestra la lista de las campañas creadas, cada campaña, viene acompañada de un botón ’Ver campaña’, el cual creará una ruta dinamicamente con la dirección de la campaña seleccionada, el módulo ’show.js’, se encarga de mostrar los detalles de una campaña dada una dirección particular. Dicho módulo tiene la siguiente estructura: 1 //Dependencias de i n t e r f a z , ru tas y e lementos u t i l e s de l cont rato 2 import React , { Component } from ’ r ea c t ’ ; 3 import Layout from ’ . . / . . / components/Layout ’ ; 4 import Campaign from ’ . . / . . / ethereum/campaign ’ ; 5 import { Card , Grid , Button } from ’ semantic�ui�r e a c t ’ ; 6 import web3 from ’ . . / . . / ethereum/web3 ’ ; 7 import ContributeForm from ’ . . / . . / components/ContributeForm ’ ; 8 import { Link } from ’ . . / . . / route s ’ ; 9 10 //Componente p r i n c i p a l que r ende r i z a l a s v a r i a b l e s de importanc ia de un contrato 11 c l a s s CampaignShow extends Component{ 12 13 //Funcion que obt i ene l o s parametros i n i c i a l e s de l componente 14 s t a t i c async g e t I n i t i a l P r o p s ( props ) { 6.3 Construcción (Construction) 117 15 16 //Se obt i ene l a i n s t an c i a de l cont rato dada su d i r e c c i on , obtenida desde l a ruta 17 const campaign = Campaign ( props . query . address ) ; 18 19 //Se l lama a l metodo de l cont rato ’ getSummary ’ que re to rna un resumen de l a campana 20 const summary = await campaign . methods . getSummary ( ) . c a l l ( ) ; 21 22 // S i l a con t r ibuc i on maxima es 0 , se reemplaza por ’� ’ 23 i f ( summary [ 1 ] == ’ 0 ’ ) { 24 summary [ 1 ] = ’� ’ 25 } 26 27 // S i e l numero maximo de cont r ibuyente s es 0 , se reemplaza por ’� ’ 28 i f ( summary [ 2 ] == ’ 0 ’ ) { 29 summary [ 2 ] = ’� ’ 30 } 31 32 //Se obt i ene l a cuenta ac t i va desde Metamask 33 const accounts = await web3 . eth . getAccounts ( ) ; 34 35 //Se re to rna e l ob j e to ’ props ’ que cont i ene todos l o s a t r i bu t o s obten idos de l a campana 36 r e turn { 37 address : props . query . address , 38 minimumContribution : summary [ 0 ] , 39 maximumContribution : summary [ 1 ] , 40 maximumContributors : summary [ 2 ] , 41 balance : summary [ 3 ] , 42 requestCount : summary [ 4 ] , 43 approversCount : summary [ 5 ] , 44 approvalRate : summary [ 6 ] , 45 r e j e c t edRate : summary [ 7 ] , 46 manager : summary [ 8 ] , 47 } ; 48 } 49 50 //Metodo que r ende r i z a l o s campos obten idos de l cont rato en t a r j e t a s s e n c i l l a s de l e e r desde l a i n t e r f a z 51 renderCards ( ) { 52 53 //Se obt ienen l o s datos desde ’ props ’ 54 const { 55 balance , 56 manager , 57 minimumContribution , 58 maximumContribution , 118 6 Caṕıtulo 6 - Marco aplicativo 59 maximumContributors , 60 requestCount , 61 approversCount , 62 approvalRate , 63 r e j e c t edRate 64 } = th i s . props ; 65 66 //Se crean l o s i tems de cada t a r j e t a , u t i l i z a ndo l o s ob j e t o s obten idos desde ’ props ’ 67 const i tems = [ 68 { 69 header : manager , 70 meta : ’ D i r ecc i on de l ge r ente ’ , 71 d e s c r i p t i o n : ’ Gerente que creo l a campana , puede c r ea r s o l i c i t u d e s y env ia r d inero de l a campana . ’ , 72 s t y l e : {overflowWrap : ’ break�word ’ } 73 } , 74 { 75 header : minimumContribution , 76 meta : ’ Contr ibuc ion minima ( wei ) ’ , 77 d e s c r i p t i o n : ’ Para c onv e r t i r s e en cont r ibuyente debe aportar a l menos e s ta cant idad de wei . ’ 78 } , 79 { 80 header : maximumContribution , 81 meta : ’ Contr ibuc ion maxima ( wei ) ’ , 82 d e s c r i p t i o n : ’ Para c onv e r t i r s e en cont r ibuyente puede aportar como maximo e s ta cant idad de wei . ’ 83 } , 84 { 85 header : maximumContributors , 86 meta : ’ Cantidad maxima de cont r ibuyente s ’ , 87 d e s c r i p t i o n : ’Numero maximo de cont r ibuyente s que pueden aportar a e s ta campana . ’ 88 } , 89 { 90 header : requestCount , 91 meta : ’Numero de s o l i c i t u d e s ’ , 92 d e s c r i p t i o n : ’Una s o l i c i t u d envia fondos de l a campana ac tua l . Las s o l i c i t u d e s deben s e r aprobadas por l o s cont r ibuyente s . ’ 93 } , 94 { 95 header : approversCount , 96 meta : ’Numero de cont r ibuyente s ’ , 97 d e s c r i p t i o n : ’ Cantidad de personas que han cont r ibu ido a e s ta campana . ’ 98 } , 99 { 6.3 Construcción (Construction) 119 100 //El ob j e to ’ ba lance ’ e s t a en e s c a l a Wei , se c onv i e r t e a Ether con l a func ion ’FromWei ’ 101 header : web3 . u t i l s . fromWei ( balance , ’ e the r ’ ) , 102 meta : ’ Balance de l a campana ( e the r ) ’ , 103 d e s c r i p t i o n : ’ El ba lance de l a campana es cuanto d inero t i e n e e s ta campana para gas ta r . ’ 104 } , 105 { 106 header : approvalRate + ” %” , 107 meta : ’ Tasa de aprobacion ’ , 108 d e s c r i p t i o n : ’ Tasa de votos de aprobacion para aprobar una s o l i c i t u d . ’ 109 } , 110 { 111 header : r e j e c t edRate + ” %” , 112 meta : ’ Tasa de rechazo ’ , 113 d e s c r i p t i o n : ’ Tasa de votos de rechazo para rechazar una s o l i c i t u d . ’ 114 } 115 ] ; 116 117 //Se retornan l a s t a r j e t a s con l o s datos as ignados 118 r e turn <Card . Group items={ i tems } /> 119 } ; 120 121 render ( ) { 122 r e turn ( 123 <Layout> 124 <h3> Informacion de l a campana </h3> 125 <Grid> 126 127 {/⇤ Grid que cont i ene l a l i s t a de t a r j e t a s y e l componente de cont r ibuc i on a campanas ⇤/} 128 <Grid .Row> 129 <Grid . Column width={10}> 130 { t h i s . renderCards ( ) } 131 </Grid . Column> 132 <Grid . Column width={6}> 133 <ContributeForm address={ t h i s . props . address}/> 134 </Grid . Column> 135 </Grid .Row> 136 <Grid .Row> 137 <Grid . Column> 138 139 {/⇤ Boton que l l e v a a l a l i s t a de s o l i c i t u d e s , segun l a d i r e c c i o n e s t a b l e c i d a en l a ruta ⇤/} 140 <Link route={ ‘/ campaigns/${ t h i s . props . address }/ reques t s ‘}> 141 <a> 142 <Button primary> 143 Ver s o l i c i t u d e s 120 6 Caṕıtulo 6 - Marco aplicativo 144 </Button> 145 </a> 146 </Link> 147 </Grid . Column> 148 </Grid .Row> 149 </Grid> 150 </Layout> 151 ) ; 152 } 153 } 154 155 export d e f au l t CampaignShow ; Algoritmo 6.17: Ruta que muestra los detalles de una campaña dada una dirección particular (campaigns/show.js) La vista renderizada por el módulo anteriomente descrito, muestra todos los detalles de importancia de la campaña, adicionalmente, posee un componente que renderiza un botón junto a un campo que un usuario puede llenar y seleccionar para convertirse en un con- tribuyente. También existe el botón que permite visualizar las solicitudes pendientes de la campaña actual. 6.3.6.8. Contribuir a una campaña La contribución a una campaña se contruye en un módulo separado del archivo ’show.js’ de- bido a que la contribución tiene su propia lógica especial que debe ser manejada de manera separada a la visualización de los atributos de la campaña. El módulo de contribución está estructurado de la siguiente manera: 1 //Dependencias de i n t e r f a z , ru tas y e lementos u t i l e s de l cont rato 2 import React , { Component } from ’ r ea c t ’ ; 3 import { Form , Input , Message , Button } from ’ semantic�ui�r e a c t ’ ; 4 import Campaign from ’ . . / ethereum/campaign ’ ; 5 import web3 from ’ . . / ethereum/web3 ’ ; 6 import { Router } from ’ . . / route s ’ ; 7 import currentIP from ’ . . / ip . j s ’ 8 9 //Componente p r i n c i p a l que r ende r i z a e l f o rmu la r i o para c on t r i b u i r a una campana 10 c l a s s ContributeForm extends Component { 11 12 // Var iab le ’ s t a t e ’ que guardara l o s datos desde e l f o rmu la r i o 13 s t a t e = { 14 value : ’ ’ , 15 errorMessage : ’ ’ , 16 l oad ing : f a l s e 6.3 Construcción (Construction) 121 17 } ; 18 19 //Funcion llamada a l hacer c l i c k en e l boton ’ Contr ibu i r ’ 20 onSubmit = async ( event ) => { 21 22 // El iminar e l comportamiento por de f e c t o de l a func ion 23 event . preventDefau l t ( ) ; 24 25 //Se obt i ene una i n s t an c i a de l a campana ac tua l mediante e l pase de parametros ocur r ido en ’ show . j s ’ 26 const campaign = Campaign ( t h i s . props . address ) ; 27 28 //Se ac t i va e l a t r i bu to ’ Loading ’ de l boton mientras que se procesa l a t r an sa c c i on en l a red 29 t h i s . s e t S t a t e ( { l oad ing : true , errorMessage : ’ ’ } ) ; 30 31 //Se obt i ene l a cuenta ac tua l de Metamask 32 const accounts = await web3 . eth . getAccounts ( ) ; 33 34 t ry { 35 36 //Se l lama a l metodo ’ con t r i bu t e ’ de l cont rato actua l , con l o s va l o r e s obten idos desde e l input de ’ Contr ibu i r ’ 37 await campaign . methods . con t r i bu t e ( ) . send ({ 38 from : accounts [ 0 ] , 39 value : web3 . u t i l s . toWei ( t h i s . s t a t e . value , ’ e the r ’ ) 40 }) ; 41 42 //Se r e a l i z a l a s o l i c i t u d a l s e r v i d o r donde se encuentra l a base de datos MongoDB para que guarde l a in formac ion de l a cont r ibuc i on r e a l i z a d a 43 f e t ch ( ’ http :// ’ + currentIP + ’ :8000/ con t r i bu t i on ’ , { 44 method : ’POST ’ , 45 headers : { 46 ’ Accept ’ : ’ a pp l i c a t i o n / j son ’ , 47 ’ Content�Type ’ : ’ a pp l i c a t i o n / j son ’ , 48 } , 49 body : JSON. s t r i n g i f y ({ 50 campaignAddress : t h i s . props . address , 51 value : web3 . u t i l s . toWei ( t h i s . s t a t e . value , ’ e the r ’ ) , 52 fromAddress : accounts [ 0 ] 53 }) 54 }) 55 56 //Una vez r e a l i z a d a l a cont r ibuc ion , se a c t u a l i z a l a pagina ac tua l para que e l u suar io pueda ve r l a 57 Router . rep laceRoute ( ‘ / campaigns/${ t h i s . props . address } ‘ ) ; 58 } catch ( e r r ) { 59 122 6 Caṕıtulo 6 - Marco aplicativo 60 //En caso de que ocurra un er ror , se c r ea r e l mensaje de e r r o r que se mostrara a l u suar io 61 t h i s . s e t S t a t e ({ errorMessage : [ ’ Asegurese de i n g r e s a r un numero va l i do de e the r o wei ( Sin l e t r a s ) ’ , ’En caso de s e r una l i s t a , no de j e e lementos en blanco ’ , ’ Ve r i f i qu e e s t a r usando su plug�in Metamask ’ , ’ Ve r i f i qu e su l i s t a de t r an s a c c i on e s pend iente s ’ ] }) ; 62 63 } 64 65 //Finalmente , termina e l proceso de ’ Loading ’ de l boton 66 t h i s . s e t S t a t e ({ l oad ing : f a l s e , va lue : ’ ’ }) ; 67 } 68 69 render ( ) { 70 r e turn ( 71 72 73 <Form onSubmit={ t h i s . onSubmit} e r r o r ={ ! ! t h i s . s t a t e . errorMessage}> 74 <Form . Fie ld> 75 <l abe l> Monto de cont r i buc i on </l abe l> 76 77 {/⇤ I ng r e s a r e l monto de l a con t r ibuc i on ⇤/} 78 <Input 79 p l a c eho ld e r=’ Cantidad de e the r con l a que desea c on t r i b u i r ’ 80 value={ t h i s . s t a t e . va lue } 81 onChange= { event => t h i s . s e t S t a t e ({ value : event . t a r g e t . va lue }) } 82 l a b e l=’ e the r ’ 83 l a b e lP o s i t i o n=’ r i g h t ’ 84 /> 85 </Form . Fie ld> 86 87 {/⇤ Mensaje de e r r o r que toma l a l i s t a de e r r o r e s desde l a func ion ’ onSubmit ’ ⇤/} 88 <Message e r r o r header=’Hubo un er ror , tome en cuenta l a s s i g u i e n t e s c on s i d e r a c i on e s ’ l i s t ={ t h i s . s t a t e . errorMessage } /> 89 90 {/⇤ Boton ’ Contr ibu i r ’ ⇤/} 91 <Button primary load ing={ t h i s . s t a t e . l oad ing}> 92 Â ¡Contr ibu i r ! 93 </Button> 94 </Form> 95 ) 96 97 98 } 99 100 } ; 101 6.3 Construcción (Construction) 123 102 export d e f au l t ContributeForm ; Algoritmo 6.18: Módulo que maneja las contribuciones a una campaña en espećıfico (Components/ContributionForm.js) Unas vez cubierta la lógica de contribución a una campaña, el siguiente flujo a cubrir, será el de visualizar solicitudes que estén pendientes en una campaña en espećıfico. 6.3.6.9. Visualizar solicitudes La tarea de renderizar solicitudes viene en paralelo con la capacidad que tienen los contri- buyentes y el gerente de interactuar con dichas solicitudes, es decir, la visualización de las solicitudes van de la mano con la aprobación, rechazo y finalización de las diferentes solici- tudes de una campaña. Renderizar e interactuar con las solicitudes es la tarea realizada por el módulo ’index.js’ (requests/index.js), su estructura es: 1 //Dependencias de i n t e r f a z , ru tas y e lementos u t i l e s de l contrato 2 import React , { Component } from ’ r ea c t ’ ; 3 import Layout from ’ . . / . . / . . / components/Layout ’ ; 4 import { Link } from ’ . . / . . / . . / rou te s ’ ; 5 import { Button , Table } from ’ semantic�ui�r e a c t ’ ; 6 import Campaign from ’ . . / . . / . . / ethereum/campaign ’ ; 7 import RequestRow from ’ . . / . . / . . / components/RequestRow ’ ; 8 import web3 from ’ . . / . . / . . / ethereum/web3 ’ ; 9 10 //Componente p r i n c i p a l que r ende r i z a l a tab la que cont i ene l a l i s t a de s o l i c i t u d e s 11 c l a s s RequestIndex extends Component { 12 13 //Funcion que obt i ene l o s parametros i n i c i a l e s de l componente 14 s t a t i c async g e t I n i t i a l P r o p s ( props ) { 15 16 //Se obt i ene l a d i r e c c i o n de l a campana ac tua l 17 const { address } = props . query ; 18 19 //Se obt i ene l a i n s t an c i a de l a campana , dada su d i r e c c i o n 20 const campaign = Campaign ( address ) ; 21 22 //Se obt ienen l a l i s t a de cuentas de Metamask 23 const accounts = await web3 . eth . getAccounts ( ) ; 24 25 //Cuenta ac tua l u t i l i z a d a 26 const currentAccount = accounts [ 0 ] ; 27 28 // L i s t a de a t r i bu t o s que se obt ienen de l a campana 29 const campaignManager = await campaign . methods . manager ( ) . c a l l ( ) ; 30 const requestCount = await campaign . methods . getRequestCount ( ) . c a l l ( ) ; 124 6 Caṕıtulo 6 - Marco aplicativo 31 const approversCount = await campaign . methods . approversCount ( ) . c a l l ( ) ; 32 const approvalRate = await campaign . methods . approvalRate ( ) . c a l l ( ) ; 33 const r e j e c t edRate = await campaign . methods . r e j e c t edRate ( ) . c a l l ( ) ; 34 35 //Balance ac tua l de l cont rato 36 const currentBalance = await web3 . eth . getBalance ( address ) ; 37 38 //Conversion a e the r de l ba lance de l cont rato 39 const balanceToEther = await web3 . u t i l s . fromWei ( currentBalance , ’ e the r ’ ) ; 40 41 //Se obt i ene l a l i s t a de s o l i c i t u d e s de l contrato 42 const r eque s t s = await Promise . a l l ( 43 Array ( pa r s e In t ( requestCount ) ) . f i l l ( ) .map( ( element , index ) => { 44 r e turn campaign . methods . r eque s t s ( index ) . c a l l ( ) ; 45 }) 46 ) ; 47 48 //Se r e t o r t a e l ob j e to con todas l a s v a r i a b l e s n e c e s a r i a s para r end e r i z a r 49 r e turn { address , r eques t s , requestCount , approversCount , campaignManager , currentAccount , approvalRate , re j ec tedRate , balanceToEther } ; 50 } 51 52 //Funcion encargada de r end e r i z a r una f i l a de l a tab la en un componente separado , junto a l a l i s t a de a t r i bu t o s n e c e s a r i o s por f i l a 53 renderRows ( ) { 54 r e turn t h i s . props . r eque s t s .map( ( request , index ) => { 55 r e turn <RequestRow 56 key={index } 57 id={index } 58 r eque s t={r eque s t } 59 address={ t h i s . props . address } 60 approversCount={ t h i s . props . approversCount} 61 approvalRate={ t h i s . props . approvalRate } 62 r e j e c t edRate={ t h i s . props . r e j e c t edRate } 63 /> 64 }) ; 65 } 66 67 render ( ) { 68 69 //Se obt ienen l o s a t r i bu t o s n e c e s a r i o s de l elemento ’ Table ’ ( Prov i s to por Semantic�UI) 70 const { Header , Row, HeaderCell , Body } = Table ; 71 72 r e turn ( 73 <Layout> 74 <h3> S o l i c i t u d e s </h3> 75 6.3 Construcción (Construction) 125 76 {/⇤ Balance de l a campana ac tua l ⇤/} 77 <h3> Balance de l a campana : { t h i s . props . balanceToEther} Ether </h3> 78 79 {/⇤ Boton para c r ea r una s o l i c i t u d ⇤/} 80 <Link route={ ‘/ campaigns/${ t h i s . props . address }/ r eque s t s /new‘}> 81 <a> 82 {/⇤ Este boton se i n h a b i l i t a s i l a persona que ve l a pagina no es e l gerente , de e s ta forma , quien no sea e l ge r ente no puede hacer c l i c k en e s t e boton ⇤/} 83 <Button primary f l o a t e d=’ r i g h t ’ s t y l e={{ marginBottom :10 }} d i s ab l ed={ t h i s . props . campaignManager != t h i s . props . currentAccount}> 84 Crear s o l i c i t u d 85 </Button> 86 </a> 87 </Link> 88 89 <Table> 90 <Header> 91 <Row> 92 93 {/⇤ Cabeceras de l a tab la ⇤/} 94 <HeaderCell> ID </HeaderCel l> 95 <HeaderCell> Fecha c r ea c i on </HeaderCel l> 96 <HeaderCell> Expirac ion </HeaderCel l> 97 <HeaderCell> Descr ipc i on </HeaderCel l> 98 <HeaderCell> Monto ( e the r ) </HeaderCel l> 99 <HeaderCell> Dest ino </HeaderCel l> 100 <HeaderCell> Cuenta de aprobados </HeaderCel l> 101 <HeaderCell> Cuenta de rechazados </HeaderCel l> 102 <HeaderCell> Rechazar </HeaderCel l> 103 <HeaderCell> Aprobar </HeaderCel l> 104 <HeaderCell> F in a l i z a r </HeaderCel l> 105 106 </Row> 107 </Header> 108 <Body> 109 {/⇤ Llamado a l componente que r e l l e n a r a l a s f i l a s de l a tab la ⇤/ } 110 { t h i s . renderRows ( ) } 111 </Body> 112 </Table> 113 114 {/⇤ Numero de s o l i c i t u d e s encontradas ⇤/} 115 <div> Encontradas { t h i s . props . requestCount } s o l i c i t u d e s . </div> 116 117 </Layout> 118 ) ; 119 } 126 6 Caṕıtulo 6 - Marco aplicativo 120 } 121 122 export d e f au l t RequestIndex ; Algoritmo 6.19: Módulo que maneja las solicitudes a una campaña en espećıfico (campaigns/requests/index.js) El módulo anterior se encarga de la renderización de la tabla que contiene todas las solicitudes de la campaña, sin embargo, cada una de las filas corresponde a cada una de las solicitudes, lo que requiere aplicar una lógica espećıfica a cada una de las filas de la tabla, por esta razón, para mostrar cada de las filas de la tabla, se creó un componente por separado que se encarga de tomar los datos de cada una de las solicitudes e integrarlas dentro de una fila para ser mostrada en el componente anterior, este componente separado, se encuentra ubicado en ’Components/RequestRow.js’: 1 //Dependencias de i n t e r f a z , ru tas y e lementos u t i l e s de l cont rato 2 import React , { Component } from ’ r ea c t ’ ; 3 import { Table , Button , Message } from ’ semantic�ui�r e a c t ’ ; 4 import web3 from ’ . . / ethereum/web3 ’ ; 5 import Campaing from ’ . . / ethereum/campaign ’ ; 6 import { Router , Link } from ’ . . / route s ’ ; 7 import currentIP from ’ . . / ip . j s ’ 8 9 //Componente p r i n c i p a l que r ende r i z a l a f i l a que cont i ene in formac ion de cada s o l i c i t u d 10 c l a s s RequestRow extends Component { 11 12 // Var iab le ’ s t a t e ’ que guarda l o s datos de ’ l oad ing ’ y mensaje de e r r o e cuando se haga c l i c k en ’ Aprobar ’ , ’ Rechazar ’ o ’ F i n a l i z a r ’ 13 s t a t e = { 14 l oad ing : f a l s e , 15 errorMessage : ’ ’ 16 } ; 17 18 //Funcion que conv i e r t e una fecha en Epoch en formato standard 19 epochToDate ( epoch ) { 20 l e t date = new Date ( epoch ⇤1000) ; 21 l e t formattedDate = date . getUTCDate ( ) + ’� ’ + ( date . getUTCMonth ( ) + 1)+ ’� ’ + date . getUTCFullYear ( ) ; 22 r e turn formattedDate ; 23 } 24 25 //Funcion llamada a l hacer c l i c k en e l boton ”Aprobar” 26 onApprove = async ( ) => { 27 28 //Se obt i ene l a i n s t an c i a de l cont rato ac tua l dada l a d i r e c c i o n desde l a ruta 29 const campaign = Campaing ( t h i s . props . address ) ; 6.3 Construcción (Construction) 127 30 31 //Se ac t i va e l a t r i bu to ’ Loading ’ de l boton mientras que se procesa l a t r an sa c c i on en l a red 32 t h i s . s e t S t a t e ({ l oad ing : true , errorMessage : ’ ’ }) 33 34 t ry { 35 36 //Se obt i ene l a cuenta ac tua l de Metamask 37 const accounts = await web3 . eth . getAccounts ( ) ; 38 39 //Se l lama a l mÃ c�todo ’ approveRequest ’ de l cont rato 40 await campaign . methods . approveRequest ( t h i s . props . id ) . send ({ 41 from : accounts [ 0 ] 42 }) ; 43 44 //Se r e a l i z a l a s o l i c i t u d a l s e r v i d o r donde se encuentra l a base de datos MongoDB para que guarde l a in formac ion de l a aprobacion r e a l i z a d a 45 f e t ch ( ’ http :// ’ + currentIP + ’ :8000/ approved ’ , { 46 method : ’POST ’ , 47 headers : { 48 ’ Accept ’ : ’ a pp l i c a t i o n / j son ’ , 49 ’ Content�Type ’ : ’ a pp l i c a t i o n / j son ’ , 50 } , 51 body : JSON. s t r i n g i f y ({ 52 campaign : t h i s . props . address , 53 approverAddress : accounts [ 0 ] , 54 id : t h i s . props . id 55 }) 56 }) 57 58 // F ina l i z ada l a t ransacc ion , se r ecarga l a pagina para que e l u suar io vea su aprobacion o rechazo render i zado 59 Router . rep laceRoute ( ‘ / campaigns/${ t h i s . props . address }/ reques t s ‘ ) ; 60 } catch ( e r r ) { 61 62 //En caso de que ocurra un er ror , se c r ea r e l mensaje de e r r o r que se mostrara a l usuar io 63 t h i s . s e t S t a t e ( { errorMessage : e r r . message} ) ; 64 } 65 66 //Finalmente , termina e l proceso de ’ Loading ’ de l boton 67 t h i s . s e t S t a t e ({ l oad ing : f a l s e , errorMessage : ’ ’ }) 68 } ; 69 70 //Funcion llamada a l hacer c l i c k en e l boton ”Rechazar” 71 onReject = async ( ) => { 72 73 //Se obt i ene l a i n s t an c i a de l cont rato ac tua l dada l a d i r e c c i o n desde l a 128 6 Caṕıtulo 6 - Marco aplicativo ruta 74 const campaign = Campaing ( t h i s . props . address ) ; 75 76 //Se ac t i va e l a t r i bu to ’ Loading ’ de l boton mientras que se procesa l a t r an sa c c i on en l a red 77 t h i s . s e t S t a t e ({ l oad ing : true , errorMessage : ’ ’ }) 78 79 t ry { 80 81 //Se obt i ene l a cuenta ac tua l de Metamask 82 const accounts = await web3 . eth . getAccounts ( ) ; 83 84 //Se l lama a l metodo ’ r e j e c tReque s t ’ de l contrato 85 await campaign . methods . r e j e c tReque s t ( t h i s . props . id ) . send ({ 86 from : accounts [ 0 ] 87 }) ; 88 89 //Se r e a l i z a l a s o l i c i t u d a l s e r v i d o r donde se encuentra l a base de datos MongoDB para que guarde l a in formac ion de l rechazo r e a l i z a d o 90 f e t ch ( ’ http : // ’ + currentIP + ’ :8000/ r e j e c t e d ’ , { 91 method : ’POST ’ , 92 headers : { 93 ’ Accept ’ : ’ a pp l i c a t i o n / j son ’ , 94 ’ Content�Type ’ : ’ a pp l i c a t i o n / j son ’ , 95 } , 96 body : JSON. s t r i n g i f y ({ 97 campaign : t h i s . props . address , 98 approverAddress : accounts [ 0 ] , 99 id : t h i s . props . id 100 }) 101 }) 102 103 // F ina l i z ada l a t ransacc ion , se r ecarga l a pagina para que e l u suar io vea su aprobacion o rechazo render i zado 104 Router . rep laceRoute ( ‘ / campaigns/${ t h i s . props . address }/ reques t s ‘ ) ; 105 106 } catch ( e r r ) { 107 //En caso de que ocurra un er ror , se c r ea r e l mensaje de e r r o r que se mostrara a l u suar io 108 t h i s . s e t S t a t e ( { errorMessage : e r r . message} ) ; 109 } 110 111 //Finalmente , termina e l proceso de ’ Loading ’ de l boton 112 t h i s . s e t S t a t e ({ l oad ing : f a l s e , errorMessage : ’ ’ }) 113 114 115 } ; 116 6.3 Construcción (Construction) 129 117 onF ina l i z e = async ( ) => { 118 119 //Se obt i ene l a i n s t an c i a de l cont rato ac tua l dada l a d i r e c c i o n desde l a ruta 120 const campaign = Campaing ( t h i s . props . address ) ; 121 122 //Se ac t i va e l a t r i bu to ’ Loading ’ de l boton mientras que se procesa l a t r an sa c c i on en l a red 123 t h i s . s e t S t a t e ({ l oad ing : true , errorMessage : ’ ’ }) 124 125 t ry { 126 127 //Se obt i ene l a cuenta ac tua l de Metamask 128 const accounts = await web3 . eth . getAccounts ( ) ; 129 130 //Se l lama a l metodo ’ f i n a l i z eRequ e s t ’ de l cont rato 131 await campaign . methods . f i n a l i z eRequ e s t ( t h i s . props . id ) . send ({ 132 from : accounts [ 0 ] 133 }) ; 134 135 //Se r e a l i z a l a s o l i c i t u d a l s e r v i d o r donde se encuentra l a base de datos MongoDB para que guarde l a in formac ion de l a f i n a l i z a c i o n r e a l i z a d a 136 f e t ch ( ’ http :// ’ + currentIP + ’ :8000/ f i n a l i z e d ’ , { 137 method : ’POST ’ , 138 headers : { 139 ’ Accept ’ : ’ a pp l i c a t i o n / j son ’ , 140 ’ Content�Type ’ : ’ a pp l i c a t i o n / j son ’ , 141 } , 142 body : JSON. s t r i n g i f y ({ 143 campaign : t h i s . props . address , 144 campaignManager : accounts [ 0 ] , 145 id : t h i s . props . id 146 }) 147 }) 148 149 // F ina l i z ada l a t ransacc ion , se r ecarga l a pagina para que e l u suar io vea su aprobacion o rechazo render i zado 150 Router . rep laceRoute ( ‘ / campaigns/${ t h i s . props . address }/ reques t s ‘ ) ; 151 152 } catch ( e r r ) { 153 154 //En caso de que ocurra un er ror , se c r ea r e l mensaje de e r r o r que se mostrara a l usuar io 155 t h i s . s e t S t a t e ( { errorMessage : e r r . message }) ; 156 } 157 158 //Finalmente , termina e l proceso de ’ Loading ’ de l boton 159 t h i s . s e t S t a t e ({ l oad ing : f a l s e , errorMessage : ’ ’ }) ; 130 6 Caṕıtulo 6 - Marco aplicativo 160 161 162 } ; 163 164 render ( ) { 165 166 //En e l metodo render , asignamos v a r i b a l e s de importanc ia que daran in formac ion a l usuar io con r e spe c to a cada s o l i c i t u d 167 const { Row, Ce l l } = Table ; 168 const { id , request , approversCount , approvalRate , r e j e c t edRate } = th i s . props ; 169 170 // Val idac ion sobre s i l a s o l i c i t u d e s ta l i s t a para s e r aprobada , se mostrara de c o l o r verde s i e s t e va l o r es ’ t rue ’ 171 const readyToApprove = reques t . approvalCount > approversCount ⇤( approvalRate ) /100 ; 172 173 // Val idac ion sobre s i l a s o l i c i t u d e s ta l i s t a para s e r rechazada , se mostrara en c o l o r naranja s i e s t e va l o r es ’ t rue ’ 174 const readyToReject = reque s t . r e j e c t sCount > approversCount ⇤( r e j e c t edRate ) /100 ; 175 176 //Se obt i ene l a f echa actua l , y se v e r i f i c a s i l a s o l i c i t u d e s ta expirada , en caso a f i rmat ivo , l a s o l i c i t u d se mostrara en c o l o r r o j o 177 const currentTime = Math . f l o o r ( ( new Date ) . getTime ( ) /1000) ; 178 const exp i red = ( ( r eque s t . c r ea t ed � currentTime + 604800) < 0) ; 179 conso l e . l og ( exp i r ed ) ; 180 181 r e turn ( 182 <Row po s i t i v e={readyToApprove && ! reque s t . complete } negat ive={exp i r ed } warning={readyToReject && ! r eque s t . complete}> 183 <Ce l l d i s ab l ed={r eque s t . complete}> { id } </Cel l> 184 <Ce l l d i s ab l ed={r eque s t . complete } c o l l a p s i n g = { t rue}> { t h i s . epochToDate ( r eque s t . c r ea t ed ) } </Cel l> 185 <Ce l l d i s ab l ed={r eque s t . complete } c o l l a p s i n g = { t rue } negat ive={ exp i r ed } > { t h i s . epochToDate ( par seF loat ( r eque s t . c r ea ted ) + 604800) } </Cel l > 186 <Ce l l d i s ab l ed={r eque s t . complete}> { r eque s t . d e s c r i p t i o n } </Cel l> 187 <Ce l l d i s ab l ed={r eque s t . complete}> {web3 . u t i l s . fromWei ( r eque s t . value , ’ e the r ’ ) } </Cel l> 188 {/⇤ Link que d i r i g e a l u suar io a l a pÃ¡gina de chequeo de cuentas en tiempo r e a l de Ethereum ⇤/} 189 <Cel l> <Link route={ ‘ h t tps : // r inkeby . e the r s can . i o / address /${ r eque s t . r e c i p i e n t } ‘}> 190 <a t a r g e t=” blank ”> 191 { r eque s t . r e c i p i e n t } 192 </a> 193 </Link> 6.3 Construcción (Construction) 131 194 </Cel l> 195 <Ce l l d i s ab l ed={r eque s t . complete}> { r eque s t . approvalCount }/{ approversCount} </Cel l> 196 <Ce l l d i s ab l ed={r eque s t . complete}> { r eque s t . r e j e c t sCount }/{ approversCount} </Cel l> 197 <Ce l l d i s ab l ed={r eque s t . complete}> 198 { r eque s t . complete ? nu l l : ( 199 <Button c o l o r=’ red ’ ba s i c onCl ick={ t h i s . onReject } l oad ing={ t h i s . s t a t e . l oad ing}> 200 Rechazar 201 </Button> 202 ) 203 } 204 </Cel l> 205 <Ce l l d i s ab l ed={r eque s t . complete}> 206 { r eque s t . complete ? nu l l : ( 207 <Button c o l o r=’ green ’ ba s i c onCl ick={ t h i s . onApprove} l oad ing={ t h i s . s t a t e . l oad ing}> 208 Aprobar 209 </Button> 210 ) 211 } 212 </Cel l> 213 <Ce l l d i s ab l ed={r eque s t . complete}> 214 { r eque s t . complete ? nu l l : ( 215 <Button c o l o r=’ t e a l ’ ba s i c onCl ick={ t h i s . onF ina l i z e } l oad ing={ t h i s . s t a t e . l oad ing}> 216 F in a l i z a r 217 </Button> 218 ) 219 220 } 221 </Cel l> 222 223 </Row> 224 ) ; 225 } 226 227 } 228 229 export d e f au l t RequestRow Algoritmo 6.20: Módulo que se encarga de construir cada una de las filas de la tabla de solicitudes (Components/RequestRow.js) 132 6 Caṕıtulo 6 - Marco aplicativo 6.3.6.10. Creación de solicitudes El último elemento que compone la solución, viene siendo la creación de solicitudes mediante el cliente web, en la ruta ’requests/index.js’ se encuentra el botón de crear solicitud, una vez presionado este botón, el formulario para crear una solicitud será renderizado en la pantalla mediante el siguiente módulo: 1 //Dependencias de i n t e r f a z , ru tas y e lementos u t i l e s de l cont rato 2 import React , { Component } from ’ r ea c t ’ ; 3 import { Form , Button , Message , Input } from ’ semantic�ui�r e a c t ’ ; 4 import Campaign from ’ . . / . . / . . / ethereum/campaign ’ ; 5 import web3 from ’ . . / . . / . . / ethereum/web3 ’ ; 6 import { Link , Router } from ’ . . / . . / . . / rou te s ’ ; 7 import Layout from ’ . . / . . / . . / components/Layout ’ ; 8 import currentIP from ’ . . / . . / . . / ip . j s ’ 9 10 11 //Componente p r i n c i p a l que r ende r i z a e l f o rmu la r i o para c r ea r una s o l i c i t u d nueva 12 c l a s s RequestNew extends Component{ 13 14 // Var iab le ’ s t a t e ’ que guardara l o s datos desde e l f o rmu la r i o 15 s t a t e = { 16 value : ’ ’ , 17 d e s c r i p t i o n : ’ ’ , 18 r e c i p i e n t : ’ ’ , 19 l oad ing : f a l s e , 20 errorMessage : ’ ’ 21 } ; 22 23 //Funcion que obt i ene l o s parametros i n i c i a l e s de l componente 24 s t a t i c async g e t I n i t i a l P r o p s ( props ) { 25 26 //Se obt i ene l a d i r e c c i o n ac tua l de l cont rato desde l a ruta 27 const { address } = props . query ; 28 r e turn { address } ; 29 30 } ; 31 32 //Funcion llamada a l hacer c l i c k en e l boton ”Crear ” 33 onSubmit = async event => { 34 35 // El iminar e l comportamiento por de f e c t o de l a func ion 36 event . preventDefau l t ( ) ; 37 38 //Se obt i ene l a i n s t an c i a de l a campana con l a que se e s t a trabajando dada una d i r e c c i o n 39 const campaign = Campaign ( t h i s . props . address ) ; 6.3 Construcción (Construction) 133 40 41 //Se obt ienen l a s v a r i a b l e s desde e l f o rmu la r i o 42 const { de s c r i p t i on , value , r e c i p i e n t } = th i s . s t a t e ; 43 44 //Se ac t i va e l a t r i bu to ’ Loading ’ de l boton mientras que se procesa l a t r an sa c c i on en l a red 45 t h i s . s e t S t a t e ({ l oad ing : true , errorMessage : ’ ’ }) 46 47 t ry { 48 49 //Se obt i ene l a cuenta ac tua l de Metamask 50 const accounts = await web3 . eth . getAccounts ( ) ; 51 52 //Se l lama a l metodo ’ createRequest ’ de l cont rato ac tua l y se l e pasan l o s parametros obten idos desde e l f o rmu la r i o 53 await campaign . methods . c reateRequest ( d e s c r i p t i on , web3 . u t i l s . toWei ( value , ’ e the r ’ ) , r e c i p i e n t ) 54 . send ({ from : accounts [ 0 ] }) ; 55 56 //Se r e a l i z a l a s o l i c i t u d a l s e r v i d o r donde se encuentra l a base de datos MongoDB para que guarde l a in formac ion de l a s o l i c i t u d r e c i e n creada 57 f e t ch ( ’ http :// ’ + currentIP + ’ :8000/ reque s t ’ , { 58 method : ’POST ’ , 59 headers : { 60 ’ Accept ’ : ’ a pp l i c a t i o n / j son ’ , 61 ’ Content�Type ’ : ’ a pp l i c a t i o n / j son ’ , 62 } , 63 body : JSON. s t r i n g i f y ({ 64 campaignManager : accounts [ 0 ] , 65 toAddress : r e c i p i e n t , 66 value : web3 . u t i l s . toWei ( value , ’ e the r ’ ) , 67 d e s c r i p t i o n : d e s c r i p t i on , 68 createdAt : Date . now( ) 69 }) 70 }) ; 71 72 //Una creada l a s o l i c i t u d , se r e d i r i g e a l u suar io a l a l i s t a de s o l i c i t u d e s 73 Router . pushRoute ( ‘ / campaigns/${ t h i s . props . address }/ reques t s ‘ ) ; 74 75 } catch ( e r r ) { 76 77 //En caso de que ocurra un er ror , se c r ea r e l mensaje de e r r o r que se mostrara a l usuar io 78 t h i s . s e t S t a t e ({ errorMessage : [ ’ Asegurese de i n g r e s a r un numero va l i do de e the r o wei ( Sin l e t r a s ) ’ , ’En caso de s e r una l i s t a , no de j e e lementos en blanco ’ , ’ Ve r i f i qu e e s t a r usando su plug�in Metamask ’ , ’ Ve r i f i qu e su l i s t a de t r an s a c c i on e s pend iente s ’ ] }) 134 6 Caṕıtulo 6 - Marco aplicativo 79 } 80 81 //Finalmente , termina e l proceso de ’ Loading ’ de l boton 82 t h i s . s e t S t a t e ({ l oad ing : f a l s e }) 83 84 } ; 85 86 render ( ) { 87 r e turn ( 88 <Layout> 89 90 {/⇤ Boton para vo lve r a l a l i s t a de s o l i c i t u d e s ⇤/} 91 <Link route={ ‘/ campaigns/${ t h i s . props . address }/ reques t s ‘}> 92 <a> 93 Atras 94 </a> 95 </Link> 96 97 <h3> Crear una nueva s o l i c i t u d </h3> 98 99 {/⇤ Formulario que r e l l e n a e l u suar io para c r ea r una s o l i c i t u d , i n i c i a lmen t e no t i e n e mensaje de e r r o r ⇤/} 100 <Form onSubmit={ t h i s . onSubmit} e r r o r ={ ! ! t h i s . s t a t e . errorMessage}> 101 <Form . Fie ld> 102 <l abe l> Descr ipc i on </l abe l> 103 104 {/⇤ I ng r e s a r l a d e s c r i p c i on de l a s o l i c i t u d ⇤/} 105 <Input 106 p l a c eho ld e r=’ Desc r ipc i on de su s o l i c i t u d ’ 107 value={ t h i s . s t a t e . d e s c r i p t i o n } 108 onChange={event => t h i s . s e t S t a t e ({ d e s c r i p t i o n : event . t a r g e t . va lue }) } 109 /> 110 </Form . Fie ld> 111 <Form . Fie ld> 112 <l abe l> Monto en ether</l abe l> 113 114 {/⇤ I ng r e s a r e l monto de l a s o l i c i t u d ⇤/} 115 <Input 116 l a b e lP o s i t i o n=’ r i g h t ’ 117 l a b e l=’ e the r ’ 118 p l a c eho ld e r=’Monto que desea r e t i r a r de l a campana ’ 119 value={ t h i s . s t a t e . va lue } 120 onChange={event => t h i s . s e t S t a t e ({ value : event . t a r g e t . va lue }) } 121 /> 122 </Form . Fie ld> 123 <Form . Fie ld> 124 <l abe l> Dest ino </l abe l> 6.3 Construcción (Construction) 135 125 126 {/⇤ I ng r e s a r l a d i r e c c i o n de s t i no l a s o l i c i t u d ⇤/} 127 <Input 128 p l a c eho ld e r=’ Di r e cc i on de s t i no a l a que i r an l o s fondos de su s o l i c i t u d ’ 129 value={ t h i s . s t a t e . r e c i p i e n t } 130 onChange={event => t h i s . s e t S t a t e ({ r e c i p i e n t : event . t a r g e t . va lue }) } 131 /> 132 </Form . Fie ld> 133 134 {/⇤ Mensaje de e r r o r que toma l a l i s t a de e r r o r e s desde l a func ion ’ onSubmit ’ ⇤/} 135 <Message e r r o r header=’Hubo un er ror , tome en cuenta l a s s i g u i e n t e s c on s i d e r a c i on e s ’ l i s t ={ t h i s . s t a t e . errorMessage } /> 136 137 {/⇤ Boton ’ Crear ’ ⇤/} 138 <Button primary load ing={ t h i s . s t a t e . l oad ing}> 139 Â¡Crear ! 140 </Button> 141 </Form> 142 </Layout> 143 ) ; 144 } 145 146 } 147 148 export d e f au l t RequestNew ; Algoritmo 6.21: Módulo que se encarga de construir el formulario para crear una solicitud (pages/campaigns/requests/news.js) 6.3.6.11. Elementos de interfaz Finalmente, existen dos componentes más que forman parte del cliente web, el primero de ellos, crea una cabecera en el cliente, el cual es reciclado en todas las vistas para darle mejor aspecto f́ısico y congruencia. El mismo está estructurado de la siguiente manera: 1 //Dependencias de i n t e r f a z , ru tas y e lementos u t i l e s de l contrato 2 import React from ’ r ea c t ’ ; 3 import { Menu } from ’ semantic�ui�r e a c t ’ ; 4 import { Link } from ’ . . / route s ’ ; 5 6 export d e f au l t ( ) => { 7 r e turn ( 8 9 <Menu s t y l e = {{ marginTop : ’ 10px ’ }} > 10 <Link route=’ / ’> 136 6 Caṕıtulo 6 - Marco aplicativo 11 <a className=’ item ’> 12 Financ iac ion Co l e c t i va 13 </a> 14 </Link> 15 16 <Menu .Menu po s i t i o n= ” r i gh t ”> 17 <Link route=’ / ’> 18 <a className=’ item ’> 19 Campanas 20 </a> 21 </Link> 22 23 <Link route=’ /campaigns/new ’> 24 <a className=’ item ’> 25 + 26 </a> 27 </Link> 28 29 30 </Menu .Menu> 31 </Menu> 32 ) ; 33 } Algoritmo 6.22: Componente que hace de cabecera a todas las páginas del cliente web (Components/Header.js) El segundo componente se encarga de centrar todos los elementos de la página para dejar margenes a ambos lados para un mejor aspecto y además, es el componente encargado de realizar la llamada al CDN de Semantic-UI para su uso: 1 //Dependencias de i n t e r f a z , ru tas y e lementos u t i l e s de l cont rato 2 import React from ’ r ea c t ’ ; 3 import { Container } from ’ semantic�ui�r e a c t ’ ; 4 import Head from ’ next /head ’ ; 5 import Header from ’ . / Header ’ ; 6 7 export d e f au l t ( props ) => { 8 r e turn ( 9 10 11 <Container> 12 <Head> 13 < l i n k r e l=” s t y l e s h e e t ” h r e f=”// cdnj s . c l o u d f l a r e . com/ ajax / l i b s / semantic �ui /2 . 2 . 12/ semantic . min . c s s ”></l ink> 14 </Head> 15 <Header /> 16 {props . c h i l d r en } 17 6.3 Construcción (Construction) 137 18 </Container> 19 ) ; 20 } ; Algoritmo 6.23: Componente que hace contenedor a todas las páginas del cliente web (Components/Layout.js) 6.3.7. Iteración 6: Almacenamiento de interacciones Mientras se desarrollaba el cliente web, se tomó en cuenta el almacenamiento de las interac- ciones en la base de datos mediante solicitudes HTTP, las interacciones a ser almacenadas son: Creación de campañas. Contribuciones. Solicitudes creadas. Aprobaciones. Rechazos. Finalizaciones. Una vez definidas estas interacciones, en la presente iteración se desarrollan los módulos que se encargan de construir los modelos que reciben estos datos de parte del cliente y los almacenan en la base de datos, y además se define el módulo controlador de dichas rutas. 6.3.7.1. Servidor MongoDB A continuación se presenta el módulo que realiza la conexión con una instancia de MongoDB en una red local, además de definir las rutas que controlan las interacciones con esta base de datos: 1 //Uso de expre s s 2 const expre s s = r equ i r e ( ’ expre s s ’ ) ; 3 const app = expre s s ( ) ; 4 5 //Mongo Plugin 6 var mongoose = r equ i r e ( ”mongoose” ) ; 7 8 //Conexion a l a base de datos 9 mongoose . connect ( ’mongodb :// l o c a l h o s t /campaignDB ’ ) ; 10 var db = mongoose . connect ion ; 11 db . on ( ” e r r o r ” , c on so l e . e r r o r . bind ( conso le , ”Connection e r r o r : ” ) ) ; 138 6 Caṕıtulo 6 - Marco aplicativo 12 db . once ( ”open” , f unc t i on ( ) { 13 conso l e . l og ( ”Conectado a l a base de datos . ” ) ; 14 }) ; 15 16 // Permit i r s o l i c i t u d e s HTTP in t e r a c t ua r con e l s e r v i d o r 17 app . use ( func t i on ( req , res , next ) { 18 r e s . header ( ’ Access�Control�Allow�Creden t i a l s ’ , t rue ) ; 19 r e s . header ( ’ Access�Control�Allow�Orig in ’ , req . headers . o r i g i n ) ; 20 r e s . header ( ’ Access�Control�Allow�Methods ’ , ’GET,PUT,POST,DELETE’ ) ; 21 r e s . header ( ’ Access�Control�Allow�Headers ’ , ’X�Requested�With , X�HTTP�Method� Override , Content�Type , Accept , Author i zat ion ’ ) ; 22 i f ( ’OPTIONS ’ == req . method ) { 23 r e s . sendStatus (200) ; 24 } e l s e { 25 next ( ) ; 26 } 27 }) ; 28 29 //Router 30 const rout e r = r equ i r e ( ” . / route s / route r . j s ” ) ( app ) ; 31 32 //Puerto en e l que co r r e e l s e r v i d o r que maneja l a base de datos 33 app . l i s t e n (8000 , f unc t i on ( ) { 34 conso l e . l og ( ’ Escuchando en e l puerto 8000 ’ ) ; 35 }) ; Algoritmo 6.24: Componente que se conecta con MongoDB (server/app.js) Una vez que este módulo se ejecuta, se crea la ruta del módulo controlador que se encargará de manejar las solicitudes que accedan al servidor: 1 module . export s = func t i on ( app ) { 2 3 //Ruta para e l procesamiento de s o l i c i t u d e s 4 app . use ( ’ / ’ , r e qu i r e ( ’ . . / main . c o n t r o l l e r . j s ’ ) ) ; 5 } ; Algoritmo 6.25: Ruta que asigna el módulo controlador que maneja las solicitudes (server/routes/router.js) 6.3.7.2. Modelos A continuación se definen los modelos para el almacenamiento en la base de datos: Campaña: 1 ”use s t r i c t ” ; 2 //Dependencia u t i l i z a d a para l a i n t e r a c c i o n con l a base de datos 3 var mongoose = r equ i r e ( ”mongoose” ) ; 4 //Dependencia u t i l i z a d a para l a c r ea c i on de ’ Schemas ’ que dan forma a l o s ob j e t o s a s e r guardados en l a base de datos 6.3 Construcción (Construction) 139 5 var Schema = mongoose . Schema ; 6 7 //Modelo de c r ea c i on de una campana 8 c l a s s campaignModel{ 9 10 //Constructor 11 con s t ruc to r (name , schema ) { 12 t h i s . name = name ; 13 t h i s . schema = schema ; 14 t h i s . model = mongoose . model ( t h i s . name , t h i s . schema ) ; 15 } 16 17 //Creacion y guardado de l ob j e to 18 createCampaign ( campaignObj ) { 19 var newCampaign = new th i s . model ({ 20 campaignManager : campaignObj . campaignManager , 21 campaignAddress : campaignObj . campaignAddress , 22 minimumContribution : campaignObj . minimumContribution , 23 maximumContribution : campaignObj . maximumContribution , 24 maximumCont : campaignObj .maximumCont , 25 approveRate : campaignObj . approveRate , 26 r e j e c tRat e : campaignObj . r e j e c tRat e 27 }) ; 28 29 //Guardar en l a base de datos 30 newCampaign . save ( func t i on ( err , data ) { 31 i f ( e r r ) con so l e . l og ( e r r ) ; 32 conso l e . l og ( ’Campana almacenada ’ ) ; 33 }) ; 34 } 35 } 36 37 //Modelo de campana a s e r guardada en l a base de datos 38 var Campaign = new campaignModel ( ’Campaign ’ , new Schema({ 39 campaignManager : Str ing , 40 campaignAddress : Str ing , 41 minimumContribution : Str ing , 42 maximumContribution : Str ing , 43 maximumCont : Str ing , 44 approveRate : Str ing , 45 r e j e c tRat e : S t r ing 46 }) ) ; 47 48 module . export s = Campaign ; Algoritmo 6.26: Modelo de una campaña para el almacenamiento en la base de datos (server/models/campaign.model.js) Contribución: 140 6 Caṕıtulo 6 - Marco aplicativo 1 ”use s t r i c t ” ; 2 //Dependencia u t i l i z a d a para l a i n t e r a c c i o n con l a base de datos 3 var mongoose = r equ i r e ( ”mongoose” ) ; 4 //Dependencia u t i l i z a d a para l a c r ea c i on de ’ Schemas ’ que dan forma a l o s ob j e t o s a s e r guardados en l a base de datos 5 var Schema = mongoose . Schema ; 6 7 //Modelo de cont r ibuc i on a una campana 8 c l a s s contr ibut ionMode l { 9 10 //Constructor 11 con s t ruc to r (name , schema ) { 12 t h i s . name = name ; 13 t h i s . schema = schema ; 14 t h i s . model = mongoose . model ( t h i s . name , t h i s . schema ) ; 15 } 16 17 //Creacion y guardado de l ob j e to 18 c r ea t eCont r ibut i on ( contr ibut ionObj ) { 19 var newContribution = new th i s . model ({ 20 campaignAddress : contr ibut ionObj . campaignAddress , 21 value : contr ibut ionObj . value , 22 fromAddress : contr ibut ionObj . fromAddress 23 }) ; 24 newContribution . save ( func t i on ( err , data ) { 25 i f ( e r r ) con so l e . l og ( e r r ) ; 26 conso l e . l og ( ’ Contr ibuc ion almacenada ’ ) ; 27 }) ; 28 } 29 } 30 31 //Modelo de cont r ibuc i on a s e r guardada en l a base de datos 32 var Contr ibut ion = new contr ibut ionModel ( ’ Contr ibut ion ’ , new Schema({ 33 campaignAddress : Str ing , 34 value : Str ing , 35 fromAddress : S t r ing 36 }) ) ; 37 38 module . export s = Contr ibut ion ; Algoritmo 6.27: Modelo de una contribución para el almacenamiento en la base de datos (server/models/contribution.model.js) Solicitudes: 1 ”use s t r i c t ” ; 2 //Dependencia u t i l i z a d a para l a i n t e r a c c i o n con l a base de datos 3 var mongoose = r equ i r e ( ”mongoose” ) ; 4 //Dependencia u t i l i z a d a para l a c r ea c i on de ’ Schemas ’ que dan forma a l o s ob j e t o s a s e r guardados en l a base de datos 6.3 Construcción (Construction) 141 5 var Schema = mongoose . Schema ; 6 7 //Modelo de s o l i c i t u d a una campana 8 c l a s s requestModel { 9 10 //Constructor 11 con s t ruc to r (name , schema ) { 12 t h i s . name = name ; 13 t h i s . schema = schema ; 14 t h i s . model = mongoose . model ( t h i s . name , t h i s . schema ) ; 15 } 16 17 //Creacion y guardado de l ob j e to 18 createRequest ( requestObj ) { 19 var newRequest = new th i s . model ({ 20 campaignManager : requestObj . campaignManager , 21 toAddress : requestObj . toAddress , 22 value : requestObj . value , 23 d e s c r i p t i o n : requestObj . d e s c r i p t i on , 24 createdAt : requestObj . createdAt 25 26 }) ; 27 28 //Guardar en l a base de datos 29 newRequest . save ( func t i on ( err , data ) { 30 i f ( e r r ) con so l e . l og ( e r r ) ; 31 conso l e . l og ( ’ S o l i c i t u d almacenada ’ ) ; 32 }) ; 33 } 34 } 35 36 //Modelo de s o l i c i t u d a s e r guardada en l a base de datos 37 var Request = new requestModel ( ’ Request ’ , new Schema({ 38 campaignManager : Str ing , 39 toAddress : Str ing , 40 value : Str ing , 41 d e s c r i p t i o n : Str ing , 42 createdAt : Number 43 }) ) ; 44 45 module . export s = Request ; Algoritmo 6.28: Modelo de una solicitud para el almacenamiento en la base de datos (server/models/request.model.js) Aprobación de una solicitud: 1 ”use s t r i c t ” ; 2 //Dependencia u t i l i z a d a para l a i n t e r a c c i o n con l a base de datos 3 var mongoose = r equ i r e ( ”mongoose” ) ; 142 6 Caṕıtulo 6 - Marco aplicativo 4 //Dependencia u t i l i z a d a para l a c r ea c i on de ’ Schemas ’ que dan forma a l o s ob j e t o s a s e r guardados en l a base de datos 5 var Schema = mongoose . Schema ; 6 7 //Modelo de aprobacion de una s o l i c i t u d 8 c l a s s approvedModel{ 9 10 //Constructor 11 con s t ruc to r (name , schema ) { 12 t h i s . name = name ; 13 t h i s . schema = schema ; 14 t h i s . model = mongoose . model ( t h i s . name , t h i s . schema ) ; 15 } 16 17 18 //Creacion y guardado de l ob j e to 19 createApproved ( approvedObj ) { 20 21 var newApproved = new th i s . model ({ 22 campaign : approvedObj . campaign , 23 approverAddress : approvedObj . approverAddress , 24 id : approvedObj . id 25 26 }) ; 27 28 //Guardar en l a base de datos 29 newApproved . save ( func t i on ( err , data ) { 30 i f ( e r r ) con so l e . l og ( e r r ) ; 31 conso l e . l og ( ’ Aprobacion almacenada ’ ) ; 32 }) ; 33 } 34 } 35 36 //Modelo de aprobacion de s o l i c i t u d a s e r guardada en l a base de datos 37 var Approved = new approvedModel ( ’ Approved ’ , new Schema({ 38 campaign : Str ing , 39 approverAddress : Str ing , 40 id : S t r ing 41 }) ) ; 42 43 module . export s = Approved ; Algoritmo 6.29: Modelo de una aprobación de una solicitud para el almacenamiento en la base de datos (server/models/approved.model.js) Rechazo de una solicitud: 1 ”use s t r i c t ” ; 2 //Dependencia u t i l i z a d a para l a i n t e r a c c i o n con l a base de datos 3 var mongoose = r equ i r e ( ”mongoose” ) ; 6.3 Construcción (Construction) 143 4 //Dependencia u t i l i z a d a para l a c r ea c i on de ’ Schemas ’ que dan forma a l o s ob j e t o s a s e r guardados en l a base de datos 5 var Schema = mongoose . Schema ; 6 7 //Modelo de rechazo a s o l i c i t u d 8 c l a s s re jectedMode l { 9 10 //Constructor 11 con s t ruc to r (name , schema ) { 12 t h i s . name = name ; 13 t h i s . schema = schema ; 14 t h i s . model = mongoose . model ( t h i s . name , t h i s . schema ) ; 15 } 16 17 18 //Creacion y guardado de l ob j e to 19 c r ea t eRe j e c t ed ( r e j e c t edObj ) { 20 21 var newRejected = new th i s . model ({ 22 campaign : r e j e c t edObj . campaign , 23 r e j e c t e rAddr e s s : r e j e c t edObj . r e j e c t e rAddre s s , 24 id : r e j e c t edObj . id 25 26 }) ; 27 28 //Guardar en l a base de datos 29 newRejected . save ( func t i on ( err , data ) { 30 i f ( e r r ) con so l e . l og ( e r r ) ; 31 conso l e . l og ( ’ Rechazo almacenado ’ ) ; 32 }) ; 33 } 34 } 35 36 //Modelo de s o l i c i t u d rechazada a s e r guardada en l a base de datos 37 var Rejected = new re jectedMode l ( ’ Rejected ’ , new Schema({ 38 campaign : Str ing , 39 approverAddress : Str ing , 40 id : S t r ing 41 }) ) ; 42 43 module . export s = Rejected ; Algoritmo 6.30: Modelo de un rechazo de una solicitud para el almacenamiento en la base de datos (server/models/rejected.model.js) Finalización de una solicitud: 1 ”use s t r i c t ” ; 2 //Dependencia u t i l i z a d a para l a i n t e r a c c i o n con l a base de datos 3 var mongoose = r equ i r e ( ”mongoose” ) ; 144 6 Caṕıtulo 6 - Marco aplicativo 4 //Dependencia u t i l i z a d a para l a c r ea c i on de ’ Schemas ’ que dan forma a l o s ob j e t o s a s e r guardados en l a base de datos 5 var Schema = mongoose . Schema ; 6 7 //Modelo de f i n a l i z a c i o n de una s o l i c i t u d 8 c l a s s f i na l i z edMode l { 9 10 //Constructor 11 con s t ruc to r (name , schema ) { 12 t h i s . name = name ; 13 t h i s . schema = schema ; 14 t h i s . model = mongoose . model ( t h i s . name , t h i s . schema ) ; 15 } 16 17 //Creacion y guardado de l ob j e to 18 c r e a t eF i n a l i z e d ( f i n a l i z e dOb j ) { 19 var newFinal ized = new th i s . model ({ 20 campaign : f i n a l i z e dOb j . campaign , 21 campaignManager : f i n a l i z e dOb j . campaignManager , 22 id : f i n a l i z e dOb j . id 23 24 }) ; 25 26 //Guardar en l a base de datos 27 newFinal ized . save ( func t i on ( err , data ) { 28 i f ( e r r ) con so l e . l og ( e r r ) ; 29 conso l e . l og ( ’ F i n a l i z a c i o n almacenada ’ ) ; 30 }) ; 31 } 32 } 33 34 //Modelo de f i n a l i z a c i o n de una s o l i c i t u d a s e r guardada en l a base de datos 35 var F ina l i z ed = new f i na l i z edMode l ( ’ F i na l i z ed ’ , new Schema({ 36 campaign : Str ing , 37 campaignManager : Str ing , 38 id : S t r ing 39 }) ) ; 40 41 module . export s = F ina l i z ed ; Algoritmo 6.31: Modelo de finalización de una solicitud para el almacenamiento en la base de datos (server/models/finalized.model.js) Finalmente, se define el módulo controlador que se encarga de utilizar todos los modelos previamente definidos para almacenar las diferentes interacciones dependiendo de la dirección a la que está dirigida la solicitud HTPP desde el lado del cliente: 1 //Dependencias n e c e s a r i a s 2 const expre s s = r equ i r e ( ’ expre s s ’ ) ; 6.3 Construcción (Construction) 145 3 const rout e r = expre s s . Router ( ) ; 4 5 //Modelos de ob j e t o s a guardar en l a base de datos 6 const mongoose = r equ i r e ( ’mongoose ’ ) ; 7 const Contr ibut ion = r equ i r e ( ’ . / models / con t r i bu t i on . model . j s ’ ) ; 8 const Campaign = r equ i r e ( ’ . / models /campaign . model . j s ’ ) ; 9 const Request = r equ i r e ( ’ . / models / r eque s t . model . j s ’ ) ; 10 const F ina l i z ed = r equ i r e ( ’ . / models / f i n a l i z e d . model . j s ’ ) ; 11 const Approved = r equ i r e ( ’ . / models /approved . model . j s ’ ) ; 12 const Rejected = r equ i r e ( ’ . / models / r e j e c t e d . model . j s ’ ) ; 13 14 //Body Parser para proce sa r s o l i c i t u d e s HTTP 15 const bodyParser = r equ i r e ( ”body�par s e r ” ) ; 16 rou te r . use ( bodyParser . ur lencoded ({ extended : f a l s e }) ) ; 17 rou te r . use ( bodyParser . j s on ( ) ) ; 18 19 //Ruta que maneja ’ c on t r i bu t i on ’ , que almacena una cont r ibuc i on 20 rou te r . post ( ’ / con t r i bu t i on ’ , f unc t i on ( req , r e s ) { 21 22 l e t contr ibut ionObj = {} ; 23 contr ibut ionObj . campaignAddress = req . body . campaignAddress ; 24 contr ibut ionObj . va lue = req . body . va lue ; 25 contr ibut ionObj . fromAddress = req . body . fromAddress ; 26 Contr ibut ion . c r ea t eCont r ibut i on ( contr ibut ionObj ) ; 27 28 }) ; 29 30 //Ruta que maneja ’ campaign ’ , que almacena una campana nueva 31 rou te r . post ( ’ /campaign ’ , f unc t i on ( req , r e s ) { 32 33 l e t campaignObj = {} ; 34 campaignObj . campaignManager = req . body . campaignManager ; 35 campaignObj . campaignAddress = req . body . campaignAddress ; 36 campaignObj . minimumContribution = req . body . minimumContribution ; 37 campaignObj . maximumContribution = req . body . maximumContribution ; 38 campaignObj .maximumCont = req . body .maximumCont ; 39 campaignObj . approveRate = req . body . approveRate ; 40 campaignObj . r e j e c tRat e = req . body . r e j e c tRat e ; 41 42 Campaign . createCampaign ( campaignObj ) ; 43 44 }) ; 45 46 //Ruta que maneja ’ r eque s t ’ , que almacena una s o l i c i t u d nueva 47 rou te r . post ( ’ / r eque s t ’ , f unc t i on ( req , r e s ) { 48 49 l e t requestObj = {} ; 50 requestObj . campaignManager = req . body . campaignManager ; 146 6 Caṕıtulo 6 - Marco aplicativo 51 requestObj . toAddress = req . body . toAddress ; 52 requestObj . va lue = req . body . va lue ; 53 requestObj . d e s c r i p t i o n = req . body . d e s c r i p t i o n ; 54 requestObj . createdAt = req . body . createdAt ; 55 56 Request . c reateRequest ( requestObj ) ; 57 58 }) ; 59 60 //Ruta que maneja ’ f i n a l i z e d ’ , que almacena una f i n a l i z a c i o n de una s o l i c i t u d 61 r ou te r . post ( ’ / f i n a l i z e d ’ , f unc t i on ( req , r e s ) { 62 63 l e t f i n a l i z e dOb j = {} ; 64 f i n a l i z e dOb j . campaign = req . body . campaign ; 65 f i n a l i z e dOb j . campaignManager = req . body . campaignManager ; 66 f i n a l i z e dOb j . id = req . body . id ; 67 68 F ina l i z ed . c r e a t eF i n a l i z e d ( f i n a l i z e dOb j ) ; 69 70 }) ; 71 72 //Ruta que maneja ’ approved ’ , que almacena una aprobacion de una s o l i c i t u d 73 r ou te r . post ( ’ /approved ’ , f unc t i on ( req , r e s ) { 74 75 l e t approvedObj = {} ; 76 approvedObj . campaign = req . body . campaign ; 77 approvedObj . approverAddress = req . body . approverAddress ; 78 approvedObj . id = req . body . id ; 79 80 Approved . createApproved ( approvedObj ) ; 81 82 }) ; 83 84 //Ruta que maneja ’ r e j e c t e d ’ , que almacena un rechazo de una s o l i c i t u d 85 r ou te r . post ( ’ / r e j e c t e d ’ , f unc t i on ( req , r e s ) { 86 87 l e t r e j e c t edObj = {} ; 88 89 r e j e c t edObj . campaign = req . body . campaign ; 90 r e j e c t edObj . approverAddress = req . body . approverAddress ; 91 r e j e c t edObj . id = req . body . id ; 92 93 Rejected . c r ea t eRe j e c t ed ( r e j e c t edObj ) ; 94 95 }) ; 96 6.4 Transición(Transition) 147 97 module . export s = route r ; Algoritmo 6.32: Módulo encargado de manejar las solicitudes que provengan del lado del cliente y almacenar en la base de datos utilizando los modelos definidos (server/main.controller.js) Una vez implementadas todas las interacciones con la base de datos, se da por terminada la fase de Construcción, ya que fueron resueltas todas las problemáticas planteadas en el caso de uso y se da cabida a la última fase de la metodoloǵıa en la cual se realizan pruebas de interfaz en ambiente de producción. 6.4. Transición(Transition) Esta última fase de la metodoloǵıa propone realizar la validación de la solución construida en la fase de construcción. A lo largo de esta fase, se mostrarán las interfaces construidas con el fin de mostrar su usabilidad y validar la propuesta que se mostrará a los usuarios finales (Gerentes y posibles contribuyentes). 6.4.1. Iteración 0: Pruebas de interfaz de usuario La presente iteración muestra las interfaces de usuario implementadas con el fin de mostrar la usabilidad y funcionalidades, además de describir el comportamiento de la aplicación en un ambiente de producción. Para iniciar la aplicación web, se ejecuta el comando ’npm run dev’ desde la consola, si- tuándose en el directorio de la herramienta. En vista de comprobar el correcto funcionamiento de las interfaces, se hizo un sondeo a 15 personas con un perfil de usuario final para que pudieran evaluar las interfaces creadas con el fin de comprobar la correcta transmisión de la información. Se muestra una tabla compartida con los usuarios que interactuaron con la aplicación para que pudieran evaluar las interfaces con una calificación del 1 al 5, donde la puntuación representa: 1. Muy mal. 2. Mal 3. Regular. 4. Bien. 5. Excelente. En la siguiente tabla puede observarse la descripción del tipo de prueba a realizar: 148 6 Caṕıtulo 6 - Marco aplicativo Tipo de prueba Aceptación Ejecutantes Usuarios finales potenciales Herramienta usada Preguntas evaluativas Veces ejecutada 15 por interfaz seleccionada Resultados Esperados 90% de resultados mayores a la media evaluativa (Mayores a 2.5) Tabla 6-8: Especificaciones de la prueba de aceptacón para interfaces gráficas. Pregunta Puntuación ¿Considera que la interfaz es agradable a la vista? ¿La información se entiende correctamente? ¿Comprende el objetivo de la interfaz? ¿La funcionalidad de los botones queda clara? ¿Se siente ubicado en la pantalla actual de la interfaz? Tabla 6-9: Tabla para evaluación de interfaces gráficas. 6.4 Transición(Transition) 149 Al momento de evaluar una interfaz, se muestran las preguntas realizadas a los usuarios, luego se encuentra el promedio de las respuestas recibidas por los mismos. A continuación se muestra la pantalla principal de la herramienta: Figura 6-15: Pantalla principal del cliente web. 150 6 Caṕıtulo 6 - Marco aplicativo Pregunta Puntuación ¿Considera que la interfaz es agradable a la vista? 4.9 ¿La información se entiende correctamente? 4.5 ¿Comprende el objetivo de la interfaz? 5 ¿La funcionalidad de los botones queda clara? 5 ¿Se siente ubicado en la pantalla actual de la interfaz? 4.8 Tabla 6-10: Tabla para evaluación de la pantalla principal del cliente web. 6.4 Transición(Transition) 151 6.4.1.1. Crear campaña La creación de campañas se muestra como un formulario que llena el gerente de la campaña, finalmente se presenta el botón para crear la campaña, una vez creada se mostrará en la pantalla principal de la aplicación: Figura 6-16: Pantalla para la creación de una campaña. 152 6 Caṕıtulo 6 - Marco aplicativo Pregunta Puntuación ¿Considera que la interfaz es agradable a la vista? 5 ¿La información se entiende correctamente? 4.1 ¿Comprende el objetivo de la interfaz? 5 ¿La funcionalidad de los botones queda clara? 5 ¿Se siente ubicado en la pantalla actual de la interfaz? 5 Tabla 6-11: Tabla para evaluación de la pantalla creación de una campaña. 6.4 Transición(Transition) 153 6.4.1.2. Visualizar una campaña / Contribuir a una campaña Las funcionalidades de visualizar una campaña y contribuir a una campaña vienen una misma vista, debido a que un posible contribuyente querrá tener a su alcance todos los detalles de la campaña a la que contribuirá: Figura 6-17: Botón de contribución para una campaña. 154 6 Caṕıtulo 6 - Marco aplicativo Pregunta Puntuación ¿Considera que la interfaz es agradable a la vista? 5 ¿La información se entiende correctamente? 4.1 ¿Comprende el objetivo de la interfaz? 4.2 ¿La funcionalidad de los botones queda clara? 4.9 ¿Se siente ubicado en la pantalla actual de la interfaz? 4.0 Tabla 6-12: Tabla para evaluación de botón de contribución para una campaña 6.4 Transición(Transition) 155 Figura 6-18: Detalles de una campaña. 156 6 Caṕıtulo 6 - Marco aplicativo Pregunta Puntuación ¿Considera que la interfaz es agradable a la vista? 5 ¿La información se entiende correctamente? 4.9 ¿Comprende el objetivo de la interfaz? 4.5 ¿La funcionalidad de los botones queda clara? 4.7 ¿Se siente ubicado en la pantalla actual de la interfaz? 4.6 Tabla 6-13: Tabla para evaluación de detalles de una campaña. 6.4 Transición(Transition) 157 6.4.1.3. Crear una solicitud La vista de creación de solicitudes es muy similar a la de creación de campañas un formulario simple, con un botón de creación de solicitud: Figura 6-19: Creación de una solicitud. 158 6 Caṕıtulo 6 - Marco aplicativo Pregunta Puntuación ¿Considera que la interfaz es agradable a la vista? 5 ¿La información se entiende correctamente? 4.8 ¿Comprende el objetivo de la interfaz? 4.9 ¿La funcionalidad de los botones queda clara? 5 ¿Se siente ubicado en la pantalla actual de la interfaz? 4.2 Tabla 6-14: Tabla para evaluación de creación de una solicitud. 6.4 Transición(Transition) 159 6.4.1.4. Aprobar/Rechazar/Finalizar solicitudes Las solicitudes son mostradas mediante una tabla, las tablas tendrán diferentes colores de- pendiendo del estado de la solicitud: Verde: Solicitud lista para ser aprobada. Naranja: Solicitud lista para ser expirada. Rojo: Solicitud expirada. Gris: Solicitud completada. 160 6 Caṕıtulo 6 - Marco aplicativo Figura 6-20: Lista de solicitudes, una lista para aprobar, una lista para ser rechazada, dos en vigencia. 6.4 Transición(Transition) 161 Pregunta Puntuación ¿Considera que la interfaz es agradable a la vista? 4.9 ¿La información se entiende correctamente? 4.2 ¿Comprende el objetivo de la interfaz? 5 ¿La funcionalidad de los botones queda clara? 5 ¿Se siente ubicado en la pantalla actual de la interfaz? 4.7 Tabla 6-15: Tabla para evaluación de lista de solicitudes. 162 6 Caṕıtulo 6 - Marco aplicativo Figura 6-21: Lista de solicitudes, una expirada, una finalizada. En vista de que las pruebas arrojaron valores por encima de los valores definidos en el tipo de prueba se asume que la construcción de las interfaces se realizó de una manera coherente y la información es transmitida de una manera eficaz. 6.4.1.5. Validación y mensajes de error A continuación se listan los mensajes de error y validación en caso de que algún usuario cometa un error al momento de ingresar datos en la aplicación web: Figura 6-22: Error al dejar campos vaćıos en la creación de una campaña. 6.4 Transición(Transition) 163 El mismo mensaje de error es desplegado al querer ingresar datos incorrectos al momento de ingresar una contribución y al querer ingresar datos inválidos en la creación de una solicitud. Figura 6-23: Error al insertar caracteres al monto de contribución. 7 Caṕıtulo 7 - Conclusiones El presente TEG muestra las bondades que brindan estos nuevos enfoques para resolver problemáticas complejas que cada vez requieren más confianza y transparencia a la hora de manejar bienes valiosos como criptomonedas y cualquier tipo de propiedad que represente un valor para el que la posea. Si bien la solución planteada no es infalible, es un paso más cerca a eliminar las malversa- ciones de bienes y corrupción en sistemas abiertos que ayudan a financiar ideas. Se logró crear una solución que, apoyada en la criptograf́ıa, las cadenas de bloques y los contratos inteligentes, puede brindar confianza a sus usuarios, y además fomenta la partici- pación colectiva y reincidente de los mismos. Este tipo de soluciones, son sólo el inicio de una tecnoloǵıa muy jóven que cada d́ıa se refina un poco más y promete revolucionar como se manejan la propiedad del individuo y la confianza que este le tiene a los sistemas distribuidos. 7.0.1. Seleccionar Caso de Uso Se logró seleccionar un caso de uso que ilustraba de una manera evidente una problemática a resolver, y además, muestra como la criptograf́ıa, apoyada en la cadena de bloques y los contratos inteligentes, puede ser una solución eficiente a dichas problemáticas con la finalidad de generar confianza y transparencia a la hora de traspasar fondos. 7.0.2. Seleccionar una metodoloǵıa de desarrollo Se planteó una metodoloǵıa que logró adaptarse y ser eficiente en los enfoques ágiles actuales sin dejar de lado prácticas tradicionales. Finalmente la metodoloǵıa resultó un pilar funda- mental a la hora de definir las etapas en las que se constrúıa la herramienta y la forma en que fueron ejecutadas. 7.0.3. Preparar el ambiente de desarrollo de la plataforma Ethereum Se hizo uso de las bibliotecas Web3, Ganache, SolC y NodeJS como piezas fundamentales a la hora de preparar ambientes de desarrollo para el uso de contratos inteligentes, ya sea de 165 manera local o en ambientes de producción. Estas herramientas permitieron la interacción con la red y los contratos inteligentes que en ella residen de una manera rápida y sencilla, se puede concluir que la preparación del ambiente para la herramienta desarrollada fue exitoso gracias al uso de estas herramientas. 7.0.4. Recopilación de datos La recopilación de las interacciones del usuario con el contrato fueron almacenadas de manera exitosa en la herramienta propuesta, MongoDB probó ser una herramienta versátil para realizar este tipo de tareas. Su similaridad con el uso de objetos de JavaScript hizo que su implementación se lograra de manera sencilla y eficiente. 7.0.5. Definir almacén de datos El alcance de la investigación no pudo cubrir una definición que pueda considerarse eficiente del punto de vista de un analista de datos. Se logró recopilar ciertos datos de importancia, pero no se pudo asegurar que la forma en que fueron almacenados fue la más eficiente o que fue utilizada la herramienta que mejor se ajuste a este tipo de análisis futuros. El uso, transformación y carga de los datos en plataformas eficientes para el procesamiento de grandes volúmenes de datos se releva a futuras investigaciones. 7.0.6. Implementar la aplicación sobre la base tecnológica de cadena de bloques y contratos inteligentes La combinación de las tecnoloǵıas utilizadas, junto con la metodoloǵıa seleccionada dieron pie a varias iteraciones que permitieron implementar en fases concretas una solución al caso de uso planteado, la solución permite una interacción directa tanto como con la red Ethereum como con los contratos inteligentes que viven en la misma. 7.0.7. Pruebas de funcionamiento Se realizaron pruebas de tipo funcional las cuales validaron el correcto funcionamiento de la aplicación en cada una de las versiones, se realizó una prueba por cada versión desplegada y las mismas ayudaron a detectar errores en cada una de las diferentes iteraciones. Adicionalmente se realizaron pruebas de aceptación las cuales fueron realizadas por potencia- les usuarios finales con la finalidad de validar la correcta transferencia de información desde la aplicación a los usuarios finales, los resultados de estas pruebas de validación arrojaron en su totalidad resultados positivos lo cual reafirmó su correcto funcionamiento. 166 7 Caṕıtulo 7 - Conclusiones 7.0.8. Pruesta en marcha Finalmente, la puesta en marcha en un ambiente de producción se logró exitosamente me- diante el uso de un nodo Infura el cual permitió que la herramienta previamente desarrollada y probada pudiera ser desplegada para que los usuarios finales pudieran interactuar con la herramienta. 7.1. Contribuciones Se sentaron las bases para el desarrollo de aplicaciones que se basen en tecnoloǵıas asociadas a las cadenas de bloques y los contratos inteligentes, el presente TEG puede sirve de gúıa para atacar diferentes casos de uso asociados a los enfoques seleccionados. Dada la arquitectura planteada, se desarrollaron varios módulos de importancia los cuales sirven de utilidad para trabajos futuros que puedan tomar los datos genera- dos por el presente TEG para aplicar diferentes técnicas de analÃtica predictiva e inteligencia artificial. 7.2. Recomendaciones Para hacer pruebas con este tipo de tecnoloǵıas, la mejor opción es utilizar la herramienta Remix, de esta manera, se pueden realizar pruebas de traspasos de fondos sin tener que involucrar valor real de ether dentro de las pruebas. Sin embargo, en caso de querer realizar pruebas en ambientes de producción, se recomienda realizar pruebas de despliegue en las redes de prueba de Ethereum (Rinkeby, Ropsten y Kovan), existen en la red varios sitios que ofrecen Ether gratis en estas redes de prueba con el fin de ayudar a los desarrolladores a probar sus aplicaciones distribuidas. 7.3. Trabajos futuros Como se contempló en la arquitectura propuesta para este TEG, los datos y la recopilación de los mismos mediante esta herramienta quedan abiertos y estructurados de manera que sea más sencillo para los expertos en el área de mineŕıa de datos o tecnoloǵıas afines tomar esos datos y aplicar algoritmos de inteligencia artificial sobre ellos y detectar patrones de comportamiento u otros patrones útiles para el estudio de estas herramientas. Bibliograf́ıa [1] Account Types, Gas, and Transactions. http://ethdocs.org/en/latest/ contracts-and-transactions/account-types-gas-and-transactions.html [2] Agile. http://www.ambysoft.com/unifiedprocess/agileUP.html [3] Base de datos no relacionales. http://nosql-database.org/. [4] Cassandra. http://cassandra.apache.org/doc/latest/ [5] CouchDB. http://docs.couchdb.org/en/2.1.1/ [6] Document Object Model (DOM). https://www.w3.org/DOM/#what [7] Dynamo. https://aws.amazon.com/es/documentation/dynamodb/ [8] Ethereum Virtual Machine. http://ethdocs.org/en/latest/introduction/ what-is-ethereum.html [9] Ganache. https://github.com/trufflesuite/ganache-core [10] HBase. https://hbase.apache.org/book.html [11] InfiniteGraph. http://www.objectivity.com/products/infinitegraph/ [12] Infura. https://infura.io/ [13] Javascript. https://developer.mozilla.org/es/docs/Web/JavaScript [14] Lenguajes de programacón. http://www.lenguajes-de-programacion.com/ lenguajes-de-programacion.shtml. [15] MetaMask. https://github.com/MetaMask/metamask-extension [16] Mocha. https://mochajs.org/ [17] MongoDB. https://www.mongodb.com/what-is-mongodb [18] Neo4j. https://neo4j.com/docs/developer-manual/current/ [19] Next. https://github.com/zeit/next.js/ 168 Bibliograf́ıa [20] React. https://reactjs.org/ [21] Redis. https://redis.io/documentation [22] Remix. https://remix.readthedocs.io/en/latest/ [23] RUP. http://www.usmp.edu.pe/publicaciones/boletin/fia/info49/articulos/ RUP%20vs.%20XP.pdf [24] Semantic. https://react.semantic-ui.com/ [25] Smart Contracts: 12 Use Cases for Business and Beyond. https://gallery. mailchimp.com/a87f67248663abe55ad9325d6/files/Smart_Contracts_12_Use_ Cases_for_Business_Beyond.pdf [26] SolC. https://github.com/ethereum/solc-js [27] Solidity. https://solidity.readthedocs.io/en/latest/index.html# [28] The General Theory of Decentralized Applications, Dapps. https://github.com/ DavidJohnstonCEO/DecentralizedApplications [29] Web3. https://github.com/ethereum/web3.js/ [30] What is Ether? https://www.ethereum.org/ether [31] Back, Adam: Hashcash - A Denial of Service Counter-Measure, August 1, 2002 [32] Buterin, Vitalik: A Next-Generation Smart Contract and Decentralized Application Platform, 2015 [33] Chohan, Usman W.: Cryptocurrencies: A Brief Thematic Review, August 4, 2017 [34] Christopher D. Clack, Lee B.: Smart Contract Templates: foundations, design landscape and research directions, August 4, 2016 [35] Gupta, Manav: Blockchain for Dummies, 2017 [36] Josh Benaloh, Michael de M.: One-way accumulators: a descentralized alternative to digital signatures, 1993 [37] L, Molina: Data mining: torturando los datos., 2016 [38] Li Deng, Dong Y.: Deep Learning Methods and Applications, 2014 [39] Muhammad Saqib Niaz, Gunter S.: Merkle Hash Tree based Techniques for Data Integrity of Outsourced Data, 2015 Bibliograf́ıa 169 [40] Nakamoto, Satoshi: Bitcoin: A Peer-to-Peer Electronic Cash System, 2008 [41] Nyce, Charles: Predictive Analytics White Paper, 2007 [42] Saarenvirta, Gary: Machine Learning in Retail, 2010 [43] Steinmetz, Wehrle K.: What Is This Peer-to-Peer About? [44] Stuart Haber, Scott S.: How to Write Time-Stamp a Digita Document