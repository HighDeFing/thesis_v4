Microsoft Word - Tesis_V10.docx UNIVERSIDAD CENTRAL DE VENEZUELA FACULTAD DE CIENCIAS ESCUELA DE COMPUTACIÓN Creación de un Plugin para NetBeans que Agilice el Desarrollo de Aplicaciones Web Utilizando el Framework Dinámica Trabajo Especial de Grado presentado ante la Ilustre Universidad Central de Venezuela por los bachilleres Carrasquero Borges, Eduardo Andrés C.I. 15.540.870 y Marfil González, Daniela Carolina C.I. 13.485.427 Para optar al título de Licenciado en Computación Tutores: Prof. Rhadamés Carmona Lic. Armando Vieira Caracas, 14 / 02 / 2011 2 ACTA Quienes suscriben, miembros del Jurado designado por el Consejo de Escuela de Computación, para examinar el Trabajo Especial de Grado presentado por los Bachilleres Eduardo Andrés Carrasquero Borges CI. 15.540.870 y Daniela Carolina Marfil González CI. 13.485.427, con el título Creación de un plugin para NetBeans que agilice el desarrollo de aplicaciones web utilizando el framework Dinámica a los fines de optar al título de Licenciado en Computación, dejan constancia de lo siguiente: Leído como fue, dicho trabajo por cada uno de los miembros del jurado, se fijó el día 17 de febrero de 2011 a las 9:00a.m., para que sus autores lo defendieran en forma pública, lo que se hizo en el salón PB III de la Escuela de Computación de la Facultad de Ciencias de la Universidad Central de Venezuela, mediante una presentación oral de su contenido, luego de lo cual respondieron las preguntas formuladas. Finalizada la defensa pública del Trabajo Especial de Grado, el jurado decidió aprobarlo. En fe de lo cual se levanta la presente Acta, en Caracas a los diecisiete días del mes de febrero del año 2011. ________________________ ________________________ Prof. Rhadamés Carmona Lic. Armando Vieira Tutor Tutor ________________________ ________________________ Prof. Eugenio Scalise Prof. Carlos Acosta Jurado Jurado 3 AGRADECIMIENTOS Y DEDICATORIA Quiero dedicarles este T.E.G. a mis padres Heriberto y Coromoto por apoyarme siempre, por sus consejos y por enseñarme la constancia y la perseverancia que hoy en día dieron sus frutos. Agradezco a mi compañera Daniela por apoyarme en la realización de este trabajo y gracias a todos los que de alguna u otra forma me ayudaron a lo largo de mi carrera. Eduardo A. Carrasquero B. Le doy GRACIAS a mis padres, por permitirme ser una estudiante Perpetua. A todos los que de alguna forma me acompañaron y a los que me ayudaron. A mis Herrrrmososss sobrinos por alejarme de la computadora cuando hacía falta. A los que ponían cara de susto con mis preguntas y huían, a los que se quedaban y dudaban conmigo, a los que me respondían, a los que simplemente me acompañaban. A los que me dieron dolores de cabeza y a los que me los quitaron. A los profesores que me inspiraron y a los que trataron de ahuyentarme. A los tutores, por la enseñanza dejada. También a Eduardo por ayudar a hacerlo posible. Simplemente… GRACIAS =) Se lo Dedico a mi yo virtual que cada día se acerca más a mi yo real. A los incrédulos, a los impacientes y sobre todo, a los pacientes que supieron esperar. Dedicada también a aquellos que inocentemente se inician en la carrera, como una muestra de que sí se puede. Desearlo es el primer paso… El camino es largo y bastante empinado a veces, pero cuando llegas… es Lo Máximo! ;) (Aunque solo sea un simple peldaño). Se la dedico a todo el que se plantee una meta y tenga la fuerza y la constancia necesaria para alcanzarla. Daniela C. Marfil G. 4 RESUMEN Título: Creación de un plugin para NetBeans que agilice el desarrollo de aplicaciones web utilizando el framework Dinámica. Autores: Eduardo A. Carrasquero B. Daniela C. Marfil G. Tutores: Prof. Rhadamés Carmona Lic. Armando Vieira El presente Trabajo Especial de Grado (T.E.G) 1 comprende la creación de una herramienta para agilizar el desarrollo de aplicaciones Web usando como base el framework Dinámica. Este framework venezolano posee un repositorio de plantillas que constituyen soluciones pre-construidas para resolver problemas comunes presentes en el desarrollo de aplicaciones web. El objetivo principal de este T.E.G es minimizar la carga de trabajo de los programadores al automatizar las tareas que comprenden el proceso de reutilización que trae consigo el uso del framework Dinámica, aumentando así la productividad. La herramienta desarrollada consiste en un plugin para NetBeans IDE formado por diversos módulos para cubrir cada una de las funcionalidades. Desde la creación y configuración de un proyecto base hasta la creación y configuración de las plantillas más importantes, así como una plantilla general y un módulo para el manejo de la seguridad. 1 A lo largo del documento se hará referencia al Trabajo Especial de Grado utilizando las siglas T.E.G. 5 Para el desarrollo del plugin se utilizaron diversas tecnologías como son el framework Dinámica, que es la base de la propuesta, NetBeans IDE 6.9 que constituye el entorno integrado de desarrollo (IDE 1 por sus siglas en inglés -Integrated Development Environment-) para el cual se creó la herramienta, Java como lenguaje de programación y Apache Tomcat versión 6.0.26 como contenedor Web. Se cumplió con los objetivos planteados y se evaluaron los resultados, determinando que la herramienta desarrollada constituye un gran aporte en el incremento de la productividad de los programadores, usuarios del framework Dinámica. Palabras Clave: Aplicaciones Web, framework, framework Dinámica, programación extrema, plugin, NetBeans. 1 A lo largo del documento se hará referencia al término Entorno Integrado de Desarrollo utilizando las siglas IDE. Consultar término en el glosario. 6 TABLA DE CONTENIDOS ACTA ................................................................................................................................. 2 AGRADECIMIENTOS Y DEDICATORIA .................................................................. 3 RESUMEN ........................................................................................................................ 4 TABLA DE CONTENIDOS ............................................................................................ 6 ÍNDICE DE FIGURAS .................................................................................................. 11 CAPÍTULO I: Propuesta ................................................................................................ 20 1.1 Planteamiento del problema.............................................................................. 20 1.2 Solución propuesta ............................................................................................ 21 1.3 Objetivo general ................................................................................................ 23 1.4 Objetivos específicos......................................................................................... 23 1.5 Límites y Alcances ............................................................................................ 24 CAPÍTULO II: Marco Conceptual................................................................................. 25 2.1 Programación Extrema (XP) ............................................................................. 25 2.1.1 Definición..................................................................................................... 26 2.1.2 Valores ......................................................................................................... 29 2.1.2.1 Comunicación: ..................................................................................................... 29 2.1.2.2 Simplicidad .......................................................................................................... 29 2.1.2.3 Feedback o retroalimentación ............................................................................. 29 2.1.2.4 Coraje ................................................................................................................... 30 2.1.2.5 Respeto ................................................................................................................. 30 2.1.3 Principios ..................................................................................................... 31 2.1.3.1 Retroalimentación veloz...................................................................................... 31 7 2.1.3.2 Asunción de simplicidad ..................................................................................... 31 2.1.3.3 Modificaciones incrementales ............................................................................ 31 2.1.3.4 Adopción del cambio........................................................................................... 31 2.1.3.5 Trabajo de calidad: .............................................................................................. 31 2.1.4 Actividades .................................................................................................. 32 2.1.4.1 Codificar ............................................................................................................... 32 2.1.4.2 Realizar Pruebas .................................................................................................. 32 2.1.4.3 Escuchar ............................................................................................................... 32 2.1.4.4 Diseñar ................................................................................................................. 32 2.1.5 Prácticas ....................................................................................................... 33 2.1.5.1 Proceso de planificación ..................................................................................... 33 2.1.5.2 Versiones pequeñas ............................................................................................. 34 2.1.5.3 Metáforas.............................................................................................................. 34 2.1.5.4 Diseño simple ...................................................................................................... 34 2.1.5.5 Pruebas ................................................................................................................. 35 2.1.5.6 Refactorización (Refactoring)............................................................................. 35 2.1.5.7 Programación en parejas ..................................................................................... 35 2.1.5.8 Propiedad colectiva del código ........................................................................... 35 2.1.5.9 Integración continua ............................................................................................ 35 2.1.5.10 Cuarenta horas semanales ................................................................................. 36 2.1.5.11 Cliente en el sitio ............................................................................................... 36 2.1.5.12 Estándares de codificación ................................................................................ 36 2.1.6 Ciclo de Vida ............................................................................................... 36 2.1.6.1 Exploración .......................................................................................................... 38 2.1.6.2 Planificación ........................................................................................................ 38 2.1.6.3 Iteraciones ............................................................................................................ 39 2.1.6.4 Producción ........................................................................................................... 39 2.1.6.5 Mantenimiento ..................................................................................................... 40 2.1.6.6 Muerte .................................................................................................................. 40 2.1.7 Instrumentos ................................................................................................. 41 8 2.1.7.1 Historias de usuario ............................................................................................. 41 2.1.7.2 Tarjeta de interfaz ................................................................................................ 45 2.1.7.3 Tareas de ingeniería ............................................................................................. 45 2.1.7.4 Tarjetas Clase, Responsabilidad y Colaboración (CRC) .................................. 47 2.2 Framework Dinámica ........................................................................................ 48 2.2.1 Características .............................................................................................. 49 2.2.2 Arquitectura del Framework ....................................................................... 50 2.2.3 Elementos de una Aplicación ..................................................................... 51 2.2.4 Estructura del Directorio ............................................................................. 53 2.2.5 El Modelo MVC de Dinámica .................................................................... 55 2.2.6 El mecanismo de procesamiento de solicitudes HTTP ............................. 57 2.2.7 Diagrama de Clases ..................................................................................... 59 2.2.8 Puntos de extensión frecuentes ................................................................... 62 2.2.9 Desarrollo de Aplicaciones ......................................................................... 63 2.2.10 Ventajas ........................................................................................................ 71 2.2.11 Plugin Dinámica para Eclipse ..................................................................... 73 2.2.11.1 Descripción ................................................................................................... 73 2.2.11.2 Funcionalidad ............................................................................................... 74 2.3 NetBeans IDE .................................................................................................... 77 2.3.1 Descripción .................................................................................................. 77 2.3.2 Funcionalidades ........................................................................................... 78 2.3.3 Ventajas ........................................................................................................ 79 2.3.4 Desarrollo de Plugins con NetBeans .......................................................... 82 2.3.5 Wizards ........................................................................................................ 86 2.3.5.1 Estructura y funcionamiento del wizard ..................................................... 88 CAPÍTULO III: Marco Aplicativo................................................................................. 91 9 3.1 Tecnología utilizada .......................................................................................... 91 3.1.2 Java ................................................................................................................. 92 3.1.3 Dinámica ........................................................................................................ 92 3.1.4 Otros aspectos ................................................................................................ 92 3.2 Adaptación de la Metodología XP ................................................................... 92 3.2.1 Descripción general ..................................................................................... 93 3.2.1.1 Equipo de desarrollo (Cliente en el sitio) ........................................................... 93 3.2.1.2 Proceso de planificación/Comunicación ............................................................ 93 3.2.1.3 Metáforas.............................................................................................................. 93 3.2.1.4 Pruebas/Feedback ................................................................................................ 93 3.2.1.5 Refactorización / modificaciones incrementales /coraje ................................... 94 3.2.1.6 Versiones pequeñas/código simple..................................................................... 94 3.2.1.7 Programación en parejas/propiedad colectiva ................................................... 94 3.2.1.8 Estándares de codificación .................................................................................. 95 3.2.1.9 Trabajo de calidad ............................................................................................... 95 3.2.1.10 Cuarenta horas semanales ................................................................................. 95 3.2.2 Ciclo de vida ................................................................................................ 95 3.2.2.1 Fase de exploración ...................................................................................... 96 3.2.2.2 Fase de planificación .................................................................................... 97 3.2.2.3 Fase de iteración ......................................................................................... 100 3.2.2.4 Fase de Análisis. ......................................................................................... 101 3.2.2.5 Fase de Diseño. ........................................................................................... 102 3.2.2.6 Fase de Codificación. ................................................................................. 107 3.2.2.7 Fase de producción ..................................................................................... 112 3.2.2.8 Fase de mantenimiento ............................................................................... 112 3.2.2.9 Fase de muerte ............................................................................................ 113 3.3 Proceso de desarrollo ...................................................................................... 113 3.3.1 Iteración 1. Metáfora del sistema (Crear plugin Dinámica) ................... 113 3.3.2 Iteración 2. Crear proyecto base ............................................................... 117 10 3.3.3 Iteración 3. Crear proyecto Security......................................................... 126 3.3.4 Iteración 4. Crear action personalizado .................................................... 129 3.3.5 Iteración 5. Crear plugin Calendario ........................................................ 139 3.3.6 Iteración 6. Crear plugin CRUD ............................................................... 144 3.3.7 Iteración 7. Crear librerías ........................................................................ 149 3.3.8 Iteración 8. Crear plugin PagedView ....................................................... 151 3.3.9 Iteración 9. Crear plugin PickList ............................................................ 156 3.3.10 Iteración 10. Crear plugin ImportExcel ................................................... 162 3.3.11 Iteración 11. Crear plugin ExportPDF ..................................................... 166 3.3.12 Iteración 12. Crear plugin ExportExcel ................................................... 171 3.3.13 Iteración 13. Crear plugin Filter ............................................................... 174 3.3.14 Iteración 14. Crear plugin Chart ............................................................... 180 3.3.15 Iteración 15. Crear plugin Agenda ........................................................... 185 3.3.16 Iteración 16. Crear plugin CRUDMasterDetail ....................................... 188 3.3.17 Iteración 17. Crear plugin CRUDSimple ................................................. 194 3.3.18 Iteración 18. Crear plugin ejecutable ....................................................... 197 3.4 Desarrollo de aplicaciones utilizando el plugin de Dinámica para NetBeans . 198 CAPÍTULO IV: Conclusiones y Recomendaciones ................................................... 202 GLOSARIO ................................................................................................................... 206 REFERENCIAS ............................................................................................................ 212 11 ÍNDICE DE FIGURAS Figura 1: Valores, principios, prácticas y actividades en XP ....................................... 28 Figura 2: Interacción entre valores, principios, prácticas y actividades en XP ........... 28 Figura 3: Prácticas en XP .............................................................................................. 33 Figura 4: Interacciones durante el ciclo de Vida XP ................................................... 37 Figura 5: Fases del Ciclo XP ......................................................................................... 40 Figura 6: Muestra de story card manual ........................................................................ 44 Figura 7: Muestra de story card electrónica .................................................................. 44 Figura 8: Muestra de task card manual ......................................................................... 46 Figura 9: Muestra de task card electrónica. .................................................................. 47 Figura 10: Muestra de tarjeta CRC. ............................................................................... 48 Figura 11: Modelo estado - acción. ................................................................................ 51 Figura 12: Directorio Dinámica. .................................................................................... 53 Figura 13: Arquitectura MVC. ....................................................................................... 56 Figura 14: Modelo MVC de Dinámica. ......................................................................... 56 Figura 15: Procesamiento de solicitudes HTTP en Dinámica. ..................................... 57 Figura 16: Diagrama de Clases - Clases básicas ........................................................... 59 Figura 17: Diagrama de Clases - Clases tipo OutPut .................................................... 60 Figura 18: Diagrama de Clases - Clases tipo Transaction ............................................ 61 Figura 19: Plantilla ViewChart - estructura del directorio ........................................... 65 Figura 20: Plantilla ViewChart - detalle estructura del directorio ............................... 66 Figura 21: Plantilla ViewChart - action form (1). ......................................................... 67 Figura 22: Plantilla ViewChart - action form ejemplo (parte 1) .................................. 68 Figura 23: Plantilla ViewChart - action form ejemplo (parte 2) .................................. 69 12 Figura 24: Plantilla ViewChart - Diagrama de actions................................................. 70 Figura 25: Plantilla ViewChart - Diagrama de clases ................................................... 71 Figura 26: Plugin Dinámica para eclipse (muestra) ...................................................... 76 Figura 27: Entorno NetBeans (muestra) ........................................................................ 79 Figura 28: Estructura de un módulo NetBeans ............................................................. 86 Figura 29: Interfaz estándar de NetBeans (Ejemplo de wizard) .................................. 87 Figura 30: Arquitectura de un wizard ............................................................................ 89 Figura 31: Diagrama de secuencia. Interacción entre WizardDescriptor, WizardPanel y VisualPanel................................................................................................................... 90 Figura 32: Diagrama Gantt Tiempo Real vs. Tiempo Estimado ................................ 100 Figura 33: Ejemplo archivo layer.xml ......................................................................... 103 Figura 34: Ejemplo archivo Bundle.properties ........................................................... 104 Figura 35: Elementos estándares definidos en iteraciones ......................................... 105 Figura 36: Menú principal ............................................................................................ 106 Figura 37: Menú contextual .......................................................................................... 106 Figura 38: Ejemplo clase VisualPanel (módulo CRUD) ............................................ 107 Figura 39: Ejemplo clase VisualPanel (módulo CRUD) ............................................ 108 Figura 40: Ejemplo clase WizardAction (módulo Calendario) .................................. 109 Figura 41: Funciones para la creación, copiado y configuración de archivos........... 110 Figura 42: Extracto del código método de validación (módulo Base). ..................... 111 Figura 43: Story card iteración principal. Creación del sistema ................................ 113 Figura 44: Arquitectura de la solución (primer planteamiento de la fase de planificación) ................................................................................................................. 114 Figura 45: La historia principal se divide en historias de menor complejidad .......... 114 13 Figura 46: Arquitectura de la solución (segundo planteamiento de la fase de planificación) ................................................................................................................. 115 Figura 47: Arquitectura de la solución desarrollada ................................................... 116 Figura 48: Story card usada para la Iteración 2. Proyecto base ................................. 117 Figura 49: Directorio módulo base .............................................................................. 121 Figura 50: Wizard general para la creación de proyectos en NetBeans (Paso 1 Creación de proyecto Base Dinámica) ......................................................................... 123 Figura 51: Wizard correspondiente a la creación del proyecto Base Dinámica (Paso 2) ........................................................................................................................................ 124 Figura 52: Código clase BasePanelVisual ................................................................... 125 Figura 53: Story card usada para la Iteración 3. Administrador de seguridad (Security) ....................................................................................................................... 126 Figura 54: Extracto de código función para la creación de queries asociados al Security .......................................................................................................................... 128 Figura 55: Story card usada para la Iteración 4. Action personalizado ..................... 129 Figura 56: Wizard action personalizado. Paso 1 Datos Básicos ................................ 132 Figura 57: Wizard action personalizado. Paso 2 Transaction .................................... 133 Figura 58: Wizard action personalizado. Paso 3 Output ............................................ 134 Figura 59: Wizard action personalizado. Paso 4 Validator ........................................ 135 Figura 60: Wizard action personalizado. Paso 5 Query/ on-exits .............................. 136 Figura 61: Extracto de código clase CreateConfig ..................................................... 138 Figura 62: Story card iteración 5 ................................................................................. 139 Figura 63: Wizard plugin Calendario ........................................................................... 142 Figura 64: Extracto de código función para consulta de BD...................................... 143 Figura 65: Story card usada para la Iteración 6. Plugin CRUD ................................. 144 14 Figura 66: Función BuscarColumnas() (Consulta la BD y llena las listas del Wizard) ........................................................................................................................................ 148 Figura 67: Task card Creación de Librerías ................................................................ 149 Figura 68: Algunas funciones incluidas en las librerías creadas en la iteración 7 .... 150 Figura 69: Story card usada para la Iteración 8. PagedView ..................................... 151 Figura 70: Wizard plugin PagedView.......................................................................... 154 Figura 71: Código función BuscarColumnas() ........................................................... 155 Figura 72: Story card usada para la Iteración 9. PickList ........................................... 156 Figura 73: Wizard plugin PickList (Paso 1)................................................................. 159 Figura 74: Wizard plugin PickList (Paso 2)................................................................. 160 Figura 75: Código función llenar_textos() .................................................................. 161 Figura 76: Story card usada para la Iteración 10. ImportExcel ................................. 162 Figura 77: Wizard plugin ImportExcel ........................................................................ 165 Figura 78: Código función creación de archivo (modelo) ImportExcel. ................... 166 Figura 79: Story card usada para la Iteración 11. ExportPDF ................................... 166 Figura 80: Wizard ExportPDF (Paso 1) ...................................................................... 169 Figura 81: Wizard ExportPDF (Paso 2) ...................................................................... 169 Figura 82: Código ExportPDF ..................................................................................... 170 Figura 83: Story card usada para la Iteración 12. ExportExcel.................................. 171 Figura 84: Función llenar_textos() utilizada en la Iteración 12. ExportExcel ......... 173 Figura 85: Story card usada para la Iteración 13. Filter ............................................. 174 Figura 86: Wizard plugin Filter (Paso 1) ..................................................................... 178 Figura 87: Extracto de código manipulación e interacción de datos de la tabla ....... 179 Figura 88: Story card usada para la Iteración 14. Chart ............................................ 180 15 Figura 89: Wizard plugin Chart ................................................................................... 183 Figura 90: Código desarrollado en la Iteración 14. Plugin Chart .............................. 184 Figura 91: Story card usada para la Iteración 15. Agenda ......................................... 185 Figura 92: Código para la creación y configuración de los archivos del plugin Agenda ........................................................................................................................................ 187 Figura 93: Story card usada para la Iteración 16. CRUDMasterDetail ..................... 188 Figura 94: Wizard plugin CRUDMasterDetail (Paso 1) ............................................. 191 Figura 95: Wizard plugin CRUDMasterDetail (Paso 2) ............................................. 192 Figura 96: Detalle de código plugin CRUDMasterDetail .......................................... 193 Figura 97: Story card usada para la Iteración 17. Plantilla CRUDSimple................. 194 Figura 98: Código función secuencias() del plugin CRUDSimple ............................ 196 Figura 99: Story card usada para la Iteración 16. Ejecutable ..................................... 197 Figura 100: Gráfico desarrollo estándar vs. desarrollo usando el plugin (Plantilla CRUD) ........................................................................................................................... 200 Figura 101: Gráfico desarrollo estándard vs. desarrollo usando el plugin (Plantilla PagedView) .................................................................................................................... 201 Figura 102: Gráfico desarrollo estándard vs. desarrollo usando el plugin (Plantilla Filter) ............................................................................................................................. 201 16 ÍNDICE DE TABLAS Tabla 1: Metodologías Ágiles vs. Metodologías Tradicionales ................................... 26 Tabla 2: Distribución de responsabilidades durante la fase de planificación .............. 39 Tabla 3: Planificación del proyecto T.E.G .................................................................... 99 Tabla 4: Resumen de plantilla base .............................................................................. 121 Tabla 5: Resumen action personalizado ...................................................................... 131 Tabla 6: Resumen de la plantilla Calendario ............................................................... 141 Tabla 7: Resumen plantilla CRUD .............................................................................. 146 Tabla 8: Resumen plantilla PagedView ....................................................................... 153 Tabla 9: Resumen plantilla PickList ............................................................................ 158 Tabla 10: Resumen plantilla ImportExcel ................................................................... 163 Tabla 11: Resumen plantilla ExportPDF .................................................................... 168 Tabla 12: Resumen plantilla ExportExcel ................................................................... 172 Tabla 13: Resumen plantilla Filter .............................................................................. 177 Tabla 14: Resumen plantilla Chart .............................................................................. 181 Tabla 15: Resumen plantilla Agenda ........................................................................... 186 Tabla 16: Resumen plantilla CRUDMasterDetail ...................................................... 190 Tabla 17: Resumen plantilla CRUDSimple ................................................................. 195 Tabla 18: Resumen de resultados desarrollo estándar vs desarrollo usando el plugin DinámicaNB .................................................................................................................. 200 17 INTRODUCCIÓN Actualmente existen diferentes opciones para agilizar el trabajo de los desarrolladores de software. Una práctica bastante común y cada vez más popular es el uso de frameworks 1 , que representan un gran paso en el desarrollo de aplicaciones, al brindar una estructura y la lógica de diseño que facilitan el desarrollo, implementación y posterior reutilización del código creado. Entre las opciones disponibles se encuentra Dinámica, un framework venezolano publicado como software libre en febrero de 2004. Cuenta con una licencia Lesser General Public License (LGPL 2 ) que permite utilizarlo libremente en proyectos tanto de código abierto (open source 3 ) como comerciales, brindando acceso a todo el código fuente y la documentación correspondiente. Dinámica reúne una serie de componentes, herramientas y técnicas para construir aplicaciones web utilizando un enfoque de desarrollo ágil, específicamente el desarrollo rápido de aplicaciones (RAD 4 por sus siglas en inglés -Rapid Application Development-), con una arquitectura MVC bajo el estándar J2EE 5 y orientado a base de datos (BD 6 ) SQL. El enfoque de Dinámica permite reducir la cantidad de código requerido por una aplicación, pudiendo completar proyectos en un corto periodo de tiempo. 1 Consultar término en el glosario 2 A lo largo del documento se hará referencia al término Lesser General Public License utilizando las siglas LGPL. Consultar término en el glosario. 3 Consultar término en el glosario. 4 A lo largo del documento se hará referencia al término Desarrollo Rápido de Aplicaciones utilizando las siglas RAD. Consultar término en el glosario 5 Consultar término en el glosario. 6 A lo largo del documento se hará referencia al término Bases de Datos utilizando las siglas BD. 18 La reutilización de código constituye un tema fundamental y pensando en ello el framework incluye una biblioteca de plantillas de soluciones pre-construidas para resolver los problemas más comunes en las aplicaciones de negocios (como la realización de búsquedas, tabulación de resultados, manejos de registros de una tabla de la BD, listados dinámicos, entre otros). Estas plantillas brindan la estructura de la solución y son fácilmente reutilizables, simplemente configurando los archivos correspondientes. A pesar de las facilidades que brinda Dinámica y su aporte en la agilización de la creación de aplicaciones web, la rapidez en el proceso de desarrollo comienza a ser menos evidente cuando las aplicaciones aumentan en tamaño, incluyendo gran cantidad de funcionalidades que requieren la reutilización de un gran número de plantillas, con el consecuente copiado y configuración del código correspondiente. De esta forma, el ahorro en la codificación es sustituido por una gran cantidad de configuración. Por esta razón, se hace necesaria la implementación de una herramienta que simplifique la reutilización de las plantillas, automatizando el copiado y configuración de los archivos a utilizar, disminuyendo notablemente la carga de trabajo del programador y permitiendo aprovechar al máximo todas las facilidades que brinda el framework. Para el desarrollo del proyecto planteado como T.E.G., se optó por el uso de metodologías ágiles, específicamente una adaptación de la programación extrema (XP 1 por sus siglas en inglés -eXtreme Programming-). Por otra parte, debido a que Dinámica está desarrollado en lenguaje Java, utilizando Servlets, JEE6 fue la plataforma seleccionada para la programación y desarrollo del código necesario. La utilización del IDE NetBeans fue un requerimiento del proyecto, razón por la cual no se consideró ningún otro IDE para llevar a cabo el plugin, además de constituir el ambiente de trabajo ideal para el desarrollo de los módulos. 1 A lo largo del documento se hará referencia al término Programación extrema utilizando las siglas XP. 19 El T.E.G. está estructurado en cuatro capítulos: En el Capítulo I se describe la situación actual que llevó al planteamiento de la propuesta para el T.E.G. y a su posterior desarrollo, especificando las necesidades presentes y la solución desarrollada para cada una de ellas. Se describen también el objetivo general y los objetivos específicos que se plantearon para llegar a la solución, así como el alcance definido para el proyecto. El Capítulo II comprende el marco teórico, agrupando diversos conceptos concernientes al proceso de desarrollo del presente trabajo, que sirven como fundamento para la presentación de las ideas y comprensión del contenido. Se incluyen los temas de XP, framework Dinámica y NetBeans IDE. En el Capítulo III se presenta el marco aplicativo. Incluye los detalles concernientes al desarrollo del plugin: arquitectura de la solución, diseño, implementación y prueba de cada uno de sus módulos. El Capítulo IV contiene las conclusiones y recomendaciones, señalando los logros alcanzados con el desarrollo del plugin y las recomendaciones para versiones o desarrollos posteriores. Luego de los cuatro capítulos, se incluye un glosario con los términos que pudieran generar dudas al lector. Gran parte de la bibliografía consultada para el desarrollo del T.E.G. se encuentra en idioma inglés. Las traducciones necesarias fueron realizadas por el grupo de trabajo y serán indicadas como parte de las referencias bibliográficas cuando así lo amerite. 20 CAPÍTULO I: Propuesta 1.1 Planteamiento del problema El framework Dinámica es un producto maduro y de alcance global. Durante más de 6 años ha sido utilizado exitosamente para una variada gama de aplicaciones no sólo en Venezuela sino en diversos países, como China, Italia, Suiza, Portugal, Estados Unidos, México, Colombia, Argentina, entre otros. Originalmente fue publicado en inglés, conformando una activa base de usuarios pero su última versión está orientada al público latinoamericano, constituyendo una comunidad de usuarios en Latinoamérica que aprovecha la tecnología de Dinámica para sus desarrollos. Dinámica dispone de diversas plantillas organizadas en un repositorio. Estas plantillas representan módulos de uso común en aplicaciones de negocios. Para resolver un problema no se parte de cero, sino que se reutiliza un módulo completo, brindando un nivel de reutilización mucho más alto que el de la clase u otro concepto atado al lenguaje de programación. La reutilización de estas plantillas agiliza enormemente el desarrollo de un proyecto, pero esta agilización o incremento en la productividad se ve mermado cuando hay que configurar o personalizar cada una de ellas en proyectos que requieran un número elevado de funcionalidades. Para desarrollar aplicaciones web utilizando Dinámica, se debe copiar el directorio raíz tomándolo como base para el nuevo proyecto. Una vez copiado el directorio, se procede a incluir las carpetas correspondientes a cada una de las funcionalidades (desde las plantillas prefabricadas) que contendrá este proyecto y luego se debe configurar los archivos correspondientes (editando cada uno de los datos necesarios). Este proceso se torna bastante tedioso; ya que el copiado y configuración de la plantilla se repite muchas veces durante el desarrollo de una aplicación y mientras más grande sea la aplicación, más tedioso se volverá el proceso porque deberá incluir mayor cantidad de funcionalidades y por ende, mayor copiado y configuración. 21 Tomando en cuenta que ya existe una herramienta similar, desarrollada para el IDE Eclipse, se decidió desarrollar una herramienta con características semejantes como opción para la comunidad de usuarios de NetBeans. 1.2 Solución propuesta Teniendo como base el planteamiento anterior, se propone crear una herramienta que permita la automatización en el proceso de reutilización que trae consigo el uso del framework Dinámica. Esta herramienta consiste en un plugin desarrollado para NetBeans IDE que, aprovechando las funcionalidades de este entorno, permita no solo crear proyectos utilizando como base el framework Dinámica, sino incluir las diversas funcionalidades a través del copiado y configuración automática de las plantillas incluidas en el repositorio. Permite además incorporar funcionalidades complejas creadas a partir de la fusión de varias plantillas. El plugin debe ser capaz de generar un proyecto desde cero, usando la plantilla de Dinámica y solicitando al usuario datos básicos de configuración como la conexión a la BD. Se presenta un listado de las plantillas ofrecidas por el Framework en donde podrá seleccionar la funcionalidad de su preferencia e ingresar los datos necesarios para su configuración. Una vez configurado, estará listo para su utilización. Con este plugin se estaría respondiendo a la necesidad de agilizar el proceso de reutilización para incorporar las plantillas de forma automática. De esta forma, se implementa un desarrollo aún más rápido, eliminando las tareas repetitivas que implica la reutilización de estas plantillas dentro de sistemas más complejos, disminuyendo así el tiempo que se invierte haciendo copias manuales y configurando cada una de las funcionalidades. Automatizar este proceso conlleva mayor eficiencia en el trabajo de los programadores con la consecuente optimización de los procesos, reduciendo el tiempo total de desarrollo y el esfuerzo necesario para llevarlo a cabo. Es por ello que el desarrollo del plugin representa una gran ayuda para disminuir la 22 carga de trabajo y permitir que los programadores dediquen más tiempo a implementar la lógica del negocio asociada a cada aplicación en lugar de invertirlo en este tipo de tareas. El desarrollo del plugin se llevó a cabo en un tiempo de 5 meses. Para ello, se utilizaron diversas herramientas tanto de hardware como de software, especificadas a continuación: • Hardware Las computadoras a utilizar poseen las siguientes especificaciones: o Procesador Intel(R) core(TM) i5 CPU M 430 2.27 GHz o 4 GB de Memoria RAM. o Disco Duro de 500 GB. • Software La plataforma de software estuvo conformada por los siguientes elementos: o Sistema Operativo Microsoft Windows 7 Home Premium. o NetBeans IDE versión 6.9. o Java Platform, Enterprise Edition 6 (Java EE 6). o Apache Tomcat versión 6.0.26. 23 1.3 Objetivo general Desarrollar un plugin para NetBeans IDE que a través de plantillas configurables permita, de forma fácil y rápida, generar funcionalidades complejas para el desarrollo de aplicaciones Web basadas en el framework Dinámica. 1.4 Objetivos específicos Para lograr el desarrollo del plugin, se plantearon diversos objetivos específicos agrupados en cuatro criterios: objetivos orientados al aprendizaje, objetivos orientados al desarrollo y por último el objetivo de prueba del sistema. A continuación se presentan cada uno de ellos: Objetivos orientados al aprendizaje: • Estudiar con mayor profundidad el Framework Dinámica. • Investigar los procedimientos para crear plugins en el IDE NetBeans. • Estudiar la metodología de XP y familiarizarse con sus prácticas, principios y actividades. • Adaptar la metodología XP al proceso de desarrollo. Objetivos orientados al desarrollo: • Seleccionar las plantillas de Dinámica a desarrollar, tomando en cuenta su prioridad de uso. • Crear los módulos que generen cada una de las plantillas seleccionadas. 24 Objetivo de prueba del sistema: • Realizar pruebas para verificar el correcto funcionamiento del plugin. 1.5 Límites y Alcances El plugin desarrollado permite la creación y configuración de un proyecto base, así como la adición de las diversas plantillas al proyecto principal y su respectiva configuración. Permite además, la creación de actions personalizados donde el programador podrá especificar cada uno de los detalles de configuración y al mismo tiempo incluir tantos actions como sea necesario. La creación del proyecto para el manejo de la seguridad se consideró importante, por lo que se incluyó dentro de las funcionalidades desarrolladas, aún cuando no estaba contemplado en la propuesta inicial. Otra adición a la propuesta original la constituyó el desarrollo de un módulo ejemplo que permita mostrar al usuario el funcionamiento de las diferentes plantillas disponibles en Dinámica. Para la selección de las plantillas a desarrollar se dio prioridad a aquellas plantillas que eran más utilizadas por el cliente y contenían las funcionalidades esenciales a la hora de desarrollar un proyecto web (proyecto base Dinámica). La inclusión del grupo restante de plantillas, se recomienda para desarrollos posteriores. Se desarrolló un total de 15 plantillas (3 plantillas básicas o generales: proyecto Dinámica, proyecto Security y action personalizado y 12 plantillas específicas: Agenda, Calendario, Chart, CRUD, CRUDSimple, CRUDMasterDetaill, ExportExcel, ExportPDF, Filter, ImportExcel, PagedView, PickList) 25 CAPÍTULO II: Marco Conceptual En el capítulo anterior se presentó la propuesta del T.E.G. y los objetivos necesarios para llevarlo a cabo, así como el alcance definido para el proyecto. El capítulo actual reúne los conceptos y temas que sirvieron como base para la investigación y desarrollo del T.E.G. y que es necesario conocer para la comprensión del contenido. Los conceptos a explicar son: XP, que corresponde a la metodología utilizada para llevar a cabo el desarrollo; NetBeans IDE, que agrupa la plataforma tecnológica utilizada y Dinámica, el framework tomado como base para la propuesta. 2.1 Programación Extrema (XP) Existen diversas alternativas a la hora de seleccionar una metodología para el desarrollo de software y la escogencia de una u otra depende tanto de las características del proyecto como de la experiencia o preferencia de los programadores. Desde hace un tiempo existe la tendencia a utilizar las llamadas metodologías ligeras o ágiles que surgen como una alternativa a las metodologías tradicionales y se basan en diversos principios que buscan solventar los inconvenientes que estas presentaban. Tienen como prioridad satisfacer al cliente mediante la entrega temprana del software y la adaptabilidad para amoldarse a los cambios en los requerimientos, incluso en etapas tardías del desarrollo, para brindar ventaja competitiva al cliente. El desarrollo del software generalmente se lleva a cabo en un período entre dos semanas y dos meses en los cuales desarrolladores y cliente trabajan en conjunto, utilizando la conversación cara a cara como forma de comunicación. La Tabla 1 muestra las diferencias entre la metodología tradicional y las metodologías ágiles. Si bien las metodologías ágiles valoran los elementos que se listan en la columna derecha de la tabla, orientan sus prioridades a los elementos de la columna izquierda y se basan en ellos para llevar a cabo el desarrollo del software. 26 Una de las metodologías ágiles más conocidas en la actualidad es XP y será descrita en esta sección del capítulo. Tabla 1: Metodologías Ágiles vs. Metodologías Tradicionales 1 2.1.1 Definición Kent Beck (1999) define XP como “Un proceso ligero, de bajo riesgo, flexible, predecible, científico y divertido de desarrollar software”. La XP fue concebida y desarrollada para satisfacer las necesidades específicas del desarrollo de software, conducido por pequeños grupos para enfrentar requerimientos que no están claramente definidos o que cambian constantemente. Esta nueva metodología desafía muchas concepciones tradicionales, incluyendo la creencia de que cambiar una pieza de software necesariamente implica un aumento dramático en el costo a través del tiempo. XP reconoce que en los proyectos se debe trabajar para alcanzar la reducción en el costo y explotar las ganancias una vez que se hayan obtenido (Beck, 1999). Desde el punto de vista de las tareas a realizar, XP asegura que cada uno de los miembros del equipo se dedicará a lo que mejor sabe hacer. Los programadores 1 Adaptación del texto: Manifiesto por el Desarrollo Ágil de Software (Beck, Beedle, Bennekum, Cockburn, Cunningham, Fowler, Grenning, Highsmith, Hunt, Jeffries, Kern, Marick, Martin, Mellor, Schwaber, Sutherland, Thomas) 27 trabajaran en las cosas que realmente importan para ellos (producir código en lugar de documentación) y lo harán siempre en conjunto, contando con el apoyo y colaboración de los miembros del equipo. En lo que respecta a los clientes y jefes de proyecto, obtendrán el mayor valor posible de cada semana de programación, apreciando el progreso del software a través de los objetivos planteados y contando con la autoridad y la libertad de cambiar el rumbo del proyecto cuando sea necesario. Además, el cliente podrá seleccionar cuáles son las funcionalidades primordiales que añadirán valor al software, así como establecer el orden en que se desarrollarán, basado en las prioridades y necesidades del negocio. La XP está basada en ciertos valores, principios y buenas prácticas de desarrollo. Estas prácticas existen desde hace mucho tiempo, incluso algunas de ellas, desde principios de la ingeniería del software. La novedad de la metodología, radica en la forma en que son utilizadas, combinadas y llevadas al extremo (de ahí el nombre de programación extrema) para lograr un software de calidad en el menor tiempo posible y minimizando los riesgos que se puedan presentar durante el desarrollo (como cambios en los requerimientos originales, retardos en el tiempo de entrega, altos costos de mantenimiento, tasa de defectos elevada, entre otros). XP comienza con cinco valores que luego son elaborados en principios que a su vez se desarrollan en prácticas. La idea es que las prácticas constituyen los elementos concretos que el equipo de trabajo puede hacer día a día, mientras que los valores constituyen el conocimiento fundamental y entendimiento que sostienen el enfoque XP. Los valores sin prácticas son difíciles de aplicar y podrían ser aplicados de tantas formas que no se tendría idea de por dónde empezar. Las prácticas sin los valores son simples actividades sin un propósito definido. Tanto valores como prácticas son necesarias pero existe una gran brecha entre ellos y los principios sirven como puente para superarla (Fowler, 2005). La Figura 1 muestra estos elementos de XP y la forma en que están construidos unos sobre otros, con actividades a lo largo de todo el ciclo de vida. 28 Figura 1: Valores, principios, prácticas y actividades en XP1 Figura 2: Interacción entre valores, principios, prácticas y actividades en XP2 1 Imagen tomada de (Baird, 2003), versionada y adaptada por el grupo de trabajo 2 Imagen tomada de (Baird, 2003) y versionada por el grupo de trabajo 29 La Figura 2 ilustra los diversos elementos que constituyen XP, desarrollados a partir de ciertos factores clave, interactúan entre sí produciendo resultados de calidad para el cliente (Baird, 2003). 2.1.2 Valores Los valores representan los aspectos considerados como fundamentales para garantizar el éxito de un proyecto de desarrollo de software, ya que darán consistencia y solidez al equipo de trabajo. Constituyen los elementos base sobre los cuales se fundamentan los principios y técnicas de XP. Son la esencia de la metodología. Desde sus inicios, la programación extrema se basó en cuatro valores: comunicación, simplicidad, retroalimentación y coraje. Posteriormente se añadió un quinto valor: el respeto. A continuación se describen cada uno de ellos: 2.1.2.1 Comunicación: constituye el primer valor de XP. Una buena comunicación es la base para ejercer un buen trabajo en equipo, donde cada uno de los miembros esté al tanto del progreso de la aplicación, los cambios e inconvenientes que puedan surgir y las alternativas para solucionarlos. En XP, programadores y clientes forman parte del equipo y se comunican entre ellos diariamente durante todo el proceso de desarrollo. Se promueve el flujo de la comunicación adecuada, empleando diversas prácticas que no podrían llevarse a cabo sin una buena comunicación. 2.1.2.2 Simplicidad: el desarrollo de software con XP debe estar basado en la simplicidad, tratando de desarrollar el código más simple que pueda lograr la funcionalidad requerida. Se debe desarrollar solo lo que el usuario necesita en un momento determinado y nada más que eso, evitando crear funcionalidades que probablemente no se utilicen nunca y manteniendo el código lo más sencillo posible. 2.1.2.3 Feedback o retroalimentación: la retroalimentación en XP constituye, principalmente, las respuestas que se obtienen del sistema al momento de realizar las pruebas y el comportamiento observado durante la puesta en producción. Las observaciones y correcciones obtenidas de los miembros del equipo también forman 30 parte de esa retroalimentación. Así, el valor retroalimentación depende, y al mismo tiempo colabora, con los anteriores (comunicación y simplicidad). Mientras mayor feedback se obtenga, más fácil será la comunicación. Si se tiene una comunicación clara, se podrá conocer qué se debe probar y qué se debe medir para aprender del sistema. Mientras más simple sea el sistema, más fácil serán las pruebas. A su vez, diseñar las pruebas brindan una idea de cuán simple puede llegar a ser el sistema (Beck, 1999). 2.1.2.4 Coraje: este valor tiene que ver con la capacidad del personal para afrontar los cambios necesarios, por muy radicales que parezcan, para obtener un sistema sencillo que funcione de la mejor forma posible. El coraje también implica ser sinceros en cuanto al progreso del proyecto y las estimaciones realizadas. Cuando se combina con los tres valores expuestos anteriormente, el coraje se vuelve realmente invaluable, pero si no se cuenta con ellos, simplemente pierde sentido. La comunicación brinda soporte al coraje al abrir nuevas posibilidades para experimentar, tomando mayores riesgos que normalmente conllevan mayores satisfacciones. La simplicidad, por su parte, hace más fácil tomar riesgos sobre un sistema simple de lo que sería teniendo uno complejo. A su vez, el coraje brinda simplicidad porque tan pronto como se descubre la posibilidad de simplificar el sistema, se hace el intento. En lo que se refiere al feedback, se hace mucho más fácil tomar riesgos en el sistema cuando se pueden obtener las respuestas de forma casi inmediata, medir los resultados y establecer la conveniencia de la nueva implementación (Beck, 1999). 2.1.2.5 Respeto: este último valor tiene que ver con el trato que debe existir entre los miembros del equipo. Cada uno debe recibir el respeto que merece como miembro valioso que es. Los desarrolladores deben respetar la experiencia de los clientes y viceversa, y los jefes de proyecto deben respetar el derecho de los programadores a aceptar responsabilidades (Wells, 2009). 31 2.1.3 Principios Aún cuando los valores fundamentan la metodología XP y constituyen un criterio para una solución exitosa, no brindan la precisión o especificidad necesaria para decidir qué prácticas se deben emplear en el desarrollo del software. Se necesita refinar esos valores y convertirlos en principios concretos con los que se pueda trabajar (Beck, 1999). XP posee cinco principios fundamentales y cada uno abarca los valores tratados en la sección anterior, apoyándose en ellos y actuando como puente entre los valores y las prácticas (ver Figura 1). A continuación se describen cada uno de los principios. 2.1.3.1 Retroalimentación veloz: el tiempo que transcurre entre una acción y su respuesta es crítico para el aprendizaje. Por eso uno de los principios de XP es obtener feedback rápidamente, interpretar la respuesta obtenida y aprovechar ese conocimiento para mejorar el sistema lo más rápido posible. De esta forma, el negocio aprende cuál es la mejor forma en que el sistema puede contribuir, y los programadores aprenden la mejor forma de diseñar, implementar y probar el sistema. 2.1.3.2 Asunción de simplicidad: se debe tratar cada problema como si se pudiera resolver de una forma realmente sencilla. Solo se debe diseñar pensando en resolver la situación actual, sin tomar en cuenta las tareas futuras. 2.1.3.3 Modificaciones incrementales: se debe pensar en resolver los problemas realizando pequeños cambios que hagan la diferencia. Este principio se debe aplicar tanto en la planificación como en el diseño y desarrollo. 2.1.3.4 Adopción del cambio: consiste en adoptar una estrategia que preserve la mayor cantidad de opciones mientras resuelve los problemas más urgentes. 2.1.3.5 Trabajo de calidad: la calidad del trabajo debe estar siempre presente. Este principio no se puede sacrificar o comprometer, debe prevalecer durante todo el proceso de desarrollo. 32 2.1.4 Actividades Los valores y principios definidos anteriormente, constituyen las bases o fundamentos de XP, pero por sí solos no definen lo que se debe hacer para llevarla a cabo. Es necesario determinar las tareas a realizar para desarrollar un buen software. La XP comprende las siguientes actividades: 2.1.4.1 Codificar: los programas de software son creados a través de la codificación, por lo tanto, es la actividad más básica o esencial que se debe realizar y no se puede obviar. Con una idea de lo que será el diseño del sistema, los desarrolladores de XP escriben código para expresar sus ideas. De esta forma, el código se convierte en una forma de comunicación y aprendizaje, ya que leyendo el código fuente, otros programadores pueden entender la lógica, los algoritmos y el flujo de las acciones. El código también se puede utilizar para las pruebas y proveer cierta especificación operacional del sistema. 2.1.4.2 Realizar Pruebas: las pruebas constituyen un elemento importante en XP y deben estar presentes durante todo el proceso de desarrollo. Se diseñan incluso antes de la codificación y se prueba y depura el código constantemente para cumplir con los valores y principios de simplicidad y calidad. Programar y realizar pruebas al mismo tiempo es mucho más rápido que simplemente programar, ya que reduce el tiempo requerido para la depuración. Se deben aplicar dos tipos de pruebas, una prueba realizada por el programador para asegurarse de que el sistema hace lo que se requiere y una prueba funcional, realizada o especificada por el cliente para demostrarle que el sistema funciona como un todo. 2.1.4.3 Escuchar: la realización de esta actividad tiene como objetivo garantizar una buena comunicación para que las ideas que se transmiten entre programadores y clientes sean perfectamente entendidas y atendidas. 2.1.4.4 Diseñar: consiste en crear la estructura a través de la cual se organizará la lógica del sistema. Un buen diseño organiza la lógica de forma tal que los cambios en 33 una parte del sistema no necesariamente impliquen cambios en otra. Se debe proveer un contexto en donde se creen buenos diseños, se corrijan los malos diseños, y se aprenda todo el que haga falta sobre el diseño actual (Beck, 1999, p.46). 2.1.5 Prácticas Para poder llevar a cabo las actividades de XP, se construye sobre los valores una docena de prácticas que los proyectos deben seguir. La Figura 3 muestra las doce prácticas de XP que serán explicadas a continuación. Figura 3: Prácticas en XP (Jeffries, s.f.)1 2.1.5.1 Proceso de planificación: determina el alcance de la próxima versión, combinando las prioridades del negocio (el cliente establece sus necesidades y el propósito del programa) y las estimaciones técnicas (los desarrolladores calculan el 1 Imagen tomada de xprogramming.com y versionada por el grupo de trabajo 34 tiempo necesario para desarrollar las funcionalidades). Permite hacer las actualizaciones necesarias para adaptarse a la realidad de la aplicación. Normalmente se inicia el desarrollo con un plan simple que se refina constantemente (Beck, 1999). La planificación constituye un punto de encuentro vital entre desarrolladores y clientes para alcanzar un objetivo común (la aplicación) (Baird, 2002). Por esta razón, reuniones periódicas son muy importantes para identificar problemas, proponer soluciones y señalar aquellos puntos a los que hay que dar mayor importancia por su dificultad o por su estado crítico (Programación Extrema, s.f.). 2.1.5.2 Versiones pequeñas: esta práctica indica que se debe poner en producción un sistema simple en corto tiempo y lanzar las nuevas versiones en ciclos muy cortos (Beck, 1999, p.47). Estas iteraciones cortas permiten que el cliente utilice el sistema lo antes posible y que se vaya completando de forma gradual y continua (Programación Extrema, s.f.). También permite controlar y manejar el proceso de desarrollo, asegurando que el cliente obtenga el software que espera. Cada versión puede ser tomada como un punto de chequeo para medir la precisión de las estimaciones realizadas durante la planificación (Baird, 2002). 2.1.5.3 Metáforas: es una simple historia que describe cómo trabaja el sistema completo. Constituye una especie de guía para definir la arquitectura del sistema. Una buena metáfora constituye una ayuda poderosa para unificar los equipos técnico y de negocios (Baird, 2002), ya que utiliza un lenguaje sencillo entendible por todos para describir la funcionalidad del sistema. Además del lenguaje común, se debe buscar expresar o traducir los deseos del cliente en algo tangible que los desarrolladores puedan construir. 2.1.5.4 Diseño simple: en todo momento el sistema debe ser diseñado tan simple como sea posible. La complejidad extra es removida tan pronto como sea descubierta (Beck, 1999, p.47). Solo se desarrollarán las funcionalidades que se necesiten en el momento, sin pensar en posibles necesidades futuras. 35 2.1.5.5 Pruebas: los programadores escriben unidades de pruebas constantemente que deben ejecutarse sin problemas para que el desarrollo pueda continuar. Los clientes escriben pruebas para demostrar que las funcionalidades están terminadas (Beck, 1999, p.47). Así, los programadores evalúan en función de métodos y los clientes evalúan en función de historias. La relación entre el código y las pruebas en XP es distinta a la existente en el desarrollo tradicional. En esta metodología, las pruebas se escriben antes que el código. Los desarrolladores escriben pruebas unitarias para probar cada método y cada cosa que podría fallar. Una vez escritas todas las pruebas, escriben solo el código necesario para superarlas (Baird, 2002). 2.1.5.6 Refactorización (Refactoring): consiste en cambiar la estructura del código sin alterar su comportamiento. En XP se realiza la refactorización para remover el código duplicado, mejorar la comunicación y simplificar o añadir flexibilidad (Beck, 1999, p.48). Para lograr la simplicidad necesaria en el código, se debe realizar una refactorización constante durante todo el proceso de desarrollo. 2.1.5.7 Programación en parejas: XP promueve la programación en parejas. Dos trabajadores comparten una estación de trabajo y se turnan para escribir el código. Mientras un programador está al frente del teclado, el otro programador puede estar revisando no solo el código que se está escribiendo sino las pruebas correspondientes, el diseño de la aplicación, etc. Al contrario de lo que se pueda pensar, se ha demostrado que esta es una forma bastante eficiente de desarrollar aplicaciones, en lugar de disminuir la productividad, la incrementa. 2.1.5.8 Propiedad colectiva del código: cualquier miembro del equipo puede cambiar cualquier parte del código en el sistema en cualquier momento (Beck, 1999, p.48). 2.1.5.9 Integración continua: se debe integrar el sistema tanto como sea posible. Cada vez que una tarea, clase o módulo sea completado, se debe integrar y construir el sistema. Una vez integrado el nuevo código, se hacen las pruebas pertinentes, se 36 solucionan los problemas que se presenten y se pasa a la siguiente tarea (Baird, 2002). 2.1.5.10 Cuarenta horas semanales: esta práctica tiene que ver con la jornada laboral de los integrantes del equipo. Para poder mantener la calidad en el desarrollo del sistema, es necesario que los programadores no se sobrecarguen de trabajo y descansen el tiempo suficiente. No deben trabajar horas extra por más de dos semanas seguidas, ya que de esta forma se produce un deterioro en el desempeño del equipo y por consiguiente en la calidad del software. Si se tiene una dedicación exclusiva al proyecto en curso y una planificación realista y bien concebida, cuarenta horas semanales deberían ser suficientes para alcanzar los objetivos planteados. 2.1.5.11 Cliente en el sitio: se debe incluir un cliente real en el equipo de desarrollo que esté disponible a tiempo completo para responder las preguntas que puedan surgir (Beck, 1999). De esta forma se tendrá el nivel de detalle y la claridad necesarios para desarrollar las funcionalidades en el menor tiempo posible; ya que se tendrán las respuestas en el mismo momento en que se producen las dudas. La presencia del cliente permite la revisión y corrección constante del sistema. 2.1.5.12 Estándares de codificación: los programadores deben escribir todo el código siguiendo normas preestablecidas o previamente acordadas que favorezcan la comunicación, modificación y corrección. De esta forma se beneficia la propiedad colectiva del código. 2.1.6 Ciclo de Vida Un proyecto XP es exitoso cuando el cliente selecciona el valor de negocio a ser implementado, basándose en la habilidad del equipo de entregar funcionalidades en el tiempo estimado. El trabajo del cliente es definir qué tiene valor, mientras que el trabajo del programador es construirlo. El cliente define el valor del negocio escribiendo historias y el programador implementa esas historias construyendo los 37 valores del negocio. El valor del negocio depende de qué se obtiene, cuándo se obtiene y cuánto cuesta. Para decidir qué hacer y cuándo, el cliente debe saber el costo de lo que pide. El programador, basado en la experiencia, provee la información necesaria. Luego el cliente escoge lo que quiere y el programador lo construye. Cada vez que se realiza este ciclo se obtiene un aprendizaje. El cliente aprende el valor de la funcionalidad propuesta, el programador aprende la dificultad real que implica construirla y ambos aprenden sobre el tiempo necesario para construirla (ver Figura 4). De esta forma, se puede saber la rapidez con la que se van cubriendo los requisitos y utilizar esa información para seleccionar la combinación de funcionalidades que se quieren en cada versión del sistema. Figura 4: Interacciones durante el ciclo de Vida XP (Baird, 2002) 1 La mejor forma de obtener una buena versión en una fecha dada, es saber cuán rápido los programadores están construyendo las funcionalidades y utilizar ese conocimiento para seleccionar la mejor combinación posible de funcionalidades a realizarse en la 1 Tabla tomada de (Baird, 2002) y traducida por el grupo de trabajo 38 fecha escogida. Para ello, se debe manejar el alcance del proyecto, planificando versiones buenas y sólidas en las fechas que se necesiten. (Anderson, Hendrickson & Jeffries, 2000, pp.14-16) Todo el proceso de desarrollo se realiza de forma cíclica con la participación constante de clientes y desarrolladores, escribiendo, probando y corrigiendo código de forma iterativa, que será lanzado en forma de versiones que irán incrementando en funcionalidad a medida que avanza el proceso. Idealmente, el ciclo de vida de XP consistiría en seis etapas o fases: 2.1.6.1 Exploración: en esta fase, los clientes plantean a grandes rasgos las historias de usuario (funcionalidades a desarrollar) que son de interés para la primera entrega del producto. Al mismo tiempo el equipo de desarrollo se familiariza con las herramientas, tecnologías y prácticas que se utilizarán en el proyecto. Se prueba la tecnología y se exploran las posibilidades de la arquitectura del sistema construyendo un prototipo. La fase de exploración toma de pocas semanas a pocos meses, dependiendo del tamaño y familiaridad que tengan los programadores con la tecnología a utilizar (Letelier y Penadés, s.f.). 2.1.6.2 Planificación: en esta fase, clientes y programadores acuerdan la fecha de lanzamiento de la primera versión del sistema y las historias de mayor valor que serán desarrolladas. En esta etapa del proceso es donde el cliente establece la prioridad de cada historia de usuario, y los programadores realizan una estimación del esfuerzo necesario para desarrollar cada una de ellas. La Tabla 2 muestra las responsabilidades de clientes y desarrolladores durante la planificación del sistema. 39 Tabla 2: Distribución de responsabilidades durante la fase de planificación (Baird, 2002) 1 2.1.6.3 Iteraciones: la planificación de las fases anteriores se divide en iteraciones cortas en las que se producirá un grupo de casos de prueba funcionales para cada una de las historias de usuario planificadas para esa iteración. La primera iteración determina la arquitectura o esqueleto de todo el sistema. La escogencia de las historias a desarrollar en las demás iteraciones queda en manos del cliente. Idealmente, al final de cada iteración, el cliente habrá completado todas las pruebas funcionales y éstas serán superadas. En este momento se está listo para ir a producción (Beck, 1999, p. 102) 2.1.6.4 Producción: durante esta fase se requiere de pruebas adicionales y revisiones de rendimiento antes de que el sistema sea lanzado. Al mismo tiempo, se deben tomar decisiones sobre la inclusión de nuevas características a la versión actual, debido a cambios durante esta fase. Las ideas que han sido propuestas y las sugerencias son documentadas para su posterior implementación (Letelier y Penadés, s.f.). Se debe saber lo que se ha hecho y cuán rápido se ha llevado a cabo, utilizando ese conocimiento para decidir lo que se hará después y lo que se deberá posponer (Anderson, Hendrickson & Jeffries, 2000, p. 181). 1 Tabla tomada de (Baird, 2002) y traducida por el grupo de trabajo 40 2.1.6.5 Mantenimiento: mientras la primera versión del sistema se encuentra en producción, se debe mantener el sistema en funcionamiento y al mismo tiempo desarrollar nuevas iteraciones que requerirán tareas de soporte para el cliente. La fase de mantenimiento puede requerir nuevo personal dentro del equipo y cambios en su estructura. Requiere de un mayor esfuerzo para satisfacer también las tareas del cliente (Letelier y Penadés, s.f.). 2.1.6.6 Muerte: esta etapa sucede cuando ya el cliente no tiene más historias para realizar. En este momento, se debe redactar un documento que describa el sistema de forma tal que pueda ser utilizado cuando se requiera realizar futuros cambios (Beck, 1999, p.104). La muerte del proyecto también ocurre cuando el sistema no genera los beneficios esperados por el cliente o cuando no hay presupuesto para mantenerlo (Letelier y Penadés, s.f.). La Figura 5 muestra las fases del ciclo XP. Figura 5: Fases del Ciclo XP (Baird, 2002) 1 1 Figura tomada de (Baird, 2002) versionada y adaptada por el grupo de trabajo 41 2.1.7 Instrumentos Aún cuando XP prescinde de la etapa de documentación excesiva tan común en los desarrollos tradicionales, hace uso de ciertos instrumentos que sirven como apoyo para llevar a cabo las diferentes etapas del proceso, registrando las necesidades del cliente (requerimientos del sistema) y facilitando la comunicación de las ideas entre los miembros del equipo. A continuación se describen algunos de ellos: 2.1.7.1 Historias de usuario: Las historias de usuario constituyen el medio utilizado en XP para especificar los requisitos del sistema a desarrollar. En ellas, el cliente describe brevemente las características que el sistema debe poseer, representando una oportunidad para expresar y al mismo tiempo refinar en qué consiste su negocio. Las historias de usuario son los elementos centrales en el proceso de planificación pero son preservadas a través de todo el proceso de desarrollo (planificación, iteración, lanzamiento). Son priorizadas conforme las necesidades del cliente, estimadas por los programadores, descompuestas en tareas al momento de realizar la planificación y probadas por los clientes a través de pruebas de aceptación para poder determinar si ha culminado su ejecución. Teniendo en cuenta lo anterior y tomando como referencia User Story (2010), una historia debe ser: • Evaluable: permitiendo escribir pruebas automáticas que detecten la presencia de la historia. • Progresiva: el cliente debe estar dispuesto a aceptar la historia como un símbolo de progreso hacia el objetivo final. • Pequeña: debe completarse en una iteración. • Estimable: el equipo técnico debe ser capaz de estimar cuánto tiempo requerirá para poner a funcionar la historia. 42 Por otra parte, teniendo en cuenta que en XP los requerimientos evolucionan conforme los desarrolladores aprenden más acerca del dominio del negocio y los clientes comprenden las posibilidades y limitaciones (Baird, 2002), no es necesario y puede no ser posible, conocer todas las historias al inicio del proceso de planificación. A medida que se va desarrollando el sistema, pueden modificarse las historias existentes e incluso definirse y crear nuevas. Algunos de los cambios a realizar serían los siguientes: • Dividir las historias: si el equipo de desarrolladores no puede realizar las estimaciones de toda la historia, o los clientes se dan cuenta que una parte de la historia es más importante que el resto, la historia se puede dividir en dos o más historias dependiendo de su complejidad (Beck, 1999, p.73). • Ordenar las historias: para el desarrollo e implementación de las historias, se debe establecer ciertas prioridades para determinar cuál de ellas debe funcionar primero. Se toman en cuenta dos criterios: • Según el valor: se podrán organizar tomando en cuenta el valor que aportan al negocio, separando las historias en aquellas sin las que el sistema no puede funcionar, aquellas que son menos importantes pero proveen un valor significativo y por último aquellas que simplemente sería bueno tener en el sistema (Beck, 1999, p.73). • Según riesgo: dividiendo las historias en: aquellas que se pueden estimar, aquellas en las que podría realizarse una estimación aceptable y aquellas en las que no se puede realizar estimación alguna (Beck, 1999, p.73). XP favorece el uso de fichas o tarjetas (story cards) para escribir las historias de usuario porque son simples, fáciles de manejar y económicas. Además, el espacio limitado ayuda a mantener la síntesis en la descripción. Algunos clientes pueden preferir el uso de herramientas digitales que le permitan almacenar la información y algunos desarrolladores podrían necesitar disponer las historias a un mayor 43 grupo de personas. Para este propósito, se pueden utilizar simples procesadores de texto o herramientas de colaboración Web (como los Wiki Wiki 1 ) que permitan a los usuarios (programadores y clientes) modificar y añadir libremente la información además de llevar un seguimiento (Baird, 2002). Tanto el formato como la cantidad de información contenida en una ficha de historia son decisión del grupo de desarrollo, pero se debe mantener tan sencilla como sea posible para apegarse a los valores de XP. Una ficha de usuario normalmente consta de: • Nombre: descripción corta que el equipo puede utilizar para discutir, estimar y llevar el seguimiento de la historia. Debe capturar el objetivo del usuario en pocas palabras, evitando el uso de números o secuencias arbitrarias de caracteres. • Texto: constituye el cuerpo de la historia. Describe el concepto de la historia en un par de oraciones. • Estimaciones: estimaciones preliminares generadas durante el proceso de planificación. Constituye un elemento extra que generalmente no forma parte de la ficha. Dado que cada historia posee estimaciones asociadas, sería útil verlas reflejadas en la tarjeta. La Figura 6 muestra un formato de la ficha de historia manual y una muestra de la ficha de historia realizada con un procesador de texto se muestra en la Figura 7. 1 Consultar término en el glosario. 44 Figura 6: Muestra de story card manual (Beck, 1999)1. Figura 7: Muestra de story card electrónica (Baird, 2002) 1 1 Tabla tomada de (Beck, 1999) 45 2.1.7.2 Tarjeta de interfaz: se puede realizar una variación de las historias de usuario, utilizándolas para desarrollar prototipos. El cliente escribe la historia y junto con el programador desarrollan un boceto que se registra en una tarjeta que sirve como guía. Posteriormente se desarrolla un prototipo no funcional de la pantalla (Baird, 2002). 2.1.7.3 Tareas de ingeniería: comúnmente conocidas como tareas (tasks), constituyen los elementos esenciales en el proceso de iteración. Surgen al tomar una historia definida en la etapa de planificación y dividirla en funcionalidades más pequeñas que necesitan ser desarrolladas para llevar a cabo la historia. Algunas tareas pueden ser comunes a varias historias y otras pueden no estar relacionadas directamente con una historia en particular (por ejemplo la migración a una nueva versión del software) (Beck, 1999, p.74). Estas tareas se registran en las llamadas tarjetas de tarea o task card. Al igual que las historias de usuario, las tareas también podrán dividirse en tareas más pequeñas si la estimación resulta en períodos de tiempo muy largos. Por otra parte, si la estimación de varias tareas resulta en períodos muy cortos, se pueden unir para formar una sola (Beck, 1999, p.74). A diferencia de las historias de usuario, las tareas son seleccionadas por cada programador antes de hacer la estimación. En las historias de usuario, el equipo de desarrollo toma responsabilidad por las historias y hace la estimación respectiva, mientras que en las tareas, el programador asume la responsabilidad y hace la estimación de forma individual (sin la intervención del equipo) (Beck, 1999, pp.76- 77). De esta forma, se debe hacer las tareas lo suficientemente pequeñas para que cada uno de los miembros del equipo entienda su significado y pueda estimar el tiempo de programación ideal para completarla (EngineeringTask, 2005). 1 Figura tomada de (Baird, 2002) 46 Otra diferencia la constituye el hecho de que las tareas pueden no estar directamente ligadas a las necesidades del cliente. Si se necesita realizar algún procedimiento a nivel técnico, se convierte automáticamente en una tarea por sí sola, se registra en la planificación y prioriza con el resto de las tareas (Beck, 1999, pp.76-77). Baird (2002) distingue los siguientes elementos de una tarjeta de tareas: • Tarea: número de secuencia. • Descripción: texto corto que describe la tarea. Si se utiliza una herramienta electrónica, se puede incluir un enlace a una sección Wiki cuando haga falta mostrar un mayor detalle. • Estimación: la estimación completa de la tarea, incluyendo las diferentes medidas utilizadas. • Actual: tiempo que tomará desarrollar la tarea. La Figura 8 muestra un ejemplo de una tarjeta de tarea (task card) manual, mientras que la Figura 9 muestra una task card electrónica. Figura 8: Muestra de task card manual (Beck, 1999) 1 1 Figura tomada de (Beck, 1999) 47 Figura 9: Muestra de task card electrónica (León, Otaiza y Zambrano) 1 . Al igual que en las historias de usuario, en las tareas no existen normas establecidas en cuanto al nivel de detalle a alcanzar. Se puede decidir agregar nuevos datos, siempre y cuando representen información relevante para el proceso de desarrollo (Baird, 2002). 2.1.7.4 Tarjetas Clase, Responsabilidad y Colaboración (CRC): ayudan al equipo a definir actividades durante el diseño del sistema. Cada tarjeta representa una clase en la programación orientada a objetos y define lo que debe hacer (responsabilidades) y las colaboraciones con las otras clases (cómo se comunican con ellas) (Programación Extrema, s.f., p. 6). Una tarjeta CRC se utiliza para ayudar a generar una tarea en caso de que no sea muy obvia (EngineeringTask, 2005). La idea es entender los objetos involucrados en lo que se va a realizar y entender cómo implementarlos o cambiarlos para poder realizar la tarea. Es importante no invertir mucho tiempo en ello, tratar de entender en los primeros minutos e inmediatamente empezar a escribir el código necesario (Anderson, Jeffries & Hendrickson, 2000, p. 87). La Figura 10 muestra el formato de una tarjeta CRC. 1 Figura tomada de (León, Otaiza y Zambrano, s.f., pp. 18-19) 48 Figura 10: Muestra de tarjeta CRC (León, Otaiza y Zambrano) 1. 2.2 Framework Dinámica En la sección anterior, se describió la metodología XP utilizada para el desarrollo del T.E.G. En esta sección se presenta el elemento base de la propuesta: el framework Dinámica. Se hará una breve descripción de los elementos que componen el framework, se explicará su arquitectura, características, ventajas y un ejemplo de aplicación para mostrar su uso. Tanto la información del framework como las imágenes presentadas fueron tomadas del material disponible en el portal web de Martín Córdova y Asociados C.A 2 (Martín Córdova y Asociados C.A., 2009b). Algunas de las imágenes fueron versionadas por el grupo de trabajo y se indicará como nota al pie cuando sea necesario. 1 Tabla tomada de (León, Otaiza y Zambrano, s.f., pp. 18-19) 2 www.martincordova.com 49 2.2.1 Características • Basado en Java. El framework Dinámica está basado en el estándar J2EE pero solo utilizando el API de Servlets. • Reutilización de código y soluciones. La reutilización es uno de los factores fundamentales de este framework. Se puede desarrollar una aplicación utilizando únicamente las plantillas disponibles sin necesidad de crear nuevas clases. En caso de ser necesario, las clases a crear serán extendidas de las clases preexistentes del framework, heredando gran parte de las funcionalidades con el consecuente ahorro de código. • Multi-idioma. Dinámica provee facilidades para la creación de aplicaciones con traducciones a diversos idiomas, utilizando marcadores especiales que representan etiquetas que son traducidas a un texto determinado en el idioma correspondiente. Estas etiquetas se encuentran en un archivo de configuración llamado labels.xml. • Programación declarativa 1 . El framework utiliza la programación declarativa para el desarrollo de aplicaciones. Una aplicación se puede crear simplemente configurando diversos archivos presentes en las plantillas pre-construidas brindadas por el framework. • Estructura MVC. Dinámica implementa el modelo MVC con ciertas modificaciones que facilitan el desarrollo de aplicaciones, brindando mayor flexibilidad. Los detalles de esta estructura serán explicados posteriormente. • RAD. Dinámica fue designado como un framework RADical por implementar este tipo de metodología en el desarrollo de software. Su orientación hacia el diseño rápido de aplicaciones se hace evidente al eliminar casi por completo la necesidad de programar y brindar plantillas pre-construidas y directorios 1 Consultar término en el glosario. 50 completos para el inicio de las aplicaciones que disminuyen el tiempo de desarrollo. • Uso de Ajax. Dinámica hace gran uso de esta técnica de programación web. Generalmente las funcionalidades del sistema contarán con una página web principal que irá cambiando dinámicamente gracias a interacciones Ajax de la página actual con otras funcionalidades. • Otras funcionalidades. Dinámica brinda soluciones para el manejo de gráficos, generación de reportes en Excel, seguridad centralizada, persistencia de data, transacciones a BDs, manejo centralizado de excepciones, validación automática de formularios, notificaciones por email. Todo esto implementado de forma transparente, el programador simplemente debe configurar los archivos correspondientes. 2.2.2 Arquitectura del Framework Conceptualmente, una aplicación desarrollada con Dinámica, podría verse como una máquina de estados donde cada página es un estado y se debe ejecutar una acción o action para pasar de un estado a otro (ver Figura 11). De esta forma, una aplicación web se reduce a una colección de actions y estados, cada action corresponde a una solicitud HTTP y genera una respuesta. Un action se puede construir de dos formas: escribiendo una clase Java o simplemente configurando un archivo XML. 51 Figura 11: Modelo estado - acción. (Martín Córdova y Asociados C.A., 2004)1 A continuación se explicarán los diferentes conceptos o elementos que intervienen en una aplicación desarrollada con Dinámica y que es necesario conocer para comprender mejor su funcionamiento. Se presentará también la estructura de directorios que constituye los diferentes archivos que conforman el framework y su ubicación dentro de la carpeta principal. El funcionamiento del framework se explicará a través del Modelo MVC de Dinámica, el mecanismo de procesamiento de solicitudes HTTP y los puntos de extensión frecuentes. Estos últimos constituyen los elementos que permiten personalizar y extender las funcionalidades del framework. Para completar la descripción de la estructura, se presentan los diagramas de clases de los diferentes tipos de clases que conforman el framework. 2.2.3 Elementos de una Aplicación Comúnmente, una aplicación de dinámica consta de actions, clases y archivos de configuración. A su vez, cada action contiene un archivo de configuración (config.xml), una plantilla HTML (template.html) y un archivo de consulta a la BD 1 Imagen tomada de (Martín Córdova y Asociados C.A., 2004) y versionada por el grupo de trabajo 52 (query.sql). Los resultados de la consulta se almacenan en recordsets propios del framework. A continuación se explicará en detalle cada uno de estos elementos presentes en el framework. • action: son la esencia de Dinámica. Constituyen las funcionalidades del sistema a desarrollar; así, cada funcionalidad de la aplicación se implementa a través de un action. Son carpetas que contienen, en su forma más general, un archivo de configuración (config.xml), un archivo de salida o página web (template.htm) y un archivo de consulta (query.sql). También pueden contener archivos de validación (validator.xml) y subdirectorios asociados a otros actions. • template.htm: este archivo representa la plantilla de la página web. Contiene el código HTML junto con las etiquetas necesarias para implementar la funcionalidad multi-idioma. • config.xml: archivo de configuración XML que determina cómo integrar los elementos para producir la salida. En este archivo se declara lo que se desea que el action ejecute en cada etapa del mecanismo MVC. En este archivo se indica, entre otras cosas, el archivo de salida, el formato de la salida, el archivo que contendrá la consulta a la BD en caso de que sea necesaria y el archivo de validación correspondiente. • validator.xml: archivo de validación. Contiene las validaciones necesarias para el procesamiento de las solicitudes. Un ejemplo de estas validaciones son la presencia de un dato enviado en un formulario y el formato o tipo de dato. • Recordsets: son utilizados por el framework para almacenar el resultado de las consultas a la BD. De esta forma los datos obtenidos son más fáciles de manejar y están disponibles al momento de ser necesitados. En la guía del programador (Martín Córdova y Asociados C.A., 2009b), se presenta la siguiente descripción de recordset “es una clase que representa una estructura de datos tabulada, columnas y registros. La data contenida en el recordset puede provenir de un 53 query SQL o de cualquier otra fuente, es desconectado porque no mantiene conexiones abiertas a la BD. Es un medio de intercambio de data tabulada entre las clases del framework, particularmente entre la Vista y el Modelo, pero se usa en otros casos también”. 2.2.4 Estructura del Directorio De forma general, una aplicación desarrollada utilizando el framework Dinámica es un módulo web básico de J2EE que define, entre otras cosas, la estructura de las carpetas de archivos para la organización de los contenidos. El framework brinda una especie de plantilla con la estructura del directorio así como los archivos básicos de configuración y lo necesario para el desarrollo de una aplicación, ahorrando el trabajo de crear todo desde cero cada vez que se inicie un nuevo proyecto. Este directorio base incluye también algunas de las acciones propias del framework necesarias en la mayoría de las aplicaciones como son el manejo centralizado de errores, validación de formularios, controles de navegación, entre otros. La Figura 12 muestra la estructura del directorio base. Figura 12: Directorio Dinámica. (Martín Córdova y Asociados C.A., 2009b)1 1 Imagen tomada de (Martín Córdova y Asociados C.A., 2009b) y versionada por el grupo de trabajo 54 Adicionalmente, el framework provee una capa de directorios para un ambiente de desarrollo bien organizado, separando los archivos fuente de los archivos binarios facilitando la producción tanto de distribuciones binarias como de archivos .war. Los actions son almacenados en subdirectorios dentro de la carpeta WEB-INF y debe existir una carpeta para cada uno de los actions. Los archivos Java deben ser colocados en paquetes dentro de la carpeta WEB- INF/source, los archivos .class dentro de la carpeta WEB-INF/classes. Si se necesita algún JAR (Java ARchive) 1 adicional se debe colocar dentro del directorio WEB- INF/lib. Adicionalmente, se tienen los archivos index.html (página de inicio de la aplicación) y default.css (contiene los estilos o forma de mostrar los contenidos HTML) que pueden ser modificados para adaptarse a los requerimientos de cada aplicación. Para la configuración, el framework utiliza el archivo web.xml, al igual que cualquier otra aplicación J2EE. Este archivo almacena los parámetros básicos de configuración para cualquier aplicación basada en Dinámica. Otro archivo de configuración presente en la carpeta WEB-INF es labels.xml. Es un archivo propio de Dinámica que proporciona la capacidad multi-idioma del framework. Contiene una serie de etiquetas y su correspondiente traducción al inglés (idioma por defecto pero puede sustituirse por cualquier otro idioma) para aquellas aplicaciones que requieran este tipo de soporte. Este archivo viene pre-cargado con las etiquetas básicas utilizadas por el framework y se pueden añadir tantas etiquetas como sea necesario. 1 A lo largo del documento se hará referencia al término Java ARchive utilizando las siglas JAR. Consultar término en el glosario. 55 2.2.5 El Modelo MVC de Dinámica En la implementación que Dinámica hace del modelo MVC, los elementos que lo integran son más genéricos y se configuran mediante parámetros. A continuación se describen cada uno de los tres elementos que conforman el MVC de Dinámica: El Modelo generalmente es una clase genérica del framework, pero podría ser una clase particular de la aplicación. El framework incluye varios tipos de Modelos de uso general en diversas aplicaciones de negocios. Para la Vista el framework incluye módulos para generar diversos tipos de salidas, desde páginas HTML simples, hasta documentos Excel. En la mayoría de los casos el control es declarativo, mediante el archivo config.xml. Por último, el Servlet Dinámica corresponde al Controlador. Hay un solo Controlador para atender todas las solicitudes y es el único que utiliza una aplicación basada en este framework. La figura 13 muestra el modelo MVC tradicional, en comparación con el modelo MVC de Dinámica, expresado como un action de una aplicación ilustrado en la figura 14. 56 Figura 13: Arquitectura MVC. (Martín Córdova y Asociados C.A., 2009b) 1 Figura 14: Modelo MVC de Dinámica. (Martín Córdova y Asociados C.A., 2004) 2 1 Imagen tomada de (Martín Córdova y Asociados C.A., 2009b) y versionada por el grupo de trabajo 2 Imagen tomada de (Martín Córdova y Asociados C.A., 2004) y versionada por el grupo de trabajo 57 2.2.6 El mecanismo de procesamiento de solicitudes HTTP Cada vez que un cliente HTTP envía una solicitud a una aplicación basada en Dinámica, dependiendo de la ruta del URL se determinará si corresponde a Dinámica procesarla, de ser así esta solicitud será pasada al Controlador para que la atienda. Las solicitudes que atiende Dinámica se denominan actions. Simplificando un poco, una aplicación web basada en Dinámica no es más que un conjunto de actions, recursos estáticos (imágenes, HTML, CSS, etc.) y clases, si es que se requiere escribir alguna. Figura 15: Procesamiento de solicitudes HTTP en Dinámica. (Martín Córdova y Asociados C.A., 2009b) 1 1 Imagen tomada de (Martín Córdova y Asociados C.A., 2009b) y versionada por el grupo de trabajo 58 A continuación se explica cómo Dinámica realiza el procesamiento de solicitudes HTTP expuesto en la figura 15. 1. El browser envía la solicitud, si el URL contiene un texto como “/action/xxxx” la solicitud será pasada al Servlet que funge como Controlador para que lo atienda. 2. El Controlador computará la ruta de una carpeta dentro de la aplicación a partir del URL. Por ejemplo si la ruta dice “/action/xxxx” entonces el Controlador buscará la carpeta /WEB-INF/action/xxxx dentro de la aplicación, y dentro de esa carpeta leerá el archivo de configuración del action (config.xml). 3. Luego de que el Controlador lee la configuración del action, procede a ejecutar el mecanismo MVC. Instancia a la clase que representa al Modelo, y ejecuta el método con la lógica de negocios. 4. Este Modelo lee lo que le corresponde de la configuración del action (qué SQLs debe ejecutar, si usa o no transacciones de BD, etc.) y procede a ejecutar la lógica de negocios apoyándose en APIs de alto nivel para acceso a BDs SQL. Al terminar puede publicar la data resultante, usando una abstracción fundamental del framework: los recordsets. 5. El Controlador detecta que el Modelo terminó su tarea, y procede a instanciar la clase de la Vista y a ejecutar el método que generará el output o respuesta del action. 6. La Vista procede a consumir los recordsets que haya publicado el Modelo, usando interfaces bien definidas entre estos tipos de módulos. El Modelo no sabe qué tipo de Vista consumirá su data, y la Vista no sabe qué tipo de Modelo publica la data, le basta que publiquen lo que la configuración dice que debe consumir. 7. La Vista utiliza componentes utilitarios del framework para cargar la plantilla de página (template.htm) a partir de la cual se generará la respuesta, y procede a “inyectar” la data de los recordset del Modelo dentro de la plantilla. Esto se hace mediante un proceso llamado “data binding”, que permite declarar en la plantilla dónde van los campos, y el framework se encarga de sustituir estas marcas por la data 59 actual, aplicando formatos de máscaras y codificaciones de caracteres especiales si así fue indicado. 8. Una vez que la respuesta ha sido generada en memoria con técnicas optimizadas a partir de los recordsets y la plantilla, la Vista la envía al browser, completando la respuesta a la solicitud y cerrando el circuito del mecanismo MVC. 2.2.7 Diagrama de Clases Dinámica contiene diversas clases que se pueden agrupar en cuatro tipos principales que son: las clases básicas o fundamentales del framework, las clases tipo Output que representan la Vista en el modelo MVC, las clases de tipo Transaction que constituyen el Modelo (en MVC) y las llamadas clases utilitarias que sirven de apoyo a las anteriores. A continuación se describirán cada una de ellas. • Clases básicas: Son las clases principales del mecanismo MVC del framework, y aunque conforman la base más abstracta, algunas de ellas contienen funcionalidad suficiente como para ser utilizadas directa y frecuentemente, otras son estrictamente abstractas, definen solamente la interfaz para las clases implementadoras y consumidoras. La figura 16 muestra el diagrama. Figura 16: Diagrama de Clases - Clases básicas 60 • Clases de tipo Output: sirven para dar salidas de tipo texto, incluyendo los formatos HTML, XML, JavaScript y text. La clase básica es GenericOutput y de ella se derivan diversas clases para propósitos variados, como generación de PDFs (utilizando el componente IText 1 ), Excel, gráficos (utilizando el componente JFreeChart 2 ), galerías de imágenes, entre otros. La figura 17 muestra el diagrama de clases. Figura 17: Diagrama de Clases - Clases tipo OutPut • Clases de tipo Transaction: en esta categoría se distinguen dos clases, GenericTransaction que es la clase base para todos los Modelos (MVC) que incluye el framework y la clase GenericTablerManager, que sirve para consultas 1 Consultar término en el glosario. 2 Consultar término en el glosario. 61 de modificación y creación de registros. La figura 18 muestra el diagrama correspondiente. Figura 18: Diagrama de Clases - Clases tipo Transaction • Clases utilitarias: son clases que proveen un API de servicios fundamentales, conforman el núcleo o API de bajo nivel. Entre las más importantes se encuentran: o dinamica.Db: Encapsula el protocolo JDBC 1 , se utiliza principalmente desde clases de tipo Model o Transaction. o dinamica.Recordset: Implementa una abstracción fundamental del framework, la de un recordset desconectado. o dinamica.TemplateEngine: constituye una de las clases más importantes y de mayor complejidad. Manipula todo tipo de plantillas basadas en texto, 1 Consultar término en el glosario. 62 HTML, XML, JavaScript o SQL y participa activamente en casi todo lo que se hace con el framework. 2.2.8 Puntos de extensión frecuentes El framework cuenta con diversos puntos de extensión que permiten extender las funcionalidades ofrecidas. Estos puntos de extensión se hacen presentes en las clases, validators y diversos elementos complementarios como plugins de gráficos y otros componentes visuales. • Clases. Si surge la necesidad de escribir clases propias de una aplicación, generalmente se realiza a través de Modelos (Modelo en la arquitectura MVC) especializados, que cumplan una función no contemplada por los Modelos del framework. Generalmente son bastante simples de desarrollar porque solo deben extender a uno de los Modelos existentes. De esta forma, la extensión del framework por parte de los programadores se hace vía herencia, extendiendo las clases básicas. El polimorfismo basado en herencia e interfaces es un aspecto básico y estructural del diseño de Dinámica. • Custom Validators. Son plugins que extienden las reglas de validación de parámetros de un request o solicitud HTTP. Se puede crear el plugin de cero, extendiendo a dinamica.AbstractValidator, o extendiendo alguno de los existentes. También se puede tomar muestras de código de alguno de estos validators para crear una versión particular. • Módulos de tipo View o plugins. Dinámica brinda la posibilidad de añadir nuevos gráficos o Charts (extendiendo la clase dinamica.AbstractChartPlugin) o crear una versión especializada de los gráficos existentes. 63 2.2.9 Desarrollo de Aplicaciones En el repositorio de plantillas de Dinámica cada plantilla tiene un propósito particular, brindando funcionalidades completas que solucionan los problemas más comunes en una aplicación. Combinando varias de ellas se puede obtener funcionalidades más complejas y una mayor personalización para satisfacer las necesidades propias de cada aplicación, configurando los archivos correspondientes. A continuación, se presentará el flujo de trabajo a seguir para crear una aplicación con este framework, utilizando una de las plantillas que se encuentran disponibles en la web. Para la explicación del ejemplo se decidió utilizar la plantilla ViewChart. Para crear una aplicación con Dinámica, lo primero que se debe hacer es crear la carpeta de la nueva aplicación en el directorio Webapps de tomcat. En esa carpeta se copian los archivos base del framework que se descargan de la página Web y tendrán la estructura indicada anteriormente. En este punto ya se tiene todo lo necesario para iniciar un proyecto con Dinámica. Viene pre-configurada para conectarse al pool de conexiones “jdbc/dinamica” que apunta a un PostgreSQL local pero se puede configurar fácilmente para conectarse con SQL Server, MySQL u Oracle. Se debe editar el archivo de configuración Web.xml para configurar parámetros como la ubicación de los logs, el nombre del pool de la BD para la aplicación, entre otros. Para enlazar la aplicación con la BD, se debe editar el archivo context.xml, para que apunte a la BD deseada. Indicando el usuario, contraseña y el nombre del pool previamente configurado en el web.xml. Posteriormente se procede a incluir las plantillas o actions necesarios, creando un directorio dentro de “/WEB-INF/action” o dentro de una subcarpeta y se copia todo el contenido de la plantilla. La plantilla a utilizar es ViewChart y consiste en una consulta con parámetros fijos u obligatorios que despliega una tabla de resultados y el gráfico correspondiente. Permite además obtener un detalle de cada uno de los resultados incluidos en la tabla. 64 La acción de inicio o de entrada a esta plantilla está ubicada en la carpeta form y es la que presenta la página principal; de ahí en adelante toda la interacción se basa en llamadas Ajax, excepto por la invocación de los gráficos, que son etiquetas <IMG> tradicionales. El directorio de ViewChart contiene, en su forma más básica, seis carpetas correspondientes a los diversos actions necesarios para ejecutar la funcionalidad: form, search, notfound, view y chart. Otras funcionalidades como drilldown, pdf y excel también pueden ser añadidas. Se explicarán cada una de ellas para entender su funcionamiento. • form: constituye el punto de partida del action. Esta carpeta contiene dos archivos: config.xml, para la configuración de este action y template.htm que es la base de todo el action ViewChart. El template.htm contiene el formulario para ingresar los datos necesarios en la búsqueda base del ViewChart. • search: a través de este action se realizan las consultas a la BD. Contiene el archivo de configuración config.xml y los archivos de consulta query.sql y total.sql que contienen las sentencias SQL necesarias para obtener los datos desde la BD. También posee un archivo validator.xml que indica los datos que se utilizarán en la consulta y si son obligatorios o no. • notfound: este action se utiliza para mostrar un mensaje indicando al usuario que no se consiguió data que coincida con el criterio de búsqueda ingresado en el formulario (form). Contiene a su vez un archivo de configuración config.xml y un archivo message.html con el mensaje correspondiente. • view: se utiliza para mostrar los resultados de la búsqueda. Además del archivo de configuración, contiene el template.htm necesario para mostrar la data obtenida de la BD. Este template.htm constituye un extracto de código que será insertado en el template del form. 65 • chart: este action se utiliza para generar gráficos. Solo contiene un archivo de configuración que indica las propiedades del gráfico a mostrar. Los charts son llamados por una etiqueta de imagen HTML (<IMG>), el que llama a este action chart obtiene como resultado el gráfico configurado. • drilldown: ofrece un mayor detalle de cada uno de los datos arrojados en la consulta principal. Posee tres archivos de consulta: query.sql, category.sql y total.sql que contienen la sentencias SQL necesarias para obtener el detalle desde la BD; un archivo validator.xml que obtiene los datos pasados por parámetros a utilizar en las consultas y un archivo template.htm donde se muestran los datos encontrados. • pdf: se utiliza para generar reportes en formato pdf. Solo contiene un archivo de configuración y la salida será directamente el archivo pdf generado. • Excel: contiene un archivo de configuración necesario para generar un archivo Excel con los resultados de la consulta. La figura 19 muestra la estructura del directorio. Figura 19: Plantilla ViewChart - estructura del directorio 66 Figura 20: Plantilla ViewChart - detalle estructura del directorio1 1 Imagen tomada de (Martín Córdova y Asociados C.A., 2009b) y versionada por el grupo de trabajo 67 En cuanto al funcionamiento del action y la interacción entre cada uno de los elementos descritos, todo comienza en el form. Es el eje central del ViewChart. Contiene tanto el filtro de búsqueda que contendrá los parámetros necesarios para la consulta, como los DIVs (etiquetas HTML) para mostrar los resultados y el código JavaScript para su funcionamiento. La figura 21 muestra la interacción entre los actions involucrados y las figuras 22 y 23 muestran el esquema de este template. Figura 21: Plantilla ViewChart - action form (1). (Martín Córdova y Asociados C.A., 2009b) 1 1 Imagen tomada de (Martín Córdova y Asociados C.A., 2009b) y versionada por el grupo de trabajo 68 Figura 22: Plantilla ViewChart - action form ejemplo (parte 1) 69 Figura 23: Plantilla ViewChart - action form ejemplo (parte 2). (Martín Córdova y Asociados C.A., 2009b)1 Una vez que el usuario introduce en el formulario los datos de la búsqueda, al presionar el botón buscar, utilizando Ajax, se invoca el action search que ejecuta todos los comandos SQL que le fueron configurados. El recordset con los parámetros del filtro es almacenado automáticamente en sesión a través del validator, así como los recordsets producto de los comandos SQL, ya que varias de las acciones posteriores usarán estos datos. Este action no imprime una salida, solo realiza un enrutamiento, direccionando el flujo de ejecución hacia dos posibles actions: notfound o view. La figura 24 muestra el detalle. Si se encontraron registros que coincidan con los datos de búsqueda, se muestran la tabla y el gráfico resultante en el DIV 2 resultado principal (Ver figura 22). Por otra parte, si la consulta no arroja ningún resultado, se muestra el mensaje generado por el action notfound dentro de ese mismo DIV. 1 Imagen tomada de (Martín Córdova y Asociados C.A., 2009b) y versionada por el grupo de trabajo 2 Consultar término en el glosario. 70 Al hacer clic sobre alguno de los registros arrojados por la consulta, se invoca vía Ajax el action drilldown que ejecuta las consultas correspondientes y muestra el resultado en el DIV específico para esta consulta (DIV respuesta DrillDown en la figura 22). Siempre que se invoca un action vía Ajax, se oculta un DIV y se muestra el DIV con el indicador de progreso. Cuando el resultado llega, se esconde el DIV de progreso y se muestra el DIV de resultado. Si se quiere utilizar los actions excel y pdf, se deberá crear una clase para cada uno de ellos. Estas clases se crean rápidamente a partir de plantillas prefabricadas que extienden a clases genéricas del framework (Ver diagrama de clases en la figura 25). Figura 24: Plantilla ViewChart - Diagrama de actions. (Martín Córdova y Asociados C.A., 2009b) 1 1 Imagen tomada de (Martín Córdova y Asociados C.A., 2009b) y versionada por el grupo de trabajo 71 Figura 25: Plantilla ViewChart - Diagrama de clases 2.2.10 Ventajas Además de las ventajas que traen consigo los frameworks como son la reutilización de código, manejo de una estructura estándar, optimización de procesos, entre otros, el uso de Dinámica en el desarrollo de aplicaciones implica: • Alta reutilización. El framework promueve la reutilización de código y de soluciones, ahorrando tiempo de desarrollo, facilitando el trabajo del programador y optimizando los procesos al utilizar soluciones ya probadas. • Minimiza el tiempo de desarrollo. Dinámica utiliza RAD. Este tipo de tecnología está orientada al desarrollo fácil y rápido de aplicaciones, pudiendo crear aplicaciones en un corto periodo de tiempo. • Uso de plantillas prefabricadas. Dinámica cuenta con una variedad de plantillas diseñadas para resolver los problemas más comunes en las aplicaciones de software. Estás plantillas han sido probadas y están listas para ser usadas, simplemente configurando los archivos necesarios. • Validación automática de formularios a través de la configuración de un archivo. Con el uso de Dinámica no es necesario programar para realizar la 72 validación de los diferentes elementos manejados en un formulario. Simplemente se utiliza un archivo validator y se añade la línea correspondiente a la validación requerida. • Multiplataforma. Al estar desarrollado en Java, bajo el estándar J2EE, obtiene las características de portabilidad de este lenguaje pudiendo ejecutarse en múltiples plataformas. • Reducción de Errores. La programación declarativa hace uso de clases genéricas, reduciendo los errores, y facilitando el mantenimiento. • Separación de la presentación de la lógica del negocio. Dinámica implementa el modelo MVC que permite, entre otras cosas, mantener la presentación separada de la lógica del negocio. Esto facilita la modificación de las páginas HTML, al contar con un código limpio y fácil de entender y mantener. Permitiendo además conservar la integridad estructural de la aplicación a medida que el proyecto va creciendo. • Manejo de estándares. Las aplicaciones construidas con Dinámica son cien por ciento compatibles con la especificación de Servlets y corren en cualquier servidor. Brindan soporte a BDs SQL tanto comerciales como de código abierto (Oracle, SQLServer, Sybase, y PostgreSQL, entre otras). • Herramienta gratuita. Dinámica posee licencia LGPL pudiendo ser utilizado de forma gratuita para el desarrollo de cualquier tipo de aplicación. Todas las plantillas y su correspondiente documentación se encuentran disponibles en el sitio web del framework. • Manejo de seguridad. Brinda las herramientas necesarias para un manejo centralizado de la seguridad. Incluye también elementos para evitar inyección de código y un administrador de seguridad para el manejo de sesiones y usuarios. 73 • Manejo transparente de BD. Tanto la apertura y cierre de la conexión a la BD como las diferentes consultas son manejadas por el framework de forma transparente. El programador solo debe especificar en un archivo la consulta que desea hacer y el framework se encargará de lo necesario para llevarla a cabo. • Soporte y Documentación. Cuenta con documentación no solo para la instalación y manejo del software sino la explicación del funcionamiento y utilización de cada una de las plantillas disponibles. • Multi-idioma. Posee los elementos necesarios para crear aplicaciones que pueden ser traducidas automáticamente a diversos idiomas. 2.2.11 Plugin Dinámica para Eclipse 2.2.11.1 Descripción El grupo de desarrollo del framework Dinámica creó un conjunto de plugins para el IDE Eclipse, como complemento del framework. Existen dos versiones de estos plugins, una versión gratuita con funcionalidades limitadas y una versión comercial (Dinámica Deluxe) con funcionalidad completa. A diferencia del framework, ambas versiones solo se distribuyen de forma binaria, sin acceso al código fuente (no son open source). Se otorga una licencia por desarrollador o por empresa que da derecho al uso, sin pago de regalías de ningún tipo (royalty free) y sin derecho de redistribución a terceros. La versión gratuita está disponible para ser descargada en el website de Dinámica e incluye un generador de cortesía, para que los usuarios de la comunidad puedan evaluar la tecnología. La versión comercial incorpora un conjunto de ocho auto- generadores de módulos y solo está disponible a través de una suscripción anual que da derecho a mejoras y correcciones, además de soporte y acceso a contenidos exclusivos mediante un portal privado. 74 El paquete de plugins contiene dos plugins: un plugin básico de Dinámica, que permite crear proyectos desde cero, reutilizar plantillas y generar un conjunto de entregables mediante Wizards de exportación y un plugin modelador de base de datos, basado en el plugin open source AmaterasERD 1 al que se ha incorporado una serie de mejoras y extensiones que también incluye los auto-generadores de módulos. 2.2.11.2 Funcionalidad El plugin básico de Dinámica incorpora las siguientes funcionalidades: • Crear aplicaciones web desde cero. • Navegar a un módulo sin necesidad de abrir un browser. • Generar diferentes reportes de sistema. • Generar WAR (solo en Dinámica Deluxe). • Reutilizar las plantillas de Dinámica, extrayéndolas del repositorio y creándolas como un módulo dentro de la aplicación. Por su parte, el plugin modelador de base de datos permite: • Crear un modelo de base de datos de cero, definiendo las tablas, columnas, relaciones e índices. • Crear un modelo de un esquema de base de datos haciendo ingeniería en reverso. 1 Consultar término en el glosario. 75 • Ver los datos de una tabla directo desde el modelo. • Ejecutar comandos SQL hacia la base de datos, • Proveer un editor para comandos SQL que colorea la sintaxis SQL y reconoce los marcadores o etiquetas de Dinámica. • Generar automáticamente un comando SQL para la consulta a la BD. • Generar documentación interactiva del modelo de BD en formato HTML, incluyendo el diagrama. • Generar plantillas de comandos SQL INSERT/UPDATE aptos para Dinámica, con todos los marcadores de los campos, así como el código XML de un archivo validator.xml a partir de la metadata 1 de la tabla seleccionada. • Generar prepared statements y el código Java necesario para invocarlos, usando los APIs de alto nivel de Dinámica para JDBC. Además de las funcionalidades listadas anteriormente, el plugin modelador de base de datos incluye el conjunto de generadores de módulos. Estos generadores pueden crear un módulo completo (plantilla de Dinámica) a partir de la metadata de la tabla o tablas seleccionadas. Teniendo el Diagrama de la BD, se selecciona una tabla, haciendo clic derecho menú "Generador de Módulos". Cada generador presenta una caja de diálogo (Wizard) con la información obtenida del modelo (el wizard se conecta con la BD y muestra al usuario los campos correspondientes). Parte de esta información puede ser configurada y adaptada por el programador para ajustar los parámetros de generación. Sin embargo, es poco lo que se puede hacer con estos datos, solo se puede editar el nombre de la etiqueta y la 1 Consultar término en el glosario. 76 alineación de los campos. No se tiene opción para seleccionar campos, cambiar la posición o el tamaño de las columnas. Cabe destacar que para el funcionamiento del plugin, el repositorio de archivos de Dinámica debe estar almacenado dentro del Tomcat. La Figura 26 muestra un ejemplo del Wizard. Figura 26: Plugin Dinámica para eclipse (muestra) 77 2.3 NetBeans IDE Actualmente existen diversas herramientas que contribuyen al desarrollo del software, facilitando la tarea de los programadores y disminuyendo los tiempos de entrega. Los IDEs 1 probablemente constituyen una de las herramientas más utilizadas, al incorporar facilidades que cubren cada una de las etapas del proceso de desarrollo, además de poseer alto nivel de personalización para adecuarse a las necesidades de cada programador. Pensando en estas necesidades han surgido gran variedad de IDEs. Entre los más populares se encuentra NetBeans IDE que fue el seleccionado para el desarrollo del presente T.E.G. y será el tema a tratar en esta sección. Se incluirá una descripción de sus funcionalidades, ventajas y las facilidades disponibles para el desarrollo de plugins. Este último tema completa el marco teórico del capítulo, iniciado con XP y NetBeans, cubriendo así todos los conceptos asociados al desarrollo del T.E.G. 2.3.1 Descripción NetBeans es un proyecto exitoso de código abierto con una gran base de usuarios, una comunidad en constante crecimiento, con cerca de cien socios y creciendo en todo el mundo. SunMicroSystems fundó el proyecto de código abierto NetBeans en junio 2000 y continúa siendo el patrocinador principal de sus proyectos. El proyecto NetBeans consiste de un IDE open source y de una plataforma de aplicaciones que permite a los desarrolladores crear diversas aplicaciones rápidamente. El IDE NetBeans está construido sobre la plataforma. Esta plataforma es un framework basado en Swing 2 que contiene Interfaces de Programación de 1 Consultar término en el glosario. 2 Consultar término en el glosario. 78 Aplicaciones (API por sus siglas en inglés Application Program Interface) 1 que simplifican el manejo de ventanas, acciones, archivos y muchos otros elementos que normalmente forman parte de las aplicaciones. Netbeans IDE es un entorno integrado de desarrollo escrito completamente en el lenguaje de programación Java, es una herramienta para programadores pensada para escribir, compilar, depurar y ejecutar programas. A pesar de estar escrito en Java puede servir para cualquier otro lenguaje de programación. NetBeans IDE es totalmente extensible y existe un número importante de módulos para extender. Es un producto libre y gratuito sin restricciones de uso. 2.3.2 Funcionalidades Todas las funciones del IDE son provistas por módulos. Cada módulo provee una función bien definida, tales como el soporte de Java, edición, o soporte para el sistema de control de versiones. NetBeans contiene todos los módulos necesarios para el desarrollo de aplicaciones Java en una sola descarga, permitiéndole al usuario comenzar a trabajar inmediatamente. La plataforma NetBeans permite que las aplicaciones sean desarrolladas a partir de un conjunto de componentes de software llamados módulos. Un módulo es un archivo JAR que contiene clases Java escritas para interactuar con las APIs de NetBeans y un archivo especial (manifest file) que lo identifica como módulo. Las aplicaciones construidas a partir de módulos pueden ser extendidas agregándole nuevos módulos. Debido a que los módulos pueden ser desarrollados independientemente, las aplicaciones basadas en la plataforma NetBeans pueden ser extendidas fácilmente por otros desarrolladores de software. La versión actual es NetBeans IDE 6.9.1 y extiende las características existentes de Java EE. Permite crear aplicaciones empresariales, web, de escritorio y móviles bajo 1 A lo largo del documento se hará referencia al término Interfaz de Programación de Aplicaciones utilizando las siglas API. 79 plataforma Java, así como C/C++, PHP, JavaScript, Groovy, y Ruby. Esta versión introduce JavaFX Composer, soporte para JavaFX SDK 1.3, interoperabilidad OSGi, soporte para el framework PHP Zend y Ruby on Rails 3.0. (NetBeans, s.f.). Además cuenta con un constructor intuitivo de interfaces Matisse, soporte de CVS, soporte a Sun ApplicationServer 8.2, Weblogic9 y JBoss 4 y está dando soporte a frameworks comerciales como son Struts 1 y Hibernate 2 . La figura 27 muestra un ejemplo de este IDE. Figura 27: Entorno NetBeans (muestra)3 2.3.3 Ventajas La utilización de NetBeans IDE para el desarrollo de aplicaciones trae consigo diversas ventajas. Algunas de ellas se listan a continuación: • Código abierto y distribución gratuita. NetBeans es un producto de código abierto, con todos los beneficios del software disponible en forma gratuita, el cual ha sido examinado por una comunidad de desarrolladores. Este enfoque de bienes comunes creativos ha permitido una mayor capacidad de uso con cada nueva versión y ha proporcionado a los desarrolladores mayor flexibilidad, al modificar 1 Consultar término en el glosario. 2 Consultar término en el glosario. 3 Imágenes tomadas de NetBeans.com 80 el IDE, si así lo desean. Para la mayoría de los desarrolladores de aplicaciones, el portal de desarrollo netbeans.org es la dirección integrada para descargas del ambiente, conjuntamente con paquetes de características especiales e información sobre el IDE. • La integración de múltiples herramientas y protocolos proporciona razones para la migración. Las amplias posibilidades de desarrollo multiplataforma de NetBeans atraen a muchos desarrolladores que han trabajado con otras herramientas. Los desarrolladores acostumbrados a trabajar con herramientas basadas en la tecnología Java, tales como el conjunto de herramientas Borland JBuilder, descubren que la migración a NetBeans puede acelerar en forma significativa los esfuerzos de desarrollo. • Facilidad de uso durante todo el ciclo de desarrollo. La facilidad de uso de NetBeans también resulta llamativa, ya que no es necesario ir más allá del portal netbeans.org, para buscar las características adicionales y los plugins de los paquetes de funciones que abarcan una diversidad de requerimientos, desde C/C++ hasta movilidad y la Web. • El soporte al modelado mejora la productividad del desarrollador. Mientras los desarrolladores descubren cómo el vasto conjunto de herramientas incluidas en NetBeans facilita el desarrollo de aplicaciones, los encargados de tomar decisiones corporativas han aprendido que el IDE mejora la productividad, a través de funciones de eficiencia integradas. Por ejemplo, la versión más reciente de NetBeans permite que el desarrollo de aplicaciones multiplataforma incluya las características de productividad disponibles en Sun Studio Enterprise. • Promoviendo las mejores prácticas para la productividad del grupo. Igualmente, NetBeans elimina la necesidad de los equipos de desarrollo que tienen que invertir demasiado tiempo manteniendo los modelos actualizados con revisiones exhaustivas que garanticen la actualización de indicadores y códigos de 81 anotación. Juntas, estas características pueden ahorrar al desarrollador muchas horas de trabajo y acelerar la disponibilidad de un nuevo programa. • Creado para acelerar el desarrollo. Permitir que los desarrolladores se concentren en la lógica comercial durante todo el ciclo de desarrollo de la aplicación es también una reflexión de cómo el software debe satisfacer los requerimientos del mercado, en la actualidad. En áreas como SOA, donde los procesos del negocio que cambian constantemente definen el uso y el diseño de la aplicación, los desarrolladores deben ser cada vez más hábiles. Las características de NetBeans como son la flexibilidad entre plataformas, el cumplimiento de UML y la capacidad de administrar la complejidad, ayudan a garantizar que las aplicaciones cumplan con los requerimientos específicos del negocio. • Soporte a desarrollo de módulos o plugins. Algunos ambientes de desarrollo requieren que los desarrolladores traten de descubrir plugins y funciones específicas, mientras otros ambientes de desarrollo integrados carecen de opciones de soporte profesional. Además, a muchos otros les faltan funciones vitales, lo cual dificulta la creación de software, en particular, en el desarrollo de aplicaciones multiplataforma. Posiblemente y de manera más notable, la carencia de soporte a estándares de la industria, a menudo, entorpece el desarrollo y, posteriormente, crea grupos de usuarios finales frustrados, al momento de aparecer una nueva aplicación creada con conjuntos de herramientas menos integrados. NetBeans IDE supera las deficiencias asociadas con otras plataformas de desarrollo y se abren nuevas posibilidades para alcanzar el desarrollo rápido y eficiente de aplicaciones multiplataforma. 82 2.3.4 Desarrollo de Plugins con NetBeans Un plugin es un programa que incrementa las funcionalidades del software principal añadiendo una función nueva, generalmente muy específica. Lo más común es que el plugin sea realizado por una compañía diferente a la que desarrolló el software principal. La idea es que el nuevo componente simplemente se integre al sistema existente. Actualmente existe como una forma modular de expandir programas, para que se puedan añadir funcionalidades sin afectar a las funcionalidades existentes o complicar el desarrollo del programa principal. Es un módulo aparte que se incluye opcionalmente en una aplicación. Constituye una forma bastante conveniente de incrementar las capacidades del software; ya que permite que otros proveedores incorporen funciones no previstas en el desarrollo original, brindando al usuario la posibilidad de agregar funciones especiales y personalizarlas según sus necesidades. La aplicación principal proporciona servicios que los nuevos componentes pueden utilizar, incluyendo un método para que se registren a sí mismos y un protocolo para el intercambio de datos. Estos componentes dependen de los servicios prestados por la aplicación principal y generalmente no funcionan por sí solos. La aplicación principal funciona independientemente de ellos, permitiendo a los usuarios finales añadir y actualizar los complementos de forma dinámica sin necesidad de hacer cambios a la aplicación principal. El API ofrece una interfaz estándar, permitiendo que terceros creen plugins que interactúen con la aplicación principal. Un API estable permite que complementos de terceros funcionen como la versión original y amplíen el ciclo de vida de las aplicaciones obsoletas. Los plugins tienen menos restricciones en sus acciones y pueden proporcionar su propias interfaces de usuario. 83 Cualquier aplicación puede proveer soporte para plugins, pero el software que normalmente suele incluir este tipo de complementos son los navegadores web, reproductores de música y manejadores de contenido. En lo que respecta a NetBeans, tanto la plataforma completa como las aplicaciones construidas sobre ella están divididas en módulos y cada una de las funcionalidades de una aplicación en la plataforma puede ser provista por un módulo distinto de NetBeans, algo parecido a un plugin. Un módulo NetBeans es un grupo de clases Java que proveen una funcionalidad específica junto con una descripción de interfaces que el módulo expone, así como la descripción de otros módulos necesarios para su funcionamiento. Se pueden crear nuevos módulos de NetBeans para uso personal. Para permitir que las aplicaciones posean el mismo nivel de modularidad, la plataforma crea mecanismos y conceptos disponibles que permiten a los módulos ser extendidos por otros módulos además de permitir comunicarse entre ellos sin tener que depender unos de otros (mínimo acoplamiento). La plataforma NetBeans desarrolla un concepto declarativo a través del cual la mayoría de los elementos necesarios para el desarrollo de las funcionalidades son definidos en archivos de descripción y configuración para evitar conexiones de estos componentes con el código fuente Java. El IDE NetBeans contiene soporte específico que facilita el desarrollo de módulos y aplicaciones así como su ejecución y depuración. Cuenta incluso con ejemplos que constituyen aplicaciones pre-construidas con todo el código necesario para su funcionamiento y están disponibles en la sección de ejemplos (New Project Samples). 84 Otros de los elementos de configuración del módulo como la ubicación y la suite a la que va a pertenecer (en caso de ser necesario) son definidos a través del wizard así como las propiedades para identificación del módulo. Crear el esqueleto de una aplicación es tan simple como crear una nueva Module Suite utilizando la plantilla mencionada anteriormente. Decidir si la aplicación será un plugin del IDE o una aplicación aparte se hace a través de la configuración y puede ser cambiada en cualquier momento. Un módulo de NetBeans es simplemente un JAR que contiene cierta metainformación almacenada en un archivo manifiesto. Entre la metainformación se encuentra la versión del módulo, las dependencias, descripción de funcionalidad, datos del autor, etc. En lo que se refiere a la estructura de los módulos, normalmente están formados por un archivo Manifest (manifest.mf), un archivo Layer (layer.xml), archivos de clases y diversos recursos como iconos, paquetes de propiedades, secciones de ayuda, entre otros. Además de los archivos mencionados, cada módulo necesita un archivo XML de configuración utilizado para introducir el módulo a la plataforma NetBeans. La presencia de los diversos archivos depende de las funcionalidades que presta el módulo así como del propósito para el que fue creado. A continuación se presenta una breve descripción de cada uno estos archivos. • El archivo manifest proporciona una descripción del módulo, sus interfaces y su ambiente. Es el único archivo obligatorio, ya que contiene el identificador del módulo. Existen diversos atributos asociados al módulo que brindan información sobre descripción, versiones, dependencias, servicios, interfaces y visibilidad. • El archivo layer constituye el archivo central de configuración en el que se define virtualmente todo lo que el módulo añade a la plataforma NetBeans. Puede ser visto como la interfaz entre el módulo y la plataforma, describiendo declarativamente la integración del módulo a la plataforma. El formato del 85 archivo está definido por una estructura jerárquica del sistema de archivos con los respectivos directorios, archivos y atributos. Durante el inicio de la aplicación, todos los archivos layer son unificados en un sistema de archivos virtual conformando el llamado FileSystem que constituye la configuración de la plataforma NetBeans en tiempo de ejecución (Böck, 2009, p. 24). • El archivo de propiedades o Bundle.properties contiene el paquete de localización 1 para la información registrada en el archivo manifest. La localización en NetBeans, se refiere al proceso de crear o proveer elementos (como texto, iconos, entre otros) específicos a un país o lenguaje, brindando cierta personalización a la GUI (Böck, 2009, p. 31). • Clases. Los archivos de clases presentes en el módulo dependerán de las funcionalidades a implementar. Normalmente se cuenta con una clase action que contiene el código de la funcionalidad y las clases WizardPanel y VisualPanel, en caso de contar con interfaz gráfica (Wizard). • Otros Recursos. Podrán incluirse otros recursos como íconos para identificar el action del módulo en el IDE NetBeans y permitir su ejecución, así como otras imágenes y archivos necesarios para la implementación de la funcionalidad. • Archivo de configuración: localizado fuera del módulo, sirve para declarar el módulo en el sistema de módulos de la plataforma NetBeans. Este archivo es leído por el sistema de módulos y la información que contiene se utiliza para cargar el módulo en el sistema. Contiene el nombre, versión y localización del módulo así como la forma en que debe ser cargado en el sistema. La figura 28 muestra la estructura general de un módulo de NetBeans. 1 Consultar término en el glosario. 86 Figura 28: Estructura de un módulo NetBeans 1 2.3.5 Wizards Un wizard es una ventana que guía al usuario paso a paso para llevar a cabo una tarea determinada. A través de estos pasos, el wizard solicita una serie de respuestas del usuario y ejecuta la tarea basada en esas respuestas. Exceptuando las respuestas del usuario, el wizard provee toda la información necesaria para la ejecución de la tarea. Usualmente, los wizards se crean para simplificar una tarea permitiendo que usuarios inexpertos puedan llevarla a cabo fácilmente. Otra razón para la creación de wizards es agilizar una tarea compleja, agrupando los diferentes pasos en una sola interfaz. De esta forma, los wizards no solo simplifican las tareas sino que agilizan su ejecución (Sun Microsystems, Inc., 2001). 1 Imagen tomada de (Böck, 2009) y versionada por el grupo de trabajo 87 NetBeans IDE cuenta con diversos wizards para la creación de plugins y estos wizards a su vez, forman la interfaz gráfica de usuario utilizada para la ejecución de las diferentes funcionalidades (como por ejemplo la creación de proyectos, modificación de propiedades, manejo de archivos y librerías, entre otros). La Figura 29 muestra la interfaz estándar de NetBeans (wizards) y sus diversos elementos. Figura 29: Interfaz estándar de NetBeans (Ejemplo de wizard) 88 2.3.5.1 Estructura y funcionamiento del wizard Tomando como referencia Böck (2009, pp. 141-142, 149-150), se describen a continuación tanto la estructura general de un wizard como la interacción de sus componentes durante su funcionamiento. La clase WizardDescriptor es una subclase del DialogDescriptor (clase estándar para la creación de diálogos) y es la que describe y configura los wizards. A su vez, la clase DialogDescriptor es una subclase de la clase NotifyDescriptor (clase que provee la descripción de notificaciones de usuario). El WizardDescriptor contiene y maneja todos los paneles en los wizards y es el responsable de diversas tareas como el manejo de los pasos y la muestra de los componentes de la GUI. En otras palabras, el WizardDescriptor es el controlador de todo el wizard. Normalmente, el WizardDescriptor provee el modelo de datos o DataModel donde se guarda la data proveniente de cada uno de los pasos. Este DataModel se puede sustituir por un modelo propio. Para cada paso del wizard, se provee un panel. Normalmente el panel se constituye de dos clases separadas. La primera clase, es el llamado panel visual o VisualPanel, implementa la GUI y usualmente extiende de JPanel. La segunda clase, llamada WizardPanel (en el diagrama) se encarga del manejo, administración y validación del panel. Extiende la clase NetBeans API WizardDescriptor.Panel<Data> y crea el panel visual a demanda, dejándolo disponible para el wizard. Tomando como base el paradigma MVC, el panel visual representa la Vista y el wizard panel actúa como controlador. El panel visual solo se encarga de lo concerniente a la interfaz de usuario proveyendo elementos que permitan la entrada de datos del usuario y haciéndolos disponibles a través de métodos get() y set(). El panel visual no contiene lógica del negocio ni maneja clases o llamadas específicas del wizard. Como resultado, el panel es totalmente reutilizable y puede ser portado hacia un wizard completamente diferente. De esta forma, el panel puede ser reutilizado en un diálogo donde la data es editada en un contexto distinto. La relación 89 entre WizardDescriptor, WizardPanel y VisualPanel se muestra en el diagrama de clases de la Figura 30. Figura 30: Arquitectura de un wizard 1 En lo que respecta al wizard se inicializa en el método performedAction () de la clase Action, que crea una instancia del ModuloWizardDescriptor. Este WizardDescriptor genera los paneles y registra un ChangeListener por cada uno de ellos para que se envíe una notificación cada vez que cambie el estatus de un panel. El VisualPanel se obtiene a través del método getComponent() del WizardPanel. Este método crea el panel visual (ModuloVisualPanel1 en el diagrama) a demanda y registra un PropertyChangeListener para informar los cambios realizados por el usuario en el panel (como el ingreso de nueva data o el cambio de la data existente). El WizardDescriptor observa el estatus de sus paneles a través del ChangeListener, que 1 Imagen tomada de (Böck, 2009) y versionada por el grupo de trabajo 90 a su vez observa el estatus de los paneles visuales a través de PropertyChangeListener. Cuando el usuario ingresa data en algún campo que tiene un listener asociado, se dispara un PropertyChangeEvent, notificando al WizardPanel que la data ha cambiado. El wizard panel recupera la data a través de los métodos get() y realiza la verificación correspondiente. Dependiendo del resultado de la verificación, se actualiza el estatus del panel. Si el estatus del panel ha cambiado, se dispara un ChangeEvent, notificando al WizardDescriptor para que verifique el estatus del panel, llamando al método isValid(). Dependiendo del valor arrojado por el método isValid(), el WizardDescriptor activa o desactiva los botones del wizard. Figura 31: Diagrama de secuencia. Interacción entre WizardDescriptor, WizardPanel y VisualPanel 1 1 Imagen tomada de (Böck, 2009) y versionada por el grupo de trabajo 91 CAPÍTULO III: Marco Aplicativo En los capítulos anteriores se presentó tanto la propuesta para el T.E.G (Capítulo I) como los conceptos necesarios para la comprensión de su desarrollo (Capítulo II). El capítulo actual muestra la aplicación de esos conceptos y la forma en que se llevó a cabo el objetivo propuesto. Se explican los detalles de la implementación y de todo el proceso de desarrollo. 3.1 Tecnología utilizada El framework Dinámica fue desarrollado teniendo como base la metodología ágil y utilizando el lenguaje de programación Java. Por esta razón la tecnología utilizada para el desarrollo del plugin estuvo basada en estos componentes. Se utilizó la programación extrema (XP) como metodología ágil de desarrollo, Java como lenguaje de programación, Apache Tomcat como contenedor Web y NetBeans IDE para la creación del plugin. A continuación se detallan los aspectos técnicos relevantes en el proceso de desarrollo. 3.1.1 NetBeans IDE: la selección de este IDE para el desarrollo del plugin fue un requisito del usuario. Por esta razón, se siguieron las convenciones establecidas por la plataforma para este tipo de desarrollos, como el uso de wizards para la ejecución de ciertas tareas. Aún cuando existe la alternativa de modificar la interfaz de usuario, se decidió mantener el uso de estos wizards para favorecer la utilización de la herramienta por parte del usuario y brindar consistencia al presentarle al usuario final el mismo entorno gráfico con el que está familiarizado. Cabe destacar que el IDE cuenta con una herramienta para la construcción de interfaces gráficas (“Matisse” Swing GUI Builder) que facilitó no solo la creación de los prototipos necesarios sino la codificación posterior. 92 3.1.2 Java: por ser el lenguaje de programación utilizado para el desarrollo del framework Dinámica (base de la propuesta del T.E.G.) se consideró conveniente su selección como lenguaje de programación para llevar a cabo el desarrollo del plugin. Las distintas APIs y librerías disponibles en este lenguaje fueron de gran ayuda durante el desarrollo. Ejemplo de ello son las APIs para: el diseño de interfaces (Swing), la conexión y consulta a BDs (JDBC) y el manejo y creación de archivos (paquete java.io). 3.1.3 Dinámica: para la utilización del framework Dinámica en el desarrollo del plugin, se debió descargar de la página Web todos los archivos correspondientes a las plantillas que se incluirían en el plugin. Estos archivos debían ser modificados y preparados para su inclusión y futura configuración. Agregando etiquetas o palabras clave que luego serían sustituidas por los datos de configuración respectivos. Se debía incluir también los drivers para la conexión con el servidor de BD (driver JDBC para PostgreSQL) y las distintas librerías necesarias para la correcta ejecución de las funcionalidades que no están contempladas en la configuración básica por considerarse elementos adicionales. 3.1.4 Otros aspectos: En lo que respecta a la instalación y configuración de las herramientas utilizadas durante el desarrollo, debido a requerimientos del cliente, se utilizó PostgreSQL como manejador de BD y la instalación y configuración del servidor correspondiente se realizó con antelación. El contendor web Apache Tomcat, se incluyó en el paquete inicial de las herramientas de NetBeans por lo que su instalación y configuración se realizó de forma automática al momento de instalar el IDE. 3.2 Adaptación de la Metodología XP Para el desarrollo del plugin se siguió la metodología XP explicada en el capítulo anterior. En las secciones siguientes se explica los detalles del proceso. 93 3.2.1 Descripción general A continuación se dará una descripción general del proceso de desarrollo utilizando como base algunas de las prácticas y principios de XP. 3.2.1.1 Equipo de desarrollo (Cliente en el sitio): El equipo de desarrollo estuvo conformado por los programadores encargados de la creación del T.E.G. y los programadores usuarios del framework Dinámica que constituyen el rol de cliente en la metodología XP. Cabe destacar que en este caso particular, los desarrolladores de la aplicación forman parte de los futuros usuarios. Por lo tanto debieron conformar o unificar ambas visiones (cliente y desarrollador) para su participación en el proceso, 3.2.1.2 Proceso de planificación/Comunicación: durante todo el desarrollo hubo una comunicación constante caracterizada por el respeto a las ideas aportadas por los diferentes miembros del equipo. Se escucharon opiniones y sugerencias de los usuarios expertos para determinar las soluciones que mejor se adaptaban a las necesidades del negocio. Además de fomentar la discusión de los resultados obtenidos en las pruebas funcionales. 3.2.1.3 Metáforas: tomando en cuenta que tanto desarrolladores como clientes formaban parte del grupo de usuarios finales, se manejaba un lenguaje común totalmente comprensible por todos. 3.2.1.4 Pruebas/Feedback: la primera muestra de feedback se presentó durante la etapa de planificación cuando clientes y desarrolladores se reunieron para determinar el objetivo del sistema. Posteriormente, a medida que se iban desarrollando cada uno de los módulos, se presentaba al cliente un boceto de interfaz inicial y se registraban sus sugerencias y observaciones, se hacían los cambios pertinentes y se presentaban nuevamente al usuario hasta lograr su aceptación. Una vez aprobada la interfaz gráfica de usuario (GUI1 por sus siglas en inglés), durante el desarrollo de las funcionalidades, los programadores hacían pruebas funcionales, verificando el código 1 Consultar término en el glosario. 94 a medida que se obtenían las respuestas del sistema, para hacer los cambios necesarios. 3.2.1.5 Refactorización / modificaciones incrementales /coraje: durante todo el proceso de desarrollo, se escuchaban las diferentes sugerencias, se probaban y seleccionaba la mejor opción y se realizaban cambios continuamente para procurar mejoras en el sistema. Un ejemplo de ello se dio, cuando al haber completado el desarrollo de varios módulos, se determinó una forma más eficiente de recolectar los datos de configuración que incrementaba la usabilidad del sistema y se decidió realizar nuevamente estos módulos para adaptarlos a la nueva implementación. También se tomó el código desarrollado en cada módulo para el manejo de archivos y de BDs y se crearon las librerías respectivas, cambiando el código de los módulos desarrollados para amoldarlos a esta nueva implementación (invocar las funciones de la librería en lugar de los métodos de la clase). 3.2.1.6 Versiones pequeñas/código simple: el sistema posee un diseño modular que permitió trabajar desarrollando módulo a módulo, integrándolos a la estructura principal a medida que se iban completando y probando. Por otra parte, solo se desarrollaron aquellas funcionalidades seleccionadas por el usuario para mantener la sencillez en el sistema. Pensando en este mismo propósito, se revisó el código constantemente para evitar la duplicación de funciones. Un ejemplo de ello lo constituye la remoción del plugin Demo de la lista de requerimientos. La realización de este plugin fue propuesta inicialmente por el equipo de desarrolladores y posteriormente removida al determinarse que no sería utilizada por el cliente. 3.2.1.7 Programación en parejas/propiedad colectiva: esta práctica de XP se cumplió de una forma bastante particular. Los programadores se reunían continuamente para desarrollar, compartir, explicar y revisar el código desarrollado. Aún cuando el desarrollo se hacía de forma simultánea, muchas de las veces no se compartía la estación de trabajo. En momentos donde este tipo de programación no era posible, la comunicación establecida se realizó vía web utilizando las diversas 95 herramientas disponibles (MSN, Skype, entre otras). La forma de trabajo cumplió con la práctica de propiedad colectiva donde ambos miembros del equipo de desarrolladores tenían acceso a todo el código y lo modificaban a voluntad cada vez que lo consideraran necesario. 3.2.1.8 Estándares de codificación: antes de iniciar el proceso de desarrollo se acordó seguir ciertas convenciones para la escritura de código, básicamente aquellas establecidas por la plataforma de trabajo, como el desarrollo modular, con el uso del wizard como estructura base para el desarrollo de los módulos y la adopción de Matisse como herramienta para el desarrollo de la GUI. 3.2.1.9 Trabajo de calidad: la implementación constante de pruebas, aunada a la revisión del cliente, aseguraron la realización de un buen producto de software que satisficiera las necesidades del cliente y agregara valor a su negocio. 3.2.1.10 Cuarenta horas semanales: esta práctica fue implementada durante las primeras etapas del proceso. Conforme se acercaba la fecha de la entrega o culminación del proyecto, se debió aumentar la dedicación para poder cumplir con los objetivos planteados. 3.2.2 Ciclo de vida La implementación de la metodología XP se realizó teniendo como base los objetivos específicos planteados en el T.E.G. que constituirían las historias de usuario. El proceso de desarrollo se llevó a cabo siguiendo las diferentes fases del ciclo de vida XP, contando con las fases de exploración, planificación, iteración y producción. La exploración permitió la familiarización con las diferentes tecnologías a utilizar. La fase de planificación sirvió para determinar la arquitectura del sistema, establecer las historias a desarrollar y los tiempos de entrega de cada una. La fase de iteración fue donde se llevó a cabo el desarrollo de las funcionalidades a través de diferentes iteraciones. Por último la fase de producción abarcó la prueba e integración del 96 sistema. Esta última fase se llevó a cabo dentro de cada una de las iteraciones. La metodología XP incluye una quinta fase, llamada muerte. Como se verá más adelante, esta fase no fue contemplada dentro del desarrollo. La adaptación que se hizo de esta metodología consistió en definir una iteración por cada uno de los módulos a desarrollar. Las revisiones y cambios necesarios se consideraron como pasos dentro de la misma iteración siempre y cuando no representaran cambios considerables en la estructura o código total como se verá posteriormente. De esta forma, tanto la documentación del proceso como su seguimiento se hacen más fáciles de realizar y entender. Los detalles de este proceso se presentan a continuación. 3.2.2.1 Fase de exploración En esta fase se buscó cumplir los objetivos específicos referentes al aprendizaje, que implicaban la investigación o estudio de las tecnologías a utilizar. Uno de los elementos a considerar para la investigación fue las características generales y elementos funcionales de NetBeans que intervenían de alguna forma en el proceso de desarrollo (sistema de archivos, manejo de wizards y diversos elementos de configuración), así como las especificaciones para el desarrollo de plugins en NetBeans (creación y manejo de módulos). Otro punto importante lo constituyó el estudio detallado de las características del framework Dinámica, así como la familiarización con las facilidades de NetBeans para el desarrollo de interfaces Swing (incluidas en el desarrollo de plugins) y demás funcionalidades. Los objetivos cubiertos en esta fase son: • Estudiar con mayor profundidad el Framework Dinámica. • Investigar los procedimientos para crear plugins en el IDE NetBeans. 97 • Estudiar la metodología de XP y familiarizarse con sus prácticas, principios y actividades. • Adaptar la metodología XP proceso de desarrollo. 3.2.2.2 Fase de planificación Siguiendo los lineamientos de XP, esta fase comprende la definición de las diferentes iteraciones que se llevaron a cabo para cumplir con los objetivos planteados. Se definió la metáfora del sistema así como la agenda con las funcionalidades a desarrollar y los tiempos estimados para llevar a cabo cada una de ellas. El detalle de estas iteraciones se explicará en secciones posteriores. En esta fase se determinaron las historias de usuario que serían desarrolladas, tomando como historia inicial el objetivo principal del T.E.G. (creación de un plugin para NetBeans que agilice el desarrollo de aplicaciones web utilizando el framework Dinámica). Esta historia constituye la metáfora del sistema, determinando así la arquitectura general de la solución que será mostrada en la primera iteración. Considerando los principios que rigen XP y dada la complejidad de la historia planteada, se debe dividir en historias más pequeñas que a su vez contendrán las tareas a realizar a lo largo de las iteraciones. Cada una de estas historias de usuario será desarrollada como un módulo o plugin independiente. Producto de las conversaciones con los usuarios y de la experiencia personal de los desarrolladores en el uso del framework, surgió un listado preliminar de los módulos o historias de usuario a desarrollar para cubrir las necesidades del cliente. Este listado tomaba como punto de partida el desarrollo de cuatro plantillas básicas o generales, como son: el proyecto base Dinámica, el proyecto Security, el proyecto Demo (que contendría los ejemplos de plantillas) y el action personalizado. Posteriormente, se debía desarrollar ocho plantillas específicas: Agenda, Calendario, CRUD, 98 ExportPDF, Filter, ImportExcel, PagedView y PickList. Durante las iteraciones, se amplió el listado de requerimientos para incluir cuatro plantillas más: Chart, ExportExcel, CRUDMasterDetail, CRUDSimple, La Tabla 3 muestra la planificación del proyecto, indicando las fechas de las primeras estimaciones realizadas durante la etapa de planificación (inicio y fin estimado en La Tabla) y las fechas en las que realmente se llevaron a cabo las historias de usuario (inicio y fin real en La Tabla). Un punto importante lo constituyen los cambios que surgieron a lo largo del proyecto, durante los cuales se eliminó el Demo de Dinámica (indicado con fondo naranja en el tabla) de la lista de requerimientos a desarrollar, por no considerarse necesario o relevante para el cliente actual y se añadieron otros plugins que surgieron como requisito durante la realización del proyecto (con fondo azul en el tabla). 99 Tabla 3: Planificación del proyecto T.E.G La Figura 33 ilustra el Diagrama Gantt de la planificación inicial (tiempo estimado en el diagrama) versus la planificación realizada (tiempo real en el diagrama). 100 Figura 32: Diagrama Gantt Tiempo Real vs. Tiempo Estimado 3.2.2.3 Fase de iteración En esta fase de la metodología XP se deben desarrollar las historias de usuario creadas en la fase de planificación, definiendo una iteración para cada historia. 101 Como se indicó en la fase anterior, para el desarrollo del T.E.G. se tomó el objetivo principal como la historia de usuario que determinaría lo que debe hacer el sistema (metáfora). Por otra parte, en el capítulo de la propuesta se indicó que para poder cumplir este objetivo, se deben llevar a cabo una serie de objetivos específicos, por lo que estos objetivos (solo aquellos referentes a las funcionalidades del sistema) constituyen la forma natural de dividir la historia principal en historias más sencillas. El desarrollo de estas historias constituirá cada una de las iteraciones a realizar. Tomando en cuenta la arquitectura modular del sistema planteado, las historias se pueden desarrollar de forma independiente sin afectar el comportamiento general del sistema, favoreciendo además el desarrollo incremental característico de XP, al integrar cada funcionalidad (módulo) a medida que se va desarrollando. Para registrar cada una de estas historias se utilizaron las llamadas story card definidas en el capítulo de XP. El formato utilizado contenía tanto el id, nombre y descripción de la historia como las estimaciones realizadas en la etapa de análisis (tiempo de desarrollo estimado, fechas de inicio y culminación) y la prioridad definida por el cliente. Al igual que en el desarrollo general del proyecto, en cada una de las iteraciones se deben cumplir ciertos pasos para llegar a la solución. Estos pasos corresponden a las actividades de XP, que son análisis, diseño, codificación y prueba y su implementación será explicada a continuación. 3.2.2.4 Análisis. En este paso se reúne toda la información necesaria para llevar a cabo el desarrollo de la iteración, determinando cuáles son las funcionalidades que debe cubrir el módulo y los datos necesarios para llevarlas a cabo, así como las validaciones correspondientes. Se precisan diversos elementos como son: datos de configuración necesarios, cantidad de paneles a utilizar para obtener esos datos y propósito del módulo. Se determinan también las validaciones correspondientes para asegurar que se introducen todos los datos necesarios y que esos datos son los adecuados. Para recabar o agrupar todo esta información, se utilizaron tablas de datos que resumían 102 tanto la descripción de cada plantilla como los parámetros necesarios para su creación y configuración, así como los archivos que se debían generar como resultado de la ejecución de cada módulo. 3.2.2.5 Diseño. En esta etapa se determina la estructura del módulo a desarrollar, que estará determinada tanto por la cantidad de datos a solicitar como por la división que se haga de ellos. Corresponde a la creación del módulo y sus respectivos wizards. Como se indicó en la sección de NetBeans del Capítulo II, normalmente un módulo de NetBeans cuenta con ciertos archivos de codificación (un archivo Bundle.properties que contiene los elementos presentes en los paneles así como sus valores iníciales y el archivo Layer.xml) y se puede agregar funcionalidad a través del uso de wizards. El wizard a su vez cuenta con una clase VisualPanel para cada uno de los pasos a seguir (un panel por cada paso), una clase WizardPanel por cada uno de esos pasos, que posee las funcionalidades asociadas a cada panel, y una clase WizardAction que se encarga de abrir e inicializar el wizard del módulo y reunir las funcionalidades asociadas a la creación y configuración de los archivos resultantes, además de cualquier otra clase que se considere necesaria. La cantidad de paneles a utilizar depende de las decisiones tomadas durante el análisis. Esta estructura general (VisualPanel, WizardPanel, WizardAction) se siguió para la creación de todos los plugins de cada iteración (historias de usuario). Para los nombres de las clases se acordó seguir el estándar ModuloVisualPaneln, ModuloWizardPaneln y ModuloWizardAction donde Modulo corresponde al nombre de cada plugin a desarrollar y n es el número correspondiente a cada uno de los pasos del panel (Ej. CalendarioVisualPanel1). Todos los archivos necesarios para la creación y configuración de la plantilla (resultado de la ejecución de cada plugin), se colocan como paquetes dentro de una carpeta resources creada para cada módulo. Dentro de las tareas de la fase de diseño se contempla la creación del módulo y personalización de la GUI. Para la creación del módulo se debe indicar no solo la 103 cantidad de paneles a utilizar (definida anteriormente) sino las clases y librerías necesarias para su funcionamiento, además del punto de acceso a la ejecución del módulo. Este último determina desde qué parte del IDE los usuarios podrán acceder a la funcionalidad, pudiendo ubicarse como opción de un menú existente en la barra de menús, como un menú dentro de la misma barra, como un botón de acceso directo en la barra de herramientas, como una opción dentro del menú contextual (clic derecho), entre otras. La Figura 34 muestra el contenido del archivo layer.xml. Los datos incluidos en este archivo especifican la configuración del módulo, indicándole a la plataforma NetBeans el punto de acceso del módulo, sus atributos y la estructura del filesystem. En esta figura se puede apreciar la estructura jerárquica del sistema de archivos (filesystem). Figura 33: Ejemplo archivo layer.xml El archivo de propiedades Bundle.properties contiene el texto relacionado con cada uno de los elementos de interfaz incluidos en el(los) VisualPanel. Este archivo puede 104 contener incluso valores para elementos de interfaz como tooltips 1 y otros datos utilizados para la identificación del módulo, como son el tipo de módulo y su descripción. Una muestra de este archivo (correspondiente al módulo base desarrollado en la iteración 2) se presenta en la Figura 35. Figura 34: Ejemplo archivo Bundle.properties En lo que se refiere a la personalización de la interfaz, se llevó a cabo a través de la creación de prototipos. Para ello se utilizó la herramienta Matisse. El prototipo creado era sometido a la evaluación del usuario antes de proceder a la codificación de las funcionalidades correspondientes. Dentro de la personalización se asignan los nombres tanto del módulo como de los pasos a seguir. Se incluyen los diferentes elementos para la obtención de los datos necesarios (campos de texto, listas, combos, etc.). A través del proceso de desarrollo se determinó que existe una constante en los datos de configuración solicitados al usuario y consiste en el nombre de la carpeta que 1 Consultar término en el glosario. 105 contendrá la plantilla y la tabla de la BD que se usará como base. Por esta razón, se decidió establecer una especie de estándar para la captación de estos “datos básicos de configuración”, utilizando los mismos elementos de interfaz en todos los módulos que lo ameriten. Para el nombre de la carpeta se decidió utilizar un campo de texto y para el ingreso del nombre de la tabla se decidió utilizar un ComboBox con el listado de las tablas de la BD asociada al proyecto. Otro elemento estándar surgido del proceso de iteración, lo constituyó la utilización de una “tabla de datos” para facilitar al usuario la selección y configuración de múltiples datos. La Figura 36 muestra un ejemplo general de wizard que contiene ambos elementos. Cabe destacar que este proceso de depuración o mejoramiento de la interfaz se produjo durante toda la fase de iteración, hasta llegar a la interfaz final (que además de los elementos citados, incluyó también el uso de imágenes o iconos para identificar). Figura 35: Elementos estándares definidos en iteraciones Otro punto importante relacionado a la GUI manejada por el usuario corresponde a la inclusión del plugin en NetBeans IDE. Para ello se decidió crear dos menús como 106 puntos de acceso a los diferentes plugin. El primer menú forma parte de la barra de menús principal del IDE y presenta un listado con cada uno de los plugins desarrollados. El segundo menú está incluido como opción del menú contextual que surge como elemento emergente al hacer clic derecho sobre una carpeta perteneciente a la jerarquía de archivos mostrada en la ventana de proyectos. La Figura 37 muestra el menú principal y la Figura 38 muestra el menú contextual. Figura 36: Menú principal Figura 37: Menú contextual 107 3.2.2.6 Codificación. La etapa de codificación comprende las tareas agregar funcionalidades y validar datos. Agregar funcionalidades. Corresponde a la codificación de las diferentes funcionalidades incluidas en el módulo (acción de cada elemento de interfaz). La codificación requerida se realiza a través de clases Java que contienen los métodos necesarios para la captación, validación y procesamiento de los datos introducidos por el usuario. Además de estos métodos, se debió incluir métodos para la conexión y consulta a BDs, creación, lectura, copia y manejo de archivos en general para poder generar los directorios de los actions necesarios en cada plantilla, así como el uso de métodos de DOMParser para el manejo de los archivos XML. El desarrollo incluyó también el uso de funciones propias de NetBeans como son lookup() y otras funciones para el manejo de los wizards (WizardDescriptor API). La Figura 39 presenta un extracto de la clase VisualPanel y las Figuras 40 y 41 presentan extractos de las clases WizardPanel y WizardAction respectivamente. Figura 38: Ejemplo clase VisualPanel (módulo CRUD) 108 Figura 39: Ejemplo clase WizardPanel (módulo CRUD) 109 Figura 40: Ejemplo clase WizardAction (módulo Calendario) Entre las funcionalidades más importantes desarrolladas y utilizadas a lo largo de todo el proyecto, se encuentran las funciones copiarArchivo() y crearArchivo() que son las encargadas de la creación y configuración de los archivos necesarios para cada plantilla utilizando como base los datos obtenidos del wizard. La Figura 42 muestra ambas funciones. 110 Figura 41: Funciones para la creación, copiado y configuración de archivos La validación de datos consiste en verificar los datos introducidos por el usuario para asegurar no solo que se introduzcan todos los datos necesarios para ejecutar cada funcionalidad, sino que esos datos sean correctos (verificar la validez de todos los datos ingresados). Cualquier error en el la data suministrada, será indicado en un mensaje de error dentro del panel. Además de las validaciones realizadas dentro de los paneles del wizard, existen validaciones asociadas a la ejecución de cada uno de los módulos, mostrando al usuario mensajes de error que aseguran que cada plantilla 111 sea creada en un directorio válido (dentro de la carpeta WEB-INF/action del proyecto). En todas las iteraciones, la validación de los datos se hizo a través del método validate() del WizardPanel. Este WizardPanel debe implementar WizardDescriptor.ValidatingPanel para poder poder implementar el método. En este método se incluyen todas las validaciones necesarias en cada panel (como la obligatoriedad de los datos), mostrando mensajes de error al usuario cuando los datos ingresados en el wizard no cumplan con las validaciones respectivas. La Figura 43 muestra un extracto del código de la función de validación desarrollada para el módulo base. Figura 42: Extracto del código método de validación (módulo Base). Prueba. Se prueba cada una de las funcionalidades codificadas en el paso anterior para asegurar que se comportan de forma adecuada, obteniendo los resultados esperados. Durante el desarrollo de las diferentes historias se realizaron tanto pruebas funcionales por parte de desarrolladores y clientes, como pruebas de interfaz que beneficiarían la usabilidad del plugin. Estas pruebas de interfaz consistían en desarrollar prototipos que mostraran al usuario no solo la disposición y distribución de los formularios de configuración sino el flujo de los eventos necesarios para llevarla a cabo. Las pruebas funcionales consistían en el uso de los diferentes 112 módulos para comprobar el comportamiento adecuado así como la obtención de los resultados esperados. 3.2.2.7 Fase de producción Una vez desarrollada cada una de las funcionalidades o módulos, se integran en la estructura general y se prueba nuevamente el sistema para comprobar su funcionamiento como una sola aplicación. Debido a la característica de elemento independiente que poseen los plugins (de forma general), en lugar de ser instalado en una sola máquina como lo señala la metodología, las actualizaciones del plugin se publicaban en el servidor para ser descargadas por los usuarios e incorporadas en el ambiente de programación (instalada como plugin de NetBeans) para realizar las pruebas pertinentes. De forma general, se ha cumplido con las historias planteadas, sin ningún cambio significativo, salvo en el caso de la creación de las librerías que debían contener las funcionalidades necesarias tanto para el acceso a la BDs como para el manejo de archivos. La creación de estas librerías constituyó una historia adicional. Otras historias adicionales (no contempladas en la etapa de planificación) e igualmente necesarias a las planteadas inicialmente, que surgieron como requerimiento durante la realización del proyecto, la constituyeron la creación de los plugins Chart, ExportExcel, CRUDSimple y CRUDMasterDetail, completando así el repositorio de plantillas que se adapta a las necesidades del cliente. 3.2.2.8 Fase de mantenimiento Tomando en cuenta que el plugin está conformado por módulos que trabajan de forma independiente, su funcionalidad nunca se vio interrumpida. Los programadores 113 contaban con versiones funcionales del sistema en cada una de las máquinas y éstas se actualizaban cuando estaba disponible la nueva versión. 3.2.2.9 Fase de muerte Aún cuando el plugin ya contiene las funcionalidades solicitadas por el cliente, se ha dejado abierto a cambios y futuras mejoras e intervenciones, por lo que esta fase no ha sido considerada como parte del ciclo de vida o desarrollo del T.E.G. 3.3 Proceso de desarrollo Como se indicó anteriormente, el desarrollo de los objetivos planteados en el T.E.G. se llevó a cabo utilizando la metodología XP, que divide el proceso en pequeñas tareas o iteraciones. Estas iteraciones corresponden a las historias de usuario surgidas en la etapa de análisis de los requerimientos del cliente. A continuación se describen cada una de las 18 iteraciones que conforman el proceso de desarrollo. 3.3.1 Iteración 1. Metáfora del sistema (Crear plugin Dinámica) Figura 43: Story card iteración principal. Creación del sistema 114 Análisis La primera iteración del ciclo de vida (mostrada en la Figura 44) debe contener la definición de metáfora y creación de la estructura del sistema. Diseño Tomando como base los resultados obtenidos en la fase de planificación, se determinó el diseño general del plugin y los diferentes módulos a desarrollar. La Figura 45 ilustra la arquitectura planteada inicialmente a partir de la historia de usuario reflejada en la story card de la Figura 44. Figura 44: Arquitectura de la solución (primer planteamiento de la fase de planificación) Debido a la complejidad que implicaba el desarrollo de este plugin, se decidió tomar esta historia de usuario y dividirla en historias de menor complejidad a realizarse en las siguientes iteraciones. La Figura 46 refleja la división de historias. Figura 45: La historia principal se divide en historias de menor complejidad 115 Teniendo como base la estructura modular de NetBeans y la forma en que se desarrollan los plugins, y pensando además en favorecer la granularidad del sistema y su futuro mantenimiento, se decidió desarrollar cada funcionalidad como un plugin individual que aún cuando formaran parte de la misma aplicación (module suite), funcionaran de forma independiente unos de otros. Estos módulos se construyen sobre la plataforma NetBeans, haciendo uso de las funcionalidades del IDE. La Figura 47 ilustra la arquitectura planteada luego de la división de la historia principal. Figura 46: Arquitectura de la solución (segundo planteamiento de la fase de planificación) De esta forma, se cumple con el objetivo inicial que consistía en crear la estructura general que contendría los diferentes módulos del plugin. Tomando en cuenta las facilidades brindadas por NetBeans, la creación de esta estructura se realiza a través de un module suite explicado en el capítulo anterior (sección desarrollo de plugins en NetBeans). 116 Además de los módulos iníciales, durante la etapa de iteración, se determinó la necesidad de crear dos librerías (BD.jar y File.jar en la Figura 47) que agruparan los métodos necesarios para la mayoría de los módulos, así como la creación de módulos adicionales (Chart, ExportExcel, CRUDSimple, CRUDMasterDetail señalados en rojo en la Figura 48) para cubrir las necesidades del cliente surgidas durante esa etapa. La Figura 48 muestra la arquitectura final del sistema, resultante de la etapa de iteración. Figura 47: Arquitectura de la solución desarrollada Codificación. No existe ningún tipo de codificación asociada a esta iteración, ya que solo se debe determinar y crear la estructura. Para la creación del module suite correspondiente, se 117 utiliza el wizard para la creación de plugins en NetBeans (menú File New Project), se selecciona “NetBeans Module” como categoría del proyecto y “Module Suite” como tipo de módulo. Se proporcionan datos como el nombre del proyecto o module suite, localización de la carpeta del proyecto, nombre de la carpeta y las dependencias del módulo. Una vez creada la estructura, se irán añadiendo los módulos a medida que se vayan desarrollando. Prueba Las pruebas para comprobar el correcto funcionamiento de la estructura, se realizaron en iteraciones posteriores cuando se añadieron cada uno de los módulos. 3.3.2 Iteración 2. Crear proyecto base Figura 48: Story card usada para la Iteración 2. Proyecto base Análisis Para el desarrollo de aplicaciones con el framework Dinámica, se debe contar con un directorio base que contiene tanto la estructura de la aplicación como todas las librerías, scripts y clases necesarias, incluyendo también los archivos de imágenes, estilos (default.css), manejo multi-idioma (labels.xml), entre otros. Aunado a esto, se debe contar con una serie de actions que brindan las funcionalidades básicas de toda 118 aplicación Dinámica, como son el control de acceso (manejo de usuario y clave), paginación de registros, manejo de errores, validaciones, entre otras. Actualmente, para hacer uso de este directorio, se debe descargar el archivo comprimido del repositorio disponible en la página Web del framework. Una vez descargado el archivo, se descomprime y se copia su contenido en la carpeta del nuevo proyecto. Dentro de Netbeans se siguen los pasos correspondientes a la creación de un proyecto web con fuentes existentes (menú File New Project Categories:Java Web Project: Web Application with Existing Sources), seleccionando la carpeta creada que posee los archivos del framework y posteriormente se debe proceder a la configuración respectiva. Esta configuración del proyecto consiste en modificar ciertos datos base como el nombre del proyecto, BD a utilizar y datos de acceso a la BD (usuario, contraseña, manejador), así como datos más específicos contenidos en el context.xml que dependerán de las funcionalidades del framework que se quieran utilizar. Esta iteración comprende el desarrollo de la historia de usuario H1 (ver Figura 49) que consiste en la creación de un plugin que permita automatizar todo el proceso de creación de proyectos con Dinámica. La idea es suministrar al usuario una interfaz que solicite los datos de configuración necesarios, cree el directorio de la aplicación y realice la configuración correspondiente. Debido a que la utilización de este plugin trae como resultado la creación de la estructura general necesaria para todo proyecto, su desarrollo era prioritario y se estableció como la primera historia a realizar. Tanto los datos de entrada (parámetros) como los datos de salida (archivos creados) se describen en La Tabla 4. 119 120 121 Tabla 4: Resumen de plantilla base Diseño Como se indicó anteriormente, para fomentar la usabilidad del sistema, facilitando el uso por parte del usuario, se decidió utilizar como GUI, los wizards de NetBeans. De esta forma, cada uno de los modulos desarrollados contará con la estructura típica del wizard consistente en tres clases básicas: Action, WizardPanel y VisualPanel. Incluyendo además los archivos básicos de configuración: manifest.mf, layer.xml y Bundle.properties. La Figura 50 muestra el directorio de los archivos que conforman el módulo base. Figura 49: Directorio módulo base Para poder crear y configurar el nuevo proyecto Dinámica de forma automática, se debe mostrar al usuario una interfaz (wizard) que permita obtener los diferentes datos 122 necesarios para la configuración del nuevo proyecto (indicados como parámetros en La Tabla 4). Se solicitan los mismos datos (básicos) necesarios para la creación de cualquier proyecto en NetBeans, además de los datos necesarios para la configuración de un proyecto Dinámica. Además de las clases básicas del wizard, se utilizó un archivo con el directorio base comprimido (BaseProject.zip), que se descomprimiría, copiaba en la ubicación especificada por el usuario y configuraba (editando el archivo context.xml incorporando los datos introducidos) para formar el proyecto base solicitado. Para la creación de proyectos en Dinámica, además del directorio base del proyecto, se debe contar con un directorio en donde irán los archivos fuente, por lo tanto este directorio también se incluyó como parte del módulo en un archivo comprimido (BaseProject2.zip) al igual que el directorio base. Se cuenta también con un archivo BaseDescription.html que contiene la descripción del proyecto En este caso particular, se utilizó una clase WizardIterator (BaseWizardIterator.java) que es la encargada de especificar las clases que definen los paneles en el wizard y su orden de ejecución (orden de los pasos), define el texto de los pasos, descomprime el achivo del proyecto y aplica la configuración al proyecto descomprimido. Para el plugin que crea el proyecto base Dinámica se estableció como punto de acceso, el wizard para la creación de proyectos (menú File New Project Categories: Java Web Projects: Base Dinámica). De esta forma el wizard para este plugin se inicia con el wizard general utilizado por NetBeans para la creación de nuevos proyectos (Ver Figura 51). 123 Figura 50: Wizard general para la creación de proyectos en NetBeans (Paso 1 Creación de proyecto Base Dinámica) La Figura 52 muestra presenta el wizard correspondiente al según paso del wizard para la creación del proyecto Base Dinámica. 124 Figura 51: Wizard correspondiente a la creación del proyecto Base Dinámica (Paso 2) Codificación Una vez determinada la interfaz a utilizar, se procedió a agregar las diferentes funcionalidades que permitieran procesar los datos introducidos y utilizarlos para crear el proyecto base así como las validaciones necesarias. La figura 53 muestra un extracto del código correspondiente a la clase VisualPanel del módulo base y su constructor. 125 Figura 52: Código clase BasePanelVisual Prueba Al inicio de la iteración, se creó el prototipo de interfaz, se mostró a los usuarios y se consultó su opinión. Producto de esta interacción con el usuario se decidió cambiar el campo de texto correspondiente al manejador de BD y sustituirlo por un ComboBox que contuviera el listado de los diferentes manejadores disponibles para trabajar con Dinámica. De esta forma se facilita su inserción, ya que el usuario no tiene que recordar los diferentes nombres ni escribirlos, evitando así la ocurrencia de errores y favoreciendo la usabilidad del sistema. Una vez codificadas las diferentes funcionalidades, se hicieron las pruebas al plugin. Durante las pruebas funcionales, se determinó que la creación de los archivos fuentes no se estaba realizando de la forma adecuada por lo que se hicieron revisiones en los métodos correspondientes. Una vez ubicado el error, se procedió a corregirlo y probar nuevamente el plugin. 126 Comprobado el buen funcionamiento del plugin base, se incluyó en el module suite y se publicó para que los usuarios lo utilizaran y probaran. 3.3.3 Iteración 3. Crear proyecto Security Análisis Figura 53: Story card usada para la Iteración 3. Administrador de seguridad (Security) La plantilla Security, base de esta iteración (ver Figura 54), permite la creación de un proyecto para el manejo de la seguridad en Dinámica. Este proyecto gestiona no solo el control de acceso a las aplicaciones, sino la creación de los diferentes roles de usuario y los permisos asociados a cada uno de ellos, definiendo servicios por cada uno de los actions o funcionalidades que posea el sistema al que maneja la seguridad (cada Security está asociado a un proyecto Dinámica). En base a los permisos asociados a cada uno de estos roles se decide el acceso a los diferentes servicios. A través del proyecto Security se realiza el registro de los diferentes usuarios que tendrá la aplicación. Al asignar un rol a cada uno de estos usuarios, automáticamente se otorgan los permisos necesarios para acceder a los servicios que necesite. 127 Para la creación de un proyecto Security se debe contar con una BD que contenga todas las tablas necesarias para el funcionamiento del proyecto. Además de haber definido previamente los roles de usuario que determinarán los límites de acceso a las diferentes funcionalidades a registrar como servicios. Tanto los archivos del proyecto como el diseño de la BD, junto con los scripts para su inicialización se encuentran entre los documentos de Dinámica disponibles en la página Web. El proyecto Security contiene todos los actions necesarios para llevar a cabo las funcionalidades de seguridad de la aplicación asociada (creación y manejo de roles, usuarios y servicios). Diseño Los pasos a seguir para la creación de este tipo de proyecto son análogos a los pasos seguidos para desarrollar cualquier aplicación Dinámica (descritos en la iteración anterior del proyecto Base), así como los datos necesarios para su configuración. Por lo tanto la creación de este plugin sigue las mismas directivas de la iteración anterior. Debido a que los datos solicitados son los mismos que en la creación del proyecto base, se reutilizó la interfaz (wizard) desarrollada y aprobada por los usuarios en el paso anterior. Por lo que no hizo falta el desarrollo de un prototipo y su correspondiente evaluación. La única variante es que, a solicitud del usuario, se agregó un Checkbox que brinda la opción de crear el esquema de BD asociado al proyecto Security. De esta forma, el usuario puede seleccionar si desea que se cree la BD correspondiente, en caso de ser necesaria. El punto de acceso para la ejecución de este plugin es análogo al de la ejecución del módulo Base de la iteración anterior (menú File New Project Categories: Java Web Projects: Security Dinámica). 128 Codificación Como se indicó, las funcionalidades para el desarrollo de este plugin son análogas a las del desarrollo realizado en la iteración anterior, salvo la funcionalidad para la creación del esquema Security de la BD. La Figura 55 presenta el código correspondiente a esta opción. La función genera dos queries: uno para la creación del esquema de BD asociado al proyecto Security, y otro encargado de la inserción de la data básica necesaria para el funcionamiento del proyecto. Figura 54: Extracto de código función para la creación de queries asociados al Security Prueba Se realizaron las pruebas funcionales correspondientes. No se presentó ningún inconveniente, funcionaba correctamente por lo que no hubo correcciones en el código. La refactorización que se presentó, fue a solicitud de los usuarios, para incluir en este módulo la opción para la creación del esquema de BD asociado al proyecto Security. 129 Se hicieron las pruebas correspondientes para verificar la creación de la BD a demanda del usuario. La nueva funcionalidad resultó como se esperaba. 3.3.4 Iteración 4. Crear action personalizado Figura 55: Story card usada para la Iteración 4. Action personalizado Análisis Esta iteración comprende la creación de un action personalizado (ver Figura 56). Como ya se indicó en la sección de Dinámica del capítulo anterior, un action es la forma de crear funcionalidades en el sistema. Así, cada action corresponde a una funcionalidad a desarrollar. En su forma más básica, un action está formado por una carpeta que contiene un archivo de configuración (config.xml), un archivo que permita la interacción con el cliente, presentando tanto formularios de solicitud de datos como resultados (template.htm), un archivo de consulta (query.sql) y un archivo de validación (validator.xml). La presencia de cada uno de estos archivos dependerá de las necesidades del programador, siendo de carácter obligatorio el uso del config.xml. 130 Tomando en cuenta la cantidad de datos que pueden ser reflejados en el archivo config.xml, por la variedad de opciones presentes en la configuración de un action, el uso de este plugin se recomienda para usuarios expertos que manejen con mayor profundidad los diferentes conceptos involucrados en el uso de cada uno de los parámetros de configuración. La estructura del config.xml normalmente se divide en summary, log, transaction y output y cada una de estas etiquetas cuenta con diversos parámetros y opciones de configuración. La idea del plugin es permitir que el programador pueda hacer uso de cada uno de estos parámetros para determinar la configuración que desee en el action a crear. Para ello se debía conocer los parámetros asociados a cada una de las etiquetas, detallados en la fase de diseño. El resumen de la plantilla se muestra en La Tabla 5. 131 Tabla 5: Resumen action personalizado Diseño Debido a la cantidad de datos necesarios, se necesitaron cinco paneles para presentarlos al usuario, un panel por cada una de las secciones del config.xml. 132 A continuación se presenta un listado de los parámetros a incluir por cada una de las secciones o etiquetas presentes en el config.xml, indicando el tipo de elemento a utilizar en el panel para obtenerlo. • Datos Básicos (Summary, log y otros): nombre del action (campo de texto), descripción (campo de texto), log (ChechkBox que indica si se necesita o no), request-encoding (campo de texto), on-error (campo de texto), id, value. Estos dos últimos datos están asociados a cada elemento set-request-encoding. Se utilizaron dos campos de texto (uno para cada uno) y una lista a la que se iban agregando los id-value conforme se necesitaban (Ver Figura 57). Figura 56: Wizard action personalizado. Paso 1 Datos Básicos • Transaction: este panel se divide en dos secciones la primera para ingresar los datos generales del transaction como son nombre de la clase, transaction (CheckBox) y jlog (CheckBox) y la sección de recordsets donde se registran los datos de los recordsets necesarios como son id (campo de texto), source (listado 133 de opciones -ComboBox-), scope (listado de opciones -ComboBox-), on-empty- return (campo de texto), max-rows (campo de texto), datasource (campo de texto), params (campo de texto). Tomando en cuenta que se puede tener tantos recordsets como se requiera, se optó por colocar un listado al que se van agregando una vez especificados los datos correspondientes. La Figura 58 muestra el panel correspondiente al paso Transaction. Figura 57: Wizard action personalizado. Paso 2 Transaction • Output: se muestran dos secciones al usuario. La primera para ingresar los datos básicos del output y la segunda para ingresar los diferentes formatos de impresión (prints) asociados al output. En la primera sección se tiene: nombre de la clase (campo de texto), template (campo de texto), content-type (campo de texto), expiration (campo de texto), set-http-headers (CheckBox), mientras que en la segunda sección se tiene mode (listado de opciones -ComboBox-), recordset (campo de texto), tag (campo de texto), control (campo de texto), page-size (campo de texto), alternate-colors (campo de texto), null-value (campo de texto). 134 Estos datos se deben especificar por cada uno de los prints a incluir, se utilizó un listado en el que se van almacenando los datos de los prints seleccionados. La Figura 59 muestra el wizard diseñado para este paso. Figura 58: Wizard action personalizado. Paso 3 Output • Validator: contiene los campos id (campo de texto), label (campo de texto), type (listado de opciones -ComboBox-), required (listado de opciones -ComboBox-), maxlen (campo de texto), min (campo de texto), max (campo de texto), regex (campo de texto), regex-error-label (campo de texto). Como se puede disponer de tantas validaciones como se necesiten, se cuenta con un listado para ir almacenando los recorsets que se vayan agregando. La Figura 60 presenta el panel correspondiente al paso 4 Validator. 135 Figura 59: Wizard action personalizado. Paso 4 Validator • Datos adicionales: dividido en dos secciones, querys y on-exits para especificar los datos de cada uno de ellos. En la sección de querys se tienen un campo de texto para el nombre del query y en la sección on-exits se tienen dos campos de texto: return-code y forward-to. Ambas secciones cuentan con un listado al que se le van agregando queries y etiquetas on-exits respectivamente. La Figura 61 muestra el wizard correspondiente al último paso del action personalizado. 136 Figura 60: Wizard action personalizado. Paso 5 Query/ on-exits En lo que se refiere al diseño de la GUI del wizard, contrario a las iteraciones anteriores, donde se decidió mantener la misma interfaz del wizard utilizado para la creación de proyectos, en esta iteración se realizó una personalización del aspecto de la GUI. Se sustituyó la imagen lateral tradicional de NetBeans por la imagen con el logo que identifica al plugin. De esta forma el usuario podrá reconocer este tipo de interfaces de forma inmediata y saber que está accediendo a funcionalidades brindadas por el plugin de Dinámica. Codificación Las funciones a desarrollar durante esta iteración incluyeron gran cantidad de validaciones así como las funciones necesarias para la creación y copia de archivos, estableciendo cierta dependencia entre los datos, de forma que se habilitaran o no dependiendo de la opción seleccionada. También fue necesario el uso de métodos que permitieran el paso de parámetros entre los diferentes paneles. Se debe tener en cuenta que la creación de los diversos archivos estará condicionada a la configuración seleccionada por el programador en cada uno de los elementos pudiendo existir o no 137 un archivo template.htm (si seleccionó la opción de output), un archivo query.sql (si se incluyó en el transaction) o un archivo validator.xml (si se indicó en la sección respectiva). La Figura 62 muestra un extracto de código de la clase CreateConfig encargada de la creación del archivo de configuración (config.xml) y otros archivos (en caso de ser necesario), correspondiente al action personalizado a crear. El contenido del archivo creado dependerá de la configuración establecida por el usuario (datos suministrados en el wizard). 138 Figura 61: Extracto de código clase CreateConfig() 139 Prueba Debido a que las diferentes etiquetas que puede contener el config.xml no son de carácter obligatorio sino que se puede utilizar una u otra dependiendo del action a realizar, durante las pruebas de usuario se determinó que debía existir una especie de verificación que permitiera al programador establecer si va a hacer uso de cada elemento. Para ello se agregó un CheckBox al inicio de cada uno de los paneles para que el usuario pudiera seleccionarlo y habilitar o inhabilitar los parámetros correspondientes a la etiqueta seleccionada. De esta forma no solo se evitan los errores del usuario al impedir el llenado de datos innecesarios sino que se facilita la creación del código correspondiente. Se realizaron pruebas funcionales para comprobar una respuesta correcta ante cada una de estas interacciones (verificando así la dependencia establecida entre los diferentes elementos presentes en los paneles), así como el paso de parámetros entre paneles, la creación de todos los archivos necesarios y la configuración correcta del archivo config.xml. Para ello se debió crear diversos casos de prueba en los que se combinaban las diferentes configuraciones. 3.3.5 Iteración 5. Crear plugin Calendario Figura 62: Story card iteración 5 140 Análisis Partiendo de la historia de usuario H7 reflejada en la story card de la Figura 63, surgió la iteración actual en la que se debía desarrollar un plugin que permitiera la creación y configuración automática de la plantilla Calendario. La plantilla Calendario permite incorporar un calendario desplegable en los formularios, facilitando el ingreso de fechas con formato y la validación de rangos de fechas tanto en la búsqueda como en el registro de datos. Aún cuando el Calendario se puede adaptar paras ser usado en cualquier tipo de formulario y aplicación, en el caso particular de la plantilla disponible en el repositorio de Dinámica, se muestra un formulario con dos fechas para establecer el rango en la búsqueda de datos. Una vez seleccionadas las fechas límites del período a consultar, se muestran en una tabla los resultados correspondientes. A través de la creación del plugin se buscaba la configuración automática de esta plantilla, permitiendo al usuario seleccionar tanto la tabla que quiere utilizar para la búsqueda, como los datos que desee ver reflejados en el resultado. Para lograr esta automatización se debía identificar los datos necesarios para la creación y configuración de los parámetros que intervienen en la plantilla. La Tabla 6 muestra un resumen de la plantilla, incluyendo los parámetros necesarios y los archivos a crear. 141 Tabla 6: Resumen de la plantilla Calendario Diseño Tomando en cuenta la cantidad de datos a solicitar, se determinó el uso de un solo panel que los agrupara en tres secciones, una sección general (datos de configuración de la plantilla), una sección de búsqueda (datos a utilizar) y una sección de resultados. En la primera sección se incluyeron los datos: nombre de la carpeta y tabla a utilizar (tabla de la BD que contendrá el o los campos de tipo fecha a utilizar para la búsqueda), en la segunda sección se muestra el listado de los campos de la tabla para seleccionar el campo base de la búsqueda y en la tercera y última sección se incluye un listado con los campos de la tabla seleccionada y un listado vacío en el que se van agregando los campos que se quiere mostrar como parte del resultado (Ver Figura 64). 142 Figura 63: Wizard plugin Calendario Además de los archivos correspondientes a la creación del módulo y del wizard del plugin calendario, se cuenta con un paquete que contiene el archivo FormTemplate.txt. Este archivo incluye las marcas a sustituir para la creación y adaptación del archivo template.html de la plantilla. Codificación Para esta iteración se hizo necesaria la creación de diversos métodos que permitieran la conexión con la base de datos y la realización de las consultas correspondientes para obtener las tablas de la BD y los campos respectivos. De esta forma el usuario no tiene que recordar con cuáles tablas cuenta y qué datos puede utilizar, evitando la ocurrencia de errores al introducir datos no existentes. Se crearon también métodos para la lectura y modificación de archivos que permitieran leer el archivo base y sustituir las marcas correspondientes por los datos necesarios para configurar la plantilla. La Figura 65 muestra un extracto del código correspondiente a la función que consulta las tablas de la BD y las coloca en el ComboBox correspondiente. 143 Figura 64: Extracto de código función para consulta de BD Prueba Se desarrolló un prototipo de interfaz que fue aprobado por el usuario luego de sugerir cambios como la sustitución de los campos de texto por listados con los datos necesarios (tablas de la BD y campos de la tabla seleccionada). Con cada uno de los métodos creados para el acceso y consulta a la BD se debió realizar pruebas para comprobar su funcionamiento. Una vez desarrollado el plugin, se hicieron pruebas funcionales para verificar la creación de todos los archivos necesarios y su correcta configuración. Tomando en cuenta el tipo y origen de los datos necesarios para la configuración de la plantilla, la interfaz del wizard debía incluir listados donde se presentaran los datos a seleccionar, tanto para la búsqueda como para la muestra de resultados, permitiendo al usuario decidir qué datos utilizar. Como se verá en iteraciones posteriores, por motivos de simplicidad y facilidad de uso, estos listados fueron sustituidos por una tabla que agrupara todos los datos necesarios. 144 3.3.6 Iteración 6. Crear plugin CRUD Figura 65: Story card usada para la Iteración 6. Plugin CRUD Análisis Aún cuando la creación de este plugin estaba pautada para iteraciones posteriores, un cambio en los requerimientos del cliente obligó a adelantar el desarrollo, ya que esta plantilla es una de las más utilizadas por el equipo de usuarios a los que va dirigido el proyecto. La plantilla CRUD permite la creación, lectura, actualización y eliminación de los registros de una tabla de la BD y este grupo de funcionalidades es uno de los más utilizados, presente casi de forma obligada en todos los proyectos. Por esta razón se estableció como de prioridad elevada y realización obligatoria. En su forma más simple, la plantilla CRUD consta de una tabla resultados, donde se muestran los registros de la tabla de la BD a la que se aplica el CRUD, y un formulario de edición/inserción que permite la modificación de los datos y la inserción de nuevos registros. En la tabla resultados, junto con los datos de cada registro se presentan dos íconos, uno para la eliminación del registro correspondiente y otro para su edición. 145 Existen distintas versiones de esta plantilla. Para el desarrollo de la iteración actual, el cliente seleccionó la versión del CRUD que normalmente utilizan durante el desarrollo de sus proyectos. Esta versión incluye un formulario que permite al usuario establecer ciertos criterios de búsqueda para filtrar los registros a mostrar en la tabla resultados. En cuanto a los datos de configuración necesarios para utilizar esta plantilla, se debe indicar datos básicos, datos del formulario de búsqueda, campos que se mostrarán en la tabla resultado y los campos para el formulario de edición/inserción. Para los campos de búsqueda o edición/inserción en los que se quiera utilizar un PickList (listado de búsqueda dinámica característico del framework Dinámica), se debe indicar el nombre o campo que aparecerá en el listado del PickList. La Tabla 7 muestra el resumen de la plantilla, incluyendo los parámetros requeridos y archivos de salida. 146 Tabla 7: Resumen plantilla CRUD 147 Diseño Para la creación de este plugin se decidió dividir los datos de configuración en tres paneles. Un primer panel dividido en dos secciones, la primera destinada a los datos básicos de configuración y la segunda para los datos del filtro de búsqueda. Un segundo panel para solicitar los datos que se quieren mostrar en la tabla de resultados y un tercer panel que reuniera los datos necesarios para la creación del formulario de edición/inserción. Además de los archivos básicos de configuración del módulo y creación del wizard, se debió incluir diversos paquetes, uno por cada carpeta de la plantilla CRUD que contenían cada uno de los archivos necesarios para el funcionamiento de esta plantilla que posteriormente serían copiados y configurados por el plugin. Codificación Las funcionalidades correspondientes al plugin CRUD consisten en diversas funciones para el acceso a la BD y la presentación de los datos obtenidos para la manipulación por parte del usuario. Para presentar los datos en la interfaz, se deben tomar los datos obtenidos de la consulta a la BD y llenar las estructuras correspondientes a los listados. La figura 67 presenta un extracto del código correspondiente. 148 Figura 66: Función BuscarColumnas() (Consulta la BD y llena las listas del Wizard) Prueba Al igual que en las iteraciones anteriores, se realizaron las diferentes pruebas para comprobar el correcto funcionamiento del wizard. Se presentaron ciertas incongruencias en la selección de los campos de las listas. Se revisó el código correspondiente y se hicieron los cambios pertinentes. Las pruebas de interfaz no arrojaron mayor novedad por utilizar elementos aprobados en iteraciones anteriores. 149 3.3.7 Iteración 7. Crear librerías Figura 67: Task card Creación de Librerías Análisis Luego de llevar a cabo las primeras iteraciones, se determinó que existían métodos comunes en las iteraciones realizadas que se repetirían en el resto de las iteraciones, como son la obtención de datos de la BD y la creación, copia y modificación de archivos. Para mantener la simplicidad característica de XP y evitar la duplicación de código, se decidió agrupar los métodos correspondientes al manejo de archivos y conformar una librería. Este mismo razonamiento se siguió para los métodos necesarios para el acceso a la BD. De esta forma, se centralizan los métodos necesarios y se hacen disponibles para la totalidad de los plugins. Diseño Tomando en cuenta que toda la aplicación está basada en módulos es aconsejable integrar como un módulo los archivos (JAR) correspondientes a las librerías. Se puede empaquetar múltiples archivos JAR en un solo módulo y establecer las 150 dependencias necesarias entre los módulos, aumentando así la consistencia de la aplicación como un todo. Después de esto, no es necesario incluir (copiar) los archivos JAR en el directorio de la aplicación (classpath) como se haría normalmente. Codificación La creación de las librerías se llevó a cabo a través de un Library Wrapper Module que es un módulo que permite incluir cualquier librería JAR en el sistema de módulos y llamarla desde cualquiera de los módulos. Se debió modificar las propiedades de los módulos desarrollados en las iteraciones anteriores para que pudieran acceder a las librerías, así como eliminar el código repetido y sustituirlo por la llamada a la función correspondiente. Un extracto del código de las funciones incluidas en las librerías se muestra en la Figura 69. Figura 68: Algunas funciones incluidas en las librerías creadas en la iteración 7 151 Prueba Se hicieron las pruebas pertinentes para comprobar el acceso a los métodos desde cada uno de los módulos creados. 3.3.8 Iteración 8. Crear plugin PagedView Figura 69: Story card usada para la Iteración 8. PagedView Análisis La plantilla PagedView permite dar formato a la salida de una consulta. Toma los datos del resultado de una consulta a la BD y los coloca como campos de una tabla para su mejor visualización. Los resultados están paginados según un valor establecido, pudiendo así determinar la cantidad de filas a mostrar en cada página. El PagedView también permite incorporar una función de ordenamiento en cada una de las columnas de la tabla. Haciendo clic en el encabezado de la columna, el usuario podrá tener los datos ordenados (creciente o decrecientemente) tomando como guía el campo seleccionado. Para mejorar la visualización de los datos, las filas de la tabla se presentan alternando un color (establecido por defecto en la configuración del framework). 152 Esta plantilla permite incorporar funcionalidades para la creación de reportes en formato PDF y Excel que facilitan al usuario el seguimiento de los datos y su persistencia e incorporación en los archivos de la empresa. Diseño En esta iteración se decidió cambiar el formato de los paneles utilizados en los plugins Calendario y CRUD, desarrollados en iteraciones anteriores (Iteraciones 5 y 6), sustituyendo las listas de selección por una tabla que reúne los datos correspondientes a los campos de la tabla de la BD base de la consulta y sus respectivas opciones de configuración. De esta forma se facilita no solo la presentación y visualización de los datos sino la selección de las opciones disponibles. Para la creación y configuración de esta plantilla se presenta un panel solicitando al usuario los datos reflejados como parámetros en la Tabla 8. Debido al nuevo diseño de la interfaz y la cantidad de datos necesarios para la creación y configuración de la plantilla PagedView, el wizard a crear está conformado por un solo paso y por consiguiente un solo panel. 153 Tabla 8: Resumen plantilla PagedView Diseño de la tabla de datos La data que se utilizaba para llenar los listados empleados en las iteraciones anteriores, ahora es almacenada en una matriz o arreglo bidimensional que posteriormente será cargada en la tabla. Entre las columnas que normalmente componen la tabla, se encuentran: seleccionar, campo, etiqueta, ordenar, ancho porcentaje y alinear. Las columnas seleccionar y ordenar contienen un CheckBox y permiten determinar qué campos estarán presentes en la plantilla y si se incorporará la función de ordenamiento en la columna correspondiente a ese campo. 154 La columna campo contiene el nombre de los campos de la tabla consultada. Para evitar errores del usuario, el contenido de esta columna no puede ser editado. La columna etiqueta corresponde a los nombres de las columnas que aparecerán en la plantilla y se llena (por defecto) con los datos correspondientes a los nombres de los campos asociados, pero es libremente editable. La columna ancho porcentaje contiene la información correspondiente al ancho que ocupará ese campo en la tabla de la plantilla. Por defecto se asigna el valor correspondiente al 100% dividido entre el número total de campos (se asume que todos los campos son seleccionados), pero una vez establecida la selección del usuario, deberá seleccionar el porcentaje correspondiente, teniendo en cuenta que la totalidad de los anchos debe corresponder al 100%. Por último, la columna alinear contiene un ComboBox con las opciones de alineación de la celda (derecha, izquierda, centro). La Figura 71 muestra el wizard con la nueva interfaz. Figura 70: Wizard plugin PagedView 155 Codificación Para esta iteración, las funcionalidades a desarrollar implican el manejo del modelo de datos que define la tabla. Debido a la diversidad de tipos de datos o elementos presentes en la tabla, se debía tomar en cuenta diferentes aspectos para el vaciado de la data proveniente de la BD. Parte del código necesario se muestra en la Figura 72. Figura 71: Código función BuscarColumnas() Prueba Las pruebas realizadas durante esta iteración, incluían pruebas de aceptación por parte del usuario para evaluar la nueva interfaz, así como las pruebas funcionales correspondientes. Cabe destacar que el nuevo diseño fue rápidamente aceptado por los usuarios. 156 Por otra parte, tomando en cuenta que para el desarrollo de todo el proyecto se decidió mantener ciertos estándares, procurando la usabilidad del plugin, manteniendo la consistencia y facilitando el uso. La interfaz propuesta para este paso implicaba la modificación de la interfaz de los módulos Calendario y CRUD para que todos los plugins desarrollados presentaran una interfaz estándar, favoreciendo el reconocimiento por parte del usuario y su rápida adaptación. De esta forma, el refactoring de los módulos surgió como una tarea adicional de la iteración actual. Incluyendo también las pruebas respectivas. 3.3.9 Iteración 9. Crear plugin PickList Figura 72: Story card usada para la Iteración 9. PickList Análisis La Figura 73 muestra los datos de la historia de usuario que originó la iteración actual. El usuario necesitaba contar con una aplicación que permitiera la creación y configuración automática de la plantilla PickList. Esta plantilla permite la incorporación de listas dinámicas en los formularios. 157 A través de esta plantilla se presenta una lista de selección (ComboBox) que tiene como contenido el resultado de una consulta a la BD. Se utiliza en aquellos casos en que los datos a seleccionar no son constantes sino que varían en el tiempo. Además de mantener las opciones actualizadas, esta plantilla evita la ocurrencia de errores al ayudar al usuario en la selección de los datos correctos. Normalmente se utiliza para mostrar las opciones correspondientes a campos que representan claves foráneas, facilitando así la selección por parte del usuario al mostrar datos más sencillos de leer que un simple id. Permite también ubicar rápidamente la información cuando se tienen largos listados de datos, al incluir criterios en la búsqueda de la información correspondiente al listado a mostrar. Para la incorporación del PickList en un formulario, se deben incluir dos campos, un campo escondido que almacene el valor del elemento seleccionado y un campo visible para mostrar la descripción del elemento. Normalmente se incluyen dos iconos al lado del campo de texto, uno para realizar la búsqueda y otro para borrar el elemento seleccionado y el contenido de los campos asociados al PickList. La Tabla 9 resume los requerimientos y archivos de salida de esta plantilla. 158 Tabla 9: Resumen plantilla PickList Diseño Para la realización del plugin correspondiente a la creación y configuración automáticas de la plantilla PickList, se definió la estructura del módulo para contener dos paneles. El primer panel corresponde a los datos básicos de configuración y datos de PickList. El segundo panel corresponde al código de implementación. Debido a que esta plantilla se utiliza embebida en un formulario, se presenta al usuario el código necesario para su implementación para que sea incorporado en la archivo de su elección. Para la selección del campo a utilizar para la implementación del PickList (campo en el formulario), se utilizó un ComboBox que se llenaba a través de una consulta a la BD donde se traían los campos de la tabla base seleccionada. Se incorporó un CheckBox que permitiera determinar si el campo iba a ser editable o solo se podría llenar con los datos del elemento seleccionado. 159 Para seleccionar los campos a mostrar en el PickList, se incorporó una tabla de datos similar a la descrita en la iteración anterior. Las figuras 74 y 75 muestran la interfaz del wizard correspondiente a la iteración actual. Figura 73: Wizard plugin PickList (Paso 1) 160 Figura 74: Wizard plugin PickList (Paso 2) Codificación Tomando en cuenta el uso de la tabla de datos desarrollada en la iteración anterior, la codificación de las funcionalidades necesarias en el paso 1 del módulo actual son muy semejantes a las desarrolladas en la iteración anterior, con pequeñas variaciones generalmente asociadas al manejo y validación de los datos. Parte de la codificación necesaria para el resto de las funcionalidades (asociadas al paso 2 del wizard) se muestran en la Figura 76. La función llenar_textos() es la que se encarga de mostrar los campos de texto que contienen el código a copiar. Estos campos son generados y configurados utilizando los datos previamente introducidos en el panel anterior (paso 1 del wizard). 161 Figura 75: Código función llenar_textos() Prueba Las pruebas de interfaz determinaron la incorporación de la opción para la edición o bloqueo del campo en el formulario que no había sido incorporada en el prototipo inicial, así como la opción de paginación. También surgió la sugerencia de agregar un botón que permitiera la selección automática de todos los campos de la tabla. Se realizaron también las respectivas pruebas funcionales y los cambios a realizar fueron menores. 162 3.3.10 Iteración 10. Crear plugin ImportExcel Figura 76: Story card usada para la Iteración 10. ImportExcel Análisis La plantilla ImportExcel determinada como prioridad para esta iteración (ver Figura 77), permite cargar registros en la BD provenientes de un archivo Excel. La idea es que el usuario de la aplicación pueda introducir los datos provenientes de reportes existentes de sus aplicaciones de negocios, facilitando además la inserción de los datos en lote. Para ello se presenta un formulario simple que permite la búsqueda del archivo que posee los datos a registrar en la BD. Estos datos y el archivo en el que se presentan deben contar con un formato establecido. Una vez leídos, son validados (utilizando un validator.xml) y de haber algún error en el formato, se mostrará al usuario el mensaje correspondiente. Si todos los datos están correctos se ejecuta una clase encargada de hacer la lectura del archivo y la obtención y registro en la BD de cada uno de los datos ingresados. La Tabla 10 muestra el resumen de la plantilla ImportExcel con los datos de configuración necesarios y el listado de archivos que debe ser creado. 163 Tabla 10: Resumen plantilla ImportExcel Diseño Para la creación del plugin se necesitó un solo panel que reúna los datos básicos de la plantilla y los datos de configuración necesarios. Además de los archivos básicos, se 164 necesitó crear diversos paquetes con los archivos a copiar, uno por cada carpeta de la plantilla original. Entre estos archivos, destaca la clase Java encargada de la lectura y procesamiento de los datos del Excel. Esta clase contiene las marcas para la incorporación del código necesario asociado a cada implementación. En lo que respecta a los elementos de interfaz, se siguieron las convenciones establecidas en iteraciones anteriores para la solicitud de los datos básicos de configuración y selección de campos a utilizar. La tabla de datos utilizada, contiene la opción de selección, nombre del campo y tipo de dato. Se incorporó la opción para utilizar un formulario existente que permitía al usuario seleccionar si el ImportExcel iba a funcionar como un action independiente (con su propio formulario) o dentro de un formulario creado previamente en un action existente. Para la selección de esta opción se utilizó un CheckBox y un campo de texto. Si se selecciona el CheckBox indicando que formará parte de un action existente, se habilita el campo de texto para que se indique el action al que pertenecerá. Se incluyó también un CheckBox para indicar el uso de secuencias 1 en la BD. Si este CheckBox es seleccionado, se habilita el ComboBox correspondiente para que el usuario seleccione la secuencia asociada a la tabla. Este ComboBox se llena a través de una consulta de la metadata de la BD del proyecto que obtiene todas las secuencias de la BD. La interfaz del wizard se presenta en la Figura 78. 1 Consultar término en el glosario. 165 Figura 77: Wizard plugin ImportExcel Codificación Además de las funcionalidades para el acceso y consulta a la BD y el manejo y llenado de datos de la tabla de datos (descritas en iteraciones anteriores), en la iteración actual se incluyeron diversas funciones para la ubicación y creación de archivos. La Figura 79 muestra el código correspondiente a la función que genera un archivo Excel que conforma el modelo para facilitar al usuario una inserción por lotes exitosa (contiene las etiquetas de los campos necesarios en el orden correcto). 166 Figura 78: Código función creación de archivo (modelo) ImportExcel. Prueba Las pruebas de interfaz realizadas por el usuario determinaron la incorporación de la opción para la utilización de secuencias. Una vez incorporado este nuevo elemento, se procedió a desarrollar las funcionalidades correspondientes y las pruebas respectivas. 3.3.11 Iteración 11. Crear plugin ExportPDF Figura 79: Story card usada para la Iteración 11. ExportPDF 167 Análisis El framework Dinámica permite incorporar en las aplicaciones, funcionalidades para generar reportes en formato PDF. Aún cuando esta funcionalidad no está disponible como un plantilla dentro del repositorio, está incorporada en varias de las plantillas existentes y su utilización es bastante común. Por esta razón, el cliente decidió incorporar en el proyecto, el desarrollo de esta funcionalidad como una plantilla, y el plugin que permitiera su creación y configuración automática surgió como historia de usuario para esta iteración. La Figura 80 resume los datos de la historia de usuario. Normalmente la creación de reportes en formato PDF, se incluye como una opción en tablas de resultados, representada como un icono en la cabecera de la tabla en aquellas plantillas que ejecutan consultas a la BD y utilizan estas tablas para mostrar los datos producto de esas consultas. Para la creación del archivo PDF, se necesita incluir en el archivo config.xml el recordset de session que contiene la consulta a ser reflejada en el archivo. Se debe incluir también los campos de esa consulta que aparecerán en el documento. Diseño Debido a la naturaleza dependiente de la plantilla (normalmente se utiliza embebida en una plantilla principal), la implementación del wizard correspondiente, es similar a la del plugin PickList presentado en la iteración 9. La Tabla 11 muestra el resumen de la plantilla. 168 Tabla 11: Resumen plantilla ExportPDF Para la creación del módulo actual se necesitaron dos paneles. El primero reúne tanto los datos básicos de la plantilla, como los datos de configuración necesarios. Una vez ingresados los datos de configuración, el segundo panel presenta al usuario el código necesario para incorporar la plantilla en el action seleccionado. Para ello, se presenta al usuario dos áreas de texto, una por cada sección de código necesaria para la implementación de la plantilla: la primera muestra el código correspondiente al ícono de PDF con la llamada a la función que ejecutará el ExportPDF, la segunda área muestra el código correspondiente a la función (JavaScript) que ejecutará el action correspondiente a la creación del archivo. Las Figuras 81 y 82 muestran los paneles correspondientes. 169 Figura 80: Wizard ExportPDF (Paso 1) Figura 81: Wizard ExportPDF (Paso 2) 170 El uso de esta plantilla está recomendado para usuarios con mayor experiencia en el uso de Dinámica, ya que deben conocer el flujo de los eventos así como la forma correcta de incorporar y utilizar esta plantilla. Codificación Entre las funcionalidades desarrolladas para esta iteración, se encuentra una función que genera una ventana emergente que permite al usuario hacer una búsqueda en el sistema de archivos. A través de esta búsqueda, se ubica el archivo .sql que contiene la consulta que genera los resultadas se desea almacenar en el PDF. Una vez seleccionado el archivo, se ejecuta una llamada a la función TraerQuery(). Esta función revisa el archivo obtenido en la búsqueda y muestra al usuario las marcas de Dinámica que contiene (en caso de haber alguna). Estas marcas deben ser sustituidas por valores genéricos que permitan la ejecución de la consulta a la BD. Si el archivo no contiene ninguna marca, se ejecuta el query correspondiente y se muestran los resultados en la tabla de datos. La Figura 83 muestra el código de esta función. Figura 82: Código ExportPDF 171 Prueba Al igual que en las iteraciones anteriores, se realizaron las respectivas pruebas funcionales y de interfaz y se hicieron los cambios y ajustes necesarios para garantizar el funcionamiento adecuado. 3.3.12 Iteración 12. Crear plugin ExportExcel Figura 83: Story card usada para la Iteración 12. ExportExcel Análisis El funcionamiento de la plantilla correspondiente a la iteración actual (descrita en la Figura 84) es análogo al de la plantilla descrita en la iteración anterior (plugin ExportPDF). Por lo tanto, el diseño y funcionamiento del módulo a desarrollar sigue los mismos pasos que el desarrollo anterior. Al igual que los reportes PDF, para exportar data a Excel solo se necesita añadir elementos en el config.xml de la acción que genera la salida en formato Excel, para que la clase genérica del framework (GenericExcelOutput) sepa qué recordset utilizar, que campos debe usar, en qué orden, además de las etiquetas que usará cada 172 encabezado. Todos estos son los parámetros de configuración que el plugin debe solicitar al usuario y se muestran como parámetros en la Tabla 12. Tabla 12: Resumen plantilla ExportExcel Diseño Para la recopilación de los datos de configuración, se diseñaron dos paneles, uno que reúne toda la información necesaria para la configuración y otro panel para mostrar al usuario el código necesario para implementar la funcionalidad ExportExcel en el action que desee. 173 Codificación Entre las diversas funcionalidades creadas en esta iteración, se encuentra la función llenar_textos() presentada en la Figura 85. Esta función genera las líneas de código mostradas en el segundo panel del wizard y que el usuario necesita conocer para poder realizar la implementación de la plantilla. El texto mostrado es independiente de los datos suministrados en los paneles anteriores. Figura 84: Función llenar_textos() utilizada en la Iteración 12. ExportExcel Prueba Para comprobar el correcto funcionamiento del módulo desarrollado, se realizaron diferentes pruebas funcionales que incluían la incorporación de la plantilla generada en diversos tipos de actions. 174 3.3.13 Iteración 13. Crear plugin Filter Figura 85: Story card usada para la Iteración 13. Filter Análisis La plantilla Filter, reflejada en la story card de la Figura 86, permite crear formularios de búsqueda para establecer ciertos criterios en las consultas a la BD. Se pueden utilizar distintos tipos de datos y criterios, permitiendo incorporar calendarios para rangos de fecha, PickList para listados de datos, búsqueda por igual, mayor, menor, en base a sub-cadenas, entre otros. Además de permitir la combinación de estas opciones, brinda la opción de establecer la obligatoriedad de los campos. El formulario está acompañado por una tabla de resultados que muestra los datos asociados a la consulta realizada. Aún cuando la versión de la plantilla disponible en la página mezcla gran cantidad de elementos, por requerimientos del cliente se decidió simplificarla para reflejar el uso que realmente se le da en las aplicaciones desarrolladas por el cliente. Esta versión solo incluye los dos elementos nombrados (formulario y tabla resultados), pudiendo incorporarse el resto de los elementos, utilizando los plugins desarrollados en iteraciones anteriores (ExportPDF y ExportExcel) así como la plantilla planteada para desarrollarse en una iteración posterior (Chart). 175 Diseño Para la creación del plugin correspondiente a la iteración actual, se decidió por un diseño de dos paneles, uno para solicitar los datos básicos de la plantilla y los datos de configuración del formulario, que constituyen los campos a utilizar y el criterio de búsqueda aplicado a cada uno de ellos (seleccionar campo, nombre del campo, etiqueta, tipo de dato, requerido, tipo de filtro) y otro panel donde el usuario pueda seleccionar y configurar los datos de los campos a mostrar en la tabla resultados (seleccionar campo, nombre del campo, etiqueta, ancho, alineación, orden) y la cantidad de filas para la paginación. En el primer panel se siguen las convenciones establecidas en las iteraciones anteriores para la solicitud de los datos básicos de la plantilla, así como el uso de una tabla de datos para la selección de los campos que formarán el filtro de búsqueda. A continuación se detallan los campos de la tabla exclusivos de esta plantilla: • Tipo de dato: indica el tipo de dato del campo correspondiente. Esta columna es meramente informativa, se presenta como guía para orientar al usuario en la selección del tipo de filtro y no podrá ser editada. • Requerido: este campo contiene un CheckBox que permite indicar si el campo a insertar es de carácter obligatorio. Si el programador establece la obligatoriedad de un campo determinado, el usuario deberá indicar el valor para este campo para poder llevar a cabo la búsqueda, de otra forma aparecerá un mensaje de error. • Tipo de filtro: indica el criterio de búsqueda a utilizar con el campo actual. Entre las diferentes opciones se encuentra: calendar (si se incluirá un calendario para la selección de un campo fecha), equal (comparación por igual), menor que, mayor que, menor igual que, mayor igual que, like (criterio usado en las BDs para comprobar que una cadena de texto contiene la subcadena indicada), contiene, PickList (para indicar si se incluirá una plantilla PickList asociada a este campo). Este campo contiene un ComboBox con todas las opciones disponibles. 176 • Campo pick: si en la celda correspondiente al tipo de filtro, se selecciona la opción “pick” para el ingreso de un PickList, se debe indicar en esta celda el nombre del campo descripción que se quiere aparezca en el listado del PickList. El id y el nombre de la tabla respectiva se obtienen y almacenan a través de métodos creados en la clase que maneja el panel y son trasparentes al usuario. En cuanto a la tabla de resultados, presenta los mismo datos y elementos de celda descritos en iteraciones anteriores (seleccionar campo, nombre de campo, etiqueta, ancho, ordenar y alineación). La Tabla 13 resume los requerimientos y archivos necesarios para el funcionamiento de esta plantilla. 177 Tabla 13: Resumen plantilla Filter 178 La Figura 87 muestra la interfaz del panel correspondiente al paso 1 (Datos de configuración) del wizard. Figura 86: Wizard plugin Filter (Paso 1) Codificación Las diferentes funcionalidades a desarrollar para esta plantilla incluyen no solo el acceso a la BD y la manipulación de los datos correspondientes para la presentación al usuario sino la interacción entre los diferentes elementos presentados en la tabla de datos. La Figura 88 muestra un extracto de código correspondiente. 179 Figura 87: Extracto de código manipulación e interacción de datos de la tabla 180 Prueba Para la evaluación de esta plantilla se diseñaron varias pruebas que incluían distintos criterios de búsqueda. Se hicieron también pruebas en la interfaz para determinar si el formato utilizado (la forma en que se manejan los datos extra presentes en esta plantilla) facilitaba la configuración de la plantilla por parte del usuario. 3.3.14 Iteración 14. Crear plugin Chart Figura 88: Story card usada para la Iteración 14. Chart Análisis La plantilla Chart permite la utilización de gráficos en un proyecto. Al igual que las plantillas ExportPDF y ExportExcel desarrolladas en las iteraciones anteriores, no constituye una plantilla del repositorio de Dinámica pero es una funcionalidad comúnmente utilizada en las aplicaciones desarrolladas por el cliente, razón por la cual decidió incorporarla como una historia de usuario a desarrollar durante esta iteración. Los datos de la historia se muestran en la story card de la Figura 89. Aún cuando es una funcionalidad sencilla, está pensada para usuarios expertos; ya que su configuración e inclusión en el proyecto requieren del conocimiento tanto del 181 funcionamiento del framework como de la configuración necesaria para la creación del gráfico correspondiente. Dinámica hace uso de la librería JFreeChart para la creación de los gráficos. Se necesita un archivo de configuración (config.xml) con los parámetros necesarios y un recordset que contenga los datos de los ejes a utilizar. Solo se hace uso de los ejes x e y (gráficos bidimensionales) y se cuenta con diversas tipos de gráficos (circular, barra, anillo, área, lineal). En el archivo de configuración se debe especificar diversos parámetros resumidos en la Tabla 14. Tabla 14: Resumen plantilla Chart 182 Diseño Para el desarrollo de este plugin se determinó un diseño de dos paneles, el primero contendría los datos básicos de la plantilla, así como los datos necesarios para la configuración del gráfico: campo a utilizar como dato para el eje x, campo a utilizar como eje y, etiquetas para cada uno de los ejes, tipo de gráfico. En el segundo panel se muestra la tabla para seleccionar los campos a mostrar en la tabla resultado que resume los datos presentados en el gráfico. Para los datos de configuración del gráfico se presentan íconos correspondientes a cada tipo de gráfico para que el usuario tenga con una ayuda visual que facilitara la selección del tipo de gráfico a utilizar. Se incluyen cada una de las opciones de gráfico que brinda Dinámica (circular, barra horizontal y vertical, anillo, área, lineal). Para la verificación del tipo de gráfico seleccionado, se presenta un listado con las diferentes opciones que además de reflejar la selección realizada a través de los íconos correspondientes, permite utilizar la opción de contar con todos los tipos de gráficos. Con la selección de esta opción, además de la tabla resultados y el gráfico correspondiente, se incluye en la plantilla los íconos correspondientes a los tipos de gráficos disponibles permitiendo al usuario de la aplicación seleccionar el tipo de gráfico en el que desea ver los resultados (cambiándolo en tiempo de ejecución). La Figura 90 muestra el panel correspondiente al wizard creado para la iteración actual. 183 Figura 89: Wizard plugin Chart Dentro del diseño del módulo se debió incluir diversos paquetes para los archivos a copiar y configurar, contando con cinco paquetes adicionales, cuatro para las carpetas correspondientes a los actions necesarios y un paquete adicional para incluir las imágenes a utilizar. Codificación Entre las diversas funcionalidades desarrolladas durante esta iteración, se destacan las funciones ejecutadas al hacer clic en alguna de las imágenes que representan las opciones de los tipos de gráficos. La figura 91 muestra el código correspondiente. 184 Figura 90: Código desarrollado en la Iteración 14. Plugin Chart Prueba En cuanto a las pruebas realizadas, se incluyeron tanto evaluación de interfaz como las respectivas pruebas funcionales para verificar el correcto funcionamiento del wizard y la respuesta obtenida de cada uno de los elementos de la interfaz. 185 3.3.15 Iteración 15. Crear plugin Agenda Figura 91: Story card usada para la Iteración 15. Agenda Análisis La plantilla agenda se seleccionó como base para el desarrollo de la iteración actual. Los datos de la historia de usuario se resumen en la Figura 92. A través de esta plantilla se permite la realización de consultas a la BD utilizando una fecha como parámetro. Esta fecha es seleccionada a través de un calendario presente en el template.htm. El calendario mostrado facilita la selección de las fechas adecuadas, al deshabilitar las fechas que no contienen data en la base de datos. Una vez seleccionada la fecha a consultar (haciendo clic sobre el calendario), la fecha llama funciones JavaScript que utilizan los parámetros de la fecha para hacer la consulta respectiva y mostrar el resultado tabulado. Para la creación y configuración de la plantilla, el módulo desarrollado debe solicitar los datos básicos, así como los datos específicos para la configuración de la agenda. El resumen de los parámetros de configuración, la descripción de la plantilla y los archivos a generar se presenta en La Tabla 15. 186 Tabla 15: Resumen plantilla Agenda Diseño Se utilizó un solo panel dividido en dos secciones, la primera para los datos básicos y la segunda para los datos correspondientes a la configuración: un ComboBox que contiene el listado de los campos de tipo fecha incluidos en la tabla base seleccionada (llenado a través de una consulta a la BD), un campo de texto para indicar el número de filas para la paginación y la tabla de datos para seleccionar los campos de la tabla resultado y configurar sus datos (etiqueta, ancho, ordenamiento, alineación). 187 Codificación El código desarrollado para esta plantilla incluye diversos métodos. La Figura 93 muestra el código correspondiente a la llamada a la función CopiarArchivo(), que se encarga de la creación y configuración de los archivos correspondientes a la plantilla. Figura 92: Código para la creación y configuración de los archivos del plugin Agenda Prueba Para la aplicación de las pruebas correspondientes a la iteración actual, se siguió la misma metodología que en las iteraciones anteriores, aplicando tanto pruebas funcionales como pruebas de interfaz. Los resultados obtenidos de las pruebas indicaron que el módulo funciona de forma adecuada. 188 3.3.16 Iteración 16. Crear plugin CRUDMasterDetail Figura 93: Story card usada para la Iteración 16. CRUDMasterDetail Análisis La iteración actual comprende el desarrollo de la Historia de usuario asociada a la creación del plugin para la creación y configuración de la plantilla CRUDMasterDetail. Esta plantilla permite la creación, lectura, actualización y eliminación de un registro Maestro o Padre y N registros Detalle o Hijos asociados. CRUDMasterDetail consta de una tabla de resultados, donde se muestran los registros de la tabla de la BD a la que se aplica el CRUD, y un formulario de edición/inserción que permite la modificación de los datos e inserción de nuevos registros, así como la inserción y edición de los registros detalle asociados al padre. En la tabla resultados, junto con los datos de cada registro se presentan dos íconos, uno para la eliminación del registro correspondiente y otro para su edición. En cuanto a los datos de configuración necesarios para utilizar esta plantilla, se debe indicar datos básicos, datos de la tabla padre, datos de la tabla hija y campos a mostrar en la tabla resultado. La tabla de la BD seleccionada como tabla padre (maestro) debe estar asociada a una o más tablas hijas para que se considere válida. 189 Una vez seleccionada, muestra el listado de las tablas hijas asociadas para que el usuario pueda seleccionar la tabla en la que se basará el detalle. Entre los datos de las tablas a utilizar (tanto padre como hija) que se deben suministrar, se debe indicar qué campos de la tabla padre se utilizarán, cuáles se podrán editar y cuáles serán obligatorios y si tendrá un PickList (de ser así indicar también los campos correspondientes). La Tabla 16 lista los parámetros necesarios y los archivos a generar. 190 Tabla 16: Resumen plantilla CRUDMasterDetail 191 Diseño Para la creación de este plugin se decidió dividir los datos de configuración en tres paneles. Un primer panel dividido en dos secciones, la primera destinada a los datos básicos de configuración y la segunda para los datos de la tabla padre. Un segundo panel para solicitar los datos de la tabla hija y un tercer panel que reuniera los datos necesarios para mostrar los datos de la BD (Tabla Resultado). Las Figuras 95 y 96 muestran los paneles correspondientes a los pasos 1 y 2 respectivamente. Figura 94: Wizard plugin CRUDMasterDetail (Paso 1) 192 Figura 95: Wizard plugin CRUDMasterDetail (Paso 2) Además de los archivos básicos de configuración, se debió incluir diversos paquetes, uno por cada carpeta de la plantilla CRUDMasterDetail que contenían cada uno de los archivos necesarios para el funcionamiento de esta plantilla. Estos archivos son copiados y configurados por el plugin. Codificación La plantilla CRUDMasterDetail incluye las funcionalidades de la plantilla CRUD (desarrollada en la iteración 6) como elementos extra para la consulta detallada en base a una tabla hija. Entre la codificación necesaria para implementar esto último, se encuentra la función BuscarTablaHija() mostrada en la Figura 97. Esta función se encarga de buscar las tablas hijas relacionadas con la tabla padre seleccionada. Si esta tabla padre seleccionada no contiene tablas asociadas, un mensaje de error será mostrado al usuario. 193 Figura 96: Detalle de código plugin CRUDMasterDetail Prueba La fase de prueba, al igual que en las iteraciones anteriores comprende la evaluación de la interfaz y pruebas funcionales por parte del usuario, así como las pruebas de código realizadas por los programadores. Se utilizó la GUI estándar previamente aceptada por los usuarios por lo que las pruebas de interfaz arrojaron resultados positivos. 194 3.3.17 Iteración 17. Crear plugin CRUDSimple Figura 97: Story card usada para la Iteración 17. Plantilla CRUDSimple Análisis A pesar de haber creado la plantilla CRUD, era necesario crear la plantilla CRUDSimple, que aunque hace las 4 funciones principales como lo son la creación, lectura, actualización y eliminación de los registros de una tabla de la BD, la presentación de los registros es distinta, al igual que sus funciones, además los creadores del Framework Dinámica también separan ambas plantillas. La plantilla CRUDSimple consta de un filtro, una tabla de resultados, donde se muestran los registros de la tabla de la BD a la que se aplica el CRUD, y un formulario de edición/inserción que permite la modificación de los datos y la inserción de nuevos registros, estos tres elementos juntos en una misma página. En la tabla resultados, junto con los datos de cada registro se presentan dos íconos, uno para la eliminación del registro correspondiente y otro para su edición. En cuanto a los datos de configuración necesarios para utilizar esta plantilla, se debe indicar datos básicos, datos del formulario de búsqueda, campos a mostrar en la tabla resultado y en el formulario de edición/inserción. Para los campos de búsqueda en los que se quiera utilizar un PickList, se debe indicar el nombre o campo que aparecerá 195 en el listado del PickList. La Tabla 17 muestra el resumen de la plantilla, incluyendo los parámetros requeridos y archivos de salida. Tabla 17: Resumen plantilla CRUDSimple 196 Diseño Para la creación de este plugin se decidió dividir los datos de configuración en tres paneles. Un primer panel dividido en dos secciones, la primera destinada a los datos básicos de configuración y la segunda para los datos del filtro de búsqueda. Un segundo panel para solicitar los datos que se quieren mostrar en la tabla de resultados y un tercer panel que reúne los datos necesarios para la creación del formulario de edición/inserción. Además de los archivos básicos de configuración asociados al módulo, se debió incluir diversos paquetes, uno por cada carpeta de la plantilla CRUDSimple que contenían cada uno de los archivos necesarios para el funcionamiento de esta plantilla que posteriormente serían copiados y configurados por el plugin. Codificación Tomando en cuenta que el CRUDSimple posee las mismas funcionalidades que el CRUD (desarrollado en la iteración 6), la codificación desarrollada para este módulo es análoga a la de la iteración 6. La Figura 99 presenta la función secuencias() utilizada en ambos módulos. Esta función hace una consulta a la BD, para obtener todas las secuencias asociadas al esquema de la BD del proyecto. Figura 98: Código función secuencias() del plugin CRUDSimple 197 Prueba Tomando en cuenta que las funcionalidades de esta plantilla son similares a las de la plantilla desarrollada en la iteración anterior (CRUDSimple), el procedimiento para llevar a cabo las pruebas fue análogo al anterior. 3.3.18 Iteración 18. Crear plugin ejecutable Figura 99: Story card usada para la Iteración 16. Ejecutable En esta iteración no se necesita realizar ningún tipo de análisis, diseño o codificación, solo la ejecución de los procedimientos necesarios para obtener un archivo ejecutable que contenga todos los módulos de la aplicación y pueda ser instalado y ejecutado en cualquier máquina. Para ello, NetBeans cuenta con ciertas funcionalidades que permiten obtener el archivo deseado (DinamicaNB.nbm). El formato creado por NetBeans para este tipo de ejecutables es el .nbm (NetBeans binary modul o módulo binario de NetBeans). Su creación se hace a través de una opción situada en el menú contextual. 198 Prueba Una vez obtenido el archivo ejecutable, se procedió a su instalación en la plataforma. Se realizaron las pruebas respectivas para comprobar que todas las funcionalidades se ejecutaran correctamente. Luego de comprobar el correcto funcionamiento del plugin como una totalidad, se publicó en el servidor para disposición de los programadores. 3.4 Desarrollo de aplicaciones utilizando el plugin de Dinámica (DinámicaNB) para NetBeans Para desarrollar una aplicación Web utilizando el plugin creado durante el T.E.G., lo primero que se debe hacer es instalar el plugin en la plataforma NetBeans. Para ello se siguen los mismos pasos que para la instalación de cualquier otro plugin: se abre la ventana de plugins desde el menú Tools Plugins. En la pestaña "Downloaded" se presiona el botón "AddPlugins...”, se abrirá una ventana para selección de archivos y se ubica el archivo DinamicaNB.nbm incorporando el archivo a la lista de plugins a instalar. Haciendo clic en el botón "Install" comienza la instalación. Una vez instalado el plugin, aparecerá el menú “Dinámica” en la barra de menú, entre los menús “view” y “navigate”, propios de NetBeans. También aparecerá como una opción dentro del menú contextual que surge al hacer clic derecho sobre un directorio (carpeta). Utilizando cualquiera de estos menús, se selecciona la plantilla a crear. Si no existe el proyecto Dinámica, se crea haciendo clic en el menú File New Project Categories: Java Web Projects: Base Dinámica. Iniciando así el wizard correspondiente a la creación del proyecto base (creado en la iteración 2. Una vez completados los datos de configuración necesarios, finaliza el wizard y se crea el proyecto Dinámica con todos los archivos necesarios. Para incorporar al proyecto funcionalidades (actions) brindadas por las plantillas incluidas en el plugin, se debe hacer clic en la carpeta donde se ubicará el action 199 (bien sea dentro de la carpeta actions de Dinámica o en un subdirectorio de ella). Luego utilizando cualquiera de los menús disponibles, se escoge la opción de la plantilla a crear. Automáticamente inicia el wizard correspondiente para la introducción de los datos necesarios. Una vez suministrados todos los datos de configuración en cada uno de los pasos, finaliza el wizard y se crea la plantilla configurada acorde a los datos introducidos en el wizard. El procedimiento se repite tantas veces como sea necesario, procediendo de forma análoga con cada una de las plantillas a utilizar. Cabe destacar que la BD asociada al proyecto Base debe estar previamente creada, ya que los wizards correspondientes a cada una de las plantillas generalmente establecen conexiones a la BD para obtener ciertos datos y facilitar el trabajo del usuario. Tomando en cuenta el proceso descrito, la creación y configuración de un proyecto Dinámica y la incorporación de múltiples plantillas utilizando el plugin DinamicaNB se reduce a tres sencillos pasos: selección del directorio, selección de la platilla en el menú y se llenado de los datos solicitados en el wizard. 3.4.1 Pruebas de desempeño. Una vez instalado el plugin en el sitio de trabajo, se realizaron pruebas de desempeño que buscaban determinar el aporte realizado por el plugin en términos de productividad. Se diseñaron casos de prueba que incluyeron la realización de tareas típicas en el desarrollo de aplicaciones utilizando Dinámica (como manejo de registros de una tabla de la BD, tabulación de resultados, formularios de búsqueda). Se tomó un grupo de usuarios habituales del framework con distintos niveles de experticia, se les explicó el procedimiento y se registraron los resultados arrojados en cada una de las pruebas. Evaluando los tiempos de desarrollo de la manera estándar de Dinámica (utilizando solo el framework y la copia y configuración manual) versus los tiempos 200 de desarrollo utilizando el nuevo plugin. Tanto los usuarios principiantes del framework como los usuarios expertos, mostraron una reducción en el tiempo invertido en la reutilización de las plantillas con el uso del plugin. La Tabla 18 muestra el resumen de los resultados obtenidos en algunas de las pruebas y las Figuras 101, 102 y 103 muestran los gráficos comparativos correspondientes. Tabla 18: Resumen de resultados desarrollo estándar vs desarrollo usando el plugin DinámicaNB Figura 100: Gráfico desarrollo estándar vs. desarrollo usando el plugin (Plantilla CRUD) 201 Figura 101: Gráfico desarrollo estándar vs. desarrollo usando el plugin (Plantilla PagedView) Figura 102: Gráfico desarrollo estándar vs. desarrollo usando el plugin (Plantilla Filter) 202 CAPÍTULO IV: Conclusiones y Recomendaciones Para alcanzar el objetivo principal planteado como T.E.G., se definió una serie de objetivos específicos que no solo ayudaron a concretar la idea sino que facilitaron su desarrollo. Estos objetivos específicos estaban divididos de acuerdo a tres criterios: aprendizaje, desarrollo y prueba. Los objetivos de aprendizaje debían alcanzarse para poder llevar a cabo los objetivos de desarrollo y éstos a su vez debían desarrollarse para cumplir con los requerimientos del cliente que conformaban el objetivo general y esencia de este T.E.G. Para la consecución de estos objetivos se estudiaron las diferentes metodologías consultando diversas bibliografías, así como artículos, tutoriales y diversos materiales disponibles en línea (internet). Tomando como referencia toda la información recabada, se procedió a realizar el desarrollo de los módulos necesarios, seleccionados por el cliente tomando en cuenta la prioridad de uso y las diferentes necesidades del negocio. Por último, el objetivo referente a la prueba del sistema se llevó a cabo de forma repetitiva e iterativa durante el desarrollo de cada uno de los módulos desarrollados así como una prueba final del sistema para comprobar que funcionaban de la forma esperada luego de la integración. Con el cumplimiento de todos estos objetivos se logró completar el desarrollo del plugin planteado, incorporando incluso más funcionalidades de las planteadas inicialmente. De esta forma, la motivación inicial implicada en la consecución del objetivo del T.E.G., consistente en minimizar el trabajo de los programadores, al crear una herramienta que permite unificar las facilidades del framework Dinámica con las ventajas del uso de NetBeans IDE, potenciando las ventajas de ambos, fue cubierta satisfactoriamente. Debido a las características del proyecto propuesto, la selección de XP como metodología de desarrollo fue idónea; ya que fomentó el trabajo conjunto y la 203 colaboración de todos los programadores involucrados en el proyecto (tanto desarrolladores como usuarios) favoreciendo un producto final de calidad, adaptado a las necesidades específicas del usuario. La participación activa del cliente y futuros usuarios durante toda la etapa de desarrollo del proyecto fue de gran ayuda y constituyó un punto importante a la hora de establecer un alcance bien definido que contribuyó al cumplimiento oportuno de las metas. La facilidades que brinda la plataforma NetBeans para el desarrollo de módulos (plugins) constituyó un punto importante en el proceso de desarrollo; ya que facilitó la definición de estandares de trabajo, desarrollo de código y utilización del plugin por parte del usuario. Por otra parte, la herramienta Matisse incluida en NetBeans, permitió la creación rápida de prototipos para la personalización de la interfaz, incluye diversas facilidades que contribuyeron al desarrollo del proyecto (como la disponibilidad de una vista tanto del código de la interfaz desarrollada como del diseño); por lo tanto su utilización fue de gran ayuda no solo a la hora de desarrollar el prototipo y modificaciones posteriores, sino de escribir y modificar el código correspondiente a cada uno de los elementos que constituirían la interfaz. Durante las pruebas de desempeño realizadas para evaluar el uso del plugin en el desarrollo de aplicaciones web, se evidenció el gran aporte que significa su incorporación al proceso de desarrollo. Los resultados de las pruebas mostraron un incremento en la productividad de los programadores, al facilitar las tareas de creación y configuración de plantillas, eliminando el copiado y edición manual de archivos y sustituyéndolos por la utilización de wizards que guían paso a paso al programador, automatizando el proceso de reutilización, agilizando el desarrollo y contribuyendo a minimizar los errores de los usuarios. La reducción en los tiempos de desarrollo es considerable, por lo que se recomienda abandonar la práctica del desarrollo acostumbrado, utilizando solo Dinámica (sin plugin) y adoptar la utilización del plugin como nuevo proceso de desarrollo. 204 Alcance Por motivos de simplicidad y ahorros en tiempo y costos, se tuvo que limitar el alcance del proyecto planteado inicialmente (en el trabajo de seminario “Dinámica: un framework para el desarrollo de aplicaciones web”), en el que se pensaba incluir todas las plantillas del repositorio de Dinámica como parte del desarrollo. Tomando en cuenta que existen plantillas que el cliente no utiliza ni necesita, se replanteó el alcance del proyecto, enfocándose no solo en el pool de plantillas a desarrollar sino el orden en el que se debía hacer, basándose en las prioridades establecidas por el cliente y tomando como mayor prioridad el desarrollo de aquellas plantillas de uso constante. Con este nuevo enfoque, se llevaron a cabo cada uno de los objetivos planteados, realizando algunas variaciones en la planificación y tiempos de entrega. Durante el desarrollo del proyecto surgieron también actividades adicionales que requerían atención y el cambio en la estructura del sistema planteada originalmente (en la fase de planificación), como la creación de librerías para el manejo de BD y manejo de archivos, así como algunos cambios en la implementación de las interfaces de configuración. Recomendaciones Tomando en cuenta que Dinámica está publicado como software libre, disponible para toda la comunidad, se piensa agregar las plantillas no contempladas en este desarrollo, además de diferentes funcionalidades como la creación de un proyecto Demo, ejemplo general que contenga todas las plantillas totalmente funcionales para permitir al usuario conocer la herramienta. De esta forma no solo se ayudará a la comprensión de las diferentes plantillas sino a la difusión del framework en la comunidad NetBeans. Persiguiendo este último objetivo, se recomienda además 205 publicar el plugin en la página web de NetBeans para que sea del conocimiento y la utilización pública acorde al enfoque libre (open source) de Dinámica. Otro punto importante, que vale la pena contemplar para futuros desarrollos es la inclusión de opciones para la implementación de las plantillas utilizando otros manejadores de BD distintos a PostgreSQL, ya que a solicitud de los usuarios, el desarrollo del T.E.G contempló solo la opción de PostgreSQL como manejador para BD. 206 GLOSARIO AmaterasERD o AmaterasUML: es un plugin para Eclipse que permite modelar BDs creando diagramas entidad relación (E/R) dentro del IDE Eclipse. Permite crear y editar diagramas E/R, importar data proveniente de una BD, generar DDL a partir de diagrama y exportar la definición de las tablas como un documento HTML. CASE: Las herramientas CASE (Computer Aided Software Engineering, Ingeniería de Software Asistida por Computadora) son diversas aplicaciones informáticas destinadas a aumentar la productividad en el desarrollo de software reduciendo el costo en términos de tiempo y de dinero. Estas herramientas pueden ayudar en todos los aspectos del ciclo de vida de desarrollo del software en tareas como el proceso de diseño del proyecto, cálculo de costos, implementación de parte del código automáticamente con el diseño dado, compilación automática, documentación o detección de errores, entre otras (Wikipedia, s.f. b). Bajo el término de Ingeniería de Software Asistida por Ordenador se incluyen una serie de herramientas, lenguajes y técnicas de programación que permiten la generación de aplicaciones de manera semiautomática. Las herramientas CASE liberan al programador de parte de su trabajo y aumentan la calidad del programa a la vez que disminuyen sus posibles errores. ComboBox: elemento de GUI que constituye un listado desplegable que permite la selección de un elemento. CVS: Concurrent Versions System (Sistema concurrente de versiones). Es un programa que permite al desarrollador guardar diferentes versiones del código fuente y obtenerlas cuando sea necesario. El programa mantiene una sola copia del código y el historial de todos los cambios realizados, permitiendo reconstruir una versión a partir de los cambios registrados. Cuando un equipo de desarrolladores utiliza CVS, 207 el control de las diferentes versiones se comparte a través del uso de un repositorio de archivos común (Whatis.com, 2005). DIV: es una etiqueta HTML que permite estructurar un documento creando divisiones lógicas. Cada división es un conjunto formado por diferentes etiquetas HTML relacionadas entre sí y a los que se les pueden aplicar propiedades comunes (Introducción al lenguaje HTML, s.f.). Por si solos no dotan al contenido de ninguna característica especial, pero junto con las definiciones de estilo permiten crear bloques o elementos personalizados. (Las etiquetas DIV y SPAN, s.f.) Framework: un framework puede definirse como una estructura o esqueleto que puede ser utilizado en partes o completamente, personalizándolo para convertirse en una aplicación. Esta estructura generalmente está formada por clases abstractas que encapsulan métodos comúnmente utilizados. GUI: siglas de Graphical User Interface o Interfaz gráfica de usuario. Es el medio con que el usuario puede comunicarse con una máquina, un equipo o una computadora y comprende todos los puntos de contacto entre el usuario y el equipo, normalmente suelen ser fáciles de entender y fáciles de accionar (Wikipedia s.f. d). Hibernate: es una herramienta de Mapeo objeto-relacional para la plataforma Java que facilita el mapeo de atributos entre una BD relacional tradicional y el modelo de objetos de una aplicación, mediante archivos declarativos (XML) que permiten establecer estas relaciones. Hibernate es software libre, distribuido bajo los términos de la licencia GNU LGPL (Wikipedia, s.f. c). IDE: Un IDE es un programa compuesto por una serie de herramientas que utilizan los programadores para desarrollar código. Un IDE puede estar pensado para ser utilizado con un único lenguaje de programación o bien puede dar cabida a varios lenguajes, como es el caso de Eclipse y NetBeans. Actualmente se conocen IDEs para la mayoría de los lenguajes de programación existentes en el mercado (por ejemplo C, C++, C#, Java, Python y Visual Basic, entre otros). Normalmente componen las 208 siguientes herramientas: editor de texto, compilador, intérprete, herramientas para la automatización, depurador, sistema de ayuda, construcción de interfaces gráficas de usuario y, opcionalmente, un sistema de control de versiones. IText: es una librería que permite la creación y manipulación dinámicas y automáticas de documentos en formato PDF. J2EE: Java Platform Enterprise Edition o Java EE (anteriormente conocido como Java 2 Platform, Enterprise Edition o J2EE hasta la versión 1.4), es una plataforma de programación -parte de la Plataforma Java- para desarrollar y ejecutar software de aplicaciones en Lenguaje de programación Java con arquitectura de N niveles distribuida, basándose ampliamente en componentes de software modulares ejecutándose sobre un servidor de aplicaciones. La plataforma Java EE está definida por una especificación. Similar a otras especificaciones del Java Community Process, Java EE es también considerada informalmente como un estándar debido a que los proveedores deben cumplir ciertos requisitos de conformidad para declarar que sus productos son conformes a Java EE; estandarizado por The Java Community Process / JCP. JDBC (Java DataBase Connectivity): conjunto de APIS que proveen un mecanismo estándar que permite a las aplicaciones Java acceder a las BDs, proveyendo métodos para ejecutar sentencias de consulta y actualización de los datos almacenados en una BD, así como el procesamiento de los resultados obtenidos. JFreeChart: es un framework open source para el lenguaje de programación Java que facilita la creación de gráficos. Provee soporte para distintos tipos de gráficos (de barra, circular, diagramas de Gantt, etc.). LGPL: Lesser General Public License. Es una licencia de software creada por la Free Software Foundation (FSF) o Fundación para el software libre. Este término se aplica a la licencia que poseen algunos softwares open source y detalla la forma en que el software y su código fuente pueden ser copiados distribuidos y modificados. 209 En contraste, la GNU General Public License pretende garantizar su libertad de compartir y modificar el software "libre", esto es para asegurar que el software es libre para todos sus usuarios. El software bajo esta licencia puede ser incorporado en software tanto libre como propietario (Beal, 2008). Localización: en NetBeans, se refiere al proceso de crear o proveer elementos (como texto, iconos, entre otros) específicos a un país o lenguaje, brindando cierta personalización a la GUI (Böck, 2009, p. 205). Metadata: Técnicamente se define metadata como la descripción del contenido. Metadata generalmente, se define como ‘la información que describe la información’ y se refiere a cualquier data utilizada para apoyar la identificación, descripción y localización de un objeto de información, como un documento (Namahn, s.f.). Haciendo referencia a esta definición, en el documento actual, el término metadata se utiliza para hacer referencia a la información que describe los datos de una BD (bien sea descripción de las tablas, de los campos en una tabla o cualquier otro elemento incluido en la BD). Programación Declarativa: es un paradigma de programación que está basado en el desarrollo de programas especificando o "declarando" un conjunto de condiciones, proposiciones, afirmaciones, restricciones, ecuaciones o transformaciones que describen el problema y detallan su solución. La solución es obtenida mediante mecanismos internos de control, sin especificar exactamente cómo encontrarla. No existen asignaciones destructivas, y las variables son utilizadas con transparencia referencial La programación declarativa es una forma de programación que implica la descripción de un problema dado en lugar de proveer una solución para dicho problema, dejando la interpretación de los pasos específicos para llegar a dicha solución a un intérprete no especificado. 210 En otras palabras, la programación declarativa provee el "qué", pero deja el "cómo" liberado a la implementación particular del intérprete. Los lenguajes declarativos están orientados a buscar la solución del problema, sin preocuparse por la forma de llegar a ello; es decir, el programador debe concentrarse en la lógica del algoritmo, más que en el control de la secuencia. En estos lenguajes de programación, se le indica a la computadora qué es lo que se desea obtener o qué es lo que se está buscando, Ejemplos de este tipo de lenguajes son SQL y PROLOG. (Baños E., Chacón J., Chiguen J., España G., Montoya J., 2006). RAD: James Martin (1990), en su primer libro describe “RAD es un ciclo de vida de desarrollo, diseñado para dar mayor rapidez al desarrollo y mejor calidad en los resultados, comparado con aquellos alcanzados con el ciclo de vida de desarrollo tradicional. Está diseñado para obtener la mayor ventaja de los poderosos desarrollos de software que han evolucionado recientemente”. RAD es una metodología o proceso de desarrollo de software que comprime las fases de análisis, planificación, diseño, construcción y prueba en una serie de ciclos cortos e iterativos que aceleran las aplicaciones de tal manera que el ciclo de vida del desarrollo es más rápido, reduciendo costos y manteniendo la calidad de los sistemas. El método RAD comprende un desarrollo iterativo, la construcción de prototipos y el uso de utilidades CASE. Secuencias: una secuencia es un objeto de BD creado por el usuario que puede ser compartido por múltiples usuarios para generar una clave única conformada por un número entero autoincremental. Normalmente se utilizan para crear claves primarias que deben ser únicas para cada fila de datos. La secuencia brinda la posibilidad de incrementar de forma automática el valor del campo al que está asociada cuando se produce el ingreso de un nuevo dato en la tabla. Servlets: un Servlet es un programa del lado del servidor escrito en Java que reside y se ejecuta en un servidor web, extendiendo la funcionalidad del servidor web para 211 entregar contenido dinámico. Se utiliza para servir recursos al cliente en el lado del servidor. Aún cuando es una tecnología de SunMicrosystem, es soportada por gran cantidad de servidores web (IBM IT Education Services, 2008). Struts o Apache Struts: es un framework open source para el desarrollo de aplicaciones web bajo J2EE. Utiliza y extiende el API Java Servlets e incentiva a los programadores a utilizar la arquitectura MVC. (Wikipedia, s.f. a). Struts se desarrollaba como parte del proyecto Jakarta de la Apache Software Foundation, pero actualmente es un proyecto independiente conocido como Apache Struts. Swing: es una librería gráfica de Java, perteneciente a las Java Foundation Classes (JFC -en español, Clases Base de Java-) que provee múltiples APIs independientes de la plataforma para permitir la interacción entre el usuario y los componentes GUI. Constituye un conjunto de herramientas útiles para el diseño de GUIs que incluye diversos controles de interfaz como botones, menús, tablas, campos de texto, entre otros. Tooltip: Es un texto corto que aparece en la pantalla como descripción de un elemento de interfaz. Este texto aparece al colocar el mouse sobre el elemento de interfaz al que está relacionado. Wiki Wiki: normalmente referido como wiki, es el término asociado a una colección de documentos de hipertexto que poseen un contenido desarrollado de forma colaborativa, permitiendo a los diferentes usuarios registrados modificar la información (Bleeping Computer LLC, s.f.). En términos tecnológicos es un software para la creación de contenido de forma colaborativa. Constituye un sistema de creación, intercambio y revisión de información en la web, de forma fácil y automática. Un Wiki sirve para crear páginas web de forma rápida y eficaz, permitiendo que varios usuarios puedan crear páginas web sobre un mismo tema, de esta forma cada usuario aporta un poco de su conocimiento para que la página web sea más completa, creando de esta forma una comunidad de usuarios que comparten contenidos acerca de un mismo tema o categoría (Maestros del Web, 2006). 212 REFERENCIAS Anderson, A., Jeffries, R. & Hendrickson, C. (2000). Extreme programming installed 1 . The XP series. (1ra edición). Boston. Addison-Wesley Professional. Baird, S. (2002). Extreme Programming Practices in Action. Artículo extraído de Sams Teach Yourself Extreme Programming in 24 Hours. Parte de Sams Teach Yourself series. Sams Publishing. Disponible en: http://www.informit.com/articles/article.aspx?p=30187 (Consultado en agosto 2010) Beal, V. (2008, Septiembre). What is Open Source Software? 1 . Internet.com Disponible en: http://www.webopedia.com/DidYouKnow/Computer_Science/2005/open_sourso.asp (Consultado en septiembre 2009) Beck, K. (1999). Extreme Programming Explained. Embrace Change 1 . (1ra edición). Boston. Addison-Wesley Professional. Disponible en: http://www.mip.sdu.dk/~brianj/Extreme%20Programming%20Explained%20- %20Kent%20Beck;%20Addison-Wesley,%201999.pdf (Consultado en julio 2010) Beck, K., Beedle, M., Bennekum, A., Cockburn, A., Cunningham, W., Fowler, M., Grenning, J., Highsmith, J., Hunt, A., Jeffries, R., Kern, J., Marick, B., Martin, R., Mellor S., Schwaber, K., Sutherland, J. & Thomas, D. (2001). Manifiesto por el Desarrollo Ágil de Software. Bleeping Computer LLC (sin fecha). The Computer Glossary. WikiWiki 1 . Disponible en: http://www.bleepingcomputer.com/glossary/definition268.html (Consultado en octubre 2010) 1 material traducido por el equipo de trabajo 213 Böck, Heiko (trad. 2009). The Definitive Guide to NetBeans™ Platform 1 . Munich. Apress1 Traductor: the NetBeans™ Platform Community Boudreau, T., Glick, J., Greene, S. Spurlin, V. & Woehr, J. (2002). NetBeans: The Definitive Guide 1 . Sebastopol, California. O'Reilly. Boudreau, T. (sin fecha). Working with the NetBeans Platform and the NetBeans Module System 1 . Disponible en: http://netbeans.org/download/magazine/02/nb02-part3-platform.pdf (Consultado en septiembre 2009) EngineeringTask 1 . (2005). Disponible en: http://www.c2.com/cgi/wiki?EngineeringTask (Consultado septiembre 2010) Fowler, M. (2005). The New Methodology 1 . Disponible en: http://www.willydev.net/descargas/Articulos/General/MetologiaXP.PDF (Consultado en agosto 2010) Jeffries, R. (sin fecha). What is Extreme Programming? 1 . Disponible en: http://xprogramming.com/xpmag/whatisxp (Consultado julio 2010) León, J., Otaiza, L. y Zambrano, S. (2010). PROGRAMACIÓN EXTREMA “XP”. Mérida. Disponible en: http://www.scribd.com/doc/26495149/Programacion- extrema-Informe (Consultado en agosto 2010) Letelier, P. y Penadés, M. (sin fecha). Metodologías ágiles para el desarrollo de software: eXtreme Programming (XP). Disponible en: http://www.willydev.net/descargas/masyxp.pdf (Consultado en agosto 2010) Maestros del Web (marzo, 2006). ¿Qué es un Wiki?. Disponible en: http://www.maestrosdelweb.com/editorial/queeswiki/ (Consultado en octubre 2010) 1 material traducido por el equipo de trabajo 214 Martin, J. (1990). RAD, Rapid Application Development 1 . New York. MacMillan Publishing Co. Namahn (sin fecha). Metadata a research note by Namahn. Disponible en: http://www.namahn.com/resources/documents/note-metadata.pdf (Consultado en octubre 2010) NetBeans. Disponible en: www.netbeans.com (Consultado en octubre 2009) Programación Extrema (sin fecha). Disponible en: s.f.http://eisc.univalle.edu.co/materias/WWW/material/lecturas/xp.pdf (Consultado septiembre 2010) Sun Microsystems, Inc. (2001). Java Look and Feel Design Guidelines: Advanced Topics 1 . Disponible en: http://java.sun.com/products/jlf/at/book/Wizards.html (Consultado septiembre 2010) Wells, D. (2009). Extreme Programming 1 . Disponible en: http://www.extremeprogramming.org/ (Consultado en septiembre 2010) Wikipedia (sin fecha a). Apache Struts 1 . Disponible en: http://en.wikipedia.org/wiki/Struts (Consultado en octubre 2009) Wikipedia (sin fecha b). Herramienta CASE. Disponible en: http://es.wikipedia.org/wiki/Herramienta_CASE (Consultado en febrero 2010) Wikipedia (sin fecha c). Hibernate (Java) 1 . Disponible en: http://en.wikipedia.org/wiki/Hibernate_(Java) (Consultado en octubre 2009) Wikipedia (sin fecha d). Interfaz de Usuario. Disponible en: http://es.wikipedia.org/wiki/Interfaz_de_usuario (Consultado en enero 2010) 1 material traducido por el equipo de trabajo