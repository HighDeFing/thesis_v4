Universidad Central de Venezuela Facultad de Ciencias Escuela de ComputaciÃ³n Centro de ComputaciÃ³n GrÃ¡fica VISUALIZACION DE ECUACIONES IMPLICITAS UTILIZANDO WEBGL Trabajo Especial de Grado presentado ante la Ilustre Universidad Central de Venezuela Por el Bachiller Juan AndrÃ©s GonzÃ¡lez Trejo para optar al tÃ­tulo de Licenciado en ComputaciÃ³n Tutor: Prof. RhadamÃ©s Carmona <Caracas, 27/10/2015> 3 Dedicatoria A mi padre, a mi madre, a mi hermana, a mis amigos, quienes me han brindado todo para que pudiera alcanzar esta meta y culminar una etapa mÃ¡s en la vida. Sin su apoyo y dedicaciÃ³n no me hubiese sido posible llegar al punto en el que me encuentro hoy en dÃ­a. 4 Agradecimientos A mi hermana quien ha sido un apoyo constante a lo largo de mi vida y un sÃ­mbolo de que querer es poder. A mi madre y padre por ser constantes y darme un empujÃ³n de seguir adelante. A mis amigos, los cuales me han apoyado en todo momento y siempre han estado ahÃ­ cuando ha sido necesario. A mi tutor, Prof. RhadamÃ©s Carmona, por asistirme mi formaciÃ³n como profesional y durante la elaboraciÃ³n de este trabajo. 5 Resumen Las Ecuaciones implÃ­citas son ampliamente utilizadas en el Ã¡rea de la matemÃ¡tica y la fÃ­sica, por lo que en el mundo cientÃ­fico han formado parte de nuestra vida cotidiana, y han ayudado a estudiar distintos fenÃ³menos. TÃ­picamente, para visualizar estas ecuaciones en tres dimensiones se utilizan algoritmos que reconstruyen la superficie 3D buscando los ceros de la funciÃ³n en una malla regular, y conectando los puntos resultantes para generar dicha superficie. Entre estos algoritmos se encuentran Marching Cubes y Tetra Cubes. Con la popularidad que ha adquirido la visualizaciÃ³n de volÃºmenes en los Ãºltimos aÃ±os, hoy en dÃ­a es posible visualizar la ecuaciÃ³n implÃ­cita sin la necesidad de realizar la reconstrucciÃ³n tridimensional. En este caso, basta evaluar la ecuaciÃ³n implÃ­cita en una malla regular 3D que forma un volumen, y configurar la funciÃ³n de transferencia para visualizar Ãºnicamente la superficie deseada (los ceros de la funciÃ³n). Basados en esta idea, podemos visualizar fÃ¡cilmente cualquier otra capa de la funciÃ³n implÃ­cita; es decir, visualizar otra superficie que no coincida con los ceros de la funciÃ³n, sino con cualquier otro valor. Por ejemplo, con la ecuaciÃ³n de una esfera x2+y2+z2-r2=u es posible visualizar las superficies generadas para distintos valores de u sin necesidad de reconstruir cada una de estas superficies, lo cual genera costos importantes de tiempo y espacio. En los Ãºltimos aÃ±os han surgido tecnologÃ­as que permiten la utilizaciÃ³n del hardware grÃ¡fico en el despliegue tridimensional en navegadores Web; entre estas tecnologÃ­as se encuentra WebGL. En este trabajo se elaborÃ³ un prototipo de aplicaciÃ³n Web basado en WebGL que implementa el algoritmo de visualizaciÃ³n de volÃºmenes llamado ray casting para el despliegue de ecuaciones implÃ­citas. Palabras claves: ecuaciones implÃ­citas, ray casting, Web Open Graphics Library (WebGL), visualizaciÃ³n de volÃºmenes. 7 Ãndice Dedicatoria .......................................................................................................................................... 3 Agradecimientos ................................................................................................................................. 4 Resumen .............................................................................................................................................. 5 Ãndice ................................................................................................................................................... 6 IntroducciÃ³n ........................................................................................................................................ 8 CapÃ­tulo 1 - DescripciÃ³n del problema .............................................................................................. 10 1.1 - Planteamiento del problema........................................................................................ 10 1.2 Objetivo General ............................................................................................................ 11 1.3 Objetivos EspecÃ­ficos ...................................................................................................... 11 1.4 SoluciÃ³n propuesta ......................................................................................................... 11 1.4.1. MetodologÃ­a de desarrollo ............................................................................ 11 1.4.3. MÃ³dulos a desarrollar.................................................................................... 12 - AnÃ¡lisis sintÃ¡ctico de la ecuaciÃ³n implÃ­cita ........................................................... 12 - Rendering de volÃºmenes: ...................................................................................... 12 - Interfaz grÃ¡fica ....................................................................................................... 12 1.4.4. Pruebas a realizar .......................................................................................... 13 CapÃ­tulo 2 â€“ Marco teÃ³rico ................................................................................................................ 14 2.1 Imagen ..................................................................................................................... 14 2.2 Pixel ......................................................................................................................... 14 2.3 Voxel ........................................................................................................................ 14 2.4 PolÃ­gono ................................................................................................................... 15 2.5 Rendering ................................................................................................................ 15 2.6 Volume Rendering (Rendering de VolÃºmenes) ....................................................... 18 2.6.1 Rendering Directo de VolÃºmenes ................................................................... 19 2.6.2 ClasificaciÃ³n .................................................................................................... 20 2.7 - Ecuaciones ImplÃ­citas ................................................................................................... 21 2.8 Ceros de funciones ......................................................................................................... 22 2.8.1 MÃ©todo de BisecciÃ³n ...................................................................................... 22 2.8.2 MÃ©todo de Newton ........................................................................................ 23 2.8.3 MÃ©todo de la Secante ..................................................................................... 24 2.8.4 MÃ©todo de PosiciÃ³n Falsa o Regula Falsi ........................................................ 25 2.8.5 MÃ©todo de MuÌˆller .......................................................................................... 26 7 2.9 Evaluadores sintÃ¡cticos .................................................................................................. 26 2.9.1 AnÃ¡lisis LÃ©xico ................................................................................................. 27 2.9.2 AnÃ¡lisis SintÃ¡ctico ........................................................................................... 27 2.9.3 Top-Down ....................................................................................................... 28 2.9.4 Botton-Up ....................................................................................................... 29 2.10 Trabajos anteriores .......................................................................................... 30 CapÃ­tulo 3 â€“ DiseÃ±o e ImplementaciÃ³n ............................................................................................ 36 3.1 Funcionamiento general del sistema ............................................................................. 36 3.2 ImplementaciÃ³n ............................................................................................................. 37 Contenido externo utilizado .................................................................................... 37 CapÃ­tulo 4 Pruebas y Resultados ....................................................................................................... 45 4.1 Ambiente de trabajo ...................................................................................................... 45 4.2 Funciones de prueba ...................................................................................................... 45 4.3 Pruebas de calidad y rendimiento .................................................................................. 45 CapÃ­tulo 5 â€“ Conclusiones y Trabajos Futuros .................................................................................. 49 Referencias ........................................................................................................................................ 50 8 IntroducciÃ³n Las Ecuaciones implÃ­citas son ampliamente utilizadas en el Ã¡rea de la matemÃ¡tica y la fÃ­sica, por lo que en el mundo cientÃ­fico han formado parte de nuestra vida cotidiana, y han ayudado a estudiar distintos fenÃ³menos (Steffen, 2003). TÃ­picamente, para visualizar estas ecuaciones en tres dimensiones se utilizan algoritmos que reconstruyen la superficie 3D buscando los ceros de la funciÃ³n en una malla regular, y conectando los puntos resultantes para generar dicha superficie. Entre estos algoritmos se encuentran Marching Cubes y Tetra Cubes ( (Lorensen & Cline, 1987) y (Hansen & Johnson, 2004)). La idea es primero evaluar las funciÃ³n implÃ­cita en los puntos (x,y,z) de una malla regular uniforme, y luego seleccionar el umbral a reconstruir (tÃ­picamente el valor cero). El resultado es un mallado de triÃ¡ngulos que puede ser visualizado en cualquier computador que tenga soporte para visualizaciÃ³n 3D. Con la popularidad que ha adquirido la visualizaciÃ³n de volÃºmenes en los Ãºltimos aÃ±os, hoy en dÃ­a es posible visualizar la ecuaciÃ³n implÃ­cita sin la necesidad de realizar la reconstrucciÃ³n tridimensional. En este caso, basta evaluar la ecuaciÃ³n implÃ­cita en una malla regular 3D que forma un volumen, y configurar la funciÃ³n de transferencia para visualizar Ãºnicamente la superficie deseada (los ceros de la funciÃ³n). Basados en esta idea, podemos visualizar fÃ¡cilmente cualquier otra capa de la funciÃ³n implÃ­cita; es decir, visualizar otra superficie que no coincida con los ceros de la funciÃ³n, sino con cualquier otro valor. Por ejemplo, con la ecuaciÃ³n de una esfera x2+y2+z2-r2=u es posible visualizar las superficies generadas para distintos valores de u sin necesidad de reconstruir cada una de estas superficies, lo cual genera costos importantes de tiempo y espacio. En los Ãºltimos aÃ±os han surgido tecnologÃ­as que permiten la utilizaciÃ³n del hardware grÃ¡fico en el despliegue tridimensional en navegadores Web; entre estas tecnologÃ­as se encuentra WebGL (acrÃ³nimo de Web Graphics Library). En este trabajo se elaborÃ³ un prototipo de aplicaciÃ³n Web basado en WebGL que implementa el algoritmo de visualizaciÃ³n de volÃºmenes llamado ray casting para el despliegue de ecuaciones implÃ­citas. Esto le permite al usuario escribir la ecuaciÃ³n implÃ­cita, definir el Ã¡rea a visualizar (subdominio de la ecuaciÃ³n), y el conjunto de umbrales con sus respectivos niveles de transparencia. En este documento se describen las tÃ©cnicas y decisiones de diseÃ±o tomadas para poder crear un prototipo de aplicaciÃ³n Web para generar el volumen a partir de la ecuaciÃ³n implÃ­cita, y desplegarlo con ray casting. EL volumen es almacenado en un atlas de textura 2D, pues la textura 3D no era soportada por WebGL al momento de iniciar la implementaciÃ³n. El documento estÃ¡ dividido en capÃ­tulos. En el capÃ­tulo 1 se describe el problema a resolver, sus objetivos y alcances. El capÃ­tulo 2 comprende el marco teÃ³rico que soporta esta investigaciÃ³n. En el capÃ­tulo 3 se describe el diseÃ±o y la implementaciÃ³n del sistema, incluyendo las funciones necesarias 9 para la correcta actualizaciÃ³n de la funciÃ³n de transferencia y re dibujo de la ecuaciÃ³n implÃ­cita. Se implementa una interfaz grÃ¡fica para controlar cada aspecto del despliegue. Haciendo uso de esta interfaz, en el capÃ­tulo 4 se discute las pruebas realizadas para demostrar el funcionamiento del sistema como un todo y la viabilidad de la utilizaciÃ³n WebGL en este campo. Finalmente, se tienen las conclusiones y trabajos a futuro de esta investigaciÃ³n en el capÃ­tulo 5. 10 CapÃ­tulo 1 - DescripciÃ³n del problema Las ecuaciones implÃ­citas estÃ¡n involucradas en diversos procesos e investigaciones. Estas nos ayudan a representar comportamientos fÃ­sicos, entre otros fenÃ³menos (Schulz, 2003). ComÃºnmente estas funciones son bidimensionales, y visualizadas en un plano 2D; esto ayuda tener una mejor idea de cÃ³mo determinar los lÃ­mites, puntos interÃ©s y caracterÃ­sticas propias de la funciÃ³n. Al pasar de un plano de 2d al espacio 3d aumenta la dificultad de ver la representaciÃ³n grÃ¡fica. Se han diseÃ±ado distintas tecnologÃ­as para facilitar el trabajo a la hora de visualizar dichas ecuaciones, hasta llegar al punto de tener aplicaciones por computador donde se escribe la funciÃ³n implÃ­cita, y esta es desplegada en 3D. El rendering o despliegue de volÃºmenes muestra una nueva forma de ver el conjunto de datos estableciendo dos vÃ­as para su despliegue por pantalla. El primer mÃ©todo, rendering directo de volÃºmenes, consiste en la asignaciÃ³n de un color y una opacidad a cada muestra (voxel), por medio de una funciÃ³n de transferencia. El volumen como tal es representado por medio de cortes igualmente espaciados de la ecuaciÃ³n implÃ­cita. Luego, mediante trazado rayos (ray casting), el volumen es proyectado en el plano imagen para su visualizaciÃ³n. El segundo mÃ©todo, el rendering indirecto de volÃºmenes, requiere de la generaciÃ³n de una de iso-superficie intermedia, tÃ­picamente reconstruida por algoritmos como Marching Cubes y Tetra Cubes (Lorensen & Cline, 1987) y (Hansen & Johnson, 2004) .Para poder observar las distintas capas de estos volÃºmenes, se utiliza un umbral por cada capa, al cual se le asigna un color y una opacidad a travÃ©s de una funciÃ³n de transferencia. Este tipo de rendering es usado para estudiar datos mÃ©dicos, piezas automotrices y funciones implÃ­citas. Se han utilizado mÃ©todos indirectos como Marching Cubes para visualizar Ecuaciones ImplÃ­citas. Visualizar decenas de capas con este mÃ©todo es poco prÃ¡ctico, puesto que requiere de espacio para almacenar todos los mallados reconstruidos, asÃ­ como tiempo para su generaciÃ³n. Es asÃ­ como el mÃ©todo de rendering directo de volÃºmenes es atractivo, pues podemos visualizar gran cantidad de capas del volumen, sin detrimento del tiempo de respuesta ni de requerimientos extras de memoria, mÃ¡s que el volumen en sÃ­. 1.1 - Planteamiento del problema Se propone desarrollar un sistema prototipo de visualizador de ecuaciones implÃ­citas aplicando la tÃ©cnica de rendering directo de volÃºmenes, que permita visualizar varias valores de superficie asociadas a la ecuaciÃ³n implÃ­cita. Por ejemplo, no solo se desea visualizar los ceros de la funciÃ³n implÃ­cita, sino cualquier otro iso-valor que nos genere informaciÃ³n de interÃ©s, de manera similar a como se visualizan los distintos tejidos en una resonancia magnÃ©tica o tomografÃ­a computarizada. Adicionalmente se desea que este sistema estÃ© disponible en la web, y no requiera de instalaciÃ³n. 11 1.2 Objetivo General Desarrollar un sistema de visualizaciÃ³n de ecuaciones implÃ­citas en la Web aplicando la tÃ©cnica de rendering de volÃºmenes. 1.3 Objetivos EspecÃ­ficos - Crear una interfaz Web que permita al usuario introducir la ecuaciÃ³n implÃ­cita, y seleccionar las valores de superficie que desea visualizar. - Crear un mÃ³dulo de anÃ¡lisis sintÃ¡ctico de la ecuaciÃ³n. - Crear un mÃ³dulo para evaluar la funciÃ³n implÃ­cita, de manera de poder generar un volumen para su posterior visualizaciÃ³n. - Crear un mÃ³dulo de visualizaciÃ³n utilizando la tÃ©cnica de ray casting. - Evaluar el rendimiento de la aplicaciÃ³n. 1.4 SoluciÃ³n propuesta A continuaciÃ³n, se presentan algunos detalles de la propuesta de soluciÃ³n, incluyendo metodologÃ­a de desarrollo a emplease, la plataforma de desarrollo, mÃ³dulos a desarrollar, y pruebas a realizar. 1.4.1. MetodologÃ­a de desarrollo Le metodologÃ­a de desarrollo a utilizar es AdHoc. En esta se planificarÃ¡n una serie de reuniones en donde se mostrarÃ¡ el desarrollo del sistema, conforme se avance en el proyecto, y se realizarÃ¡n los cambios y sugerencias hechas por el tutor. Se utilizarÃ¡ la versiÃ³n de sublime text (Skinner, 2015) como ambiente de desarrollo, usando como API librerÃ­as graficas OpenGL ES 2.0 y librerÃ­a de shaders GLSL 1 para esta aplicaciÃ³n, los cuales estÃ¡n incluidas dentro de WebGL. Asimismo, nos apoyaremos en plantillas de Bootstrap para el diseÃ±o de interfaces, todo bajo el lenguaje de javascript/HTML/css3 para implementar el sistema. 1.4.2. Plataforma de desarrollo y pruebas Plataforma de hardware CPU Intel Core i7Q740 1.73GHz RAM 8GB NVIDIA geforce 310m (mobile graphics) 512mb ddr3 Plataforma de software OpenGL ES 2.0. Windows 8.1 Javascript/HTML5/ccs3 12 1.4.3. MÃ³dulos a desarrollar Para solucionar el problema planteado, se desean desarrollar los siguientes mÃ³dulos: - AnÃ¡lisis sintÃ¡ctico de la ecuaciÃ³n implÃ­cita Se debe crear un mÃ³dulo que verifique si la cadena de caracteres introducida es una funciÃ³n valida. El analizador a usar es un framework de la librerÃ­a de Boost c++ (Guzman, 2010), llamado Spirit. Este analizador sintÃ¡ctico posee gran flexibilidad que brindan las plantillas y la sobrecarga de operadores de c++. Esto hace que sea sencillo de construir, ademÃ¡s de poseer una adecuada documentaciÃ³n. Se utilizarÃ¡ regex de boost para comprobar que la cadena introducida es cumple con las reglas lÃ©xicas correctas, y se definirÃ¡ una gramÃ¡tica que evaluarÃ¡ la expresiÃ³n dada. - Rendering de volÃºmenes: Se utilizarÃ¡ ray casting basado en GPU. SegÃºn el trabajo de (Klaus Engel, 2001), se utilizarÃ¡ la post-clasificaciÃ³n y la clasificaciÃ³n pre-integrada. La razÃ³n de utilizar la clasificaciÃ³n pre-integrada es que permite capturar los detalles finos de la funciÃ³n de transferencia, que con la post-clasificaciÃ³n requerirÃ­a aumentar significativamente la taza de muestreo del volumen, acarreando una reducciÃ³n en el tiempo de respuesta. - Interfaz grÃ¡fica La interfaz se diseÃ±arÃ¡ con el fin de cumplir con los requisitos mÃ­nimos para la visualizaciÃ³n de la ecuaciÃ³n implÃ­cita. El usuario debe poder introducir los valores de superficie a visualizar, y tener la posibilidad de asignarle color, transparencia y demÃ¡s propiedades de rendering a cada iso-valor. El usuario debe poder especificar el dominio en el cuÃ¡l se evaluarÃ¡ la funciÃ³n implÃ­cita mediante una caja alineada a los ejes (i.e. xmin, ymin, zmin, xmax, ymax, zmax). Debido a que en principio el usuario podrÃ­a no conocer el rango funciÃ³n (el conjunto de valores que puede tomar [fmin,fmax]), la aplicaciÃ³n podrÃ­a guiar al usuario. Para ello, la funciÃ³n implÃ­cita puede ser primero evaluada en el dominio establecido para conocer el rango [fmin, fmax] de la funciÃ³n, y una vez conocido dicho rango, solicitarle al usuario dÃ³nde estarÃ­an ubicados los valores de superficie que desea visualizar, siempre dentro de dicho rango de valores. En esta direcciÃ³n, se puede crear un control especial que permita al usuario introducir los valores de superficie y cambiarlos en forma sencilla, como se muestra en la Fig. 1.1. En la imagen a continuaciÃ³n podemos observar un prototipo de la interfaz grÃ¡fica a realizar. El primer elemento contiene los campos para establecer el sub volumen de la ecuaciÃ³n a visualizar, dados por los puntos extremos min(x,y,z) y max(x,y,z) de una caja alineada a los ejes. En este dialogo se introducen valores flotantes (sean positivos o negativos) de cada uno de los limites (x,y,z) de la ecuaciÃ³n. Se agrega un campo para definir el nÃºmero de subdivisiones el cada eje. Por ejemplo, si colocamos 32 subdivisiones significa que el volumen serÃ¡ discretizado en 323 muestras. En el siguiente campo se insertarÃ¡ la ecuaciÃ³n de la forma descrita, en el que los sÃ­mbolos representarÃ¡n las operaciones asociadas, como suma (+), resta (-), multiplicaciÃ³n (*), divisiÃ³n (/), potenciaciÃ³n (^) y agrupaciÃ³n de operadores(+,-,*,^,) y operandos (X,Y,Z) con parÃ©ntesis. 13 En el tercer campo el usuario podrÃ¡ seleccionar los diferentes iso valores, y moverlos libremente en el rango de valores [fmin, fmax] determinado por el sistema. El iso valor y su color asociado serÃ¡n mostrados con un simple objeto de color (triÃ¡ngulo o cuadrado), y el valor flotante asociado podrÃ¡ visualizarse en otro control. A su vez se mostrarÃ¡ una ventana informativa donde se pueden editar los datos de la funciÃ³n de transferencia para cada iso-valor, como el color (R,G,B) y absorciÃ³n (A). Fig. 1.1: prototipo de interfaz para seleccionar valores de superficie El modelo de iluminaciÃ³n a utilizar es Phong Shading (Foley, van Dam, Feiner, & Hughes, 1996), el cual se puede habilitar o deshabilitar. Los colores difusos y especular de una iso-superficie estÃ¡n definidos por el mismo color RGB de la funciÃ³n de transferencia para dicha iso-superficie. 1.4.4. Pruebas a realizar Las diferentes pruebas a realizar buscan medir el tiempo de reconstrucciÃ³n y el tiempo de rendering para diferentes ecuaciones implÃ­citas, variando la cantidad de valores de superficie, y considerando distintas resoluciones del volumen. xmin: ymin: xmin: TamaÃ±o de la celda xmax:: ymax: xmax: X^2+Y^2+(Z^2)/2 f(x,y,z)= Iso2 fmax fmin Valores de superficie: Iso1, iso2, iso3, â€¦. resoluciÃ³n Min Max 14 CapÃ­tulo 2 â€“ Marco teÃ³rico En este capÃ­tulo se introducen los conceptos bÃ¡sicos de imagen, pixel, voxel, entre otros, necesarios para describir brevemente el proceso de rendering, y particularmente el rendering de volÃºmenes, del cual se describen el mÃ©todo a implementar (ray casting). 2.1 Imagen La palabra imagen proviene del latÃ­n imago. La imagen es un artefacto que representa o registra la percepciÃ³n visual, por ejemplo, una foto en dos dimensiones. Algunas de las caracterÃ­sticas de la imagen son: - Pueden ser de dos dimensiones, como una fotografÃ­a, o las que aparecen en un monitor. TambiÃ©n pueden ser de tres dimensiones, como una estatua o un holograma. Estos Ãºltimos son capturados por dispositivos Ã³pticos, como cÃ¡maras, espejos, lentes, telescopios, microscÃ³picos, etc. Otros objetos naturales y fenÃ³menos, como el ojo humano o superficies de agua tambiÃ©n los capturan. - La palabra imagen es usada para figuras bidimensionales como un mapa, un grafo, un grÃ¡fico de torta o una pintura. En un amplio espectro, las imÃ¡genes pueden ser generadas manualmente (como es el caso de los dibujos y una pieza de arte), o mediante un computador, en donde se pueden generar imÃ¡genes sintÃ©ticas (generadas con tÃ©cnicas de computaciÃ³n grÃ¡fica), se pueden obtener mediante digitalizaciÃ³n de imÃ¡genes existentes, o simplemente se pueden reproducir o imprimir. 2.2 Pixel En una imagen digital, un pixel, es simplemente un punto de la imagen, el cual puede ser direccionado mediante un par de coordenadas enteras. En un dispositivo de despliegue, es el elemento mÃ¡s pequeÃ±o controlable por el hardware del dispositivo. Cada pixel es una muestra de una imagen real; lÃ³gicamente mÃ¡s muestras proveen una mejor representaciÃ³n de la imagen original. La intensidad de cada pixel es variable. Su color es tÃ­picamente representado por tres o cuatro componentes de intensidad ya sean rojo, verde y azul, o los componentes cyan, magenta, amarillo y negro en el caso de las impresoras. La palabra pixel proviene de la contracciÃ³n de "picture" (pix) y "element" (el). Encontramos construcciones similares para las palabras voxel (volume element) y texel (texture element). 2.3 Voxel AsÃ­ como el pixel es la unidad mÃ­nima discreta direccionable en una imagen digital, el voxel es similarmente una unidad discreta que representa un punto de un volumen. En un voxel pueden almacenarse distintas propiedades, como una densidad, una opacidad, un color, un gradiente, etc. El 15 valor de un voxel puede representar diversas propiedades. En cada aparato de captura (por ejemplo, CT, MRI y ultrasonido) tiene una interpretaciÃ³n distinta. Para volÃºmenes representados por una malla regular, los voxels no tienen por lo general su posiciÃ³n (sus coordenadas) codificada explÃ­citamente junto con sus valores. La posiciÃ³n de un voxel se infiere basÃ¡ndose en su posiciÃ³n relativa con respecto a otros voxels, es decir, su posiciÃ³n en la estructura de datos que define el volumen discretizado. Los voxels se utilizan con frecuencia en la visualizaciÃ³n y el anÃ¡lisis de datos mÃ©dicos y cientÃ­ficos. Por lo general, se hace abstracciÃ³n de un voxel como un punto de la malla regular, y no un sub volumen del volumen original. Dependiendo del tipo de datos y el uso previsto para el conjunto de datos, el espacio que hay entre voxels puede ser reconstruido y/o aproximado, por ejemplo, mediante interpolaciÃ³n. Entre los usos mÃ¡s frecuentes de los voxels estÃ¡ la medicina para representar data volumÃ©trica de pacientes, la representaciÃ³n de datos geolÃ³gicos para explotaciÃ³n petrolera, la representaciÃ³n de la tierra en los juegos y la simulaciÃ³n. Los terrenos de voxels suelen ser utilizados en vez de un mapa de altura gracias a que se pueden representar las salientes, cuevas, arcos, y otras caracterÃ­sticas del terreno en 3d como es el caso de C4 engine [LLC, 2001]. Estas caracterÃ­sticas cÃ³ncavas no pueden ser representadas en un mapa de altura dado que solo la capa superior del terreno (una altura por cada punto) puede ser representada. 2.4 PolÃ­gono En geometrÃ­a un polÃ­gono es una figura plana que estÃ¡ dada por una cadena finita de segmentos de rectas, formando un ciclo o un circuito. Estos segmentos son llamados bordes o lados; los puntos donde dos bordes se encuentran son los vÃ©rtices o esquinas. El interior de un polÃ­gono es llamado cuerpo. Un n-Ã¡gono es un polÃ­gono de n lados. La palabra polÃ­gono proviene del griego polÃºs â€œmuchosâ€, y gÅnÃ­a â€œesquinaâ€ o â€œÃ¡nguloâ€. Los polÃ­gonos son usados en computaciÃ³n grÃ¡fica para componer imÃ¡genes o modelos por lo general en tres dimensiones. No siempre son triangulares. Estos surgen cuando se modela la superficie del objeto. En contraste a los pixeles y voxels, los polÃ­gonos se representan a menudo explÃ­citamente por las coordenadas de sus vÃ©rtices. Una consecuencia directa de esta diferencia es que los polÃ­gonos son capaces de representar de manera eficaz las estructuras 3D simples con espacios homogÃ©neos, mientras que los voxels son adecuados para la representaciÃ³n de espacios no homogÃ©neos. 2.5 Rendering Rendering es el proceso de transformaciÃ³n de una escena en una imagen [STEVENS, 1993]. En el rendering, se suele emplear un modelo de iluminaciÃ³n para generar una simulaciÃ³n realista del comportamiento de luces, texturas y materiales (agua, madera, metal, plÃ¡stico, tela, etcÃ©tera). TambiÃ©n se pueden considerar los comportamientos fÃ­sicos como en el caso de las colisiones y fluidos (ver Fig. 2.1). 16 Figura 2.1: Ejemplo del resultado final del proceso de rendering, donde se recrea una escena con distintos materiales, texturas e iluminaciÃ³n Como se puede apreciar en la Fig. 2.1, una escena contiene objetos, los cuales pueden estar definidos por un lenguaje o estructura de datos. Dicha estructura contiene la geometrÃ­a, el punto de vista, las texturas, la iluminaciÃ³n e informaciÃ³n del sombreado (shading), es decir, la descripciÃ³n de la escena. Los datos contenidos en la escena son transferidos a un programa de rendering, cuyo resultado final es una imagen digital o grÃ¡fico raster. Durante el rendering 3D se suelen utilizar distintos sistemas de coordenadas, como coordenadas de mundo, de modelo, de vista, de recorte o clipping, etc. Las transformaciones que llevan un sistema de coordenadas a otro suelen representarse por una matriz. Varios de los usos del rendering estÃ¡n ligados a la arquitectura, video juegos, simulaciÃ³n, pelÃ­culas o efectos visuales de televisiÃ³n y diseÃ±o asistido por computador (Computer-Aided Design; CAD). Cada uno emplea diferentes balances de elementos y tÃ©cnicas. Como producto, hay una gran variedad de motores de rendering disponibles; algunos de estos estÃ¡n integrados en grandes paquetes de modelaje y animaciÃ³n, otros son de uso dedicado, como proyectos de cÃ³digo libre, juegos, etc. Para visualizar la escena en tiempo real, se suele utilizar un pipeline grÃ¡fico, el cual convierte primitivas grÃ¡ficas del espacio de modelo en primitivas dentro del espacio del dispositivo, es decir, en pÃ­xeles. Partes de este pipeline grÃ¡fico son implementadas en el hardware grÃ¡fico para tener mejores tiempos de respuestas. Con el avance de la tecnologÃ­a, algunas etapas de este pipeline grÃ¡fico tienen la facilidad de ser programables. AsÃ­, algunos de sus estados son de hecho unidades de programaciÃ³n; esto quiere decir que podemos implementar nuestros modelos de luz o transformaciones geomÃ©tricas, teniendo libertad en la transformaciÃ³n de cada vÃ©rtice y de la 17 asignaciÃ³n de color a cada fragmento. Los aceleradores grÃ¡ficos programables, son tambiÃ©n conocidos como GPU (Graphics Processor Unit, o unidad de procesamiento grÃ¡fico). La Unidad de Procesamiento GrÃ¡fico (Graphic Processing Unit; GPU) es un dispositivo diseÃ±ado con el propÃ³sito de acelerar la creaciÃ³n de imÃ¡genes en el frame buffer (memoria dedicada de video que contiene los datos completos de cada cuadro de imagen). Las GPUs se encuentran embebidas en sistemas, telÃ©fonos mÃ³viles, computadores personales, estaciones de trabajo y consolas de videojuegos. La GPU moderna es eficiente manipulando los grÃ¡ficos del computador, y gracias a su estructura de alto paralelismo es mÃ¡s eficiente que el CPU. La GPU se encarga de hacer el cÃ¡lculo del modelo de iluminaciÃ³n, rasterizaciÃ³n, texturizaciÃ³n y clipping (recortes); este Ãºltimo consiste la eliminaciÃ³n de porciones de objetos extendidos mÃ¡s allÃ¡ de una regiÃ³n predeterminada de la escena (e.g. un clippling plane), quedando asÃ­ un subconjunto de los objetos a ser desplegados (STEVENS, 1993). El proceso de rendering se puede describir mediante la EcuaciÃ³n 1.1. Esta ecuaciÃ³n no abarca todo el fenÃ³meno luminoso, pero es parte del modelo de iluminaciÃ³n para generar imÃ¡genes por medio de la computadora. EcuaciÃ³n 1.1 (EcuaciÃ³n de rendering o cÃ¡lculo del modelo de iluminaciÃ³n) La ecuaciÃ³n 1.1 describe como en una posiciÃ³n x y direcciÃ³n w particular, la luz de salida(ğ¿ğ‘œ) es la suma de la luz emitida (ğ¿ğ‘’) y el reflejo de la luz. El reflejo de la luz por otra parte se modela como una integral donde intervienen la luz de entrada(ğ¿ğ‘–) de todas las direcciones, multiplicada por el reflejo de la superficie ğ‘“ğ‘Ÿ(ğ‘¥, ï¿½âƒ‘âƒ‘ï¿½ , ï¿½âƒ‘âƒ‘ï¿½ ) , y el Ã¡ngulo de entrada de la luz (ï¿½âƒ‘âƒ‘ï¿½ â‹… ï¿½âƒ‘ï¿½ ) . Esto define el transporte de la luz a travÃ©s de la escena. La funciÃ³n de distribuciÃ³n bidireccional de reflectancia (BRDF) ğ‘“ğ‘Ÿ(ğ‘¥, ï¿½âƒ‘âƒ‘ï¿½ , ï¿½âƒ‘âƒ‘ï¿½ ), expresa un modelo de interacciÃ³n de luz con las superficies, en cual se destacan 2 tipos: la reflexiÃ³n difusa y la reflexiÃ³n especular. 2.5.1 CaracterÃ­sticas del Rendering El motor de rendering posee una abundante cantidad de caracterÃ­sticas visuales para dar un resultado realista en lo posible. El desarrollo y la investigaciÃ³n en el rendering se han enfocado en encontrar formas de simular estas caracterÃ­sticas visuales de manera eficiente. Algunas de estas caracterÃ­sticas estÃ¡n directamente relacionadas con algoritmos y tÃ©cnicas, mientras que otras caracterÃ­sticas son producto de la uniÃ³n de varias tÃ©cnicas. Algunas de estas tÃ©cnicas son: ï‚· Shading (sombreado): define cÃ³mo el color y el brillo de una superficie varÃ­an segÃºn la iluminaciÃ³n ï‚· Texture-mapping (aplicaciÃ³n de textura): es un mÃ©todo para aplicar detalle de textura sobre superficies 18 ï‚· Bump-mapping: es un mÃ©todo para simular a escala pequeÃ±a protuberancias o hendiduras sobre superficies ï‚· Neblina: define cÃ³mo la luz obscurece cuando pasa por medio de una atmÃ³sfera densa ï‚· Sombras: muestra el efecto de obstrucciÃ³n de la luz ï‚· Sombras suaves: variaciÃ³n de oscuridad causada por fuentes de luz parcialmente ocultas ï‚· ReflexiÃ³n: efecto espejo, un rayo de luz incide sobre una superficie y es reflejado ï‚· Transparencia: transmisiÃ³n continua de la luz a travÃ©s de objetos sÃ³lidos ï‚· RefracciÃ³n: curvatura de la luz asociada con la transparencia ï‚· DifracciÃ³n: desviaciÃ³n de la luz al encontrar un obstÃ¡culo o al atravesar una rendija ï‚· IluminaciÃ³n indirecta: superficies iluminadas por la luz reflejada de otras superficies, en lugar de ser iluminada por una fuente de luz directa ï‚· CÃ¡ustica: es la combinaciÃ³n de los rayos de luz reflejada o refractada por una superficie u objeto curvo, o la proyecciÃ³n de esa combinaciÃ³n de rayos en otra superficie ï‚· Depth of field (profundidad de campo): efecto que hace que objetos aparezcan borrosos o fuera de foco cuando se estÃ¡ muy lejos, en frente o detrÃ¡s de un objeto enfocado ï‚· Motion blur (borrosidad por movimiento): los objetos aparecen borrosos dado el movimiento de alta velocidad o movimiento de la cÃ¡mara ï‚· Rendering no foto realÃ­stico: rendering de escenas en un estilo artÃ­stico, destinado a verse como una pintura o un dibujo 2.6 Volume Rendering (Rendering de VolÃºmenes) En visualizaciÃ³n cientÃ­fica y computaciÃ³n grÃ¡fica, es una tÃ©cnica utilizada para generar una imagen a partir de la proyecciÃ³n de un volumen, simulando cÃ³mo se propaga la luz a travÃ©s de dicho volumen (B & D, 2007). TÃ­picamente este volumen viene dado por un conjunto de imÃ¡genes seriadas 2D, igualmente espaciadas, adquiridas por CT, MRI, entre otros (ver Fig. 2.2). La distancia entre muestras (voxels) de un mismo corte tambiÃ©n es constante, generando un patrÃ³n regular llamado mallado volumÃ©trico regular. Figura 2.2: rendering de un volumen capturado por un escÃ¡ner CT 19 Hay dos vertientes para visualizar el volumen: el despliegue indirecto de volÃºmenes, el cual requiere de la generaciÃ³n de una superficie antes de su visualizaciÃ³n, y el despliegue directo de volÃºmenes, el cual visualiza el volumen partir de la proyecciÃ³n de sus muestras. En el caso de despliegue indirecto de volÃºmenes, vale mencionar el algoritmo de Marching Cubes (B & D, 2007), que es una tÃ©cnica comÃºn utilizada para la extracciÃ³n de valores de superficie, en el cual toma 8 muestras adyacentes a la vez (formando un cubo imaginario), en donde se determinan los polÃ­gonos que atraviesan ese cubo mediante interpolaciÃ³n lineal. Para el caso de despliegue directo de volÃºmenes, estudiaremos la tÃ©cnica de ray casting, la cual serÃ¡ implementada en este trabajo. 2.6.1 Rendering Directo de VolÃºmenes Para hacer una proyecciÃ³n 2D del conjunto de voxels 3D, primero hay que definir una cÃ¡mara en el espacio en relaciÃ³n con el volumen. TambiÃ©n, hay que definir la opacidad y el color de cada voxel [Levoy, 1988]. Esto se define por lo general con una funciÃ³n de transferencia unidimensional [Infogrames, 2003]. Con dicha funciÃ³n de transferencia se define el valor RGBA (Red, Green, Blue, Alpha; las siglas para cada color y trasparencia) para cada valor posible de voxel. Esta funciÃ³n suele ser una funciÃ³n lineal a trozos, por cada componente de la tupla RGBA. El proceso de asignar un color y una opacidad a un voxel se llama clasificaciÃ³n. El pipeline del rendering de volÃºmenes sigue una serie de pasos que constan del muestreo (sampling), clasificaciÃ³n y composiciÃ³n. El muestreo consiste en reconstruir muestras del volumen por medio de la interpolaciÃ³n de voxels. Esto se realiza debido a que, al proyectar el volumen, las muestras originales del mismo no coinciden con la ubicaciÃ³n de los pixeles, por lo que en cambio se reconstruyen los voxels que estÃ¡n a lo largo de un rayo que pasa por el pixel desde la posiciÃ³n del observador. La clasificaciÃ³n e iluminaciÃ³n consiste en darle color y opacidad al voxel reconstruido. Mediante una funciÃ³n de transferencia se le otorga un color y opacidad inicial al voxel, el cual es usado en conjunto con un modelo de iluminaciÃ³n para calcular su contribuciÃ³n lumÃ­nica. Luego de muestrear, clasificar e iluminar cada voxel al largo de la discretizaciÃ³n de un rayo, estos deben ser compuestos de acuerdo al modelo fÃ­sico del volumen. El orden en que se realiza el proceso de clasificaciÃ³n y muestreo determina el tipo de clasificaciÃ³n. Se realiza post-clasificaciÃ³n cuando se reconstruye el voxel y luego es clasificado, mientras que se realiza pre-clasificaciÃ³n cuando primero se clasifican las muestras del volumen original, y luego se realiza la reconstrucciÃ³n de las muestras (B & D, 2007). La tÃ©cnica de ray casting se deduce directamente de la ecuaciÃ³n de rendering [Kajiya, 1986]. Esta provee resultados de alta calidad. En esta tÃ©cnica se genera un rayo por cada pixel deseado de la imagen. Usando un modelo simple de cÃ¡mara, el rayo comienza desde el centro de proyecciÃ³n de la cÃ¡mara (normalmente la ubicaciÃ³n del ojo) y pasa a travÃ©s de un pixel en el plano imagen imaginario ubicado entre la cÃ¡mara y el volumen. En la intersecciÃ³n de rayo con el volumen, el volumen es muestreado en intervalos regulares o adaptativos para, a travÃ©s de la composiciÃ³n, 20 obtener el valor de un pixel en la imagen. El proceso se realiza por cada pixel en la imagen (ver Fig. 2.3). Figura 2.3: pasos de ray casting para un pixel de la imagen. (1) Se lanza un rayo desde el ojo, pasando por un pÃ­xel de la imagen. (2) Se reconstruyen muestras del volumen a lo largo del rayo. (3) Se clasifican e iluminan dichas muestras. (4) Se componen las muestras para obtener el color del pixel 2.6.2 ClasificaciÃ³n En el despliegue de volumen existen diversos mÃ©todos para procesar dicho volumen y ser mostrado por pantalla, estos mÃ©todos de clasificaciÃ³n de volumen ayudan a tener una mejor visualizaciÃ³n de este (K. & T., 2001). ClasificaciÃ³n en este caso es la asignaciÃ³n de un color una opacidad a ese valor del conjunto datos. Dentro de los mÃ©todos de clasificaciÃ³n tenemos: PRE-CLASIFICACIÃ“N: Indica la aplicaciÃ³n de la funciÃ³n de transferencia a los puntos de muestreo discretizados antes de la etapa de interpolaciÃ³n de datos. En otras palabras, el color y la absorciÃ³n son calculados en una etapa de pre procesamiento para cada punto de muestreo y luego se usa para interpolar el color y la opacidad con el fin de calcular la representaciÃ³n integral del volumen POST-CLASIFICACIÃ“N: El orden de las operaciones se invierte, con respecto a la Pre-clasificaciÃ³n. Este tipo de clasificaciÃ³n se caracteriza por la aplicaciÃ³n de la funciÃ³n de transferencia despuÃ©s de la interpolaciÃ³n de la opacidad a partir de los valores escalares de los puntos de muestreo discretizados. PRE-INTEGRACIÃ“N: La idea principal de la clasificaciÃ³n pre-integrada es dividir el proceso de integraciÃ³n numÃ©rica. La integraciÃ³n por separado del campo escalar continÃºo y las funciones de transferencia se lleva a cabo para hacer frente a la problemÃ¡tica de la frecuencia de Nyquist. Mientras el campo escalar del volumen puede ser suave, la funciÃ³n de transferencia entre dos muestras del campo escalar podrÃ­a requerir una alta tasa de muestreo para capturar todos los detalles. 21 Para evitar el muestreo excesivo de la funciÃ³n de transferencia durante el rendering, una alternativa es pre calcular la integral entre cada par posible de muestras cuantizadas de un rayo, y en tiempo de rendering, obtener la integral pre-calculada entre cada par de muestras consecutivas en O(1). En la Fig 2.4 podemos apreciar el rendering utilizando las diferentes tÃ©cnicas de clasificaciÃ³n. Figura 2.4: Ejemplo de las diferentes clasificaciones: de izquierda a derecha (a)pre- clasificacion (b)pos-clasificacion (c)pre-integracion 2.7 - Ecuaciones ImplÃ­citas Una funciÃ³n explicita, es una funciÃ³n que es dada en tÃ©rminos de una o mÃ¡s variables independientes. Por ejemplo, en la siguiente funciÃ³n ğ‘¦ = ğ‘“(ğ‘¥) = ğ‘¥2 + 3ğ‘¥ âˆ’ 8, ğ‘¦ es la variable dependiente y es dada en tÃ©rminos una variable independiente ğ‘¥. Se llama variable independiente a los valores que pueden tomar los elementos del dominio de la funciÃ³n. Generalmente se denota por x para funciones bidimensionales. En el ejemplo anterior, ğ‘¥ âˆˆ ğ‘ ya que asÃ­ fue especificada. Se llama variable dependiente a los valores que pueden tomar la imagen o rango de la funciÃ³n. Generalmente se denota por la letra ğ‘¦ para funciones bidimensionales, dÃ³nde ğ‘¦ = ğ‘“(ğ‘¥). En el ejemplo anterior, ğ‘¦ âˆˆ {âˆ’2,âˆ’53,âˆ’73,âˆ’43,âˆ’83,âˆ’1,â€¦ } Los valores de x que anulan la funciÃ³n (i.e. x:f(x)=0) son las raÃ­ces de la funciÃ³n. TambiÃ©n son llamados los ceros de la funciÃ³n. Las funciones implÃ­citas, por otro lado, son usualmente dadas en tÃ©rmino de ambas variables (dependientes e independientes), como por ejemplo: ğ‘“(ğ‘¥, ğ‘¦) = 2ğ‘¦ + ğ‘ ğ‘’ğ‘›(âˆ’ğ‘¥) . La ecuaciÃ³n de una funciÃ³n, es la expresiÃ³n algebraica que resume cÃ³mo se obtienen los valores del conjunto final a partir de los valores del conjunto inicial funciÃ³n, tal y como se presenta la funciÃ³n explÃ­cita: ğ‘¦ = ğ‘“(ğ‘¥) = ğ‘¥2 + 3ğ‘¥ âˆ’ 8. Similarmente, la ecuaciÃ³n implÃ­cita no es mÃ¡s que el resumen de los valores obtenidos a partir de una FunciÃ³n ImplÃ­cita. Por ejemplo, 22 { (x,y)ïƒïƒ‚2 : ğ‘“(ğ‘¥, ğ‘¦) = ğ‘¦ + ğ‘¥2 âˆ’ 3ğ‘¥ + 8 = 0 } Los ceros de la funciÃ³n f(x,y) son en este caso los puntos (x,y) que pertenecen a la ecuaciÃ³n implÃ­cita. 2.8 Ceros de funciones Existen diversos mÃ©todos para hallar las raÃ­ces de funciones; la idea es obtener una soluciÃ³n de la ecuaciÃ³n ğ‘“(ğ‘¥) = 0, para una funciÃ³n dada ğ‘“. Entre los mÃ©todos se encuentran los mÃ©todos cerrados (BisecciÃ³n, Regula Falsi, MuÌˆller) los cuales parten de un intervalo dado para hallar la raÃ­z de dicha ecuaciÃ³n. Por otro lado se encuentran los mÃ©todos abiertos (Newton, Secante) que establecen distintas condiciones para hallar la raÃ­z. Varios de estos mÃ©todos para hallar raÃ­ces requieren ser comprobada si la funciÃ³n preserva el orden (monÃ³tona creciente) o es reverso (monÃ³tona decreciente), ya que existen funciones que no son monÃ³tonas y puede que no exista la raÃ­z en ese intervalo seleccionado. Una funciÃ³n ğ‘“ que define un subconjunto de nÃºmeros reales se llama monÃ³tona creciente, si para cada ğ‘¥ e ğ‘¦ tales que ğ‘¥ â‰¤ ğ‘¦ se tiene que ğ‘“(ğ‘¥) â‰¤ ğ‘“(ğ‘¦). Del mismo modo una funciÃ³n se llama monÃ³tona decreciente, si para cada ğ‘¥ e ğ‘¦ tales que ğ‘¦ â‰¤ ğ‘¥ se cumple que ğ‘“(ğ‘¥) â‰¥ ğ‘“(ğ‘¦) . La monotonicidad puede estar presente en un sub dominio de la funciÃ³n (por ejemplo, en un sub intervalo), o es todo su dominio. A continuaciÃ³n, estudiaremos varios mÃ©todos clÃ¡sicos de ceros de funciones, a saber: BisecciÃ³n, Newton, Secante, Regula Falsi y MÃ¼ller. 2.8.1 MÃ©todo de BisecciÃ³n Supongamos que ğ‘“ es una funciÃ³n continÃºa definida en el intervalo [ğ‘, ğ‘] con ğ‘“(ğ‘) y ğ‘“(ğ‘) de signos diferentes. De acuerdo con el teorema del valor intermedio, este teorema nos indica que si ğ‘¢ es un numero entre ğ‘“(ğ‘) y ğ‘“(ğ‘) con ğ‘“(ğ‘) > ğ‘¢ > ğ‘“(ğ‘) o ğ‘“(ğ‘) < ğ‘¢ < ğ‘“(ğ‘), entonces existe un ğ‘ïƒ[ğ‘, ğ‘], tal que ğ‘“(ğ‘) = ğ‘¢. Si bien el procedimiento se aplica, aunque exista mÃ¡s de una raÃ­z en el intervalo (ğ‘, ğ‘), por razones de simplicidad suponemos que la raÃ­z de este intervalo es Ãºnica. El mÃ©todo requiere dividir varias veces a la mitad los sub intervalos de [ğ‘, ğ‘] y, en cada paso, localizar la mitad que contenga a ğ‘. Para empezar, supongamos que ğ‘1 = ğ‘ y ğ‘1 = ğ‘, y sea ğ‘š1, el punto medio de [ğ‘, ğ‘]; es decir: ğ‘š1 = ğ‘1 + ğ‘1âˆ’ğ‘1 2 = ğ‘1 + ğ‘1 2 . Si ğ‘“(ğ‘š1) = 0, entonces ğ‘ = ğ‘š1; de no ser asÃ­ entonces ğ‘“(ğ‘š1) tiene el mismo signo que ğ‘“(ğ‘1) o ğ‘“(ğ‘1). Si ğ‘“(ğ‘1) y ğ‘“(ğ‘š1) tienen el mismo signo, entonces ğ‘ pertenece (ğ‘š1, ğ‘1) y tomamos ğ‘2 = ğ‘š1 y ğ‘2 = ğ‘1 . Si ğ‘“(ğ‘1) y ğ‘“(ğ‘š1) tienen signos opuestos, entonces ğ‘ pertenece (ğ‘1,ğ‘š1) y tomamos ğ‘2 = ğ‘1 ğ‘¦ ğ‘2 = ğ‘š1. DespuÃ©s volvemos a aplicar el proceso al intervalo [ğ‘2, ğ‘2] tomando el punto medio m2, de forma iterativa hasta obtener la raÃ­z de dicha funciÃ³n con ciertos decimales de 23 precisiÃ³n. Haciendo un anÃ¡lisis del mÃ©todo se garantiza la convergencia de la raÃ­z de f si f es una funciÃ³n continua dentro del intervalo establecido [ğ‘, ğ‘] y tanto f(a) como f(b) tienen signos opuestos. El error absoluto se reduce a la mitad por cada paso, por lo que el mÃ©todo converge de manera lineal (ver Fig. 2.5). El error luego de n iteraciones es acotado por |mn â€“ c| <= |b-a|/2n. Esta fÃ³rmula es usada para determinar el nÃºmero de iteraciones para converger a la raÃ­z deseada con una cierta tolerancia t. AsÃ­, n >= log2(b-a)-t. Figura 2.5: Ejemplo de aplicaciÃ³n del MÃ©todo de BisecciÃ³n [Ziegler, 2004] 2.8.2 MÃ©todo de Newton Parte de una aproximaciÃ³n inicial ğ‘¥0 y obtiene una aproximaciÃ³n mejorada, ğ‘¥1, dada por la fÃ³rmula: ğ‘¥1 = ğ‘¥0 â€“ ğ‘“(ğ‘¥0) ğ‘“â€™(ğ‘¥0) (1) La ecuaciÃ³n 1 anterior puede derivarse del desarrollo en serie de Taylor. Para un entorno del punto ğ‘¥ğ‘› : ğ‘“(ğ‘¥) = ğ‘“(ğ‘¥ğ‘›) + ğ‘“â€™(ğ‘¥ğ‘›)(ğ‘¥ âˆ’ ğ‘¥ğ‘›) + (ğ‘¥ âˆ’ ğ‘¥ğ‘›) 2 ğ‘“â€™â€™(ğ‘¥ğ‘›) 2! + â€¦ si se trunca el desarrollo a partir del termino de grado 2, y evaluamos en ğ‘¥ğ‘›+1:ğ‘“(ğ‘¥ğ‘›+1) = ğ‘“(ğ‘¥ğ‘›) + ğ‘“â€²(ğ‘¥ğ‘›)( ğ‘¥ğ‘›+1 âˆ’ ğ‘¥ğ‘›), y si ademÃ¡s se acepta que ğ‘¥ğ‘›+1 tiende a la raÃ­z, se ha de cumplir que ğ‘“(ğ‘¥ğ‘›+1) = 0. Luego sustituyendo en la expresiÃ³n anterior, obtenemos 0 = ğ‘“(ğ‘¥ğ‘›) + ğ‘“â€²(ğ‘¥ğ‘›)( ğ‘¥ğ‘›+1 âˆ’ ğ‘¥ğ‘›). Finalmente, despejamos xn+1 y obtenemos la ecuaciÃ³n (1). El mÃ©todo de Newton tiene una interpretaciÃ³n geomÃ©trica sencilla, como se puede apreciar del anÃ¡lisis de la Fig. 2.6. De hecho, el mÃ©todo de Newton consiste en una linealizaciÃ³n de la funciÃ³n, es decir, ğ‘“ se reemplaza por una recta tal que contiene al punto (ğ‘¥0, ğ‘“(ğ‘¥0)) y cuya pendiente coincide con la derivada de la funciÃ³n del punto, ğ‘“(ğ‘¥0). La nueva aproximaciÃ³n a la raÃ­z, ğ‘¥1 , se obtiene de la intersecciÃ³n de la funciÃ³n lineal con el eje ğ‘¥. 24 Figura 2.6: Ejemplo de la aplicaciÃ³n del Metodo de Newton [Pauls, 2011] Otra forma de derivar la ecuaciÃ³n (1) es utilizando la ecuaciÃ³n de la recta que pasa por el punto (ğ‘¥0, ğ‘“(ğ‘¥0)) y de pendiente ğ‘¦ â€“ ğ‘“(ğ‘¥0) = ğ‘“(ğ‘¥0)(ğ‘¥ âˆ’ ğ‘¥0). Haciendo ğ‘¦ = 0 y despejando ğ‘¥ obtenemos la ecuacion (1). La convergencia de este mÃ©todo es cuadrÃ¡tica. 2.8.3 MÃ©todo de la Secante Requiere dos puntos iniciales, los cuales pueden ser arbitrarios. Consiste en trazar rectas secantes a la curva de la ecuaciÃ³n que se estÃ¡ analizando, y verificar la intersecciÃ³n de dichas rectas con el eje de las x para determinar si es la raÃ­z que se busca (ver Fig 2.7). Al ser un mÃ©todo abierto, converge con la raÃ­z con una velocidad semejante a la de Newton, aunque similarmente al mÃ©todo de Newton, la convergencia no estÃ¡ garantizada si el iterado inicial estÃ¡ lejos de la raÃ­z. Su principal diferencia con el mÃ©todo de Newton es que no se requiere obtener la derivada de la funciÃ³n para realizar las aproximaciones, lo cual facilita las cosas al momento de crear un cÃ³digo para encontrar raÃ­ces por medio de este mÃ©todo. La convergencia de este mÃ©todo es de 1.62 (sÃºper lineal), pero no llega a ser cuadrÃ¡tica. El mÃ©todo de la secante se basa en la fÃ³rmula de Newton, pero evita el cÃ¡lculo de la derivada usando la siguiente aproximaciÃ³n: ğ‘“â€™(ğ‘¥ğ‘–) â‰ˆ ğ‘“(ğ‘¥ğ‘–âˆ’1) âˆ’ğ‘“(ğ‘¥ğ‘–) ğ‘¥ğ‘–âˆ’1 â€“ ğ‘¥ğ‘– . Sustituyendo en la fÃ³rmula de newton, obtenemos: ğ‘¥ğ‘–+1 = ğ‘¥ğ‘– â€“ ğ‘“(ğ‘¥ğ‘–) ğ‘“â€™(ğ‘¥ğ‘–) â‰ˆ ğ‘¥ğ‘– â€“ ğ‘“(ğ‘¥ğ‘–) ğ‘“(ğ‘¥ğ‘–âˆ’1)âˆ’ğ‘“(ğ‘¥ğ‘–) ğ‘¥ğ‘–âˆ’1âˆ’ğ‘¥ğ‘– , ğ‘¥ğ‘–+1 â‰ˆ ğ‘¥ğ‘– âˆ’ ğ‘“(ğ‘¥ğ‘–)(ğ‘¥ğ‘–+1âˆ’ğ‘¥ğ‘–) ğ‘“(ğ‘¥ğ‘–+1)âˆ’ğ‘“(ğ‘¥ğ‘–) 25 Figura 2.7 Ejemplo de la aplicaciÃ³n del MÃ©todo de la Secante 2.8.4 MÃ©todo de PosiciÃ³n Falsa o Regula Falsi El mÃ©todo de la posiciÃ³n falsa usa lo mejor de la bisecciÃ³n y del mÃ©todo de la secante. Este mÃ©todo, como en el mÃ©todo de la bisecciÃ³n, parte de dos puntos que rodean a la raÃ­z ğ‘“(ğ‘¥) = 0, es decir, dos puntos ğ‘¥0 y ğ‘¥1 tales que ğ‘“(ğ‘¥0)ğ‘“(ğ‘¥1) < 0. La siguiente aproximaciÃ³n, ğ‘¥2, se calcula como la intersecciÃ³n con el eje ğ‘¥ de la recta que une ambos puntos (empleando la ecuaciÃ³n ğ‘¥2 = ğ‘¥0 âˆ’ ğ‘¥1âˆ’ğ‘¥0 ğ‘“(ğ‘¥1)âˆ’ğ‘“(ğ‘¥0) ğ‘“(ğ‘¥0) del mÃ©todo de la secante). La asignaciÃ³n del nuevo intervalo de bÃºsqueda se realiza como en el mÃ©todo de la bisecciÃ³n: entre ambos intervalos [ğ‘¥0, ğ‘¥2] y [ğ‘¥2, ğ‘¥1], se toma aquel que cumpla ğ‘“(ğ‘¥ğ‘šğ‘–ğ‘›)ğ‘“(ğ‘¥ğ‘šğ‘ğ‘¥) < 0. En la Fig. 2.8 se representa geomÃ©tricamente el mÃ©todo. Similar a BisecciÃ³n, la convergencia de este mÃ©todo es lineal, e igualmente la convergencia estÃ¡ garantizada. Figura 2.8 Ejemplo de la aplicaciÃ³n del mÃ©todo de Regula Falsi 2.8.5 MÃ©todo de MuÌˆller Consiste en utilizar tres aproximaciones iniciales ğ‘¥0, ğ‘¥1 ğ‘¦ ğ‘¥2 a la raÃ­z de ğ‘“(ğ‘¥) = 0 , y determinar la siguiente aproximaciÃ³n al considerar la ecuaciÃ³n de la parÃ¡bola que pasa por los puntos (ğ‘¥0, ğ‘“(ğ‘¥0)); (ğ‘¥1, ğ‘“(ğ‘¥1)) ğ‘¦ (ğ‘¥2, ğ‘“(ğ‘¥2)). La intersecciÃ³n con el eje ğ‘¥ en el punto (ğ‘¥3, ğ‘‚) define la aproximaciÃ³n a la raÃ­z de ğ‘“. Para hallar ğ‘¥3, primero se encuentra los coeficientes de la ecuacioÌn de la parabÌola. 26 ğ‘¦(ğ‘¥) = ğ‘0(ğ‘¥ âˆ’ ğ‘¥2) 2 + ğ‘1(ğ‘¥ âˆ’ ğ‘¥2) 2 + ğ‘2, donde: ğ‘0 = (ğ‘¥1âˆ’ ğ‘¥2)[ğ‘“(ğ‘¥0) âˆ’ ğ‘“(ğ‘¥2)] âˆ’ (ğ‘¥0 âˆ’ ğ‘¥2)[ğ‘“(ğ‘¥1) âˆ’ ğ‘“(ğ‘¥2)] (ğ‘¥0 âˆ’ ğ‘¥2)(ğ‘¥1 âˆ’ ğ‘¥2)(ğ‘¥0 âˆ’ ğ‘¥1) , ğ‘1 = ğ‘“(ğ‘¥2)â€“ ğ‘“(ğ‘¥1) ğ‘¥2 â€“ ğ‘¥1 + (ğ‘¥2 â€“ ğ‘¥1)ğ‘0, ğ‘2 = ğ‘“(ğ‘¥2). La aproximaciÃ³n a la raÃ­z x3 del polinomio es obtenida de la siguiente forma, ğ‘¥3 = ğ‘¥2 âˆ’ 2 ğ‘2 ğ‘1 + ğ‘ ğ‘–ğ‘”ğ‘›(ğ‘1)âˆšğ‘1 2 âˆ’ 4 ğ‘0 ğ‘2 . Para continuar con el proceso, se eligen de las tres aproximaciones iniciales las dos mÃ¡s prÃ³ximas a ğ‘¥3, y luego se renombran como ğ‘¥0, ğ‘¥1 ğ‘¦ ğ‘¥2, y se repite el proceso tanto como desee (Ver Fig. 2.9). La velocidad de convergencia del mÃ©todo es 1.84. Figura 2.9: Ejemplo de la aplicaciÃ³n del mÃ©todo de MuÌˆller (DaFeda, 2010) 2.9 Evaluadores sintÃ¡cticos Antes de explicar los evaluadores sintÃ¡cticos tenemos que tener en cuenta que existe un proceso de traducciÃ³n por parte de la computadora en donde, en nuestro caso, la entrada de datos 27 es la ecuaciÃ³n (Aho, Lam, & Sethi, 2007) (Northwood, 2009). La traducciÃ³n estÃ¡ compuesta por dos etapas: ï‚· AnÃ¡lisis lÃ©xico: el flujo de caracteres de entrada se convierte en un flujo de lexemas. Un lexema es una unidad gramatical mÃ­nima reconocida por el lenguaje. Por ejemplo, un lexema puede ser un identificador, un operador, una palabra reservada del lenguaje o una constante (nÃºmeros, strings, etc.) ï‚· AnÃ¡lisis sintÃ¡ctico: a este flujo de lexemas se le aplican reglas de una gramÃ¡tica que define al lenguaje que queremos reconocer. Estas reglas generalmente forman una gramÃ¡tica libre de contexto, aunque depende del lenguaje que se quiere reconocer. 2.9.1 AnÃ¡lisis LÃ©xico El anÃ¡lisis lÃ©xico es la extracciÃ³n de palabras individuales o lexemas a partir de una secuencia de sÃ­mbolos. Otros roles del analizador lÃ©xico incluyen remover los espacios en blanco y los comentarios. El proceso de transformaciÃ³n a lexemas, consiste en la construcciÃ³n de un autÃ³mata finito que agrupa los sÃ­mbolos de la entrada. Este autÃ³mata se construye una sola vez y es usado cada vez que se desea hacer el anÃ¡lisis lÃ©xico de un nuevo conjunto de sÃ­mbolos. Generalmente un lexema puede ser un identificador, operadores del lenguaje, palabras reservadas y constantes (numÃ©ricas y cadenas de caracteres). AsÃ­, una entrada como la siguiente: â€œif (velocidad > 50)â€ se traduce a â€œ<if> <parÃ©ntesis abierto> <identificador> <operador relacional> <constante> <parÃ©ntesis cerrado>â€, obteniendo a partir de un flujo de sÃ­mbolos un flujo de lexemas. El autÃ³mata se construye de forma tal que se reconozca siempre el lexema mÃ¡s largo posible. AsÃ­, por ejemplo, el lexema â€œabcâ€ podrÃ­a identificarse como tres identificadores seguidos (a, b y c) o como un solo identificador. Esta regla garantiza que el identificador mÃ¡s largo es reconocido. Para construir un analizador lÃ©xico pueden definirse los lexemas del lenguaje con una gramÃ¡tica lineal (usando una expresiÃ³n regular), y aplicando el algoritmo de construcciÃ³n de Thompson es posible crear el autÃ³mata asociado. Pueden tambiÃ©n usarse programas como flex los cuales permiten definir los lexemas del lenguaje y generan cÃ³digo C para manejar el autÃ³mata y reconocer los distintos lexemas. El autÃ³mata se representa de forma muy compacta usando una tabla de transiciÃ³n de estados. En el caso de las ecuaciones es necesario definir las expresiones regulares que definen a cada lexema del lenguaje: nombres de funciones, operadores y constantes, y luego generar un analizador sintÃ¡ctico usando algÃºn generador de analizadores lÃ©xicos. 2.9.2 AnÃ¡lisis SintÃ¡ctico Una vez que le flujo de sÃ­mbolos es convertido es un flujo de lexemas, este debe ser procesado por el analizador sintÃ¡ctico. Debe existir una gramÃ¡tica libre de contexto que represente 28 al lenguaje que se desea reconocer. Esa gramÃ¡tica especifica mediante reglas, cuÃ¡les son las construcciones vÃ¡lidas del lenguaje, esto es, de quÃ© forma es posible combinar los lexemas para reconocer frases del lenguaje. El resultado del anÃ¡lisis sintÃ¡ctico es un Ã¡rbol que representa el anÃ¡lisis que se le hizo a la entrada. Este Ã¡rbol almacena en cada nodo un lexema, y su estructura indica que operaciÃ³n de debe aplicar. Por ejemplo, en el caso de ecuaciones, un operador binario tendrÃ¡ siempre dos nodos hijos (las dos expresiones que se desean sumar). Un nombre de una funciÃ³n tendrÃ¡ tantos hijos como parÃ¡metros tenga la funciÃ³n. Identificadores y constantes numÃ©ricas aparecerÃ¡n siempre como hojas de Ã©ste Ã¡rbol (ver Fig 2.10). Figura 2.10: Ejemplo de un Ã¡rbol de anÃ¡lisis Un analizador sintÃ¡ctico necesita un autÃ³mata de pila para poder representarse. Existen varios tipos de algoritmos para construir analizadores sintÃ¡cticos, pero los dos tipos mÃ¡s usados son los analizadores descendientes (top-down) y ascendiente (bottom-up). 2.9.3 Top-Down El anÃ¡lisis top-down puede ser desglosado en dos clases: analizadores en backtracking, en el cual intenta aplicar la regla de la gramÃ¡tica y si falla retrocede un paso; y los analizadores predictivos, que consisten en tratar de predecir el prÃ³ximo sÃ­mbolo no terminal en la entrada usando uno o mÃ¡s tokens de bÃºsqueda hacia adelante. Los analizadores en backtracking pueden manejar gramÃ¡ticas complejas, pero los analizadores predictivos son mÃ¡s rÃ¡pidos. 2.9.3.1 Descendiente Recursivo Los analizadores sintÃ¡cticos predictivos permiten reconocer un conjunto de las gramÃ¡ticas libres de contexto, en las que las reglas gramaticales permiten decidir sin ambigÃ¼edad cual regla aplicar. Sin embargo, existen gramÃ¡ticas libres de contexto en donde esto no es posible, y es necesario utilizar un analizador sintÃ¡ctico mÃ¡s poderoso. Los analizadores recursivos descendientes son predictivos, pueden identificar cuÃ¡l regla aplicar examinando uno o mÃ¡s lexemas (K). De ahÃ­, este grupo de analizadores sintÃ¡cticos son llamados LL(K), en donde K es el nÃºmero de lexemas que deben examinar para saber que regla aplicar. Los mÃ¡s sencillos son los LL(1) que al examinar el siguiente lexema pueden reconocer cuÃ¡l regla de la gramÃ¡tica aplicar. Su implementaciÃ³n es bastante sencilla, ya que generalmente cada no terminal de 29 la gramÃ¡tica se corresponde con una funciÃ³n que toma decisiones dependiendo del siguiente lexema leÃ­do. Cuando la gramÃ¡tica no permite utilizar este tipo de analizadores sintÃ¡cticos es necesario utilizar analizadores bottom up. 2.9.3.2 AnÃ¡lisis tipo LL(1) El LL(1) es un analizador tipo top-down que usa una pila como memoria. En el inicio, el sÃ­mbolo inicial es puesto dentro de la pila, y prÃ³ximo a esto tiene 2 acciones disponibles: Generar, que consiste en remplazar un sÃ­mbolo no terminal A en el tope de la pila por una cadena de caracteres Î± usando la regla de la gramÃ¡tica A â†’ Î±; y la otra acciÃ³n Match, la cual verifica que el token en el tope de la pila y el prÃ³ximo token de entrada coincide (y, en el caso de acierto, desapila ambos). La acciÃ³n es seleccionada usando la tabla de anÃ¡lisis. 2.9.4 Botton-Up El anÃ¡lisis de forma top-down trabaja trazando las derivaciones por la izquierda, mientras que el anÃ¡lisis de forma bottom-up trabaja haciendo una derivaciÃ³n por la derecha de forma inversa. La forma de frase derecha, son las derivaciones de la extremidad derecha que se le pueden hacer a una cadena. Y un anÃ¡lisis de una cadena de caracteres consume tokens de izquierda a derecha hasta la derivaciÃ³n extrema derecha inversa. Una forma de manejarlo es usando una cadena de caracteres definida por una expansiÃ³n de un sÃ­mbolo no terminal en la forma de frase derecha. Este mÃ©todo de anÃ¡lisis trabaja comenzando con una pila vacÃ­a y teniendo dos operaciones: shift (salto), el cual coloca el prÃ³ximo token de entrada dentro de la pila; y el otro mÃ©todo reduce (reducciÃ³n), remplazando el lado derecho de la regla de una gramÃ¡tica con su lado izquierdo. La pila de anÃ¡lisis se mantiene con tokens que son desplazados en el hasta que se tiene un manejador en el tope de la pila, con lo cual vamos a reducirlo mediante la inversiÃ³n de expansiÃ³n. 2.9.4.1 AnÃ¡lisis tipo LR(0) Un objeto tipo LR(0) es una forma de monitorear el progreso hacia un manejador. Este es representado por unas reglas de producciÃ³n en conjunto con un punto. El lado derecho de la gramÃ¡tica tiene una parte detrÃ¡s del punto y la otra parte en frente del punto. Esto nos dice que el anÃ¡lisis ha igualado una sub cadena de caracteres derivada por el componente que estÃ¡ a la izquierda del punto y que ahora nos sirve para hacer match a lo que estÃ© en el flujo de entrada, definido por un componente a la derecha del punto. El anÃ¡lisis LR(0) pertenece a una clase general de analizadores, llamada analizadores tipo LR. Estos pueden tomar ventaja de los sÃ­mbolos que estÃ¡n mÃ¡s adelantes, muy parecido a los analizadores de top-down donde el lado izquierdo se expande en el lado derecho basado en un sÃ­mbolo que estÃ¡ mÃ¡s adelante (si es que hay). Los principales mÃ©todos tipo LR son: ï‚· SLR(1) â€“ el lado izquierdo solo se remplaza con el de la derecha si el sÃ­mbolo de mÃ¡s adelante estÃ¡ en el conjunto Follow del lado izquierdo. ï‚· LR(1) â€“ este utiliza un subconjunto del Follow set del lado izquierdo que tiene en cuenta el contexto (el Ã¡rbol a lo anterior e izquierda del lado izquierdo). 30 ï‚· LALR(1) â€“ esto reduce el nÃºmero de estados comparado con LR(1) y (si tenemos suerte), usa un subconjunto apropiado del Follow set del lado izquierdo. 2.9.5 RecuperaciÃ³n de Errores Similar al anÃ¡lisis LL(1), existen tres posibles acciones para el manejo de errores: ï‚· Desapilar un estado de la pila ï‚· Desapilar un token de la entrada hasta tener uno aceptable (el cual reanudarÃ¡ el anÃ¡lisis) ï‚· Apilar un Nuevo estado dentro de la pila 2.10 Trabajos anteriores El trabajo de Luiz H. de Figueiredo en el 1992 nos presenta mÃ©todos discretos de base fÃ­sica para generar aproximaciones poligonales de funciones implÃ­citas e incluso superficies implÃ­citas. Estos procedimientos no solo generan una aproximaciÃ³n de la superficie, sino tambiÃ©n producen una estructura adecuada para simulaciÃ³n numÃ©rica y la modelaciÃ³n de base fÃ­sica y sistemas de animaciÃ³n. Al mismo tiempo describen cÃ³mo son estas ecuaciones y cuÃ¡l es el uso que se quiere dar en la modelaciÃ³n fÃ­sica, y establecen que cada superficie se compone de estructura poligonal. TambiÃ©n ofrecen dos sistemas para construir las aproximaciones poligonales, que incluyen el sistema discreto fÃ­sico, el cual se abstrae de la materia ensamblada por partÃ­culas unidas a otras fuerzas. Varias de estas fuerzas fÃ­sicas pueden ser naturalmente modeladas usando sistemas discretos. Los sistemas de partÃ­culas consisten en tener un conjunto finito de partÃ­culas el cual tiene una posiciÃ³n inicial en el espacio y el comportamiento a travÃ©s del tiempo es gobernado por una serie de reglas algorÃ­tmicas. El segundo sistema son los de Spring-Mass, â€œresortes-masaâ€, que es un tipo de partÃ­cula fÃ­sica en el sistema estructurado por la uniÃ³n de pares de partÃ­culas con resortes. Los resortes imponen una fuerza interna que depende de la distancia entre esas partÃ­culas y es gobernada por el comportamiento global del sistema. Luego de tener estos dos sistemas, los autores establecen un sistema dinÃ¡mico de poligonizaciÃ³n usando un sistema de partÃ­culas. En el primer caso hacen un muestreo de cada una de las partÃ­culas (ver Fig 2.11) y las estructuran creando una malla (ver Fig 2.12) y de esta forma modelan la superficie deseada (ver Fig 2.13), bajo la simulaciÃ³n de fÃ­sica de partÃ­culas. Para el caso de la poligonizaciÃ³n por medio del sistema de Spring-Mass, se hace una subordinaciÃ³n triangular, donde los elementos de estos sistemas estÃ¡n asociados con la triangulaciÃ³n Freudental del espacio. 31 Figura 2.11: Ejemplo de (a)(izquierda) trayectorias y (b)(derecha) posicionamiento de las partÃ­culas en 2D Figura 12: Ejemplo de Puntos de Control de la esfera(a) y creaciÃ³n del mallado de esfera (b) Figura 13: Ejemplo de mayado 3D antes (a) y despuÃ©s (b) de la deformaciÃ³n usando Spring Mass, como se puede apreciar el mallado cambia ajustÃ¡ndose a la figura. Estos sistemas estÃ¡n sujetos a fuerzas de deformaciÃ³n derivadas de la gradiente de la ecuaciÃ³n principal. Su posiciÃ³n de equilibrio da la triangulaciÃ³n de una regiÃ³n del espacio que contiene la ecuaciÃ³n M y tiene las siguientes propiedades: a.- M es una transversal a la triangulaciÃ³n b.- Las divisiones son cuasi-regulares 32 c.- Por cada enÃ©simo simplex ğœ que intersecta M existe un punto perteneciente a M cercano al baricentro de ğœ cuya tangente del espacio M en el punto p es cercano al soporte del hiperplano de una de las caras de ğœ. (ver Fig. 2.14) Figura 2.14: TriangulaciÃ³n Subordinada, proceso previo antes de crear el mallado La generaciÃ³n del mallado por Spring-Mass consiste en la triangulaciÃ³n Freudental, que es creada a partir de la ecuaciÃ³n principal, usando como lÃ­mite un volumen que delimita la ecuaciÃ³n implÃ­cita. Cada simplex (triÃ¡ngulo) que intersecta la ecuaciÃ³n implÃ­cita es identificada. En conjunto, estos forman una intersecciÃ³n compleja simplicial. El sistema Spring-Mass es creado por la asociaciÃ³n de los nodos de masa y los resortes a los vÃ©rtices y aristas de cada intersecciÃ³n compleja. Luego de esta generaciÃ³n del mallado se usa un enfoque fÃ­sico para la obtenciÃ³n de la triangulaciÃ³n final que serÃ¡ usada para realizar la poligonalizaciÃ³n de M (Luiz, Gomez, Demitri, & Luiz, 1992). AÃ±os mÃ¡s tarde, en 1994, el trabajo realizado por Jules Bloomenthal, de la universidad de Calgary, de An Implicit Surface Polygonizer, nos describe cÃ³mo a partir de una ecuaciÃ³n implÃ­cita, puede construirse un mallado de triÃ¡ngulos para ser visualizado en pantalla. Esto permite que una superficie sea desplegada de la forma convencional a partir de polÃ­gonos. La poligonalizaciÃ³n se realiza mediante el uso de la tÃ©cnica de tetra cubes, combinado con Regula Falsi para mejorar la precisiÃ³n en la bÃºsqueda de ceros de funciones (ver fig. 2.15a y 2.15b). A partir de la ecuaciÃ³n implÃ­cita se genera un volumen discreto (malla regular), evaluando la funciÃ³n implÃ­cita en un conjunto de puntos (x,y,z) igualmente espaciados. Luego, cada conjunto de 8 muestras conectadas (cubo), es dividido en tetraedros, en donde se evalÃºa si la superficie corta al tetraedro. Para ello se tiene una tabla de 16 casos, de las 16 formas en que la superficie puede cortar al tetraedro, ya que la funciÃ³n puede ser negativa o positiva en cada vÃ©rtice del tetraedro. Originalmente el corte de la superficie (los ceros de la funciÃ³n) con el tetraedro se aproxima por interpolaciÃ³n lineal, pero dado que se conoce la ecuaciÃ³n implÃ­cita, se utiliza Regula Falsi para obtener una mejor aproximaciÃ³n a la raÃ­z en cada arista intersecada (Bloomenthal, 1994). 33 Fig 15a proceso de poligonizaciÃ³n Fig 15b configuraciÃ³n de entradas del poligonizador usando tetra cubes. En el aÃ±o 2001, el trabajo de Klaus Engel et al. exploran el uso rendering de volÃºmenes para visualizar resonancias magnÃ©ticas, tomografÃ­as computarizadas, e incluso volÃºmenes sintÃ©ticos provenientes de ecuaciones implÃ­citas. La tÃ©cnica de rendering utilizada se basa en el uso de texturas 2D y texturas 3D, con planos alineados. Utilizan la tÃ©cnica de pre-integraciÃ³n para mejorar la calidad visual del rendering. En el aÃ±o 2001, el trabajo de R. Carmona et al., reconstruye superficies, pero combinando Marching Cubes con los mÃ©todos de ceros de funciones como Regula Falsi y BisecciÃ³n. El sistema RenderAll permite adicionalmente realizar el rendering del volumen a la par que la superficie reconstruida (ver Fig.2.16). El rendering del volumen se realiza con texturas 3D y planos alineados al viewport. Para combinar el rendering de volÃºmenes con el rendering de una superficie reconstruida, se despliega un plano alineado al viewport, seguido de los polÃ­gonos de la superficie que se encuentran entre dicho plano y el prÃ³ximo plano. La idea se repite hasta haber desplegado todos los planos alineados al viewport. En cada par de planos consecutivos, se despliegan los triÃ¡ngulos de la superficie que estÃ©n total o parcialmente entre estos en coordenadas de ojo. Se usa una actualizaciÃ³n de una lista de triÃ¡ngulos activos, que ordena los triÃ¡ngulos desde el mÃ¡s lejano al mÃ¡s cercano. Esto permite determinar los triÃ¡ngulos activos para el prÃ³ximo par de planos con pocos chequeos. Los fragmentos remanentes de triÃ¡ngulos (Ã¡reas de triÃ¡ngulos parcialmente fuera del par de cortes) 34 deben ser cortados para no ser desplegados dos veces. En este caso se utilizan los planos de corte soportados por el hardware grÃ¡fico (Carmona., 2001). Figura 2.16: RenderAll. La primera imagen de izquierda a derecha muestra el despliegue de la superficie con phong shading. La segunda y tercera imagen de izquierda a derecha muestran el rendering del volumen sin iluminaciÃ³n y con iluminaciÃ³n Phong. La Ãºltima imagen muestra la mezcla de superficie y volumen intercalando polÃ­gonos del volumen con triÃ¡ngulos de la superficie. A partir de los aÃ±os siguientes al 2004 se exploran diferentes tÃ©cnicas para mejorar el rendimiento de estas aplicaciones, evitando el uso excesivo de recursos. Tal es el caso del trabajo de Bruno Rodrigues de Araujo y Joaquim Armando Pires Jorge, titulado Curvature Dependent Polygonization of Implicit Surface, en el cual nos explican cÃ³mo el enfoque de Triangle Marching reduce esta carga de recursos en la mÃ¡quina. En sus trabajos previos estudian mÃ©todos basados en particiÃ³n de celdas en los cuales se destacan el Marching Cubes y la variante Marching Tetrahedra. Esto algoritmos ofrece buen rendimiento, pero en ocasiones carece de la calidad adecuada. El segundo mÃ©todo es el Surface Tracking, donde destaca el Marching Triangle y el algoritmo de Hartmann. BÃ¡sicamente estos mÃ©todos generan mallados del mismo tamaÃ±o con triÃ¡ngulos cuasi equilÃ¡teros. Pero estos no se adaptan a las propiedades de la superficie, tomando muchos triÃ¡ngulos pequeÃ±os aproximados a las superficies con pocas variaciones en la curvatura. El Ãºltimo de los mÃ©todos son los Mallados Adaptativos. Estos comienzan desde un mallado de alta calidad, aplica operaciones divisiÃ³n de aristas y colapso de aristas para simplificar y optimizar el mallado en tiempo real. Al final, se obtienen mÃ¡s triÃ¡ngulos en donde la curvatura es mÃ¡s pronunciada, requiriendo asÃ­ mÃ¡s detalle (AraÂ´ujo & Jorge, 2004). En otro trabajo, realizado por Andrew Corrigan y H. Quynh Dinh, en el 2005, titulado Computing and Rendering Implicit Surfaces Composed of Radial Basis Functions on the GPU, se exploran mÃ©todos de funciones con base radial. Esto autores muestran cÃ³mo se comporta este mÃ©todo en la GPU, ya que todo es almacenado en una textura 3D y no en una forma convencional (Corrigan & Dinh, 2005). Un ejemplo de colaboradores de mozilla developer network, el trabajo de Malgoratza Jatczyk, en el 2013, muestra tecnologÃ­as Web (usando el API de OpenGL ES) para crear una aplicaciÃ³n demo para triangular y visualizar ecuaciones implÃ­citas en WebGL (Jatczyk, 2013). 35 Como podemos apreciar los mÃ©todos para visualizar ecuaciones implÃ­citas se basan primordialmente en la reconstrucciÃ³n de una iso-superficie, y mejorar el rendimiento y/o calidad del rendering. Pocos trabajos han utilizado el rendering directo de volÃºmenes, el cual permite la visualizaciÃ³n del volumen sin requerir de la reconstrucciÃ³n de una superficie intermedia. Una de las ventajas que vemos de utilizar el rendering de volÃºmenes es que se pueden visualizar distintas â€œcapasâ€ de una ecuaciÃ³n implÃ­cita, sin generar un impacto significativo en el tiempo de respuesta de la aplicaciÃ³n, y sin generar mayores retos en el almacenamiento, como sÃ­ sucede en el caso de querer reconstruir todas estas capas (que podrÃ­an ser decenas), una por una, utilizando mallas de triÃ¡ngulos. 36 CapÃ­tulo 3 â€“ DiseÃ±o e ImplementaciÃ³n En este capÃ­tulo se explica cÃ³mo se realizÃ³ el diseÃ±o y la implementaciÃ³n del sistema, se hace una breve explicaciÃ³n con diagramas de flujo e imÃ¡genes de la interfaz. Se muestran como los mÃ³dulos estÃ¡n compuestos y como engranan para generar el rendering. Se hace una descripciÃ³n con los algoritmos de todo el proceso. 3.1 Funcionamiento general del sistema El prototipo de sistema se puede describir globalmente en la Fig. 3.1. Al iniciar el sistema, se va a mostrar la ecuaciÃ³n de una esfera la cual es la que se tiene por defecto. Se comienza con la inicializaciÃ³n del sistema con valores por defecto como el tamaÃ±o de la caja en los mÃ¡ximos y mÃ­nimos (-2,-2,-2) y (2,2,2), el nÃºmero de voxels en cada dimensiÃ³n (64), el tamaÃ±o de la funciÃ³n de transferencia (1024), 2 valores de superficie (una de color amarillo y otra roja, de grosor 30 pÃ­xeles), y como funciÃ³n a visualizar, una esfera unitaria. Durante la interacciÃ³n del usuario con la interfaz, el mismo puede cambiar cualquiera de los parÃ¡metros, en cualquier momento, para definir la entrada de datos. Al recibir los datos de entrada, estos valores pasan por el generador de la textura del volumen (ver diagrama de flujo Fig. 3.2). El generador de la textura simplemente evalÃºa la funciÃ³n dentro de la caja, con el espaciado de voxels fijado en cada dimensiÃ³n. Luego se discretiza la funciÃ³n de transferencia en una paleta de colores o textura unidimensional de tipo RGBA. Inicialmente la funciÃ³n de transferencia contiene dos valores de superficie, aplicados a las posiciones 0 y 222 del rango [0,1023]. Luego se prepara el contexto de render colocando los parÃ¡metros adecuados para ejecutar el algoritmo de dos pasadas del ray casting, haciendo asÃ­ el despliegue de la funciÃ³n implÃ­cita. Figura 3.1: interfaz + contenedor Canvas WebGL en una grilla de 9x3 de bootstrap 37 3.2 ImplementaciÃ³n En la implementaciÃ³n de los mÃ³dulos de despliegue se hizo con las especificaciones del grupo Khronos group de WebGL 1.0 y la librerÃ­a de THREEjs que facilita la creaciÃ³n de la escena y del despliegue total del volumen. A continuaciÃ³n, se introducen las diferentes librerÃ­as y plugins usador para la implementaciÃ³n: Contenido externo utilizado Para crear el Visualizador de VolÃºmenes en WebGL, se utilizaron diversos recursos externos entre ellos librerÃ­as y otros como plugins de javasript, los cuales son nombrados a continuaciÃ³n: ï‚· THREEjs: librerÃ­a que crea primitivas de WebGL con mayor facilidad que la versiÃ³n estÃ¡ndar de WebGL. ï‚· OrbitControls: librerÃ­a externa a THREEjs permite colocar controles sobre la cÃ¡mara. ï‚· Bootstrap: agrega estilos al diseÃ±o de la pÃ¡gina. ï‚· JQuery: librerÃ­a con el fin de mejora desarrollo y uso de las variables de javascript. ï‚· JQuery-UI: es extensiÃ³n de jQuery que permite agregar widgets u objetos de interfaz grÃ¡fica. ï‚· Math: librerÃ­a que agrega mÃ¡s funciones a la librerÃ­a bÃ¡sica de matemÃ¡ticas de javascript, permite compilar, analizar expresiones matemÃ¡ticas. ï‚· Detector: plugin que informa si ocurriÃ³ algÃºn error en la instancia de WebGL sobre un objeto canvas. ï‚· Stats: plugin que visualiza informaciÃ³n sobre cuadros por segundo/tiempo de muestreo/ memoria usada En la figura 3.2 se muestra el diagrama de flujo de cada uno de los mÃ³dulos y como se comunican entre sÃ­ hasta general la imagen de salida por pantalla Fig 3.2 diagrama de la aplicaciÃ³n general 38 A continuaciÃ³n, se explicarÃ¡ cÃ³mo fue implementado cada mÃ³dulo, usando como guÃ­a el diagrama de flujo Se tomaron en consideraciÃ³n limitantes de la especificaciÃ³n de WebGL 1.0 en el que nos indica que no se puede hacer uso de texturas 3D y texturas que no sean en potencia de 2, pero existen mÃ©todos para hacer creer al programa que estÃ¡ leyendo una textura como si fuera 3D. En los programas de shaders se usa un algoritmo que hace procesamiento de un Atlas de textura 2D como si fuera una textura 3D. 3.2.1 Generador de la textura del volumen Haciendo seguimiento al diagrama de flujo por medio de la entrada de datos, si el usuario introdujo o hizo cambios en el tamaÃ±o de la caja contenedora del volumen (MÃ­nimos y MÃ¡ximos), o en el NÃºmero de Voxels, o en la ecuaciÃ³n implÃ­cita, este mÃ³dulo crea el volumen. Para la creaciÃ³n del atlas de textura se usÃ³ una librerÃ­a de JavaScript mathjs para poder evaluar con exactitud si la expresiÃ³n escrita, es vÃ¡lida. Esta librerÃ­a ofrece una extensa cantidad de funciones que pueden ser usadas en conjunto con expresiones matemÃ¡ticas en las que podemos listar: +,-,*,/,agrupaciÃ³n (),pre multiplicaciÃ³n <numero>(). Una vez evaluada es almacenada en una variable para su uso en la construcciÃ³n del volumen. En el proceso de creaciÃ³n del atlas se usa un arreglo que representa la matriz del volumen 4 componentes (RGBA). En cada componente se almacena un valor de la gradiente de la funciÃ³n (RGB) y en el 4to componente (A) se guarda el valor de la funciÃ³n f(x,y,z). El vector gradiente se almacena con el fin de aplicar un modelo de iluminaciÃ³n local durante el rendering. El volumen en enviado al GPU como un atlas de textura 2D, representando lÃ³gicamente una textura 3D. 3.2.2 Actualizador de funciÃ³n de transferencia Dentro de esta etapa, se construye la funciÃ³n de transferencia la cual especifica en quÃ© posiciÃ³n sobre el volumen se encuentra cada iso-valor, de quÃ© color es, y quÃ© opacidad tiene. La funciÃ³n se almacena en una textura 1D de tipo RGBA que por defecto abarca el rango de [0,1023]. Al finalizar esta etapa, la textura se carga en una unidad de textura, y recibe como nombre "transferencia" en el programa de shader. 3.2.3 actualizador de las texturas Cada vez que el usuario introduce datos de la funciÃ³n de transferencia (inserciÃ³n, eliminaciÃ³n, modificaciÃ³n de un iso-valor y sus atributos), se actualiza la textura correspondiente a la funciÃ³n de transferencia. Si el usuario realiza alguna modificaciÃ³n sobre los parÃ¡metros de la funciÃ³n implÃ­cita (caja, nÃºmero de voxels o la funciÃ³n en sÃ­), se crea un nuevo volumen RGBA, e igualmente se envÃ­a a la unidad de textura correspondiente. 3.2.4 contexto webGl En este mÃ³dulo se crea el ambiente para utilizar openGL en el browser, en el cual valores como tamaÃ±o de la caja, geometrÃ­a de despliegue de volumen y los algoritmos involucrados en el ray casting conviven con el entorno HTML/CSS/JavaScript de la aplicaciÃ³n. 39 3.2.5 MÃ³dulo de Render El mÃ³dulo de rendering realiza un ray casting sobre el volumen. Para poder describir en mÃ¡s detalle cÃ³mo se procesa la textura de volumen, se colocan algunos de los algoritmos clave para el desarrollo de la aplicaciÃ³n, donde se describen aspectos importantes y procesos intermediarios antes de hacer el despliegue del volumen e integraciÃ³n con la interfaz. Toda interacciÃ³n con el resultado del despliegue resulta en una llamada a actualizar el prÃ³ximo cuadro a dibujar como lo son la rotaciÃ³n, la translaciÃ³n, el zoom in, el zoom out, y llamadas de la interfaz tambiÃ©n pasa por este proceso. Figura 3.4: FunciÃ³n de muestreos del Atlas 2D La funciÃ³n presentada en la Fig 3.4 ayuda al raycasting a obtener las muestras de la textura 2D pero haciendo interpolaciÃ³n tri lineal. Una textura 2D de tamaÃ±o (n,m,k) es almacenada en una textura 2D de tamaÃ±o (n*k,m). Sabiendo esto, se puede realizar una fÃ³rmula de acceso para determinar sobre quÃ© par de sub texturas 2D se debe hacer el muestreo para simular la interpolaciÃ³n tri lineal. Una vez determinado el par de sub texturas 2D (zSlices0, zSlices1), se calcula un desplazamiento dentro de cada sub textura 2D para hallar la posiciÃ³n del voxel a muestrear en cada corte. Este desplazamiento es xOffset. Luego de muestrear en ambas sub texturas, se realiza una interpolaciÃ³n lineal entre ambas muestras mediante la funciÃ³n mix. El algoritmo de la Fig. 3.5 corresponde a la funciÃ³n principal del ray casting. En este se toman una muestra de la textura, luego se extraen valores que conforman las normales de la muestra y es realizado el proceso de iluminaciÃ³n sobre cada una de las muestras, despuÃ©s se extrae el color y se realiza el proceso de pos clasificaciÃ³n, y retorna el acumulado al color fragmento. Continuando con el algoritmo de la Fig. 3.5 calcula la distancia que hay entre las dos caras de entrada y salida del rayo (front and back), se fija un tamaÃ±o del paso (step) que es dividido entre la diagonal de la caja, se crea un delta que nos indica el tamaÃ±o o longitud del rayo y un acumulador de color, se procede a hacer muestreos progresivos segÃºn la longitud del rayo y la cantidad de absorciÃ³n acumulada. La absorciÃ³n se calcula por la ecuaciÃ³n de rendering en donde se evalÃºa sobre el coeficiente de absorciÃ³n exp(-0.7 * ColorSample.a), luego, se hace la obtenciÃ³n de una muestra del 40 volumen dentro del contenedor, se hace la acumulaciÃ³n de color sobre la funciÃ³n de transferencia y este resultado se muestra por fragmento de shader. Figura 3.5: Algoritmo de RayCasting + BlingPhong 41 Figura 3.6: DefiniciÃ³n de las ShaderMaterial El algoritmo mostrado en la Fig. 3.6 muestra como es configurados los dos ShaderMaterial que conforman los dos pasos del algoritmo de ray casting. El primero se utiliza para desplegar las caras traseras del volumen, representando la salida de los rayos del volumen. Mientras que la segunda pasada, despliega las caras frontales del volumen, y conociendo las caras traseras del mismo, permite calcular la longitud de cada rayo por fragmento. Luego de pasar por estos mÃ³dulos se genera una imagen como resultado que es desplegado en el dispositivo de salida (monitor) del computador. Para el desarrollo de la interfaz (Fig 3.7, 3.8, 3.9), se hace uso de tecnologÃ­as estÃ¡ndares de HTML5/CSS/Javascript y de librerÃ­as que facilitan la creaciÃ³n, como JQuery para rÃ¡pida actualizaciÃ³n de variables, BootStrap para el diseÃ±o y estilo de la pÃ¡gina, plugins, como Bootstrap colorpicker y Jquery UI para agregar mÃ¡s caracterÃ­sticas que complementan el diseÃ±o de la interfaz. Mediante la interfaz grÃ¡fica, el usuario puede variar los parÃ¡metros de la funciÃ³n implÃ­cita, y los parÃ¡metros de visualizaciÃ³n. Dentro de estos controles existen dos etapas, antes de dibujar y despuÃ©s de dibujar. 42 Figura 3.7: Interfaz grÃ¡fica para definir la funciÃ³n a visualizar Figura 3.8: Definiendo los valores de superficie a considerar en la funciÃ³n de transferencia 43 Figura 3.9: DiÃ¡logo modal para agregar mÃ¡s Valores de superficie Como podemos observar en la Fig. 3.7, se encuentran los elementos de la interfaz grÃ¡fica en los que tenemos: ï‚· MÃ¡ximos y MÃ­nimos: son los componentes que definen el tamaÃ±o mÃ¡ximo y mÃ­nimo de la caja en los ejes x,y,z. ï‚· EcuaciÃ³n ImplÃ­cita (f(x,y,z)): en este campo se escribe la funciÃ³n. ï‚· NÃºmero de Voxels: es la cantidad de muestras por eje del volumen. En este caso se observa 64, lo que corresponde a 64 en el eje X, 64 en Y, y 64 en Z. ï‚· Funciones de Transferencia: dos opciones Normal (pos-clasificaciÃ³n) y Simpson (pre- integraciÃ³n). Este define de quÃ© forma se construye la funciÃ³n de transferencia y se especifica la resoluciÃ³n que posee la misma (256, 512 o 1024). La funciÃ³n de transferencia pre- integrada queda como trabajo a futuro. ï‚· Dibujar: toma todos los parÃ¡metros principales (MÃ¡ximos y MÃ­nimos, la funciÃ³n y nÃºmero de voxels) y hace un despliegue de dicha funciÃ³n. ï‚· Centrar: coloca la figura en el centro de la pantalla. En las figuras 3.8 y 3.9 contienen la interfaz necesaria para definir la funciÃ³n de transferencia, es decir, el conjunto de valores de superficie a visualizar, junto a sus colores y opacidades. ï‚· Rango de Valores de superficie: estos componentes estÃ¡n a lo largo del rango de la funciÃ³n. Su funciÃ³n es indicar en quÃ© parte del volumen estÃ¡n ubicados (posiciÃ³n), su ancho o grosor (Ancho), color y AbsorciÃ³n. ï‚· Iso-Valor Seleccionado: esta ventana muestra el valor seleccionado actualmente con sus caracterÃ­sticas, pueden ser cambiadas en cualquier momento. 44 ï‚· Por Ãºltimo, se encuentra el BotÃ³n de agregar mÃ¡s Valores de superficie (Fig. 3.8). Este despliega un diÃ¡logo modal en el cual se muestran todos los valores de superficie actuales, sus caracterÃ­sticas si se desean agregar mÃ¡s o eliminar (Fig 3.9). 45 CapÃ­tulo 4 Pruebas y Resultados Previo a definir las pruebas realizadas junto con sus resultados, es importante establecer los parÃ¡metros bajo los cuales se llevaron a cabo estas pruebas, asÃ­ como los recursos que se han utilizado para poder completar el Visualizador de VolÃºmenes en WebGL. 4.1 Ambiente de trabajo Las pruebas se realizaron bajo un ambiente con las siguientes especificaciones: ï‚· Sistema operativo: Windows 10 - 64bits ï‚· Procesador: Intel Core i7 740qm â€“ 1.73Ghz ï‚· Memoria RAM: 8GB DDR3 ï‚· Tarjeta GrÃ¡fica: Geforce 310m, con 512MB DDR3. Como herramienta principal para el desarrollo de este trabajo se utilizÃ³ Sublime Text editor (Skinner, 2015), debido a la flexibilidad que posee en cuanto al desarrollo web y a la familiaridad que se tiene con la utilizaciÃ³n de esta herramienta. 4.2 Funciones de prueba Se seleccionaron las siguientes 3 funciones: ï‚· Esfera: f(x,y,z) = x^2+y^2+z^2-1 ï‚· Toroide: f(x,y,z) = ((X*X)+(Y*Y)+(Z*Z))^2-4*Z*((X*X)+(Y*Y)+(Z*Z))-8*X*X-8*(Y*Y) + 12*(Z*Z) - 16*Z +16 ï‚· Jacky: f(x,y,z) = 1/(X*X/9+4*Y*Y+4*Z*Z)^4+1/(Y*Y/9+4*X*X+4*Z*Z)^4+1/(Z*Z/9+4*Y*Y+4*X*X)^4+1/((4*X /3-4)^2+16.0*Y*Y/9.0+16.0*Z*Z/9.0)^4.0+1.0/((4*X/3+4)^2+16.0*Y*Y/9+16*Z*Z/9)^4 + 1/((4*Y/3-4)^2+16*X*X/9+16*Z*Z/9)^4+1/((4*Y/3+4)^2+16*X*X/9+16*Z*Z/9)^4)^-0.25-1 Cada una de estas funciones fue desplegada con 3 valores de superficie de 2% de grosor en la funciÃ³n de transferencia. Como referencia el valor de superficie cuyo color es el azul tiene un valor de opacidad de 1.0, mientras que para los valores de superficie restantes se colocÃ³ 0.01 como valor de opacidad (ver Fig. 4.1). 4.3 Pruebas de calidad y rendimiento El tamaÃ±o del volumen medido en voxels y el tamaÃ±o de la funciÃ³n de transferencia discretizada influyen tanto en la calidad del despliegue como en el tiempo de respuesta. En esta prueba se pretende realizar una comparaciÃ³n tanto de calidad como de tiempo de respuesta conforme se varÃ­an estos parÃ¡metros. 46 Esfera Toroide Jacky Figura 4.1: ecuaciones utilizadas. En los 3 casos se utilizÃ³ una funciÃ³n de transferencia discretizada en 1024 entradas, y se construyÃ³ un volumen de 643 voxels. FunciÃ³n de Transferencia 256 N. de voxels 16x16x16 FunciÃ³n de Transferencia 256 N. de voxels 32x32x32 FunciÃ³n de Transferencia 256 N. de voxels 64x64x64 FunciÃ³n de Transferencia 512 N. de voxels 16x16x16 FunciÃ³n de Transferencia 512 N. de voxels 32x32x32 FunciÃ³n de Transferencia 512 N. de voxels 64x64x64 FunciÃ³n de Transferencia 1024 N. de voxels 16x16x16 FunciÃ³n de Transferencia 1024 N. de voxels 32x32x32 FunciÃ³n de Transferencia 1024 N. de voxels 64x64x64 Tabla 4.2 Funciones de Transferencia versus Numero de Voxels 47 En la Fig. 4.2 podemos apreciar que a medida que el nÃºmero de voxels aumenta, se pueden apreciar mejor los detalles, y se reducen los artefactos visuales. El mismo fenÃ³meno sucede al aumentar la resoluciÃ³n de la funciÃ³n de transferencia, al discretizarse con mÃ¡s muestras. Los mejores resultados visuales se obtienen con 643 voxels y 1024 entradas en la funciÃ³n de transferencia. En la tabla 4.1 se hizo la prueba de tiempo de respuesta con diferentes tamaÃ±os de funciÃ³n de trasferencia y diferentes nÃºmeros de voxels, fijando el paso entre muestras en 1 voxel usando la ecuaciÃ³n del jacky. Muestreos por voxel indica la cantidad de muestreos que se hace por cada ciclo del raycasting. Este es definido por 1/diagonal de la caja que es previamente calculado. Si tomamos como medida principal la tasa de cuadros por segundo (fps o frames per second), tenemos que el rendimiento disminuye a medida que aumenta la resoluciÃ³n del volumen. FunciÃ³n de Transferencia NÃºmero de Voxels Muestreos por voxel Rata de cuadros por segundo 256 64x64x64 1 35fps 256 32x32x32 1 45fps 256 16x16x16 1 60fps 512 64x64x64 1 35fps 512 32x32x32 1 45fps 512 16x16x16 1 60fps 1024 64x64x64 1 35fps 1024 32x32x32 1 45fps 1024 16x16x16 1 60fps Tabla 4.1: FunciÃ³n de Transferencia variable vs Numero de voxels variable Como prueba siguiente, queremos estudiar cÃ³mo afecta el paso de rendering o muestreos por voxel en la calidad del rendering. Si este nÃºmero aumenta (ver Fig. 4.3) podrÃ­amos perder detalles en el rendering, pues es posible no capturar todos los valores de superficie adecuadamente, o contar con pocas muestras del volumen para ciertos valores de superficie. El el paso es mÃ¡s corto, se recolecta mejores detalles, y la calidad del rendering es superior. Figura 4.3: diferentes longitudes del paso (1/diagonal, 0.5/diagonal, 0.25/diagonal) con funciÃ³n de transferencia de (1024), y la ecuaciÃ³n del toroide Como podemos observar en este ejemplo del toroide, si fijamos el paso a 1 podemos tener menor cantidad de muestras lo que traduce a perdida de detalles (ver Fig. 4.3 izquierda) y una rata 48 de cuadros mÃ¡s estable (ver tabla 4.2). Si fijamos el paso a 0.25 tenemos mayor detalle, pero hay una caÃ­da de rata de cuadros por segundo, que, en el peor caso, se tienen apenas 6fps. NÃºmero de Voxels Cantidad del Paso/ 1 Voxel FunciÃ³n de Transferencia Rata de cuadros por segundo 64x64x64 1 256 35fps 64x64x64 1 512 35fps 64x64x64 1 1024 35fps 64x64x64 0.5 256 29fps 64x64x64 0.5 512 29fps 64x64x64 0.5 1024 29fps 64x64x64 0.25 256 6fps 64x64x64 0.25 512 6fps 64x64x64 0.25 1024 6fps 32x32x32 1 256 45fps 32x32x32 1 512 45fps 32x32x32 1 1024 45fps 32x32x32 0.5 256 39fps 32x32x32 0.5 512 39fps 32x32x32 0.5 1024 39fps 32x32x32 0.25 256 18fps 32x32x32 0.25 512 18fps 32x32x32 0.25 1024 18fps 16x16x16 1 256 60fps 16x16x16 1 512 60fps 16x16x16 1 1024 60fps 16x16x16 0.5 256 55fps 16x16x16 0.5 512 55fps 16x16x16 0.5 1024 55fps 16x16x16 0.25 256 39fps 16x16x16 0.25 512 39fps 16x16x16 0.25 1024 39fps Tabla 4.2: Funciones de Transferencia versus NÃºmero de Voxels del volumen y longitud del Paso de rendering 49 CapÃ­tulo 5 â€“ Conclusiones y Trabajos Futuros En este trabajo se desarrollÃ³ un prototipo de sistema web usando el estÃ¡ndar de WebGL para despliegue de ecuaciones implÃ­citas mediante la tÃ©cnica de visualizaciÃ³n directa de volÃºmenes. El sistema permite definir y desplegar mÃºltiples valores de superficie (f(x,y,z) = c) de la funciÃ³n implÃ­cita al mismo tiempo, asignando color, opacidad, y grosor por cada superficie, con una interfaz sencilla. Debido a que es una aplicaciÃ³n web con el estÃ¡ndar WebGL, la calidad u velocidad del despliegue dependerÃ¡ del tipo de navegador web y del hardware utilizado, lo cual puede producir insatisfacciÃ³n en algunos sistemas de computaciÃ³n de bajo rendimiento grÃ¡fico. Por limitaciones del framework actual de WebGL no se permite el uso de texturas 3D, por lo que en este trabajo se simularon las texturas 3D mediante un atlas de textura 2D, realizando el muestreo del atlas mediante una funciÃ³n propia. En cuanto a los resultados obtenidos, se puede apreciar a que mayor resoluciÃ³n del volumen y de la funciÃ³n de transferencia, la calidad del despliegue es superior, pero el tiempo requerido para generar un cuadro de imagen aumenta. Igualmente, si reducimos la longitud del paso en el algoritmo de ray casting, la calidad del despliegue aumenta, pero la rata de cuadros por segundo puede bajar drÃ¡sticamente. Como trabajos a futuro se propone rediseÃ±ar la aplicaciÃ³n con el estÃ¡ndar de WebGL 2.0, el cual aplica soporte completo de OpenGL ES 3.0 que permite el uso de texturas que no potencias de 2 y texturas 3D, y utiliza de GLSL 3.0. Igualmente se propone terminar el mÃ³dulo de visualizaciÃ³n con pre-integraciÃ³n, para obtener un despliegue de gran calidad, sin necesidad de requerir reducir el paso de ray casting, ni de asignarle un grosor al valor de superficie en la funciÃ³n de transferencia. Cabe destacar que a esta aplicaciÃ³n es posible agregarle un mÃ³dulo de visualizaciÃ³n de datos mÃ©dicos, puesto que solo habrÃ­a que cambiar la fuente del volumen. En vez de generar un volumen a partir de una ecuaciÃ³n implÃ­cita, este podrÃ­a cargarse de un archivo. bastarÃ­a agregar como mÃ­nimo un manejador de archivos tipo RAW, especificar el tamaÃ±o y el nÃºmero de bits por muestra del volumen. Finalmente, se desea que estÃ¡ aplicaciÃ³n estÃ© disponible en la pÃ¡gina Web del Centro de ComputaciÃ³n GrÃ¡fica, bajo el dominio ccg.ciens.ucv.ve. 50 Referencias Aho, A. V., Lam, M. S., & Sethi, R. (2007). Compilers principles, techniques and tools. Boston: Pearson Addyson Wesley. AraÂ´ujo, B. R., & Jorge, J. A. (2004). Curvature Dependent Polygonization of Implicit Surfaces. Computer Graphics and Image Processing, 2004. Proceedings. 17th Brazilian Symposium on Formal Methods (pÃ¡gs. 266 - 273). Maceio - Alagoas: IEEE. B, P., & D, B. (2007). Visualization in Medicine. Burlington: Morgan Kaufmann Publisher. Bhalerao, A., Pfister, H., Halle, M., & Kikinis, R. (2000). Fast Re-Rendering of Volume and Surface Graphics by Depth, Color and Opacity Buffering. Journal of Medical Image Analysis, Vol 4, Issue 3, 235-251. Bloomenthal, J. A. (1994). Graphics Gems IV. San Diego, CA, USA: Academic Press Professional, Inc. Burden, R. y. (2009). AnÃ¡lisis NumÃ©rico 7ma Edicion. Youngstone: CENGAGE Learning. Carmona., R. (2001). TriangulaciÃ³n de Ecuaciones ImplÃ­citas Combinando Cubos Marchantes con Algoritmos de Ceros de Funciones. LI ConvenciÃ³n Anual AsoVAC. Corrigan, A., & Dinh, H. Q. (2005). Computing and Rendering Implicit Surfaces Composed of Radial Basis Functions on the GPU. International Workshop on Volume Graphics, 187-195. DaFeda. (2010). Mathematics; ranting & learning. Obtenido de DaFeda's Blog: http://dafeda.wordpress.com/2010/09/09/mullers-method-deriving-of-and-code/ Fleming, W. (1965). Functions of several Variables. New York: Addison-Wesley. Foley, J. D., van Dam, A., Feiner, S. K., & Hughes, J. F. (1996). Computer Graphics: Principles and Practice (2nd ed. in C). Addison-Wesley Publishing Company. Foundation, T. j. (2015). JQuery. Obtenido de jQuery: The Write Less, Do More, JavaScript Library.: https://jquery.com/ Guzman, J. d. (2010). Boost.Spirit. Obtenido de boost-spirit: http://boost-spirit.com/home/ Hansen, C. D., & Johnson, C. R. (2004). Visualization Handbook. Salt Lake City: Elsevier. Jatczyk, M. (15 de Junio de 2013). Desing concept - Graphics art desing. Obtenido de http://designconcept.webdev20.pl/: http://www.webdev20.pl/skins/default/js/demos/implicit-equation-3d- grapher/index.html Jong, J. d. (2015). mathjs. Obtenido de math.js | an extensive math library for JavaScript and Node.js: http://mathjs.org/ K., E., & T., K. M. (2001). High Quality Pre-Integrated Volume Rendering Using Hardware-Accelerated Pixel Shading. ACM Press, 9-16. 51 Kajiya, J. T. (1986). THE RENDERING EQUATION. SIGGRAPH '86 Proceedings of the 13th annual conference on Computer graphics and interactive techniques (pÃ¡gs. 143-150 ). California Institute of Technology: SIGGRAPH. Kaplan, W. (1949). Advanced Calculus. Michigan: Addison-Wesley 5th edition. Klaus Engel, M. K. (2001). High-Quality Pre-Integrated Volume Rendering Using Hardware- Accelerated Pixel Shading. Visualization and Interactive Systems Group, University of Stuttgart, Germany. Levoy, M. (1988). Display of Surfaces from Volume Data. IEEE Computer Graphics and Applications, 29-37. LLC, T. S. (2001). C4 Game Engine . Obtenido de Terathon: http://www.terathon.com Lorensen, W. E., & Cline, H. E. (6 de 11 de 1987). Marching cubes: A high resolution 3d surface construction algorithm. ACM Computer Graphics 21 (4), pÃ¡gs. 163â€“169. Lorensen, W. E., & Cline, H. E. (1987). MARCHING CUBES: A HIGH RESOLUTION 3D SURFACE CONSTRUCTION ALGORITHM. Computer Graphics, 163-169. M., W., J., N., & Davis, T. (1997). OpenGL, Programming Guide. Addison-Wesley Developers Press, 2da. EdiciÃ³n. Mark Otto, j. (18 de August de 2011). Bootstrap. Obtenido de Bootstrap The world's most popular mobile-fisrt and responsive front-end framework: http://getbootstrap.com/ mrdoob. (23 de April de 2010). threejs dat org. Obtenido de three.js A Javascript 3D library: http://threejs.org/ Northwood, C. (2009). Lexical and Syntax Analysis of Programming Languages. Obtenido de http://www.pling.org.uk/: http://www.pling.org.uk/cs/lsa.html Pauls. (2011). Lamar University. Obtenido de Paul's Online Math Notes: http://tutorial.math.lamar.edu/Classes/CalcI/NewtonsMethod.aspx Philippe Lacroute, M. L. (July de 1994). Fast Volume Rendering Using a Shear-Warp Factorization of the Viewing Transformation. Computer Graphics Procedings, Anual Conference Series, 1994 (pÃ¡gs. 451-458). Stanford: SIGGRAPH. qiao, m. a. (2011). threejs OrbitControl. Obtenido de three.js A Javascript 3D library: http://threejs.org/ R. Carmona, O. R. (1997). Aspectos de ImplementaciÃ³n para el algoritmo de Cubos Marchantes. 47o ConvenciÃ³n Anual AsoVAC. R. Carmona, O. R. (1999). Cubos Marchantes: una implementaciÃ³n eficiente. In Proc. XXV Conferencia Latinoamericana de InformÃ¡tica. Paraguay, La AsunciÃ³n, Agosto. Schulz, S. (2003). Four Lectures on Differential-Algebraic Equations. Institut fÃ¼r Mathematik. 52 Skinner, J. (2015). Sublime Text: The text editor you'ill fall in love. Obtenido de Sublime Text: http://www.sublimetext.com/ Steffen, S. (2003). Four Lectures on Differential-Algebraic Equations. Berlin: Humboldt UniversitÂ¨at zu Berlin. STEVENS, R. T. (1993). Quick Reference to Computer Graphics Terms. Academic Press, Inc. Westover, L. A. (1991). SPLATTING: A Parallel, Feed-Forward Volume Rendering Algorithm. North Carolina: The University of North Carolina. Willian E. Lorensen, H. E. (27-31 de Julio de 1987). Marching Cubes: A high resolution 3D surface construction algorithm. Computer Graphics, Volumen 21, NÃºmero 4, pÃ¡gs. 163-1699. WolframMathWorks. (2014). WolframMathWorks. Obtenido de WolframMathWorks: http://mathworld.wolfram.com/SecantMethod.html Ziegler, J. (2004). The LEDA Tutorial. Obtenido de The LEDA Tutorial: http://www.leda- tutorial.org/en/discussion/ch06s03.htmlUniversidad Central de Venezuela Facultad de Ciencias Escuela de ComputaciÃ³n Centro de ComputaciÃ³n GrÃ¡fica VISUALIZACION DE ECUACIONES IMPLICITAS UTILIZANDO WEBGL Trabajo Especial de Grado presentado ante la Ilustre Universidad Central de Venezuela Por el Bachiller Juan AndrÃ©s GonzÃ¡lez Trejo para optar al tÃ­tulo de Licenciado en ComputaciÃ³n Tutor: Prof. RhadamÃ©s Carmona <Caracas, 27/10/2015> 3 Dedicatoria A mi padre, a mi madre, a mi hermana, a mis amigos, quienes me han brindado todo para que pudiera alcanzar esta meta y culminar una etapa mÃ¡s en la vida. Sin su apoyo y dedicaciÃ³n no me hubiese sido posible llegar al punto en el que me encuentro hoy en dÃ­a. 4 Agradecimientos A mi hermana quien ha sido un apoyo constante a lo largo de mi vida y un sÃ­mbolo de que querer es poder. A mi madre y padre por ser constantes y darme un empujÃ³n de seguir adelante. A mis amigos, los cuales me han apoyado en todo momento y siempre han estado ahÃ­ cuando ha sido necesario. A mi tutor, Prof. RhadamÃ©s Carmona, por asistirme mi formaciÃ³n como profesional y durante la elaboraciÃ³n de este trabajo. 5 Resumen Las Ecuaciones implÃ­citas son ampliamente utilizadas en el Ã¡rea de la matemÃ¡tica y la fÃ­sica, por lo que en el mundo cientÃ­fico han formado parte de nuestra vida cotidiana, y han ayudado a estudiar distintos fenÃ³menos. TÃ­picamente, para visualizar estas ecuaciones en tres dimensiones se utilizan algoritmos que reconstruyen la superficie 3D buscando los ceros de la funciÃ³n en una malla regular, y conectando los puntos resultantes para generar dicha superficie. Entre estos algoritmos se encuentran Marching Cubes y Tetra Cubes. Con la popularidad que ha adquirido la visualizaciÃ³n de volÃºmenes en los Ãºltimos aÃ±os, hoy en dÃ­a es posible visualizar la ecuaciÃ³n implÃ­cita sin la necesidad de realizar la reconstrucciÃ³n tridimensional. En este caso, basta evaluar la ecuaciÃ³n implÃ­cita en una malla regular 3D que forma un volumen, y configurar la funciÃ³n de transferencia para visualizar Ãºnicamente la superficie deseada (los ceros de la funciÃ³n). Basados en esta idea, podemos visualizar fÃ¡cilmente cualquier otra capa de la funciÃ³n implÃ­cita; es decir, visualizar otra superficie que no coincida con los ceros de la funciÃ³n, sino con cualquier otro valor. Por ejemplo, con la ecuaciÃ³n de una esfera x2+y2+z2-r2=u es posible visualizar las superficies generadas para distintos valores de u sin necesidad de reconstruir cada una de estas superficies, lo cual genera costos importantes de tiempo y espacio. En los Ãºltimos aÃ±os han surgido tecnologÃ­as que permiten la utilizaciÃ³n del hardware grÃ¡fico en el despliegue tridimensional en navegadores Web; entre estas tecnologÃ­as se encuentra WebGL. En este trabajo se elaborÃ³ un prototipo de aplicaciÃ³n Web basado en WebGL que implementa el algoritmo de visualizaciÃ³n de volÃºmenes llamado ray casting para el despliegue de ecuaciones implÃ­citas. Palabras claves: ecuaciones implÃ­citas, ray casting, Web Open Graphics Library (WebGL), visualizaciÃ³n de volÃºmenes. 7 Ãndice Dedicatoria .......................................................................................................................................... 3 Agradecimientos ................................................................................................................................. 4 Resumen .............................................................................................................................................. 5 Ãndice ................................................................................................................................................... 6 IntroducciÃ³n ........................................................................................................................................ 8 CapÃ­tulo 1 - DescripciÃ³n del problema .............................................................................................. 10 1.1 - Planteamiento del problema........................................................................................ 10 1.2 Objetivo General ............................................................................................................ 11 1.3 Objetivos EspecÃ­ficos ...................................................................................................... 11 1.4 SoluciÃ³n propuesta ......................................................................................................... 11 1.4.1. MetodologÃ­a de desarrollo ............................................................................ 11 1.4.3. MÃ³dulos a desarrollar.................................................................................... 12 - AnÃ¡lisis sintÃ¡ctico de la ecuaciÃ³n implÃ­cita ........................................................... 12 - Rendering de volÃºmenes: ...................................................................................... 12 - Interfaz grÃ¡fica ....................................................................................................... 12 1.4.4. Pruebas a realizar .......................................................................................... 13 CapÃ­tulo 2 â€“ Marco teÃ³rico ................................................................................................................ 14 2.1 Imagen ..................................................................................................................... 14 2.2 Pixel ......................................................................................................................... 14 2.3 Voxel ........................................................................................................................ 14 2.4 PolÃ­gono ................................................................................................................... 15 2.5 Rendering ................................................................................................................ 15 2.6 Volume Rendering (Rendering de VolÃºmenes) ....................................................... 18 2.6.1 Rendering Directo de VolÃºmenes ................................................................... 19 2.6.2 ClasificaciÃ³n .................................................................................................... 20 2.7 - Ecuaciones ImplÃ­citas ................................................................................................... 21 2.8 Ceros de funciones ......................................................................................................... 22 2.8.1 MÃ©todo de BisecciÃ³n ...................................................................................... 22 2.8.2 MÃ©todo de Newton ........................................................................................ 23 2.8.3 MÃ©todo de la Secante ..................................................................................... 24 2.8.4 MÃ©todo de PosiciÃ³n Falsa o Regula Falsi ........................................................ 25 2.8.5 MÃ©todo de MuÌˆller .......................................................................................... 26 7 2.9 Evaluadores sintÃ¡cticos .................................................................................................. 26 2.9.1 AnÃ¡lisis LÃ©xico ................................................................................................. 27 2.9.2 AnÃ¡lisis SintÃ¡ctico ........................................................................................... 27 2.9.3 Top-Down ....................................................................................................... 28 2.9.4 Botton-Up ....................................................................................................... 29 2.10 Trabajos anteriores .......................................................................................... 30 CapÃ­tulo 3 â€“ DiseÃ±o e ImplementaciÃ³n ............................................................................................ 36 3.1 Funcionamiento general del sistema ............................................................................. 36 3.2 ImplementaciÃ³n ............................................................................................................. 37 Contenido externo utilizado .................................................................................... 37 CapÃ­tulo 4 Pruebas y Resultados ....................................................................................................... 45 4.1 Ambiente de trabajo ...................................................................................................... 45 4.2 Funciones de prueba ...................................................................................................... 45 4.3 Pruebas de calidad y rendimiento .................................................................................. 45 CapÃ­tulo 5 â€“ Conclusiones y Trabajos Futuros .................................................................................. 49 Referencias ........................................................................................................................................ 50 8 IntroducciÃ³n Las Ecuaciones implÃ­citas son ampliamente utilizadas en el Ã¡rea de la matemÃ¡tica y la fÃ­sica, por lo que en el mundo cientÃ­fico han formado parte de nuestra vida cotidiana, y han ayudado a estudiar distintos fenÃ³menos (Steffen, 2003). TÃ­picamente, para visualizar estas ecuaciones en tres dimensiones se utilizan algoritmos que reconstruyen la superficie 3D buscando los ceros de la funciÃ³n en una malla regular, y conectando los puntos resultantes para generar dicha superficie. Entre estos algoritmos se encuentran Marching Cubes y Tetra Cubes ( (Lorensen & Cline, 1987) y (Hansen & Johnson, 2004)). La idea es primero evaluar las funciÃ³n implÃ­cita en los puntos (x,y,z) de una malla regular uniforme, y luego seleccionar el umbral a reconstruir (tÃ­picamente el valor cero). El resultado es un mallado de triÃ¡ngulos que puede ser visualizado en cualquier computador que tenga soporte para visualizaciÃ³n 3D. Con la popularidad que ha adquirido la visualizaciÃ³n de volÃºmenes en los Ãºltimos aÃ±os, hoy en dÃ­a es posible visualizar la ecuaciÃ³n implÃ­cita sin la necesidad de realizar la reconstrucciÃ³n tridimensional. En este caso, basta evaluar la ecuaciÃ³n implÃ­cita en una malla regular 3D que forma un volumen, y configurar la funciÃ³n de transferencia para visualizar Ãºnicamente la superficie deseada (los ceros de la funciÃ³n). Basados en esta idea, podemos visualizar fÃ¡cilmente cualquier otra capa de la funciÃ³n implÃ­cita; es decir, visualizar otra superficie que no coincida con los ceros de la funciÃ³n, sino con cualquier otro valor. Por ejemplo, con la ecuaciÃ³n de una esfera x2+y2+z2-r2=u es posible visualizar las superficies generadas para distintos valores de u sin necesidad de reconstruir cada una de estas superficies, lo cual genera costos importantes de tiempo y espacio. En los Ãºltimos aÃ±os han surgido tecnologÃ­as que permiten la utilizaciÃ³n del hardware grÃ¡fico en el despliegue tridimensional en navegadores Web; entre estas tecnologÃ­as se encuentra WebGL (acrÃ³nimo de Web Graphics Library). En este trabajo se elaborÃ³ un prototipo de aplicaciÃ³n Web basado en WebGL que implementa el algoritmo de visualizaciÃ³n de volÃºmenes llamado ray casting para el despliegue de ecuaciones implÃ­citas. Esto le permite al usuario escribir la ecuaciÃ³n implÃ­cita, definir el Ã¡rea a visualizar (subdominio de la ecuaciÃ³n), y el conjunto de umbrales con sus respectivos niveles de transparencia. En este documento se describen las tÃ©cnicas y decisiones de diseÃ±o tomadas para poder crear un prototipo de aplicaciÃ³n Web para generar el volumen a partir de la ecuaciÃ³n implÃ­cita, y desplegarlo con ray casting. EL volumen es almacenado en un atlas de textura 2D, pues la textura 3D no era soportada por WebGL al momento de iniciar la implementaciÃ³n. El documento estÃ¡ dividido en capÃ­tulos. En el capÃ­tulo 1 se describe el problema a resolver, sus objetivos y alcances. El capÃ­tulo 2 comprende el marco teÃ³rico que soporta esta investigaciÃ³n. En el capÃ­tulo 3 se describe el diseÃ±o y la implementaciÃ³n del sistema, incluyendo las funciones necesarias 9 para la correcta actualizaciÃ³n de la funciÃ³n de transferencia y re dibujo de la ecuaciÃ³n implÃ­cita. Se implementa una interfaz grÃ¡fica para controlar cada aspecto del despliegue. Haciendo uso de esta interfaz, en el capÃ­tulo 4 se discute las pruebas realizadas para demostrar el funcionamiento del sistema como un todo y la viabilidad de la utilizaciÃ³n WebGL en este campo. Finalmente, se tienen las conclusiones y trabajos a futuro de esta investigaciÃ³n en el capÃ­tulo 5. 10 CapÃ­tulo 1 - DescripciÃ³n del problema Las ecuaciones implÃ­citas estÃ¡n involucradas en diversos procesos e investigaciones. Estas nos ayudan a representar comportamientos fÃ­sicos, entre otros fenÃ³menos (Schulz, 2003). ComÃºnmente estas funciones son bidimensionales, y visualizadas en un plano 2D; esto ayuda tener una mejor idea de cÃ³mo determinar los lÃ­mites, puntos interÃ©s y caracterÃ­sticas propias de la funciÃ³n. Al pasar de un plano de 2d al espacio 3d aumenta la dificultad de ver la representaciÃ³n grÃ¡fica. Se han diseÃ±ado distintas tecnologÃ­as para facilitar el trabajo a la hora de visualizar dichas ecuaciones, hasta llegar al punto de tener aplicaciones por computador donde se escribe la funciÃ³n implÃ­cita, y esta es desplegada en 3D. El rendering o despliegue de volÃºmenes muestra una nueva forma de ver el conjunto de datos estableciendo dos vÃ­as para su despliegue por pantalla. El primer mÃ©todo, rendering directo de volÃºmenes, consiste en la asignaciÃ³n de un color y una opacidad a cada muestra (voxel), por medio de una funciÃ³n de transferencia. El volumen como tal es representado por medio de cortes igualmente espaciados de la ecuaciÃ³n implÃ­cita. Luego, mediante trazado rayos (ray casting), el volumen es proyectado en el plano imagen para su visualizaciÃ³n. El segundo mÃ©todo, el rendering indirecto de volÃºmenes, requiere de la generaciÃ³n de una de iso-superficie intermedia, tÃ­picamente reconstruida por algoritmos como Marching Cubes y Tetra Cubes (Lorensen & Cline, 1987) y (Hansen & Johnson, 2004) .Para poder observar las distintas capas de estos volÃºmenes, se utiliza un umbral por cada capa, al cual se le asigna un color y una opacidad a travÃ©s de una funciÃ³n de transferencia. Este tipo de rendering es usado para estudiar datos mÃ©dicos, piezas automotrices y funciones implÃ­citas. Se han utilizado mÃ©todos indirectos como Marching Cubes para visualizar Ecuaciones ImplÃ­citas. Visualizar decenas de capas con este mÃ©todo es poco prÃ¡ctico, puesto que requiere de espacio para almacenar todos los mallados reconstruidos, asÃ­ como tiempo para su generaciÃ³n. Es asÃ­ como el mÃ©todo de rendering directo de volÃºmenes es atractivo, pues podemos visualizar gran cantidad de capas del volumen, sin detrimento del tiempo de respuesta ni de requerimientos extras de memoria, mÃ¡s que el volumen en sÃ­. 1.1 - Planteamiento del problema Se propone desarrollar un sistema prototipo de visualizador de ecuaciones implÃ­citas aplicando la tÃ©cnica de rendering directo de volÃºmenes, que permita visualizar varias valores de superficie asociadas a la ecuaciÃ³n implÃ­cita. Por ejemplo, no solo se desea visualizar los ceros de la funciÃ³n implÃ­cita, sino cualquier otro iso-valor que nos genere informaciÃ³n de interÃ©s, de manera similar a como se visualizan los distintos tejidos en una resonancia magnÃ©tica o tomografÃ­a computarizada. Adicionalmente se desea que este sistema estÃ© disponible en la web, y no requiera de instalaciÃ³n. 11 1.2 Objetivo General Desarrollar un sistema de visualizaciÃ³n de ecuaciones implÃ­citas en la Web aplicando la tÃ©cnica de rendering de volÃºmenes. 1.3 Objetivos EspecÃ­ficos - Crear una interfaz Web que permita al usuario introducir la ecuaciÃ³n implÃ­cita, y seleccionar las valores de superficie que desea visualizar. - Crear un mÃ³dulo de anÃ¡lisis sintÃ¡ctico de la ecuaciÃ³n. - Crear un mÃ³dulo para evaluar la funciÃ³n implÃ­cita, de manera de poder generar un volumen para su posterior visualizaciÃ³n. - Crear un mÃ³dulo de visualizaciÃ³n utilizando la tÃ©cnica de ray casting. - Evaluar el rendimiento de la aplicaciÃ³n. 1.4 SoluciÃ³n propuesta A continuaciÃ³n, se presentan algunos detalles de la propuesta de soluciÃ³n, incluyendo metodologÃ­a de desarrollo a emplease, la plataforma de desarrollo, mÃ³dulos a desarrollar, y pruebas a realizar. 1.4.1. MetodologÃ­a de desarrollo Le metodologÃ­a de desarrollo a utilizar es AdHoc. En esta se planificarÃ¡n una serie de reuniones en donde se mostrarÃ¡ el desarrollo del sistema, conforme se avance en el proyecto, y se realizarÃ¡n los cambios y sugerencias hechas por el tutor. Se utilizarÃ¡ la versiÃ³n de sublime text (Skinner, 2015) como ambiente de desarrollo, usando como API librerÃ­as graficas OpenGL ES 2.0 y librerÃ­a de shaders GLSL 1 para esta aplicaciÃ³n, los cuales estÃ¡n incluidas dentro de WebGL. Asimismo, nos apoyaremos en plantillas de Bootstrap para el diseÃ±o de interfaces, todo bajo el lenguaje de javascript/HTML/css3 para implementar el sistema. 1.4.2. Plataforma de desarrollo y pruebas Plataforma de hardware CPU Intel Core i7Q740 1.73GHz RAM 8GB NVIDIA geforce 310m (mobile graphics) 512mb ddr3 Plataforma de software OpenGL ES 2.0. Windows 8.1 Javascript/HTML5/ccs3 12 1.4.3. MÃ³dulos a desarrollar Para solucionar el problema planteado, se desean desarrollar los siguientes mÃ³dulos: - AnÃ¡lisis sintÃ¡ctico de la ecuaciÃ³n implÃ­cita Se debe crear un mÃ³dulo que verifique si la cadena de caracteres introducida es una funciÃ³n valida. El analizador a usar es un framework de la librerÃ­a de Boost c++ (Guzman, 2010), llamado Spirit. Este analizador sintÃ¡ctico posee gran flexibilidad que brindan las plantillas y la sobrecarga de operadores de c++. Esto hace que sea sencillo de construir, ademÃ¡s de poseer una adecuada documentaciÃ³n. Se utilizarÃ¡ regex de boost para comprobar que la cadena introducida es cumple con las reglas lÃ©xicas correctas, y se definirÃ¡ una gramÃ¡tica que evaluarÃ¡ la expresiÃ³n dada. - Rendering de volÃºmenes: Se utilizarÃ¡ ray casting basado en GPU. SegÃºn el trabajo de (Klaus Engel, 2001), se utilizarÃ¡ la post-clasificaciÃ³n y la clasificaciÃ³n pre-integrada. La razÃ³n de utilizar la clasificaciÃ³n pre-integrada es que permite capturar los detalles finos de la funciÃ³n de transferencia, que con la post-clasificaciÃ³n requerirÃ­a aumentar significativamente la taza de muestreo del volumen, acarreando una reducciÃ³n en el tiempo de respuesta. - Interfaz grÃ¡fica La interfaz se diseÃ±arÃ¡ con el fin de cumplir con los requisitos mÃ­nimos para la visualizaciÃ³n de la ecuaciÃ³n implÃ­cita. El usuario debe poder introducir los valores de superficie a visualizar, y tener la posibilidad de asignarle color, transparencia y demÃ¡s propiedades de rendering a cada iso-valor. El usuario debe poder especificar el dominio en el cuÃ¡l se evaluarÃ¡ la funciÃ³n implÃ­cita mediante una caja alineada a los ejes (i.e. xmin, ymin, zmin, xmax, ymax, zmax). Debido a que en principio el usuario podrÃ­a no conocer el rango funciÃ³n (el conjunto de valores que puede tomar [fmin,fmax]), la aplicaciÃ³n podrÃ­a guiar al usuario. Para ello, la funciÃ³n implÃ­cita puede ser primero evaluada en el dominio establecido para conocer el rango [fmin, fmax] de la funciÃ³n, y una vez conocido dicho rango, solicitarle al usuario dÃ³nde estarÃ­an ubicados los valores de superficie que desea visualizar, siempre dentro de dicho rango de valores. En esta direcciÃ³n, se puede crear un control especial que permita al usuario introducir los valores de superficie y cambiarlos en forma sencilla, como se muestra en la Fig. 1.1. En la imagen a continuaciÃ³n podemos observar un prototipo de la interfaz grÃ¡fica a realizar. El primer elemento contiene los campos para establecer el sub volumen de la ecuaciÃ³n a visualizar, dados por los puntos extremos min(x,y,z) y max(x,y,z) de una caja alineada a los ejes. En este dialogo se introducen valores flotantes (sean positivos o negativos) de cada uno de los limites (x,y,z) de la ecuaciÃ³n. Se agrega un campo para definir el nÃºmero de subdivisiones el cada eje. Por ejemplo, si colocamos 32 subdivisiones significa que el volumen serÃ¡ discretizado en 323 muestras. En el siguiente campo se insertarÃ¡ la ecuaciÃ³n de la forma descrita, en el que los sÃ­mbolos representarÃ¡n las operaciones asociadas, como suma (+), resta (-), multiplicaciÃ³n (*), divisiÃ³n (/), potenciaciÃ³n (^) y agrupaciÃ³n de operadores(+,-,*,^,) y operandos (X,Y,Z) con parÃ©ntesis. 13 En el tercer campo el usuario podrÃ¡ seleccionar los diferentes iso valores, y moverlos libremente en el rango de valores [fmin, fmax] determinado por el sistema. El iso valor y su color asociado serÃ¡n mostrados con un simple objeto de color (triÃ¡ngulo o cuadrado), y el valor flotante asociado podrÃ¡ visualizarse en otro control. A su vez se mostrarÃ¡ una ventana informativa donde se pueden editar los datos de la funciÃ³n de transferencia para cada iso-valor, como el color (R,G,B) y absorciÃ³n (A). Fig. 1.1: prototipo de interfaz para seleccionar valores de superficie El modelo de iluminaciÃ³n a utilizar es Phong Shading (Foley, van Dam, Feiner, & Hughes, 1996), el cual se puede habilitar o deshabilitar. Los colores difusos y especular de una iso-superficie estÃ¡n definidos por el mismo color RGB de la funciÃ³n de transferencia para dicha iso-superficie. 1.4.4. Pruebas a realizar Las diferentes pruebas a realizar buscan medir el tiempo de reconstrucciÃ³n y el tiempo de rendering para diferentes ecuaciones implÃ­citas, variando la cantidad de valores de superficie, y considerando distintas resoluciones del volumen. xmin: ymin: xmin: TamaÃ±o de la celda xmax:: ymax: xmax: X^2+Y^2+(Z^2)/2 f(x,y,z)= Iso2 fmax fmin Valores de superficie: Iso1, iso2, iso3, â€¦. resoluciÃ³n Min Max 14 CapÃ­tulo 2 â€“ Marco teÃ³rico En este capÃ­tulo se introducen los conceptos bÃ¡sicos de imagen, pixel, voxel, entre otros, necesarios para describir brevemente el proceso de rendering, y particularmente el rendering de volÃºmenes, del cual se describen el mÃ©todo a implementar (ray casting). 2.1 Imagen La palabra imagen proviene del latÃ­n imago. La imagen es un artefacto que representa o registra la percepciÃ³n visual, por ejemplo, una foto en dos dimensiones. Algunas de las caracterÃ­sticas de la imagen son: - Pueden ser de dos dimensiones, como una fotografÃ­a, o las que aparecen en un monitor. TambiÃ©n pueden ser de tres dimensiones, como una estatua o un holograma. Estos Ãºltimos son capturados por dispositivos Ã³pticos, como cÃ¡maras, espejos, lentes, telescopios, microscÃ³picos, etc. Otros objetos naturales y fenÃ³menos, como el ojo humano o superficies de agua tambiÃ©n los capturan. - La palabra imagen es usada para figuras bidimensionales como un mapa, un grafo, un grÃ¡fico de torta o una pintura. En un amplio espectro, las imÃ¡genes pueden ser generadas manualmente (como es el caso de los dibujos y una pieza de arte), o mediante un computador, en donde se pueden generar imÃ¡genes sintÃ©ticas (generadas con tÃ©cnicas de computaciÃ³n grÃ¡fica), se pueden obtener mediante digitalizaciÃ³n de imÃ¡genes existentes, o simplemente se pueden reproducir o imprimir. 2.2 Pixel En una imagen digital, un pixel, es simplemente un punto de la imagen, el cual puede ser direccionado mediante un par de coordenadas enteras. En un dispositivo de despliegue, es el elemento mÃ¡s pequeÃ±o controlable por el hardware del dispositivo. Cada pixel es una muestra de una imagen real; lÃ³gicamente mÃ¡s muestras proveen una mejor representaciÃ³n de la imagen original. La intensidad de cada pixel es variable. Su color es tÃ­picamente representado por tres o cuatro componentes de intensidad ya sean rojo, verde y azul, o los componentes cyan, magenta, amarillo y negro en el caso de las impresoras. La palabra pixel proviene de la contracciÃ³n de "picture" (pix) y "element" (el). Encontramos construcciones similares para las palabras voxel (volume element) y texel (texture element). 2.3 Voxel AsÃ­ como el pixel es la unidad mÃ­nima discreta direccionable en una imagen digital, el voxel es similarmente una unidad discreta que representa un punto de un volumen. En un voxel pueden almacenarse distintas propiedades, como una densidad, una opacidad, un color, un gradiente, etc. El 15 valor de un voxel puede representar diversas propiedades. En cada aparato de captura (por ejemplo, CT, MRI y ultrasonido) tiene una interpretaciÃ³n distinta. Para volÃºmenes representados por una malla regular, los voxels no tienen por lo general su posiciÃ³n (sus coordenadas) codificada explÃ­citamente junto con sus valores. La posiciÃ³n de un voxel se infiere basÃ¡ndose en su posiciÃ³n relativa con respecto a otros voxels, es decir, su posiciÃ³n en la estructura de datos que define el volumen discretizado. Los voxels se utilizan con frecuencia en la visualizaciÃ³n y el anÃ¡lisis de datos mÃ©dicos y cientÃ­ficos. Por lo general, se hace abstracciÃ³n de un voxel como un punto de la malla regular, y no un sub volumen del volumen original. Dependiendo del tipo de datos y el uso previsto para el conjunto de datos, el espacio que hay entre voxels puede ser reconstruido y/o aproximado, por ejemplo, mediante interpolaciÃ³n. Entre los usos mÃ¡s frecuentes de los voxels estÃ¡ la medicina para representar data volumÃ©trica de pacientes, la representaciÃ³n de datos geolÃ³gicos para explotaciÃ³n petrolera, la representaciÃ³n de la tierra en los juegos y la simulaciÃ³n. Los terrenos de voxels suelen ser utilizados en vez de un mapa de altura gracias a que se pueden representar las salientes, cuevas, arcos, y otras caracterÃ­sticas del terreno en 3d como es el caso de C4 engine [LLC, 2001]. Estas caracterÃ­sticas cÃ³ncavas no pueden ser representadas en un mapa de altura dado que solo la capa superior del terreno (una altura por cada punto) puede ser representada. 2.4 PolÃ­gono En geometrÃ­a un polÃ­gono es una figura plana que estÃ¡ dada por una cadena finita de segmentos de rectas, formando un ciclo o un circuito. Estos segmentos son llamados bordes o lados; los puntos donde dos bordes se encuentran son los vÃ©rtices o esquinas. El interior de un polÃ­gono es llamado cuerpo. Un n-Ã¡gono es un polÃ­gono de n lados. La palabra polÃ­gono proviene del griego polÃºs â€œmuchosâ€, y gÅnÃ­a â€œesquinaâ€ o â€œÃ¡nguloâ€. Los polÃ­gonos son usados en computaciÃ³n grÃ¡fica para componer imÃ¡genes o modelos por lo general en tres dimensiones. No siempre son triangulares. Estos surgen cuando se modela la superficie del objeto. En contraste a los pixeles y voxels, los polÃ­gonos se representan a menudo explÃ­citamente por las coordenadas de sus vÃ©rtices. Una consecuencia directa de esta diferencia es que los polÃ­gonos son capaces de representar de manera eficaz las estructuras 3D simples con espacios homogÃ©neos, mientras que los voxels son adecuados para la representaciÃ³n de espacios no homogÃ©neos. 2.5 Rendering Rendering es el proceso de transformaciÃ³n de una escena en una imagen [STEVENS, 1993]. En el rendering, se suele emplear un modelo de iluminaciÃ³n para generar una simulaciÃ³n realista del comportamiento de luces, texturas y materiales (agua, madera, metal, plÃ¡stico, tela, etcÃ©tera). TambiÃ©n se pueden considerar los comportamientos fÃ­sicos como en el caso de las colisiones y fluidos (ver Fig. 2.1). 16 Figura 2.1: Ejemplo del resultado final del proceso de rendering, donde se recrea una escena con distintos materiales, texturas e iluminaciÃ³n Como se puede apreciar en la Fig. 2.1, una escena contiene objetos, los cuales pueden estar definidos por un lenguaje o estructura de datos. Dicha estructura contiene la geometrÃ­a, el punto de vista, las texturas, la iluminaciÃ³n e informaciÃ³n del sombreado (shading), es decir, la descripciÃ³n de la escena. Los datos contenidos en la escena son transferidos a un programa de rendering, cuyo resultado final es una imagen digital o grÃ¡fico raster. Durante el rendering 3D se suelen utilizar distintos sistemas de coordenadas, como coordenadas de mundo, de modelo, de vista, de recorte o clipping, etc. Las transformaciones que llevan un sistema de coordenadas a otro suelen representarse por una matriz. Varios de los usos del rendering estÃ¡n ligados a la arquitectura, video juegos, simulaciÃ³n, pelÃ­culas o efectos visuales de televisiÃ³n y diseÃ±o asistido por computador (Computer-Aided Design; CAD). Cada uno emplea diferentes balances de elementos y tÃ©cnicas. Como producto, hay una gran variedad de motores de rendering disponibles; algunos de estos estÃ¡n integrados en grandes paquetes de modelaje y animaciÃ³n, otros son de uso dedicado, como proyectos de cÃ³digo libre, juegos, etc. Para visualizar la escena en tiempo real, se suele utilizar un pipeline grÃ¡fico, el cual convierte primitivas grÃ¡ficas del espacio de modelo en primitivas dentro del espacio del dispositivo, es decir, en pÃ­xeles. Partes de este pipeline grÃ¡fico son implementadas en el hardware grÃ¡fico para tener mejores tiempos de respuestas. Con el avance de la tecnologÃ­a, algunas etapas de este pipeline grÃ¡fico tienen la facilidad de ser programables. AsÃ­, algunos de sus estados son de hecho unidades de programaciÃ³n; esto quiere decir que podemos implementar nuestros modelos de luz o transformaciones geomÃ©tricas, teniendo libertad en la transformaciÃ³n de cada vÃ©rtice y de la 17 asignaciÃ³n de color a cada fragmento. Los aceleradores grÃ¡ficos programables, son tambiÃ©n conocidos como GPU (Graphics Processor Unit, o unidad de procesamiento grÃ¡fico). La Unidad de Procesamiento GrÃ¡fico (Graphic Processing Unit; GPU) es un dispositivo diseÃ±ado con el propÃ³sito de acelerar la creaciÃ³n de imÃ¡genes en el frame buffer (memoria dedicada de video que contiene los datos completos de cada cuadro de imagen). Las GPUs se encuentran embebidas en sistemas, telÃ©fonos mÃ³viles, computadores personales, estaciones de trabajo y consolas de videojuegos. La GPU moderna es eficiente manipulando los grÃ¡ficos del computador, y gracias a su estructura de alto paralelismo es mÃ¡s eficiente que el CPU. La GPU se encarga de hacer el cÃ¡lculo del modelo de iluminaciÃ³n, rasterizaciÃ³n, texturizaciÃ³n y clipping (recortes); este Ãºltimo consiste la eliminaciÃ³n de porciones de objetos extendidos mÃ¡s allÃ¡ de una regiÃ³n predeterminada de la escena (e.g. un clippling plane), quedando asÃ­ un subconjunto de los objetos a ser desplegados (STEVENS, 1993). El proceso de rendering se puede describir mediante la EcuaciÃ³n 1.1. Esta ecuaciÃ³n no abarca todo el fenÃ³meno luminoso, pero es parte del modelo de iluminaciÃ³n para generar imÃ¡genes por medio de la computadora. EcuaciÃ³n 1.1 (EcuaciÃ³n de rendering o cÃ¡lculo del modelo de iluminaciÃ³n) La ecuaciÃ³n 1.1 describe como en una posiciÃ³n x y direcciÃ³n w particular, la luz de salida(ğ¿ğ‘œ) es la suma de la luz emitida (ğ¿ğ‘’) y el reflejo de la luz. El reflejo de la luz por otra parte se modela como una integral donde intervienen la luz de entrada(ğ¿ğ‘–) de todas las direcciones, multiplicada por el reflejo de la superficie ğ‘“ğ‘Ÿ(ğ‘¥, ï¿½âƒ‘âƒ‘ï¿½ , ï¿½âƒ‘âƒ‘ï¿½ ) , y el Ã¡ngulo de entrada de la luz (ï¿½âƒ‘âƒ‘ï¿½ â‹… ï¿½âƒ‘ï¿½ ) . Esto define el transporte de la luz a travÃ©s de la escena. La funciÃ³n de distribuciÃ³n bidireccional de reflectancia (BRDF) ğ‘“ğ‘Ÿ(ğ‘¥, ï¿½âƒ‘âƒ‘ï¿½ , ï¿½âƒ‘âƒ‘ï¿½ ), expresa un modelo de interacciÃ³n de luz con las superficies, en cual se destacan 2 tipos: la reflexiÃ³n difusa y la reflexiÃ³n especular. 2.5.1 CaracterÃ­sticas del Rendering El motor de rendering posee una abundante cantidad de caracterÃ­sticas visuales para dar un resultado realista en lo posible. El desarrollo y la investigaciÃ³n en el rendering se han enfocado en encontrar formas de simular estas caracterÃ­sticas visuales de manera eficiente. Algunas de estas caracterÃ­sticas estÃ¡n directamente relacionadas con algoritmos y tÃ©cnicas, mientras que otras caracterÃ­sticas son producto de la uniÃ³n de varias tÃ©cnicas. Algunas de estas tÃ©cnicas son: ï‚· Shading (sombreado): define cÃ³mo el color y el brillo de una superficie varÃ­an segÃºn la iluminaciÃ³n ï‚· Texture-mapping (aplicaciÃ³n de textura): es un mÃ©todo para aplicar detalle de textura sobre superficies 18 ï‚· Bump-mapping: es un mÃ©todo para simular a escala pequeÃ±a protuberancias o hendiduras sobre superficies ï‚· Neblina: define cÃ³mo la luz obscurece cuando pasa por medio de una atmÃ³sfera densa ï‚· Sombras: muestra el efecto de obstrucciÃ³n de la luz ï‚· Sombras suaves: variaciÃ³n de oscuridad causada por fuentes de luz parcialmente ocultas ï‚· ReflexiÃ³n: efecto espejo, un rayo de luz incide sobre una superficie y es reflejado ï‚· Transparencia: transmisiÃ³n continua de la luz a travÃ©s de objetos sÃ³lidos ï‚· RefracciÃ³n: curvatura de la luz asociada con la transparencia ï‚· DifracciÃ³n: desviaciÃ³n de la luz al encontrar un obstÃ¡culo o al atravesar una rendija ï‚· IluminaciÃ³n indirecta: superficies iluminadas por la luz reflejada de otras superficies, en lugar de ser iluminada por una fuente de luz directa ï‚· CÃ¡ustica: es la combinaciÃ³n de los rayos de luz reflejada o refractada por una superficie u objeto curvo, o la proyecciÃ³n de esa combinaciÃ³n de rayos en otra superficie ï‚· Depth of field (profundidad de campo): efecto que hace que objetos aparezcan borrosos o fuera de foco cuando se estÃ¡ muy lejos, en frente o detrÃ¡s de un objeto enfocado ï‚· Motion blur (borrosidad por movimiento): los objetos aparecen borrosos dado el movimiento de alta velocidad o movimiento de la cÃ¡mara ï‚· Rendering no foto realÃ­stico: rendering de escenas en un estilo artÃ­stico, destinado a verse como una pintura o un dibujo 2.6 Volume Rendering (Rendering de VolÃºmenes) En visualizaciÃ³n cientÃ­fica y computaciÃ³n grÃ¡fica, es una tÃ©cnica utilizada para generar una imagen a partir de la proyecciÃ³n de un volumen, simulando cÃ³mo se propaga la luz a travÃ©s de dicho volumen (B & D, 2007). TÃ­picamente este volumen viene dado por un conjunto de imÃ¡genes seriadas 2D, igualmente espaciadas, adquiridas por CT, MRI, entre otros (ver Fig. 2.2). La distancia entre muestras (voxels) de un mismo corte tambiÃ©n es constante, generando un patrÃ³n regular llamado mallado volumÃ©trico regular. Figura 2.2: rendering de un volumen capturado por un escÃ¡ner CT 19 Hay dos vertientes para visualizar el volumen: el despliegue indirecto de volÃºmenes, el cual requiere de la generaciÃ³n de una superficie antes de su visualizaciÃ³n, y el despliegue directo de volÃºmenes, el cual visualiza el volumen partir de la proyecciÃ³n de sus muestras. En el caso de despliegue indirecto de volÃºmenes, vale mencionar el algoritmo de Marching Cubes (B & D, 2007), que es una tÃ©cnica comÃºn utilizada para la extracciÃ³n de valores de superficie, en el cual toma 8 muestras adyacentes a la vez (formando un cubo imaginario), en donde se determinan los polÃ­gonos que atraviesan ese cubo mediante interpolaciÃ³n lineal. Para el caso de despliegue directo de volÃºmenes, estudiaremos la tÃ©cnica de ray casting, la cual serÃ¡ implementada en este trabajo. 2.6.1 Rendering Directo de VolÃºmenes Para hacer una proyecciÃ³n 2D del conjunto de voxels 3D, primero hay que definir una cÃ¡mara en el espacio en relaciÃ³n con el volumen. TambiÃ©n, hay que definir la opacidad y el color de cada voxel [Levoy, 1988]. Esto se define por lo general con una funciÃ³n de transferencia unidimensional [Infogrames, 2003]. Con dicha funciÃ³n de transferencia se define el valor RGBA (Red, Green, Blue, Alpha; las siglas para cada color y trasparencia) para cada valor posible de voxel. Esta funciÃ³n suele ser una funciÃ³n lineal a trozos, por cada componente de la tupla RGBA. El proceso de asignar un color y una opacidad a un voxel se llama clasificaciÃ³n. El pipeline del rendering de volÃºmenes sigue una serie de pasos que constan del muestreo (sampling), clasificaciÃ³n y composiciÃ³n. El muestreo consiste en reconstruir muestras del volumen por medio de la interpolaciÃ³n de voxels. Esto se realiza debido a que, al proyectar el volumen, las muestras originales del mismo no coinciden con la ubicaciÃ³n de los pixeles, por lo que en cambio se reconstruyen los voxels que estÃ¡n a lo largo de un rayo que pasa por el pixel desde la posiciÃ³n del observador. La clasificaciÃ³n e iluminaciÃ³n consiste en darle color y opacidad al voxel reconstruido. Mediante una funciÃ³n de transferencia se le otorga un color y opacidad inicial al voxel, el cual es usado en conjunto con un modelo de iluminaciÃ³n para calcular su contribuciÃ³n lumÃ­nica. Luego de muestrear, clasificar e iluminar cada voxel al largo de la discretizaciÃ³n de un rayo, estos deben ser compuestos de acuerdo al modelo fÃ­sico del volumen. El orden en que se realiza el proceso de clasificaciÃ³n y muestreo determina el tipo de clasificaciÃ³n. Se realiza post-clasificaciÃ³n cuando se reconstruye el voxel y luego es clasificado, mientras que se realiza pre-clasificaciÃ³n cuando primero se clasifican las muestras del volumen original, y luego se realiza la reconstrucciÃ³n de las muestras (B & D, 2007). La tÃ©cnica de ray casting se deduce directamente de la ecuaciÃ³n de rendering [Kajiya, 1986]. Esta provee resultados de alta calidad. En esta tÃ©cnica se genera un rayo por cada pixel deseado de la imagen. Usando un modelo simple de cÃ¡mara, el rayo comienza desde el centro de proyecciÃ³n de la cÃ¡mara (normalmente la ubicaciÃ³n del ojo) y pasa a travÃ©s de un pixel en el plano imagen imaginario ubicado entre la cÃ¡mara y el volumen. En la intersecciÃ³n de rayo con el volumen, el volumen es muestreado en intervalos regulares o adaptativos para, a travÃ©s de la composiciÃ³n, 20 obtener el valor de un pixel en la imagen. El proceso se realiza por cada pixel en la imagen (ver Fig. 2.3). Figura 2.3: pasos de ray casting para un pixel de la imagen. (1) Se lanza un rayo desde el ojo, pasando por un pÃ­xel de la imagen. (2) Se reconstruyen muestras del volumen a lo largo del rayo. (3) Se clasifican e iluminan dichas muestras. (4) Se componen las muestras para obtener el color del pixel 2.6.2 ClasificaciÃ³n En el despliegue de volumen existen diversos mÃ©todos para procesar dicho volumen y ser mostrado por pantalla, estos mÃ©todos de clasificaciÃ³n de volumen ayudan a tener una mejor visualizaciÃ³n de este (K. & T., 2001). ClasificaciÃ³n en este caso es la asignaciÃ³n de un color una opacidad a ese valor del conjunto datos. Dentro de los mÃ©todos de clasificaciÃ³n tenemos: PRE-CLASIFICACIÃ“N: Indica la aplicaciÃ³n de la funciÃ³n de transferencia a los puntos de muestreo discretizados antes de la etapa de interpolaciÃ³n de datos. En otras palabras, el color y la absorciÃ³n son calculados en una etapa de pre procesamiento para cada punto de muestreo y luego se usa para interpolar el color y la opacidad con el fin de calcular la representaciÃ³n integral del volumen POST-CLASIFICACIÃ“N: El orden de las operaciones se invierte, con respecto a la Pre-clasificaciÃ³n. Este tipo de clasificaciÃ³n se caracteriza por la aplicaciÃ³n de la funciÃ³n de transferencia despuÃ©s de la interpolaciÃ³n de la opacidad a partir de los valores escalares de los puntos de muestreo discretizados. PRE-INTEGRACIÃ“N: La idea principal de la clasificaciÃ³n pre-integrada es dividir el proceso de integraciÃ³n numÃ©rica. La integraciÃ³n por separado del campo escalar continÃºo y las funciones de transferencia se lleva a cabo para hacer frente a la problemÃ¡tica de la frecuencia de Nyquist. Mientras el campo escalar del volumen puede ser suave, la funciÃ³n de transferencia entre dos muestras del campo escalar podrÃ­a requerir una alta tasa de muestreo para capturar todos los detalles. 21 Para evitar el muestreo excesivo de la funciÃ³n de transferencia durante el rendering, una alternativa es pre calcular la integral entre cada par posible de muestras cuantizadas de un rayo, y en tiempo de rendering, obtener la integral pre-calculada entre cada par de muestras consecutivas en O(1). En la Fig 2.4 podemos apreciar el rendering utilizando las diferentes tÃ©cnicas de clasificaciÃ³n. Figura 2.4: Ejemplo de las diferentes clasificaciones: de izquierda a derecha (a)pre- clasificacion (b)pos-clasificacion (c)pre-integracion 2.7 - Ecuaciones ImplÃ­citas Una funciÃ³n explicita, es una funciÃ³n que es dada en tÃ©rminos de una o mÃ¡s variables independientes. Por ejemplo, en la siguiente funciÃ³n ğ‘¦ = ğ‘“(ğ‘¥) = ğ‘¥2 + 3ğ‘¥ âˆ’ 8, ğ‘¦ es la variable dependiente y es dada en tÃ©rminos una variable independiente ğ‘¥. Se llama variable independiente a los valores que pueden tomar los elementos del dominio de la funciÃ³n. Generalmente se denota por x para funciones bidimensionales. En el ejemplo anterior, ğ‘¥ âˆˆ ğ‘ ya que asÃ­ fue especificada. Se llama variable dependiente a los valores que pueden tomar la imagen o rango de la funciÃ³n. Generalmente se denota por la letra ğ‘¦ para funciones bidimensionales, dÃ³nde ğ‘¦ = ğ‘“(ğ‘¥). En el ejemplo anterior, ğ‘¦ âˆˆ {âˆ’2,âˆ’53,âˆ’73,âˆ’43,âˆ’83,âˆ’1,â€¦ } Los valores de x que anulan la funciÃ³n (i.e. x:f(x)=0) son las raÃ­ces de la funciÃ³n. TambiÃ©n son llamados los ceros de la funciÃ³n. Las funciones implÃ­citas, por otro lado, son usualmente dadas en tÃ©rmino de ambas variables (dependientes e independientes), como por ejemplo: ğ‘“(ğ‘¥, ğ‘¦) = 2ğ‘¦ + ğ‘ ğ‘’ğ‘›(âˆ’ğ‘¥) . La ecuaciÃ³n de una funciÃ³n, es la expresiÃ³n algebraica que resume cÃ³mo se obtienen los valores del conjunto final a partir de los valores del conjunto inicial funciÃ³n, tal y como se presenta la funciÃ³n explÃ­cita: ğ‘¦ = ğ‘“(ğ‘¥) = ğ‘¥2 + 3ğ‘¥ âˆ’ 8. Similarmente, la ecuaciÃ³n implÃ­cita no es mÃ¡s que el resumen de los valores obtenidos a partir de una FunciÃ³n ImplÃ­cita. Por ejemplo, 22 { (x,y)ïƒïƒ‚2 : ğ‘“(ğ‘¥, ğ‘¦) = ğ‘¦ + ğ‘¥2 âˆ’ 3ğ‘¥ + 8 = 0 } Los ceros de la funciÃ³n f(x,y) son en este caso los puntos (x,y) que pertenecen a la ecuaciÃ³n implÃ­cita. 2.8 Ceros de funciones Existen diversos mÃ©todos para hallar las raÃ­ces de funciones; la idea es obtener una soluciÃ³n de la ecuaciÃ³n ğ‘“(ğ‘¥) = 0, para una funciÃ³n dada ğ‘“. Entre los mÃ©todos se encuentran los mÃ©todos cerrados (BisecciÃ³n, Regula Falsi, MuÌˆller) los cuales parten de un intervalo dado para hallar la raÃ­z de dicha ecuaciÃ³n. Por otro lado se encuentran los mÃ©todos abiertos (Newton, Secante) que establecen distintas condiciones para hallar la raÃ­z. Varios de estos mÃ©todos para hallar raÃ­ces requieren ser comprobada si la funciÃ³n preserva el orden (monÃ³tona creciente) o es reverso (monÃ³tona decreciente), ya que existen funciones que no son monÃ³tonas y puede que no exista la raÃ­z en ese intervalo seleccionado. Una funciÃ³n ğ‘“ que define un subconjunto de nÃºmeros reales se llama monÃ³tona creciente, si para cada ğ‘¥ e ğ‘¦ tales que ğ‘¥ â‰¤ ğ‘¦ se tiene que ğ‘“(ğ‘¥) â‰¤ ğ‘“(ğ‘¦). Del mismo modo una funciÃ³n se llama monÃ³tona decreciente, si para cada ğ‘¥ e ğ‘¦ tales que ğ‘¦ â‰¤ ğ‘¥ se cumple que ğ‘“(ğ‘¥) â‰¥ ğ‘“(ğ‘¦) . La monotonicidad puede estar presente en un sub dominio de la funciÃ³n (por ejemplo, en un sub intervalo), o es todo su dominio. A continuaciÃ³n, estudiaremos varios mÃ©todos clÃ¡sicos de ceros de funciones, a saber: BisecciÃ³n, Newton, Secante, Regula Falsi y MÃ¼ller. 2.8.1 MÃ©todo de BisecciÃ³n Supongamos que ğ‘“ es una funciÃ³n continÃºa definida en el intervalo [ğ‘, ğ‘] con ğ‘“(ğ‘) y ğ‘“(ğ‘) de signos diferentes. De acuerdo con el teorema del valor intermedio, este teorema nos indica que si ğ‘¢ es un numero entre ğ‘“(ğ‘) y ğ‘“(ğ‘) con ğ‘“(ğ‘) > ğ‘¢ > ğ‘“(ğ‘) o ğ‘“(ğ‘) < ğ‘¢ < ğ‘“(ğ‘), entonces existe un ğ‘ïƒ[ğ‘, ğ‘], tal que ğ‘“(ğ‘) = ğ‘¢. Si bien el procedimiento se aplica, aunque exista mÃ¡s de una raÃ­z en el intervalo (ğ‘, ğ‘), por razones de simplicidad suponemos que la raÃ­z de este intervalo es Ãºnica. El mÃ©todo requiere dividir varias veces a la mitad los sub intervalos de [ğ‘, ğ‘] y, en cada paso, localizar la mitad que contenga a ğ‘. Para empezar, supongamos que ğ‘1 = ğ‘ y ğ‘1 = ğ‘, y sea ğ‘š1, el punto medio de [ğ‘, ğ‘]; es decir: ğ‘š1 = ğ‘1 + ğ‘1âˆ’ğ‘1 2 = ğ‘1 + ğ‘1 2 . Si ğ‘“(ğ‘š1) = 0, entonces ğ‘ = ğ‘š1; de no ser asÃ­ entonces ğ‘“(ğ‘š1) tiene el mismo signo que ğ‘“(ğ‘1) o ğ‘“(ğ‘1). Si ğ‘“(ğ‘1) y ğ‘“(ğ‘š1) tienen el mismo signo, entonces ğ‘ pertenece (ğ‘š1, ğ‘1) y tomamos ğ‘2 = ğ‘š1 y ğ‘2 = ğ‘1 . Si ğ‘“(ğ‘1) y ğ‘“(ğ‘š1) tienen signos opuestos, entonces ğ‘ pertenece (ğ‘1,ğ‘š1) y tomamos ğ‘2 = ğ‘1 ğ‘¦ ğ‘2 = ğ‘š1. DespuÃ©s volvemos a aplicar el proceso al intervalo [ğ‘2, ğ‘2] tomando el punto medio m2, de forma iterativa hasta obtener la raÃ­z de dicha funciÃ³n con ciertos decimales de 23 precisiÃ³n. Haciendo un anÃ¡lisis del mÃ©todo se garantiza la convergencia de la raÃ­z de f si f es una funciÃ³n continua dentro del intervalo establecido [ğ‘, ğ‘] y tanto f(a) como f(b) tienen signos opuestos. El error absoluto se reduce a la mitad por cada paso, por lo que el mÃ©todo converge de manera lineal (ver Fig. 2.5). El error luego de n iteraciones es acotado por |mn â€“ c| <= |b-a|/2n. Esta fÃ³rmula es usada para determinar el nÃºmero de iteraciones para converger a la raÃ­z deseada con una cierta tolerancia t. AsÃ­, n >= log2(b-a)-t. Figura 2.5: Ejemplo de aplicaciÃ³n del MÃ©todo de BisecciÃ³n [Ziegler, 2004] 2.8.2 MÃ©todo de Newton Parte de una aproximaciÃ³n inicial ğ‘¥0 y obtiene una aproximaciÃ³n mejorada, ğ‘¥1, dada por la fÃ³rmula: ğ‘¥1 = ğ‘¥0 â€“ ğ‘“(ğ‘¥0) ğ‘“â€™(ğ‘¥0) (1) La ecuaciÃ³n 1 anterior puede derivarse del desarrollo en serie de Taylor. Para un entorno del punto ğ‘¥ğ‘› : ğ‘“(ğ‘¥) = ğ‘“(ğ‘¥ğ‘›) + ğ‘“â€™(ğ‘¥ğ‘›)(ğ‘¥ âˆ’ ğ‘¥ğ‘›) + (ğ‘¥ âˆ’ ğ‘¥ğ‘›) 2 ğ‘“â€™â€™(ğ‘¥ğ‘›) 2! + â€¦ si se trunca el desarrollo a partir del termino de grado 2, y evaluamos en ğ‘¥ğ‘›+1:ğ‘“(ğ‘¥ğ‘›+1) = ğ‘“(ğ‘¥ğ‘›) + ğ‘“â€²(ğ‘¥ğ‘›)( ğ‘¥ğ‘›+1 âˆ’ ğ‘¥ğ‘›), y si ademÃ¡s se acepta que ğ‘¥ğ‘›+1 tiende a la raÃ­z, se ha de cumplir que ğ‘“(ğ‘¥ğ‘›+1) = 0. Luego sustituyendo en la expresiÃ³n anterior, obtenemos 0 = ğ‘“(ğ‘¥ğ‘›) + ğ‘“â€²(ğ‘¥ğ‘›)( ğ‘¥ğ‘›+1 âˆ’ ğ‘¥ğ‘›). Finalmente, despejamos xn+1 y obtenemos la ecuaciÃ³n (1). El mÃ©todo de Newton tiene una interpretaciÃ³n geomÃ©trica sencilla, como se puede apreciar del anÃ¡lisis de la Fig. 2.6. De hecho, el mÃ©todo de Newton consiste en una linealizaciÃ³n de la funciÃ³n, es decir, ğ‘“ se reemplaza por una recta tal que contiene al punto (ğ‘¥0, ğ‘“(ğ‘¥0)) y cuya pendiente coincide con la derivada de la funciÃ³n del punto, ğ‘“(ğ‘¥0). La nueva aproximaciÃ³n a la raÃ­z, ğ‘¥1 , se obtiene de la intersecciÃ³n de la funciÃ³n lineal con el eje ğ‘¥. 24 Figura 2.6: Ejemplo de la aplicaciÃ³n del Metodo de Newton [Pauls, 2011] Otra forma de derivar la ecuaciÃ³n (1) es utilizando la ecuaciÃ³n de la recta que pasa por el punto (ğ‘¥0, ğ‘“(ğ‘¥0)) y de pendiente ğ‘¦ â€“ ğ‘“(ğ‘¥0) = ğ‘“(ğ‘¥0)(ğ‘¥ âˆ’ ğ‘¥0). Haciendo ğ‘¦ = 0 y despejando ğ‘¥ obtenemos la ecuacion (1). La convergencia de este mÃ©todo es cuadrÃ¡tica. 2.8.3 MÃ©todo de la Secante Requiere dos puntos iniciales, los cuales pueden ser arbitrarios. Consiste en trazar rectas secantes a la curva de la ecuaciÃ³n que se estÃ¡ analizando, y verificar la intersecciÃ³n de dichas rectas con el eje de las x para determinar si es la raÃ­z que se busca (ver Fig 2.7). Al ser un mÃ©todo abierto, converge con la raÃ­z con una velocidad semejante a la de Newton, aunque similarmente al mÃ©todo de Newton, la convergencia no estÃ¡ garantizada si el iterado inicial estÃ¡ lejos de la raÃ­z. Su principal diferencia con el mÃ©todo de Newton es que no se requiere obtener la derivada de la funciÃ³n para realizar las aproximaciones, lo cual facilita las cosas al momento de crear un cÃ³digo para encontrar raÃ­ces por medio de este mÃ©todo. La convergencia de este mÃ©todo es de 1.62 (sÃºper lineal), pero no llega a ser cuadrÃ¡tica. El mÃ©todo de la secante se basa en la fÃ³rmula de Newton, pero evita el cÃ¡lculo de la derivada usando la siguiente aproximaciÃ³n: ğ‘“â€™(ğ‘¥ğ‘–) â‰ˆ ğ‘“(ğ‘¥ğ‘–âˆ’1) âˆ’ğ‘“(ğ‘¥ğ‘–) ğ‘¥ğ‘–âˆ’1 â€“ ğ‘¥ğ‘– . Sustituyendo en la fÃ³rmula de newton, obtenemos: ğ‘¥ğ‘–+1 = ğ‘¥ğ‘– â€“ ğ‘“(ğ‘¥ğ‘–) ğ‘“â€™(ğ‘¥ğ‘–) â‰ˆ ğ‘¥ğ‘– â€“ ğ‘“(ğ‘¥ğ‘–) ğ‘“(ğ‘¥ğ‘–âˆ’1)âˆ’ğ‘“(ğ‘¥ğ‘–) ğ‘¥ğ‘–âˆ’1âˆ’ğ‘¥ğ‘– , ğ‘¥ğ‘–+1 â‰ˆ ğ‘¥ğ‘– âˆ’ ğ‘“(ğ‘¥ğ‘–)(ğ‘¥ğ‘–+1âˆ’ğ‘¥ğ‘–) ğ‘“(ğ‘¥ğ‘–+1)âˆ’ğ‘“(ğ‘¥ğ‘–) 25 Figura 2.7 Ejemplo de la aplicaciÃ³n del MÃ©todo de la Secante 2.8.4 MÃ©todo de PosiciÃ³n Falsa o Regula Falsi El mÃ©todo de la posiciÃ³n falsa usa lo mejor de la bisecciÃ³n y del mÃ©todo de la secante. Este mÃ©todo, como en el mÃ©todo de la bisecciÃ³n, parte de dos puntos que rodean a la raÃ­z ğ‘“(ğ‘¥) = 0, es decir, dos puntos ğ‘¥0 y ğ‘¥1 tales que ğ‘“(ğ‘¥0)ğ‘“(ğ‘¥1) < 0. La siguiente aproximaciÃ³n, ğ‘¥2, se calcula como la intersecciÃ³n con el eje ğ‘¥ de la recta que une ambos puntos (empleando la ecuaciÃ³n ğ‘¥2 = ğ‘¥0 âˆ’ ğ‘¥1âˆ’ğ‘¥0 ğ‘“(ğ‘¥1)âˆ’ğ‘“(ğ‘¥0) ğ‘“(ğ‘¥0) del mÃ©todo de la secante). La asignaciÃ³n del nuevo intervalo de bÃºsqueda se realiza como en el mÃ©todo de la bisecciÃ³n: entre ambos intervalos [ğ‘¥0, ğ‘¥2] y [ğ‘¥2, ğ‘¥1], se toma aquel que cumpla ğ‘“(ğ‘¥ğ‘šğ‘–ğ‘›)ğ‘“(ğ‘¥ğ‘šğ‘ğ‘¥) < 0. En la Fig. 2.8 se representa geomÃ©tricamente el mÃ©todo. Similar a BisecciÃ³n, la convergencia de este mÃ©todo es lineal, e igualmente la convergencia estÃ¡ garantizada. Figura 2.8 Ejemplo de la aplicaciÃ³n del mÃ©todo de Regula Falsi 2.8.5 MÃ©todo de MuÌˆller Consiste en utilizar tres aproximaciones iniciales ğ‘¥0, ğ‘¥1 ğ‘¦ ğ‘¥2 a la raÃ­z de ğ‘“(ğ‘¥) = 0 , y determinar la siguiente aproximaciÃ³n al considerar la ecuaciÃ³n de la parÃ¡bola que pasa por los puntos (ğ‘¥0, ğ‘“(ğ‘¥0)); (ğ‘¥1, ğ‘“(ğ‘¥1)) ğ‘¦ (ğ‘¥2, ğ‘“(ğ‘¥2)). La intersecciÃ³n con el eje ğ‘¥ en el punto (ğ‘¥3, ğ‘‚) define la aproximaciÃ³n a la raÃ­z de ğ‘“. Para hallar ğ‘¥3, primero se encuentra los coeficientes de la ecuacioÌn de la parabÌola. 26 ğ‘¦(ğ‘¥) = ğ‘0(ğ‘¥ âˆ’ ğ‘¥2) 2 + ğ‘1(ğ‘¥ âˆ’ ğ‘¥2) 2 + ğ‘2, donde: ğ‘0 = (ğ‘¥1âˆ’ ğ‘¥2)[ğ‘“(ğ‘¥0) âˆ’ ğ‘“(ğ‘¥2)] âˆ’ (ğ‘¥0 âˆ’ ğ‘¥2)[ğ‘“(ğ‘¥1) âˆ’ ğ‘“(ğ‘¥2)] (ğ‘¥0 âˆ’ ğ‘¥2)(ğ‘¥1 âˆ’ ğ‘¥2)(ğ‘¥0 âˆ’ ğ‘¥1) , ğ‘1 = ğ‘“(ğ‘¥2)â€“ ğ‘“(ğ‘¥1) ğ‘¥2 â€“ ğ‘¥1 + (ğ‘¥2 â€“ ğ‘¥1)ğ‘0, ğ‘2 = ğ‘“(ğ‘¥2). La aproximaciÃ³n a la raÃ­z x3 del polinomio es obtenida de la siguiente forma, ğ‘¥3 = ğ‘¥2 âˆ’ 2 ğ‘2 ğ‘1 + ğ‘ ğ‘–ğ‘”ğ‘›(ğ‘1)âˆšğ‘1 2 âˆ’ 4 ğ‘0 ğ‘2 . Para continuar con el proceso, se eligen de las tres aproximaciones iniciales las dos mÃ¡s prÃ³ximas a ğ‘¥3, y luego se renombran como ğ‘¥0, ğ‘¥1 ğ‘¦ ğ‘¥2, y se repite el proceso tanto como desee (Ver Fig. 2.9). La velocidad de convergencia del mÃ©todo es 1.84. Figura 2.9: Ejemplo de la aplicaciÃ³n del mÃ©todo de MuÌˆller (DaFeda, 2010) 2.9 Evaluadores sintÃ¡cticos Antes de explicar los evaluadores sintÃ¡cticos tenemos que tener en cuenta que existe un proceso de traducciÃ³n por parte de la computadora en donde, en nuestro caso, la entrada de datos 27 es la ecuaciÃ³n (Aho, Lam, & Sethi, 2007) (Northwood, 2009). La traducciÃ³n estÃ¡ compuesta por dos etapas: ï‚· AnÃ¡lisis lÃ©xico: el flujo de caracteres de entrada se convierte en un flujo de lexemas. Un lexema es una unidad gramatical mÃ­nima reconocida por el lenguaje. Por ejemplo, un lexema puede ser un identificador, un operador, una palabra reservada del lenguaje o una constante (nÃºmeros, strings, etc.) ï‚· AnÃ¡lisis sintÃ¡ctico: a este flujo de lexemas se le aplican reglas de una gramÃ¡tica que define al lenguaje que queremos reconocer. Estas reglas generalmente forman una gramÃ¡tica libre de contexto, aunque depende del lenguaje que se quiere reconocer. 2.9.1 AnÃ¡lisis LÃ©xico El anÃ¡lisis lÃ©xico es la extracciÃ³n de palabras individuales o lexemas a partir de una secuencia de sÃ­mbolos. Otros roles del analizador lÃ©xico incluyen remover los espacios en blanco y los comentarios. El proceso de transformaciÃ³n a lexemas, consiste en la construcciÃ³n de un autÃ³mata finito que agrupa los sÃ­mbolos de la entrada. Este autÃ³mata se construye una sola vez y es usado cada vez que se desea hacer el anÃ¡lisis lÃ©xico de un nuevo conjunto de sÃ­mbolos. Generalmente un lexema puede ser un identificador, operadores del lenguaje, palabras reservadas y constantes (numÃ©ricas y cadenas de caracteres). AsÃ­, una entrada como la siguiente: â€œif (velocidad > 50)â€ se traduce a â€œ<if> <parÃ©ntesis abierto> <identificador> <operador relacional> <constante> <parÃ©ntesis cerrado>â€, obteniendo a partir de un flujo de sÃ­mbolos un flujo de lexemas. El autÃ³mata se construye de forma tal que se reconozca siempre el lexema mÃ¡s largo posible. AsÃ­, por ejemplo, el lexema â€œabcâ€ podrÃ­a identificarse como tres identificadores seguidos (a, b y c) o como un solo identificador. Esta regla garantiza que el identificador mÃ¡s largo es reconocido. Para construir un analizador lÃ©xico pueden definirse los lexemas del lenguaje con una gramÃ¡tica lineal (usando una expresiÃ³n regular), y aplicando el algoritmo de construcciÃ³n de Thompson es posible crear el autÃ³mata asociado. Pueden tambiÃ©n usarse programas como flex los cuales permiten definir los lexemas del lenguaje y generan cÃ³digo C para manejar el autÃ³mata y reconocer los distintos lexemas. El autÃ³mata se representa de forma muy compacta usando una tabla de transiciÃ³n de estados. En el caso de las ecuaciones es necesario definir las expresiones regulares que definen a cada lexema del lenguaje: nombres de funciones, operadores y constantes, y luego generar un analizador sintÃ¡ctico usando algÃºn generador de analizadores lÃ©xicos. 2.9.2 AnÃ¡lisis SintÃ¡ctico Una vez que le flujo de sÃ­mbolos es convertido es un flujo de lexemas, este debe ser procesado por el analizador sintÃ¡ctico. Debe existir una gramÃ¡tica libre de contexto que represente 28 al lenguaje que se desea reconocer. Esa gramÃ¡tica especifica mediante reglas, cuÃ¡les son las construcciones vÃ¡lidas del lenguaje, esto es, de quÃ© forma es posible combinar los lexemas para reconocer frases del lenguaje. El resultado del anÃ¡lisis sintÃ¡ctico es un Ã¡rbol que representa el anÃ¡lisis que se le hizo a la entrada. Este Ã¡rbol almacena en cada nodo un lexema, y su estructura indica que operaciÃ³n de debe aplicar. Por ejemplo, en el caso de ecuaciones, un operador binario tendrÃ¡ siempre dos nodos hijos (las dos expresiones que se desean sumar). Un nombre de una funciÃ³n tendrÃ¡ tantos hijos como parÃ¡metros tenga la funciÃ³n. Identificadores y constantes numÃ©ricas aparecerÃ¡n siempre como hojas de Ã©ste Ã¡rbol (ver Fig 2.10). Figura 2.10: Ejemplo de un Ã¡rbol de anÃ¡lisis Un analizador sintÃ¡ctico necesita un autÃ³mata de pila para poder representarse. Existen varios tipos de algoritmos para construir analizadores sintÃ¡cticos, pero los dos tipos mÃ¡s usados son los analizadores descendientes (top-down) y ascendiente (bottom-up). 2.9.3 Top-Down El anÃ¡lisis top-down puede ser desglosado en dos clases: analizadores en backtracking, en el cual intenta aplicar la regla de la gramÃ¡tica y si falla retrocede un paso; y los analizadores predictivos, que consisten en tratar de predecir el prÃ³ximo sÃ­mbolo no terminal en la entrada usando uno o mÃ¡s tokens de bÃºsqueda hacia adelante. Los analizadores en backtracking pueden manejar gramÃ¡ticas complejas, pero los analizadores predictivos son mÃ¡s rÃ¡pidos. 2.9.3.1 Descendiente Recursivo Los analizadores sintÃ¡cticos predictivos permiten reconocer un conjunto de las gramÃ¡ticas libres de contexto, en las que las reglas gramaticales permiten decidir sin ambigÃ¼edad cual regla aplicar. Sin embargo, existen gramÃ¡ticas libres de contexto en donde esto no es posible, y es necesario utilizar un analizador sintÃ¡ctico mÃ¡s poderoso. Los analizadores recursivos descendientes son predictivos, pueden identificar cuÃ¡l regla aplicar examinando uno o mÃ¡s lexemas (K). De ahÃ­, este grupo de analizadores sintÃ¡cticos son llamados LL(K), en donde K es el nÃºmero de lexemas que deben examinar para saber que regla aplicar. Los mÃ¡s sencillos son los LL(1) que al examinar el siguiente lexema pueden reconocer cuÃ¡l regla de la gramÃ¡tica aplicar. Su implementaciÃ³n es bastante sencilla, ya que generalmente cada no terminal de 29 la gramÃ¡tica se corresponde con una funciÃ³n que toma decisiones dependiendo del siguiente lexema leÃ­do. Cuando la gramÃ¡tica no permite utilizar este tipo de analizadores sintÃ¡cticos es necesario utilizar analizadores bottom up. 2.9.3.2 AnÃ¡lisis tipo LL(1) El LL(1) es un analizador tipo top-down que usa una pila como memoria. En el inicio, el sÃ­mbolo inicial es puesto dentro de la pila, y prÃ³ximo a esto tiene 2 acciones disponibles: Generar, que consiste en remplazar un sÃ­mbolo no terminal A en el tope de la pila por una cadena de caracteres Î± usando la regla de la gramÃ¡tica A â†’ Î±; y la otra acciÃ³n Match, la cual verifica que el token en el tope de la pila y el prÃ³ximo token de entrada coincide (y, en el caso de acierto, desapila ambos). La acciÃ³n es seleccionada usando la tabla de anÃ¡lisis. 2.9.4 Botton-Up El anÃ¡lisis de forma top-down trabaja trazando las derivaciones por la izquierda, mientras que el anÃ¡lisis de forma bottom-up trabaja haciendo una derivaciÃ³n por la derecha de forma inversa. La forma de frase derecha, son las derivaciones de la extremidad derecha que se le pueden hacer a una cadena. Y un anÃ¡lisis de una cadena de caracteres consume tokens de izquierda a derecha hasta la derivaciÃ³n extrema derecha inversa. Una forma de manejarlo es usando una cadena de caracteres definida por una expansiÃ³n de un sÃ­mbolo no terminal en la forma de frase derecha. Este mÃ©todo de anÃ¡lisis trabaja comenzando con una pila vacÃ­a y teniendo dos operaciones: shift (salto), el cual coloca el prÃ³ximo token de entrada dentro de la pila; y el otro mÃ©todo reduce (reducciÃ³n), remplazando el lado derecho de la regla de una gramÃ¡tica con su lado izquierdo. La pila de anÃ¡lisis se mantiene con tokens que son desplazados en el hasta que se tiene un manejador en el tope de la pila, con lo cual vamos a reducirlo mediante la inversiÃ³n de expansiÃ³n. 2.9.4.1 AnÃ¡lisis tipo LR(0) Un objeto tipo LR(0) es una forma de monitorear el progreso hacia un manejador. Este es representado por unas reglas de producciÃ³n en conjunto con un punto. El lado derecho de la gramÃ¡tica tiene una parte detrÃ¡s del punto y la otra parte en frente del punto. Esto nos dice que el anÃ¡lisis ha igualado una sub cadena de caracteres derivada por el componente que estÃ¡ a la izquierda del punto y que ahora nos sirve para hacer match a lo que estÃ© en el flujo de entrada, definido por un componente a la derecha del punto. El anÃ¡lisis LR(0) pertenece a una clase general de analizadores, llamada analizadores tipo LR. Estos pueden tomar ventaja de los sÃ­mbolos que estÃ¡n mÃ¡s adelantes, muy parecido a los analizadores de top-down donde el lado izquierdo se expande en el lado derecho basado en un sÃ­mbolo que estÃ¡ mÃ¡s adelante (si es que hay). Los principales mÃ©todos tipo LR son: ï‚· SLR(1) â€“ el lado izquierdo solo se remplaza con el de la derecha si el sÃ­mbolo de mÃ¡s adelante estÃ¡ en el conjunto Follow del lado izquierdo. ï‚· LR(1) â€“ este utiliza un subconjunto del Follow set del lado izquierdo que tiene en cuenta el contexto (el Ã¡rbol a lo anterior e izquierda del lado izquierdo). 30 ï‚· LALR(1) â€“ esto reduce el nÃºmero de estados comparado con LR(1) y (si tenemos suerte), usa un subconjunto apropiado del Follow set del lado izquierdo. 2.9.5 RecuperaciÃ³n de Errores Similar al anÃ¡lisis LL(1), existen tres posibles acciones para el manejo de errores: ï‚· Desapilar un estado de la pila ï‚· Desapilar un token de la entrada hasta tener uno aceptable (el cual reanudarÃ¡ el anÃ¡lisis) ï‚· Apilar un Nuevo estado dentro de la pila 2.10 Trabajos anteriores El trabajo de Luiz H. de Figueiredo en el 1992 nos presenta mÃ©todos discretos de base fÃ­sica para generar aproximaciones poligonales de funciones implÃ­citas e incluso superficies implÃ­citas. Estos procedimientos no solo generan una aproximaciÃ³n de la superficie, sino tambiÃ©n producen una estructura adecuada para simulaciÃ³n numÃ©rica y la modelaciÃ³n de base fÃ­sica y sistemas de animaciÃ³n. Al mismo tiempo describen cÃ³mo son estas ecuaciones y cuÃ¡l es el uso que se quiere dar en la modelaciÃ³n fÃ­sica, y establecen que cada superficie se compone de estructura poligonal. TambiÃ©n ofrecen dos sistemas para construir las aproximaciones poligonales, que incluyen el sistema discreto fÃ­sico, el cual se abstrae de la materia ensamblada por partÃ­culas unidas a otras fuerzas. Varias de estas fuerzas fÃ­sicas pueden ser naturalmente modeladas usando sistemas discretos. Los sistemas de partÃ­culas consisten en tener un conjunto finito de partÃ­culas el cual tiene una posiciÃ³n inicial en el espacio y el comportamiento a travÃ©s del tiempo es gobernado por una serie de reglas algorÃ­tmicas. El segundo sistema son los de Spring-Mass, â€œresortes-masaâ€, que es un tipo de partÃ­cula fÃ­sica en el sistema estructurado por la uniÃ³n de pares de partÃ­culas con resortes. Los resortes imponen una fuerza interna que depende de la distancia entre esas partÃ­culas y es gobernada por el comportamiento global del sistema. Luego de tener estos dos sistemas, los autores establecen un sistema dinÃ¡mico de poligonizaciÃ³n usando un sistema de partÃ­culas. En el primer caso hacen un muestreo de cada una de las partÃ­culas (ver Fig 2.11) y las estructuran creando una malla (ver Fig 2.12) y de esta forma modelan la superficie deseada (ver Fig 2.13), bajo la simulaciÃ³n de fÃ­sica de partÃ­culas. Para el caso de la poligonizaciÃ³n por medio del sistema de Spring-Mass, se hace una subordinaciÃ³n triangular, donde los elementos de estos sistemas estÃ¡n asociados con la triangulaciÃ³n Freudental del espacio. 31 Figura 2.11: Ejemplo de (a)(izquierda) trayectorias y (b)(derecha) posicionamiento de las partÃ­culas en 2D Figura 12: Ejemplo de Puntos de Control de la esfera(a) y creaciÃ³n del mallado de esfera (b) Figura 13: Ejemplo de mayado 3D antes (a) y despuÃ©s (b) de la deformaciÃ³n usando Spring Mass, como se puede apreciar el mallado cambia ajustÃ¡ndose a la figura. Estos sistemas estÃ¡n sujetos a fuerzas de deformaciÃ³n derivadas de la gradiente de la ecuaciÃ³n principal. Su posiciÃ³n de equilibrio da la triangulaciÃ³n de una regiÃ³n del espacio que contiene la ecuaciÃ³n M y tiene las siguientes propiedades: a.- M es una transversal a la triangulaciÃ³n b.- Las divisiones son cuasi-regulares 32 c.- Por cada enÃ©simo simplex ğœ que intersecta M existe un punto perteneciente a M cercano al baricentro de ğœ cuya tangente del espacio M en el punto p es cercano al soporte del hiperplano de una de las caras de ğœ. (ver Fig. 2.14) Figura 2.14: TriangulaciÃ³n Subordinada, proceso previo antes de crear el mallado La generaciÃ³n del mallado por Spring-Mass consiste en la triangulaciÃ³n Freudental, que es creada a partir de la ecuaciÃ³n principal, usando como lÃ­mite un volumen que delimita la ecuaciÃ³n implÃ­cita. Cada simplex (triÃ¡ngulo) que intersecta la ecuaciÃ³n implÃ­cita es identificada. En conjunto, estos forman una intersecciÃ³n compleja simplicial. El sistema Spring-Mass es creado por la asociaciÃ³n de los nodos de masa y los resortes a los vÃ©rtices y aristas de cada intersecciÃ³n compleja. Luego de esta generaciÃ³n del mallado se usa un enfoque fÃ­sico para la obtenciÃ³n de la triangulaciÃ³n final que serÃ¡ usada para realizar la poligonalizaciÃ³n de M (Luiz, Gomez, Demitri, & Luiz, 1992). AÃ±os mÃ¡s tarde, en 1994, el trabajo realizado por Jules Bloomenthal, de la universidad de Calgary, de An Implicit Surface Polygonizer, nos describe cÃ³mo a partir de una ecuaciÃ³n implÃ­cita, puede construirse un mallado de triÃ¡ngulos para ser visualizado en pantalla. Esto permite que una superficie sea desplegada de la forma convencional a partir de polÃ­gonos. La poligonalizaciÃ³n se realiza mediante el uso de la tÃ©cnica de tetra cubes, combinado con Regula Falsi para mejorar la precisiÃ³n en la bÃºsqueda de ceros de funciones (ver fig. 2.15a y 2.15b). A partir de la ecuaciÃ³n implÃ­cita se genera un volumen discreto (malla regular), evaluando la funciÃ³n implÃ­cita en un conjunto de puntos (x,y,z) igualmente espaciados. Luego, cada conjunto de 8 muestras conectadas (cubo), es dividido en tetraedros, en donde se evalÃºa si la superficie corta al tetraedro. Para ello se tiene una tabla de 16 casos, de las 16 formas en que la superficie puede cortar al tetraedro, ya que la funciÃ³n puede ser negativa o positiva en cada vÃ©rtice del tetraedro. Originalmente el corte de la superficie (los ceros de la funciÃ³n) con el tetraedro se aproxima por interpolaciÃ³n lineal, pero dado que se conoce la ecuaciÃ³n implÃ­cita, se utiliza Regula Falsi para obtener una mejor aproximaciÃ³n a la raÃ­z en cada arista intersecada (Bloomenthal, 1994). 33 Fig 15a proceso de poligonizaciÃ³n Fig 15b configuraciÃ³n de entradas del poligonizador usando tetra cubes. En el aÃ±o 2001, el trabajo de Klaus Engel et al. exploran el uso rendering de volÃºmenes para visualizar resonancias magnÃ©ticas, tomografÃ­as computarizadas, e incluso volÃºmenes sintÃ©ticos provenientes de ecuaciones implÃ­citas. La tÃ©cnica de rendering utilizada se basa en el uso de texturas 2D y texturas 3D, con planos alineados. Utilizan la tÃ©cnica de pre-integraciÃ³n para mejorar la calidad visual del rendering. En el aÃ±o 2001, el trabajo de R. Carmona et al., reconstruye superficies, pero combinando Marching Cubes con los mÃ©todos de ceros de funciones como Regula Falsi y BisecciÃ³n. El sistema RenderAll permite adicionalmente realizar el rendering del volumen a la par que la superficie reconstruida (ver Fig.2.16). El rendering del volumen se realiza con texturas 3D y planos alineados al viewport. Para combinar el rendering de volÃºmenes con el rendering de una superficie reconstruida, se despliega un plano alineado al viewport, seguido de los polÃ­gonos de la superficie que se encuentran entre dicho plano y el prÃ³ximo plano. La idea se repite hasta haber desplegado todos los planos alineados al viewport. En cada par de planos consecutivos, se despliegan los triÃ¡ngulos de la superficie que estÃ©n total o parcialmente entre estos en coordenadas de ojo. Se usa una actualizaciÃ³n de una lista de triÃ¡ngulos activos, que ordena los triÃ¡ngulos desde el mÃ¡s lejano al mÃ¡s cercano. Esto permite determinar los triÃ¡ngulos activos para el prÃ³ximo par de planos con pocos chequeos. Los fragmentos remanentes de triÃ¡ngulos (Ã¡reas de triÃ¡ngulos parcialmente fuera del par de cortes) 34 deben ser cortados para no ser desplegados dos veces. En este caso se utilizan los planos de corte soportados por el hardware grÃ¡fico (Carmona., 2001). Figura 2.16: RenderAll. La primera imagen de izquierda a derecha muestra el despliegue de la superficie con phong shading. La segunda y tercera imagen de izquierda a derecha muestran el rendering del volumen sin iluminaciÃ³n y con iluminaciÃ³n Phong. La Ãºltima imagen muestra la mezcla de superficie y volumen intercalando polÃ­gonos del volumen con triÃ¡ngulos de la superficie. A partir de los aÃ±os siguientes al 2004 se exploran diferentes tÃ©cnicas para mejorar el rendimiento de estas aplicaciones, evitando el uso excesivo de recursos. Tal es el caso del trabajo de Bruno Rodrigues de Araujo y Joaquim Armando Pires Jorge, titulado Curvature Dependent Polygonization of Implicit Surface, en el cual nos explican cÃ³mo el enfoque de Triangle Marching reduce esta carga de recursos en la mÃ¡quina. En sus trabajos previos estudian mÃ©todos basados en particiÃ³n de celdas en los cuales se destacan el Marching Cubes y la variante Marching Tetrahedra. Esto algoritmos ofrece buen rendimiento, pero en ocasiones carece de la calidad adecuada. El segundo mÃ©todo es el Surface Tracking, donde destaca el Marching Triangle y el algoritmo de Hartmann. BÃ¡sicamente estos mÃ©todos generan mallados del mismo tamaÃ±o con triÃ¡ngulos cuasi equilÃ¡teros. Pero estos no se adaptan a las propiedades de la superficie, tomando muchos triÃ¡ngulos pequeÃ±os aproximados a las superficies con pocas variaciones en la curvatura. El Ãºltimo de los mÃ©todos son los Mallados Adaptativos. Estos comienzan desde un mallado de alta calidad, aplica operaciones divisiÃ³n de aristas y colapso de aristas para simplificar y optimizar el mallado en tiempo real. Al final, se obtienen mÃ¡s triÃ¡ngulos en donde la curvatura es mÃ¡s pronunciada, requiriendo asÃ­ mÃ¡s detalle (AraÂ´ujo & Jorge, 2004). En otro trabajo, realizado por Andrew Corrigan y H. Quynh Dinh, en el 2005, titulado Computing and Rendering Implicit Surfaces Composed of Radial Basis Functions on the GPU, se exploran mÃ©todos de funciones con base radial. Esto autores muestran cÃ³mo se comporta este mÃ©todo en la GPU, ya que todo es almacenado en una textura 3D y no en una forma convencional (Corrigan & Dinh, 2005). Un ejemplo de colaboradores de mozilla developer network, el trabajo de Malgoratza Jatczyk, en el 2013, muestra tecnologÃ­as Web (usando el API de OpenGL ES) para crear una aplicaciÃ³n demo para triangular y visualizar ecuaciones implÃ­citas en WebGL (Jatczyk, 2013). 35 Como podemos apreciar los mÃ©todos para visualizar ecuaciones implÃ­citas se basan primordialmente en la reconstrucciÃ³n de una iso-superficie, y mejorar el rendimiento y/o calidad del rendering. Pocos trabajos han utilizado el rendering directo de volÃºmenes, el cual permite la visualizaciÃ³n del volumen sin requerir de la reconstrucciÃ³n de una superficie intermedia. Una de las ventajas que vemos de utilizar el rendering de volÃºmenes es que se pueden visualizar distintas â€œcapasâ€ de una ecuaciÃ³n implÃ­cita, sin generar un impacto significativo en el tiempo de respuesta de la aplicaciÃ³n, y sin generar mayores retos en el almacenamiento, como sÃ­ sucede en el caso de querer reconstruir todas estas capas (que podrÃ­an ser decenas), una por una, utilizando mallas de triÃ¡ngulos. 36 CapÃ­tulo 3 â€“ DiseÃ±o e ImplementaciÃ³n En este capÃ­tulo se explica cÃ³mo se realizÃ³ el diseÃ±o y la implementaciÃ³n del sistema, se hace una breve explicaciÃ³n con diagramas de flujo e imÃ¡genes de la interfaz. Se muestran como los mÃ³dulos estÃ¡n compuestos y como engranan para generar el rendering. Se hace una descripciÃ³n con los algoritmos de todo el proceso. 3.1 Funcionamiento general del sistema El prototipo de sistema se puede describir globalmente en la Fig. 3.1. Al iniciar el sistema, se va a mostrar la ecuaciÃ³n de una esfera la cual es la que se tiene por defecto. Se comienza con la inicializaciÃ³n del sistema con valores por defecto como el tamaÃ±o de la caja en los mÃ¡ximos y mÃ­nimos (-2,-2,-2) y (2,2,2), el nÃºmero de voxels en cada dimensiÃ³n (64), el tamaÃ±o de la funciÃ³n de transferencia (1024), 2 valores de superficie (una de color amarillo y otra roja, de grosor 30 pÃ­xeles), y como funciÃ³n a visualizar, una esfera unitaria. Durante la interacciÃ³n del usuario con la interfaz, el mismo puede cambiar cualquiera de los parÃ¡metros, en cualquier momento, para definir la entrada de datos. Al recibir los datos de entrada, estos valores pasan por el generador de la textura del volumen (ver diagrama de flujo Fig. 3.2). El generador de la textura simplemente evalÃºa la funciÃ³n dentro de la caja, con el espaciado de voxels fijado en cada dimensiÃ³n. Luego se discretiza la funciÃ³n de transferencia en una paleta de colores o textura unidimensional de tipo RGBA. Inicialmente la funciÃ³n de transferencia contiene dos valores de superficie, aplicados a las posiciones 0 y 222 del rango [0,1023]. Luego se prepara el contexto de render colocando los parÃ¡metros adecuados para ejecutar el algoritmo de dos pasadas del ray casting, haciendo asÃ­ el despliegue de la funciÃ³n implÃ­cita. Figura 3.1: interfaz + contenedor Canvas WebGL en una grilla de 9x3 de bootstrap 37 3.2 ImplementaciÃ³n En la implementaciÃ³n de los mÃ³dulos de despliegue se hizo con las especificaciones del grupo Khronos group de WebGL 1.0 y la librerÃ­a de THREEjs que facilita la creaciÃ³n de la escena y del despliegue total del volumen. A continuaciÃ³n, se introducen las diferentes librerÃ­as y plugins usador para la implementaciÃ³n: Contenido externo utilizado Para crear el Visualizador de VolÃºmenes en WebGL, se utilizaron diversos recursos externos entre ellos librerÃ­as y otros como plugins de javasript, los cuales son nombrados a continuaciÃ³n: ï‚· THREEjs: librerÃ­a que crea primitivas de WebGL con mayor facilidad que la versiÃ³n estÃ¡ndar de WebGL. ï‚· OrbitControls: librerÃ­a externa a THREEjs permite colocar controles sobre la cÃ¡mara. ï‚· Bootstrap: agrega estilos al diseÃ±o de la pÃ¡gina. ï‚· JQuery: librerÃ­a con el fin de mejora desarrollo y uso de las variables de javascript. ï‚· JQuery-UI: es extensiÃ³n de jQuery que permite agregar widgets u objetos de interfaz grÃ¡fica. ï‚· Math: librerÃ­a que agrega mÃ¡s funciones a la librerÃ­a bÃ¡sica de matemÃ¡ticas de javascript, permite compilar, analizar expresiones matemÃ¡ticas. ï‚· Detector: plugin que informa si ocurriÃ³ algÃºn error en la instancia de WebGL sobre un objeto canvas. ï‚· Stats: plugin que visualiza informaciÃ³n sobre cuadros por segundo/tiempo de muestreo/ memoria usada En la figura 3.2 se muestra el diagrama de flujo de cada uno de los mÃ³dulos y como se comunican entre sÃ­ hasta general la imagen de salida por pantalla Fig 3.2 diagrama de la aplicaciÃ³n general 38 A continuaciÃ³n, se explicarÃ¡ cÃ³mo fue implementado cada mÃ³dulo, usando como guÃ­a el diagrama de flujo Se tomaron en consideraciÃ³n limitantes de la especificaciÃ³n de WebGL 1.0 en el que nos indica que no se puede hacer uso de texturas 3D y texturas que no sean en potencia de 2, pero existen mÃ©todos para hacer creer al programa que estÃ¡ leyendo una textura como si fuera 3D. En los programas de shaders se usa un algoritmo que hace procesamiento de un Atlas de textura 2D como si fuera una textura 3D. 3.2.1 Generador de la textura del volumen Haciendo seguimiento al diagrama de flujo por medio de la entrada de datos, si el usuario introdujo o hizo cambios en el tamaÃ±o de la caja contenedora del volumen (MÃ­nimos y MÃ¡ximos), o en el NÃºmero de Voxels, o en la ecuaciÃ³n implÃ­cita, este mÃ³dulo crea el volumen. Para la creaciÃ³n del atlas de textura se usÃ³ una librerÃ­a de JavaScript mathjs para poder evaluar con exactitud si la expresiÃ³n escrita, es vÃ¡lida. Esta librerÃ­a ofrece una extensa cantidad de funciones que pueden ser usadas en conjunto con expresiones matemÃ¡ticas en las que podemos listar: +,-,*,/,agrupaciÃ³n (),pre multiplicaciÃ³n <numero>(). Una vez evaluada es almacenada en una variable para su uso en la construcciÃ³n del volumen. En el proceso de creaciÃ³n del atlas se usa un arreglo que representa la matriz del volumen 4 componentes (RGBA). En cada componente se almacena un valor de la gradiente de la funciÃ³n (RGB) y en el 4to componente (A) se guarda el valor de la funciÃ³n f(x,y,z). El vector gradiente se almacena con el fin de aplicar un modelo de iluminaciÃ³n local durante el rendering. El volumen en enviado al GPU como un atlas de textura 2D, representando lÃ³gicamente una textura 3D. 3.2.2 Actualizador de funciÃ³n de transferencia Dentro de esta etapa, se construye la funciÃ³n de transferencia la cual especifica en quÃ© posiciÃ³n sobre el volumen se encuentra cada iso-valor, de quÃ© color es, y quÃ© opacidad tiene. La funciÃ³n se almacena en una textura 1D de tipo RGBA que por defecto abarca el rango de [0,1023]. Al finalizar esta etapa, la textura se carga en una unidad de textura, y recibe como nombre "transferencia" en el programa de shader. 3.2.3 actualizador de las texturas Cada vez que el usuario introduce datos de la funciÃ³n de transferencia (inserciÃ³n, eliminaciÃ³n, modificaciÃ³n de un iso-valor y sus atributos), se actualiza la textura correspondiente a la funciÃ³n de transferencia. Si el usuario realiza alguna modificaciÃ³n sobre los parÃ¡metros de la funciÃ³n implÃ­cita (caja, nÃºmero de voxels o la funciÃ³n en sÃ­), se crea un nuevo volumen RGBA, e igualmente se envÃ­a a la unidad de textura correspondiente. 3.2.4 contexto webGl En este mÃ³dulo se crea el ambiente para utilizar openGL en el browser, en el cual valores como tamaÃ±o de la caja, geometrÃ­a de despliegue de volumen y los algoritmos involucrados en el ray casting conviven con el entorno HTML/CSS/JavaScript de la aplicaciÃ³n. 39 3.2.5 MÃ³dulo de Render El mÃ³dulo de rendering realiza un ray casting sobre el volumen. Para poder describir en mÃ¡s detalle cÃ³mo se procesa la textura de volumen, se colocan algunos de los algoritmos clave para el desarrollo de la aplicaciÃ³n, donde se describen aspectos importantes y procesos intermediarios antes de hacer el despliegue del volumen e integraciÃ³n con la interfaz. Toda interacciÃ³n con el resultado del despliegue resulta en una llamada a actualizar el prÃ³ximo cuadro a dibujar como lo son la rotaciÃ³n, la translaciÃ³n, el zoom in, el zoom out, y llamadas de la interfaz tambiÃ©n pasa por este proceso. Figura 3.4: FunciÃ³n de muestreos del Atlas 2D La funciÃ³n presentada en la Fig 3.4 ayuda al raycasting a obtener las muestras de la textura 2D pero haciendo interpolaciÃ³n tri lineal. Una textura 2D de tamaÃ±o (n,m,k) es almacenada en una textura 2D de tamaÃ±o (n*k,m). Sabiendo esto, se puede realizar una fÃ³rmula de acceso para determinar sobre quÃ© par de sub texturas 2D se debe hacer el muestreo para simular la interpolaciÃ³n tri lineal. Una vez determinado el par de sub texturas 2D (zSlices0, zSlices1), se calcula un desplazamiento dentro de cada sub textura 2D para hallar la posiciÃ³n del voxel a muestrear en cada corte. Este desplazamiento es xOffset. Luego de muestrear en ambas sub texturas, se realiza una interpolaciÃ³n lineal entre ambas muestras mediante la funciÃ³n mix. El algoritmo de la Fig. 3.5 corresponde a la funciÃ³n principal del ray casting. En este se toman una muestra de la textura, luego se extraen valores que conforman las normales de la muestra y es realizado el proceso de iluminaciÃ³n sobre cada una de las muestras, despuÃ©s se extrae el color y se realiza el proceso de pos clasificaciÃ³n, y retorna el acumulado al color fragmento. Continuando con el algoritmo de la Fig. 3.5 calcula la distancia que hay entre las dos caras de entrada y salida del rayo (front and back), se fija un tamaÃ±o del paso (step) que es dividido entre la diagonal de la caja, se crea un delta que nos indica el tamaÃ±o o longitud del rayo y un acumulador de color, se procede a hacer muestreos progresivos segÃºn la longitud del rayo y la cantidad de absorciÃ³n acumulada. La absorciÃ³n se calcula por la ecuaciÃ³n de rendering en donde se evalÃºa sobre el coeficiente de absorciÃ³n exp(-0.7 * ColorSample.a), luego, se hace la obtenciÃ³n de una muestra del 40 volumen dentro del contenedor, se hace la acumulaciÃ³n de color sobre la funciÃ³n de transferencia y este resultado se muestra por fragmento de shader. Figura 3.5: Algoritmo de RayCasting + BlingPhong 41 Figura 3.6: DefiniciÃ³n de las ShaderMaterial El algoritmo mostrado en la Fig. 3.6 muestra como es configurados los dos ShaderMaterial que conforman los dos pasos del algoritmo de ray casting. El primero se utiliza para desplegar las caras traseras del volumen, representando la salida de los rayos del volumen. Mientras que la segunda pasada, despliega las caras frontales del volumen, y conociendo las caras traseras del mismo, permite calcular la longitud de cada rayo por fragmento. Luego de pasar por estos mÃ³dulos se genera una imagen como resultado que es desplegado en el dispositivo de salida (monitor) del computador. Para el desarrollo de la interfaz (Fig 3.7, 3.8, 3.9), se hace uso de tecnologÃ­as estÃ¡ndares de HTML5/CSS/Javascript y de librerÃ­as que facilitan la creaciÃ³n, como JQuery para rÃ¡pida actualizaciÃ³n de variables, BootStrap para el diseÃ±o y estilo de la pÃ¡gina, plugins, como Bootstrap colorpicker y Jquery UI para agregar mÃ¡s caracterÃ­sticas que complementan el diseÃ±o de la interfaz. Mediante la interfaz grÃ¡fica, el usuario puede variar los parÃ¡metros de la funciÃ³n implÃ­cita, y los parÃ¡metros de visualizaciÃ³n. Dentro de estos controles existen dos etapas, antes de dibujar y despuÃ©s de dibujar. 42 Figura 3.7: Interfaz grÃ¡fica para definir la funciÃ³n a visualizar Figura 3.8: Definiendo los valores de superficie a considerar en la funciÃ³n de transferencia 43 Figura 3.9: DiÃ¡logo modal para agregar mÃ¡s Valores de superficie Como podemos observar en la Fig. 3.7, se encuentran los elementos de la interfaz grÃ¡fica en los que tenemos: ï‚· MÃ¡ximos y MÃ­nimos: son los componentes que definen el tamaÃ±o mÃ¡ximo y mÃ­nimo de la caja en los ejes x,y,z. ï‚· EcuaciÃ³n ImplÃ­cita (f(x,y,z)): en este campo se escribe la funciÃ³n. ï‚· NÃºmero de Voxels: es la cantidad de muestras por eje del volumen. En este caso se observa 64, lo que corresponde a 64 en el eje X, 64 en Y, y 64 en Z. ï‚· Funciones de Transferencia: dos opciones Normal (pos-clasificaciÃ³n) y Simpson (pre- integraciÃ³n). Este define de quÃ© forma se construye la funciÃ³n de transferencia y se especifica la resoluciÃ³n que posee la misma (256, 512 o 1024). La funciÃ³n de transferencia pre- integrada queda como trabajo a futuro. ï‚· Dibujar: toma todos los parÃ¡metros principales (MÃ¡ximos y MÃ­nimos, la funciÃ³n y nÃºmero de voxels) y hace un despliegue de dicha funciÃ³n. ï‚· Centrar: coloca la figura en el centro de la pantalla. En las figuras 3.8 y 3.9 contienen la interfaz necesaria para definir la funciÃ³n de transferencia, es decir, el conjunto de valores de superficie a visualizar, junto a sus colores y opacidades. ï‚· Rango de Valores de superficie: estos componentes estÃ¡n a lo largo del rango de la funciÃ³n. Su funciÃ³n es indicar en quÃ© parte del volumen estÃ¡n ubicados (posiciÃ³n), su ancho o grosor (Ancho), color y AbsorciÃ³n. ï‚· Iso-Valor Seleccionado: esta ventana muestra el valor seleccionado actualmente con sus caracterÃ­sticas, pueden ser cambiadas en cualquier momento. 44 ï‚· Por Ãºltimo, se encuentra el BotÃ³n de agregar mÃ¡s Valores de superficie (Fig. 3.8). Este despliega un diÃ¡logo modal en el cual se muestran todos los valores de superficie actuales, sus caracterÃ­sticas si se desean agregar mÃ¡s o eliminar (Fig 3.9). 45 CapÃ­tulo 4 Pruebas y Resultados Previo a definir las pruebas realizadas junto con sus resultados, es importante establecer los parÃ¡metros bajo los cuales se llevaron a cabo estas pruebas, asÃ­ como los recursos que se han utilizado para poder completar el Visualizador de VolÃºmenes en WebGL. 4.1 Ambiente de trabajo Las pruebas se realizaron bajo un ambiente con las siguientes especificaciones: ï‚· Sistema operativo: Windows 10 - 64bits ï‚· Procesador: Intel Core i7 740qm â€“ 1.73Ghz ï‚· Memoria RAM: 8GB DDR3 ï‚· Tarjeta GrÃ¡fica: Geforce 310m, con 512MB DDR3. Como herramienta principal para el desarrollo de este trabajo se utilizÃ³ Sublime Text editor (Skinner, 2015), debido a la flexibilidad que posee en cuanto al desarrollo web y a la familiaridad que se tiene con la utilizaciÃ³n de esta herramienta. 4.2 Funciones de prueba Se seleccionaron las siguientes 3 funciones: ï‚· Esfera: f(x,y,z) = x^2+y^2+z^2-1 ï‚· Toroide: f(x,y,z) = ((X*X)+(Y*Y)+(Z*Z))^2-4*Z*((X*X)+(Y*Y)+(Z*Z))-8*X*X-8*(Y*Y) + 12*(Z*Z) - 16*Z +16 ï‚· Jacky: f(x,y,z) = 1/(X*X/9+4*Y*Y+4*Z*Z)^4+1/(Y*Y/9+4*X*X+4*Z*Z)^4+1/(Z*Z/9+4*Y*Y+4*X*X)^4+1/((4*X /3-4)^2+16.0*Y*Y/9.0+16.0*Z*Z/9.0)^4.0+1.0/((4*X/3+4)^2+16.0*Y*Y/9+16*Z*Z/9)^4 + 1/((4*Y/3-4)^2+16*X*X/9+16*Z*Z/9)^4+1/((4*Y/3+4)^2+16*X*X/9+16*Z*Z/9)^4)^-0.25-1 Cada una de estas funciones fue desplegada con 3 valores de superficie de 2% de grosor en la funciÃ³n de transferencia. Como referencia el valor de superficie cuyo color es el azul tiene un valor de opacidad de 1.0, mientras que para los valores de superficie restantes se colocÃ³ 0.01 como valor de opacidad (ver Fig. 4.1). 4.3 Pruebas de calidad y rendimiento El tamaÃ±o del volumen medido en voxels y el tamaÃ±o de la funciÃ³n de transferencia discretizada influyen tanto en la calidad del despliegue como en el tiempo de respuesta. En esta prueba se pretende realizar una comparaciÃ³n tanto de calidad como de tiempo de respuesta conforme se varÃ­an estos parÃ¡metros. 46 Esfera Toroide Jacky Figura 4.1: ecuaciones utilizadas. En los 3 casos se utilizÃ³ una funciÃ³n de transferencia discretizada en 1024 entradas, y se construyÃ³ un volumen de 643 voxels. FunciÃ³n de Transferencia 256 N. de voxels 16x16x16 FunciÃ³n de Transferencia 256 N. de voxels 32x32x32 FunciÃ³n de Transferencia 256 N. de voxels 64x64x64 FunciÃ³n de Transferencia 512 N. de voxels 16x16x16 FunciÃ³n de Transferencia 512 N. de voxels 32x32x32 FunciÃ³n de Transferencia 512 N. de voxels 64x64x64 FunciÃ³n de Transferencia 1024 N. de voxels 16x16x16 FunciÃ³n de Transferencia 1024 N. de voxels 32x32x32 FunciÃ³n de Transferencia 1024 N. de voxels 64x64x64 Tabla 4.2 Funciones de Transferencia versus Numero de Voxels 47 En la Fig. 4.2 podemos apreciar que a medida que el nÃºmero de voxels aumenta, se pueden apreciar mejor los detalles, y se reducen los artefactos visuales. El mismo fenÃ³meno sucede al aumentar la resoluciÃ³n de la funciÃ³n de transferencia, al discretizarse con mÃ¡s muestras. Los mejores resultados visuales se obtienen con 643 voxels y 1024 entradas en la funciÃ³n de transferencia. En la tabla 4.1 se hizo la prueba de tiempo de respuesta con diferentes tamaÃ±os de funciÃ³n de trasferencia y diferentes nÃºmeros de voxels, fijando el paso entre muestras en 1 voxel usando la ecuaciÃ³n del jacky. Muestreos por voxel indica la cantidad de muestreos que se hace por cada ciclo del raycasting. Este es definido por 1/diagonal de la caja que es previamente calculado. Si tomamos como medida principal la tasa de cuadros por segundo (fps o frames per second), tenemos que el rendimiento disminuye a medida que aumenta la resoluciÃ³n del volumen. FunciÃ³n de Transferencia NÃºmero de Voxels Muestreos por voxel Rata de cuadros por segundo 256 64x64x64 1 35fps 256 32x32x32 1 45fps 256 16x16x16 1 60fps 512 64x64x64 1 35fps 512 32x32x32 1 45fps 512 16x16x16 1 60fps 1024 64x64x64 1 35fps 1024 32x32x32 1 45fps 1024 16x16x16 1 60fps Tabla 4.1: FunciÃ³n de Transferencia variable vs Numero de voxels variable Como prueba siguiente, queremos estudiar cÃ³mo afecta el paso de rendering o muestreos por voxel en la calidad del rendering. Si este nÃºmero aumenta (ver Fig. 4.3) podrÃ­amos perder detalles en el rendering, pues es posible no capturar todos los valores de superficie adecuadamente, o contar con pocas muestras del volumen para ciertos valores de superficie. El el paso es mÃ¡s corto, se recolecta mejores detalles, y la calidad del rendering es superior. Figura 4.3: diferentes longitudes del paso (1/diagonal, 0.5/diagonal, 0.25/diagonal) con funciÃ³n de transferencia de (1024), y la ecuaciÃ³n del toroide Como podemos observar en este ejemplo del toroide, si fijamos el paso a 1 podemos tener menor cantidad de muestras lo que traduce a perdida de detalles (ver Fig. 4.3 izquierda) y una rata 48 de cuadros mÃ¡s estable (ver tabla 4.2). Si fijamos el paso a 0.25 tenemos mayor detalle, pero hay una caÃ­da de rata de cuadros por segundo, que, en el peor caso, se tienen apenas 6fps. NÃºmero de Voxels Cantidad del Paso/ 1 Voxel FunciÃ³n de Transferencia Rata de cuadros por segundo 64x64x64 1 256 35fps 64x64x64 1 512 35fps 64x64x64 1 1024 35fps 64x64x64 0.5 256 29fps 64x64x64 0.5 512 29fps 64x64x64 0.5 1024 29fps 64x64x64 0.25 256 6fps 64x64x64 0.25 512 6fps 64x64x64 0.25 1024 6fps 32x32x32 1 256 45fps 32x32x32 1 512 45fps 32x32x32 1 1024 45fps 32x32x32 0.5 256 39fps 32x32x32 0.5 512 39fps 32x32x32 0.5 1024 39fps 32x32x32 0.25 256 18fps 32x32x32 0.25 512 18fps 32x32x32 0.25 1024 18fps 16x16x16 1 256 60fps 16x16x16 1 512 60fps 16x16x16 1 1024 60fps 16x16x16 0.5 256 55fps 16x16x16 0.5 512 55fps 16x16x16 0.5 1024 55fps 16x16x16 0.25 256 39fps 16x16x16 0.25 512 39fps 16x16x16 0.25 1024 39fps Tabla 4.2: Funciones de Transferencia versus NÃºmero de Voxels del volumen y longitud del Paso de rendering 49 CapÃ­tulo 5 â€“ Conclusiones y Trabajos Futuros En este trabajo se desarrollÃ³ un prototipo de sistema web usando el estÃ¡ndar de WebGL para despliegue de ecuaciones implÃ­citas mediante la tÃ©cnica de visualizaciÃ³n directa de volÃºmenes. El sistema permite definir y desplegar mÃºltiples valores de superficie (f(x,y,z) = c) de la funciÃ³n implÃ­cita al mismo tiempo, asignando color, opacidad, y grosor por cada superficie, con una interfaz sencilla. Debido a que es una aplicaciÃ³n web con el estÃ¡ndar WebGL, la calidad u velocidad del despliegue dependerÃ¡ del tipo de navegador web y del hardware utilizado, lo cual puede producir insatisfacciÃ³n en algunos sistemas de computaciÃ³n de bajo rendimiento grÃ¡fico. Por limitaciones del framework actual de WebGL no se permite el uso de texturas 3D, por lo que en este trabajo se simularon las texturas 3D mediante un atlas de textura 2D, realizando el muestreo del atlas mediante una funciÃ³n propia. En cuanto a los resultados obtenidos, se puede apreciar a que mayor resoluciÃ³n del volumen y de la funciÃ³n de transferencia, la calidad del despliegue es superior, pero el tiempo requerido para generar un cuadro de imagen aumenta. Igualmente, si reducimos la longitud del paso en el algoritmo de ray casting, la calidad del despliegue aumenta, pero la rata de cuadros por segundo puede bajar drÃ¡sticamente. Como trabajos a futuro se propone rediseÃ±ar la aplicaciÃ³n con el estÃ¡ndar de WebGL 2.0, el cual aplica soporte completo de OpenGL ES 3.0 que permite el uso de texturas que no potencias de 2 y texturas 3D, y utiliza de GLSL 3.0. Igualmente se propone terminar el mÃ³dulo de visualizaciÃ³n con pre-integraciÃ³n, para obtener un despliegue de gran calidad, sin necesidad de requerir reducir el paso de ray casting, ni de asignarle un grosor al valor de superficie en la funciÃ³n de transferencia. Cabe destacar que a esta aplicaciÃ³n es posible agregarle un mÃ³dulo de visualizaciÃ³n de datos mÃ©dicos, puesto que solo habrÃ­a que cambiar la fuente del volumen. En vez de generar un volumen a partir de una ecuaciÃ³n implÃ­cita, este podrÃ­a cargarse de un archivo. bastarÃ­a agregar como mÃ­nimo un manejador de archivos tipo RAW, especificar el tamaÃ±o y el nÃºmero de bits por muestra del volumen. Finalmente, se desea que estÃ¡ aplicaciÃ³n estÃ© disponible en la pÃ¡gina Web del Centro de ComputaciÃ³n GrÃ¡fica, bajo el dominio ccg.ciens.ucv.ve. 50 Referencias Aho, A. V., Lam, M. S., & Sethi, R. (2007). Compilers principles, techniques and tools. Boston: Pearson Addyson Wesley. AraÂ´ujo, B. R., & Jorge, J. A. (2004). Curvature Dependent Polygonization of Implicit Surfaces. Computer Graphics and Image Processing, 2004. Proceedings. 17th Brazilian Symposium on Formal Methods (pÃ¡gs. 266 - 273). Maceio - Alagoas: IEEE. B, P., & D, B. (2007). Visualization in Medicine. Burlington: Morgan Kaufmann Publisher. Bhalerao, A., Pfister, H., Halle, M., & Kikinis, R. (2000). Fast Re-Rendering of Volume and Surface Graphics by Depth, Color and Opacity Buffering. Journal of Medical Image Analysis, Vol 4, Issue 3, 235-251. Bloomenthal, J. A. (1994). Graphics Gems IV. San Diego, CA, USA: Academic Press Professional, Inc. Burden, R. y. (2009). AnÃ¡lisis NumÃ©rico 7ma Edicion. Youngstone: CENGAGE Learning. Carmona., R. (2001). TriangulaciÃ³n de Ecuaciones ImplÃ­citas Combinando Cubos Marchantes con Algoritmos de Ceros de Funciones. LI ConvenciÃ³n Anual AsoVAC. Corrigan, A., & Dinh, H. Q. (2005). Computing and Rendering Implicit Surfaces Composed of Radial Basis Functions on the GPU. International Workshop on Volume Graphics, 187-195. DaFeda. (2010). Mathematics; ranting & learning. Obtenido de DaFeda's Blog: http://dafeda.wordpress.com/2010/09/09/mullers-method-deriving-of-and-code/ Fleming, W. (1965). Functions of several Variables. New York: Addison-Wesley. Foley, J. D., van Dam, A., Feiner, S. K., & Hughes, J. F. (1996). Computer Graphics: Principles and Practice (2nd ed. in C). Addison-Wesley Publishing Company. Foundation, T. j. (2015). JQuery. Obtenido de jQuery: The Write Less, Do More, JavaScript Library.: https://jquery.com/ Guzman, J. d. (2010). Boost.Spirit. Obtenido de boost-spirit: http://boost-spirit.com/home/ Hansen, C. D., & Johnson, C. R. (2004). Visualization Handbook. Salt Lake City: Elsevier. Jatczyk, M. (15 de Junio de 2013). Desing concept - Graphics art desing. Obtenido de http://designconcept.webdev20.pl/: http://www.webdev20.pl/skins/default/js/demos/implicit-equation-3d- grapher/index.html Jong, J. d. (2015). mathjs. Obtenido de math.js | an extensive math library for JavaScript and Node.js: http://mathjs.org/ K., E., & T., K. M. (2001). High Quality Pre-Integrated Volume Rendering Using Hardware-Accelerated Pixel Shading. ACM Press, 9-16. 51 Kajiya, J. T. (1986). THE RENDERING EQUATION. SIGGRAPH '86 Proceedings of the 13th annual conference on Computer graphics and interactive techniques (pÃ¡gs. 143-150 ). California Institute of Technology: SIGGRAPH. Kaplan, W. (1949). Advanced Calculus. Michigan: Addison-Wesley 5th edition. Klaus Engel, M. K. (2001). High-Quality Pre-Integrated Volume Rendering Using Hardware- Accelerated Pixel Shading. Visualization and Interactive Systems Group, University of Stuttgart, Germany. Levoy, M. (1988). Display of Surfaces from Volume Data. IEEE Computer Graphics and Applications, 29-37. LLC, T. S. (2001). C4 Game Engine . Obtenido de Terathon: http://www.terathon.com Lorensen, W. E., & Cline, H. E. (6 de 11 de 1987). Marching cubes: A high resolution 3d surface construction algorithm. ACM Computer Graphics 21 (4), pÃ¡gs. 163â€“169. Lorensen, W. E., & Cline, H. E. (1987). MARCHING CUBES: A HIGH RESOLUTION 3D SURFACE CONSTRUCTION ALGORITHM. Computer Graphics, 163-169. M., W., J., N., & Davis, T. (1997). OpenGL, Programming Guide. Addison-Wesley Developers Press, 2da. EdiciÃ³n. Mark Otto, j. (18 de August de 2011). Bootstrap. Obtenido de Bootstrap The world's most popular mobile-fisrt and responsive front-end framework: http://getbootstrap.com/ mrdoob. (23 de April de 2010). threejs dat org. Obtenido de three.js A Javascript 3D library: http://threejs.org/ Northwood, C. (2009). Lexical and Syntax Analysis of Programming Languages. Obtenido de http://www.pling.org.uk/: http://www.pling.org.uk/cs/lsa.html Pauls. (2011). Lamar University. Obtenido de Paul's Online Math Notes: http://tutorial.math.lamar.edu/Classes/CalcI/NewtonsMethod.aspx Philippe Lacroute, M. L. (July de 1994). Fast Volume Rendering Using a Shear-Warp Factorization of the Viewing Transformation. Computer Graphics Procedings, Anual Conference Series, 1994 (pÃ¡gs. 451-458). Stanford: SIGGRAPH. qiao, m. a. (2011). threejs OrbitControl. Obtenido de three.js A Javascript 3D library: http://threejs.org/ R. Carmona, O. R. (1997). Aspectos de ImplementaciÃ³n para el algoritmo de Cubos Marchantes. 47o ConvenciÃ³n Anual AsoVAC. R. Carmona, O. R. (1999). Cubos Marchantes: una implementaciÃ³n eficiente. In Proc. XXV Conferencia Latinoamericana de InformÃ¡tica. Paraguay, La AsunciÃ³n, Agosto. Schulz, S. (2003). Four Lectures on Differential-Algebraic Equations. Institut fÃ¼r Mathematik. 52 Skinner, J. (2015). Sublime Text: The text editor you'ill fall in love. Obtenido de Sublime Text: http://www.sublimetext.com/ Steffen, S. (2003). Four Lectures on Differential-Algebraic Equations. Berlin: Humboldt UniversitÂ¨at zu Berlin. STEVENS, R. T. (1993). Quick Reference to Computer Graphics Terms. Academic Press, Inc. Westover, L. A. (1991). SPLATTING: A Parallel, Feed-Forward Volume Rendering Algorithm. North Carolina: The University of North Carolina. Willian E. Lorensen, H. E. (27-31 de Julio de 1987). Marching Cubes: A high resolution 3D surface construction algorithm. Computer Graphics, Volumen 21, NÃºmero 4, pÃ¡gs. 163-1699. WolframMathWorks. (2014). WolframMathWorks. Obtenido de WolframMathWorks: http://mathworld.wolfram.com/SecantMethod.html Ziegler, J. (2004). The LEDA Tutorial. Obtenido de The LEDA Tutorial: http://www.leda- tutorial.org/en/discussion/ch06s03.html