UNIVERSIDAD CENTRAL DE VENEZUELA FACULTAD DE CIENCIAS ESCUELA DE COMPUTACI√ìN IMPLEMENTACI√ìN DE UNA APLICACI√ìN PARA DETECCI√ìN AUTOMATIZADA DE CAMBIOS EN P√ÅGINAS WEB PARA EL PROTOTIPO DEL ARCHIVO WEB DE VENEZUELA Trabajo Especial de Grado presentado ante la ilustre Universidad Central de Venezuela por Br. Luis Aguiar Para optar al t√≠tulo de Licenciado en Computaci√≥n Tutora: Profa. Mercy Ospina Caracas, 2019 Acta Agradecimientos y Dedicatorias Agradecimientos y Dedicatorias El presente trabajo se lo dedico a mis padres por haberme dado la vida y haber estado siempre ah√≠ para m√≠, siendo pilares incondicionales de apoyo y amor a lo largo de mi existencia; a mi abuela Naylet, por ser mi segunda madre y ayudar a criarme y hacerme un hombre de bien de la mejor manera que pudo, apoyarme cuando lo necesitaba y ayudarme constantemente a pesar de las diferencias de opiniones que a veces pudimos tener; a mi abuelo Orlando, por mostrarme con el ejemplo como ser una persona de bien, por crear en m√≠ un amor incondicional a la Universidad desde mi tierna infancia, demostr√°ndome que no es s√≥lo una casa de estudios, sino un hogar que siempre me ha recibido y que siempre estar√° en mi coraz√≥n. A mi abuela Iraida y mi t√≠a Yoleida, por siempre recibirme en sus hogares y crear en m√≠ el amor a aprender y aprender y seguir aprendiendo, ya que esto lograr√≠a expandir mis horizontes, a mi t√≠o Orlando Antonio, por siempre ayudarme sin pedir algo a cambio con todo lo que estuviese dentro de su poder. A la Universidad Central de Venezuela, por ser un segundo hogar para m√≠ a lo largo de toda mi carrera, a mis profesores, por guiarme durante cada uno de estos a√±os con sus lecciones tanto dentro como fuera del aula de clases, al Centro de Investigaci√≥n de Sistemas de Informaci√≥n, donde conoc√≠ personas maravillosas como la profesora Mercy y la profesora Tina, que me mantuvieron motivado a terminar mis estudios de pregrado a pesar de las dificultades por las cuales est√° pasando el pa√≠s. A mi novia Roselyn, por nunca faltar cuando lo necesitaba, por darme su apoyo y su amor de manera incondicional y convertir mi vida tanto dentro como fuera de la universidad en una experiencia a√∫n m√°s maravillosa y darme motivos para ser mejor cada d√≠a. A todos mis compa√±eros estudiantes, tanto de mi carrera como de otras, ya que ellos lograron que mi vida estudiantil fuese algo m√°s que s√≥lo participar en las clases, con quienes pas√© per√≠odos dif√≠ciles y no tan dif√≠ciles, pero todos igualmente divertidos, durante √©stos √∫ltimos a√±os. A todas las personas que nombro aqu√≠ (y algunas que probablemente se me est√©n olvidando, les ruego me disculpen por eso), de verdad quiero, desde el fondo de mi coraz√≥n, decirles ‚ÄúGracias por todo, no lo hubiese logrado de no haberlos conocido‚Äù. Resumen Resumen El patrimonio digital, definido por la Unesco en su Carta sobre la prevenci√≥n del patrimonio digital (UNESCO, 2009), est√° conformado por todos aquellos contenidos culturales cuyo origen es digital, que incluye tanto los sitios web como el contenido audiovisual, los documentos y libros digitales. En relaci√≥n con los contenidos publicados en la web, debido a la naturaleza vol√°til que tiene este medio, tiende a desaparecer con el tiempo, por lo que si no existe un proceso o sistema que se encargue de almacenarlo, se pierde, es decir, el patrimonio digital no es auto-preservable. Debido a esta ocurrencia, se han venido desarrollando diversos sistemas como los Archivos Web cuyo prop√≥sito es, precisamente, guardar el patrimonio digital para su preservaci√≥n, para generaciones futuras. El presente Trabajo Especial de Grado, que forma parte del Prototipo de Archivo Web de Venezuela (desarrollado en la Escuela de Computaci√≥n de la Facultad de Ciencias de la Universidad Central de Venezuela) tiene como objetivo desarrollar una aplicaci√≥n Web para la detecci√≥n de cambios en los sitios web, con el fin de automatizar este proceso con miras a dar soporte a los M√≥dulos de Adquisici√≥n y Almacenamiento de contenidos, y al M√≥dulo de Predicci√≥n de Cambios. La presente aplicaci√≥n analiza el contenido del c√≥digo de dos versiones de un sitio web, uno almacenado y otro en proceso de adquisici√≥n, con el fin de detectar y calcular una ponderaci√≥n de los cambios entre ellas, as√≠ como la ubicaci√≥n espacial de dichas modificaciones, para calcular la importancia de los cambios lo que servir√° de entrada al m√≥dulo de almacenamiento para decidir si se almacena la versi√≥n nueva en el Archivo. La metodolog√≠a usada durante el desarrollo de la aplicaci√≥n fue una variaci√≥n de eXtreme Programming, entre otras razones, debido al tama√±o del equipo, su compatibilidad para el desarrollo de diferentes componentes, cada cual est√° enmarcado dentro de una iteraci√≥n y la gran tolerancia a cambios en los requerimientos que esta filosof√≠a profesa. Los resultados obtenidos fueron satisfactorios, logrando la realizaci√≥n de la detecci√≥n de los cambios que se presentan en el c√≥digo de las p√°ginas web que sean recibidas, adicionalmente la aplicaci√≥n logra determinar la importancia de los cambios de acuerdo con su ubicaci√≥n espacial con respecto al navegador al momento de realizar la renderizaci√≥n del sitio analizado. Palabras clave: Archivo Web, detecci√≥n, cambios, Importancia, preservaci√≥n Web Tabla de contenido ACTA .............................................................. ERROR! BOOKMARK NOT DEFINED. AGRADECIMIENTOS Y DEDICATORIAS ................................................................ C RESUMEN ................................................................................................................. D TABLA DE CONTENIDO ........................................................................................... 5 √çNDICE DE FIGURAS ................................................................................................ 7 √çNDICE DE TABLAS .................................................................................................. 9 INTRODUCCI√ìN ...................................................................................................... 10 CAP√çTULO 1 PLANTEAMIENTO DEL PROBLEMA ............................................... 12 1.1. EL M√ìDULO DE ADQUISICI√ìN ......................................................................................................... 13 1.2. JUSTIFICACI√ìN ............................................................................................................................. 17 1.3. OBJETIVOS .................................................................................................................................. 17 1.3.1. Objetivo General ................................................................................................................ 17 1.3.2. Objetivos Espec√≠ficos ......................................................................................................... 17 1.4. ALCANCE ..................................................................................................................................... 17 CAP√çTULO 2 MARCO TE√ìRICO ............................................................................. 19 2.1. PRESERVACI√ìN WEB .................................................................................................................... 19 2.2. ARCHIVO WEB ............................................................................................................................. 19 2.3. PRINCIPIO DE PARETO .................................................................................................................. 20 2.4. HERRAMIENTAS TECNOL√ìGICAS .................................................................................................... 21 2.4.1. Python ................................................................................................................................ 21 2.4.2. Flask ................................................................................................................................... 22 2.4.3. MVC .................................................................................................................................... 22 2.4.4. MTV .................................................................................................................................... 23 2.4.5. Servicios Web..................................................................................................................... 24 2.4.6. M√≥dulos Python .................................................................................................................. 28 2.4.7. Detecci√≥n de cambios en p√°ginas web .............................................................................. 29 CAP√çTULO 3 MARCO PROCEDIMENTAL .............................................................. 34 3.1. METODOLOG√çAS DE DESARROLLO DE SOFTWARE ........................................................................... 34 3.1.1. Metodolog√≠as Tradicionales ............................................................................................... 34 3.1.2. Metodolog√≠as √Ågiles ........................................................................................................... 36 3.2. ARQUITECTURA DE SOFTWARE BASADA EN COMPONENTES ........................................................... 41 3.2.1. Herramientas que pertenecen al desarrollo de software basado en componentes ........... 41 CAP√çTULO 4 MARCO APLICATIVO ....................................................................... 45 4.1. DEFINICI√ìN DE REQUERIMIENTOS ................................................................................................. 45 4.2. OBJETIVO DE LA APLICACI√ìN ......................................................................................................... 45 4.3. ARQUITECTURA DE LA SOLUCI√ìN PROPUESTA ................................................................................ 45 4.4. METAS DE LA APLICACI√ìN ............................................................................................................. 46 4.5. ADAPTACI√ìN DE LA METODOLOG√çA EXTREME PROGRAMMING (XP) USANDO UNA ARQUITECTURA DE SOFTWARE BASADA EN COMPONENTES ............................................................................................... 47 4.5.1. Primera Iteraci√≥n (Investigaci√≥n): ...................................................................................... 47 4.5.2. Segunda Iteraci√≥n (Cambio cuantitativo): .......................................................................... 51 4.5.3. Tercera Iteraci√≥n (Desarrollo de la Interfaz): ..................................................................... 56 4.5.4. Cuarta Iteraci√≥n (Cambio cualitativo): ................................................................................ 64 4.5.5. Quinta Iteraci√≥n (Pruebas funcionales del sistema): ......................................................... 70 CONCLUSIONES Y RECOMENDACIONES ........................................................... 83 ANEXOS .................................................................................................................. 85 5.1. SCRIPTS DE HERITRIX................................................................................................................... 85 REFERENCIAS BIBLIOGR√ÅFICAS Y ELECTR√ìNICAS ........................................ 88 √çndice de figuras FIGURA 1 ACTIVIDADES PARA LA PRESERVACI√ìN WEB (Ospina, Martinez, Leon, & Kabchi, 2014) ................................................................................................................ 12 FIGURA 2 ARQUITECTURA DEL ARCHIVO WEB (Ospina, Martinez, Leon, & Kabchi, 2014) ............................................................................................................................. 13 FIGURA 3 COMPONENTES DEL M√ìDULO DE ADQUISICI√ìN (Carabali & Casanova, 2014) ............................................................................................................................. 14 Figura 4 Algoritmo de predicci√≥n simple (Carabali & Casanova, 2014) ........................ 15 Figura 5 Clasificaci√≥n de Sitios Web basado en el Algoritmo Simple de Predicci√≥n (Carabali & Casanova, 2014) ........................................................................................ 16 Figura 6 Cambio Importante .......................................................................................... 18 FIGURA 7 PATR√ìN MVC (Patr√≥n Modelo Vista Controlador, n.d.) ................................... 22 FIGURA 8 FLUJO WEB SERVICE (W3C, 2004) .............................................................. 25 FIGURA 9 FASES DEL MSF (Microsoft Corporation, 2006) ................................................ 35 Figura 10 Interfaces de componentes (Sommerville, Ingenier√≠a del Software, 2005) ... 43 Figura 11 ELEMENTOS DEL MODELO DE COMPONENTES (Sommerville, Ingenier√≠a del Software, 2005) ............................................................................................................. 43 Figura 12 TIPOS DE COMPOSICI√ìN DE COMPONENTES (Sommerville, Ingenier√≠a del Software, 2005) ............................................................................................................................. 44 Figura 13 Arquitectura del Prototipo del AWV ............................................................... 46 Figura 14 Arquitectura de la aplicaci√≥n ......................................................................... 46 Figura 15 Instalaci√≥n Python ......................................................................................... 50 Figura 16 Dise√±o Historia de Usuario 1. Iteraci√≥n 2 ...................................................... 52 Figura 17 Importaci√≥n de dependencias ....................................................................... 53 Figura 18 Scraping y almacenamiento del c√≥digo HTML .............................................. 53 Figura 19 Porcentaje de diferenciaci√≥n entre bloques .................................................. 54 Figura 20 Ponderaci√≥n cuantitativa seg√∫n el Principio de Pareto ................................. 55 Figura 21 Dise√±o Historia de Usuario 1. Iteraci√≥n 3 ...................................................... 58 Figura 22 Dise√±o Historia de Usuario 2. Iteraci√≥n 3 ..................................................... 58 Figura 23 Historia de Usuario 1. Iteraci√≥n 1. Instalaci√≥n Flask ..................................... 59 Figura 24 Ejemplo de uso de plantillas en Flask ........................................................... 59 Figura 25 Archivo app.py .............................................................................................. 60 Figura 26 Reconstrucci√≥n y captura del sitio web actualizado ...................................... 61 Figura 27 Creaci√≥n gr√°fico de barras con resultados .................................................... 62 Figura 28 Representaci√≥n de Sitio Web en una Matriz de Posici√≥n .............................. 66 Figura 29 Definici√≥n de Segmentos en el Sitio Web ..................................................... 67 Figura 30 Modificaci√≥n de filas en Matriz de Posici√≥n ................................................... 67 Figura 31 Localizaci√≥n espacial de Bloques con Cambios............................................ 68 Figura 32 Correlaci√≥n de posici√≥n entre Bloques con Cambios y Matriz de Posici√≥n ... 68 Figura 33 Ponderaci√≥n de Importancias Cualitativa y Cuantitativa ............................... 69 FIGURA 34 SCRIPT CREAR_JOB_EN_REMOTO.SH (Carre√±o, 2016) .......................... 85 FIGURA 35 SCRIPT MOVER_ARCHIVO.SH (Carre√±o, 2016) ........................................ 85 FIGURA 36 SCRIPT MOVER_ARCHIVO.SH (Carre√±o, 2016) ........................................ 86 √çndice de Tablas Tabla 1 Comparativo entre enfoques metodol√≥gicos .................................................... 36 Tabla 2 Caracter√≠sticas de los Componentes ................................................................ 42 Tabla 3 Historia de Usuario 1. Iteraci√≥n 1 ..................................................................... 48 Tabla 4 Historia de Usuario 2. Iteraci√≥n 1 ..................................................................... 48 Tabla 5 Caso de Prueba 1. Iteraci√≥n 1 .......................................................................... 50 Tabla 6 Caso de Prueba 2. Iteraci√≥n 1 .......................................................................... 51 Tabla 7 Historia de Usuario 1. Iteraci√≥n 2 ..................................................................... 51 Tabla 8 Caso de Prueba 1. Iteraci√≥n 2 .......................................................................... 55 Tabla 9 Historia de Usuario 1. Iteraci√≥n 3 ..................................................................... 56 Tabla 10 Historia de Usuario 2. Iteraci√≥n 3 ................................................................... 57 Tabla 11 Caso de Prueba 1. Iteraci√≥n 3 ........................................................................ 62 Tabla 12 Caso de Prueba 2. Iteraci√≥n 3 ........................................................................ 63 Tabla 13 Caso de Prueba 3. Iteraci√≥n 3 ........................................................................ 63 Tabla 14 Historia de Usuario 1. Iteraci√≥n 4 ................................................................... 64 Tabla 15 Caso de Prueba 1. Iteraci√≥n 4 ........................................................................ 69 Tabla 16 Historia de Usuario 1. Iteraci√≥n 5 ................................................................... 70 Tabla 17 Caso de Prueba 1. Iteraci√≥n 5 ........................................................................ 72 Tabla 18 Caso de Prueba 2. Iteraci√≥n 5 ........................................................................ 72 Tabla 19 Caso de Prueba 3. Iteraci√≥n 5 ........................................................................ 74 Tabla 20 Caso de Prueba 4. Iteraci√≥n 5 ........................................................................ 75 Tabla 21 Caso de Prueba 5. Iteraci√≥n 5 ........................................................................ 76 Tabla 22 Caso de Prueba 6. Iteraci√≥n 5 ........................................................................ 77 Tabla 23 Caso de Prueba 7. Iteraci√≥n 5 ........................................................................ 78 Tabla 24 Caso de Prueba 8. Iteraci√≥n 5 ........................................................................ 79 Tabla 25 Caso de Prueba 9. Iteraci√≥n 5 ........................................................................ 81 Tabla 26 Caso de Prueba 10. Iteraci√≥n 5 ...................................................................... 82 Introducci√≥n Introducci√≥n El patrimonio cultural es aquello que ha sido considerado como relevante para la historia de una sociedad, comunidad o pueblo y que forma parte de sus tradiciones, costumbres, folclor y educaci√≥n. Es posible realizar una divisi√≥n de este en dos grandes grupos, los cuales se suelen denominar ‚Äúpatrimonio tangible‚Äù y ‚Äúpatrimonio intangible, definido por la Unesco en su Carta sobre la prevenci√≥n del patrimonio digital (UNESCO, 2009), entra dentro de esta √∫ltima categor√≠a, donde est√°n , archivos multimedia, documentos y libros digitales, y entre ellos podemos destacar las p√°ginas web que se ha denominado . La preservaci√≥n del patrimonio cultural es un deber de la humanidad para salvaguardar el conocimiento que all√≠ se refleja y los Archivos Web (Web Archive, WA), son Sistemas de Informaci√≥n usados para resguardar el contenido de sitios web, proceso denominado preservaci√≥n de la web o preservaci√≥n web. La naturaleza de los contenidos web, los cuales cambian constantemente, hace que este proceso, brinde un hist√≥rico de los cambios que se presentan en estos, siendo un insumo importante para aquellos que deseen realizar estudios sociales, antropol√≥gicos o tecnol√≥gicos. En Venezuela se est√° desarrollando un prototipo de Archivo Web, que cumple con las funciones principales de adquisici√≥n, almacenamiento y acceso a los contenidos preservados que caracterizan a este tipo de sistemas. Dicho prototipo es responsabilidad del Centro de Investigaci√≥n de Sistemas de Informaci√≥n de la UCV. Para mantener el hist√≥rico nombrado anteriormente se debe realizar una adquisici√≥n regular de los sitios web que se preservan, para lo cual es importante determinar si los contenidos han cambiado, sin necesidad de intervenci√≥n de un humano. En el presente trabajo se propone una implementaci√≥n de la aplicaci√≥n de Detecci√≥n de Cambios para el mencionado Archivo Web que permita determinar las variaciones entre dos versiones de un sitio de manera eficiente y automatizada, reduciendo el tiempo usado para la revisi√≥n (la cual actualmente se realiza de forma manual) y los recursos de almacenamiento, ya que s√≥lo ser√°n guardadas las versiones que contengan una variaci√≥n que sea relevante de acuerdo a los c√°lculos realizados por la aplicaci√≥n. El presente documento est√° estructurado en cuatro (04) cap√≠tulos de la siguiente manera: En el Cap√≠tulo 1 se expresan los motivos por los cuales se realiz√≥ el presente Trabajo Especial de Grado, as√≠ como los objetivos a lograr que fueron establecidos para el desarrollo de este. En el Cap√≠tulo 2 se mencionan las definiciones te√≥ricas y las herramientas tecnol√≥gicas que fueron utilizadas como base fundamental para el desarrollo completo del presente trabajo. En el Cap√≠tulo 3 son explicadas las metodolog√≠as de desarrollo consideradas para la realizaci√≥n del proyecto y se detalla cu√°l fue escogida y las razones detr√°s de la elecci√≥n. Introducci√≥n En el Cap√≠tulo 4 se exponen las tareas realizadas en conjunto con la aplicaci√≥n de los conceptos explicados anteriormente con el fin de llevar a cabo exitosamente el alcance de los objetivos planteados, de igual forma se describen de manera separada cada una de las fases de desarrollo que fueron definidas por la metodolog√≠a establecida. Cap√≠tulo I. Cap√≠tulo 1 PLANTEAMIENTO DEL PROBLEMA Un archivo web es un sistema de informaci√≥n cuyo prop√≥sito es preservar de manera hist√≥rica contenido web de inter√©s como patrimonio cultural. Para ello, deben llevarse a cabo un conjunto de tareas (Masan√©s, 2006) que hagan factible la preservaci√≥n de la web. Estas tareas son preservadas en la Figura 1 FIGURA 1 ACTIVIDADES PARA LA PRESERVACI√ìN WEB (Ospina, Martinez, Leon, & Kabchi, 2014) ‚Ä¢ La selecci√≥n permite limitar el √°mbito del archivo, pudiendo preservar contenidos locales o de un tipo en particular. Por ejemplo, contenidos de un pa√≠s o educativos. ‚Ä¢ La adquisici√≥n logra que se puedan almacenar los cambios que se generan sobre los contenidos que se preservan a trav√©s del tiempo ‚Ä¢ El almacenamiento requiere estrategias que permitan preservar grandes vol√∫menes de informaci√≥n (del orden de los Terabytes), archivos (millones de archivos) y formatos. ‚Ä¢ El acceso o recuperaci√≥n de los contenidos est√° estrechamente ligado a la forma en que se encuentran almacenados, pero debido a la naturaleza hipertextual y multimedia de la web, se espera que el usuario final pueda acceder a este contenido de manera similar a cuando lo hace en los servidores originales. Actualmente en la Escuela de Computaci√≥n de la Universidad Central de Venezuela UCV se est√° desarrollando, como un proyecto de investigaci√≥n, un prototipo de Archivo Web basado en tecnolog√≠as de software libre, dirigido a preservar sitios Web de Venezuela. La arquitectura general de dicho sistema se puede observar en la Fig. 2, donde se distinguen los tres m√≥dulos que se describen a continuaci√≥n: Cap√≠tulo I. FIGURA 2 ARQUITECTURA DEL ARCHIVO WEB (Ospina, Martinez, Leon, & Kabchi, 2014) ‚Ä¢ El m√≥dulo de adquisici√≥n: encargado de obtener de manera regular una copia de los documentos web que confirman los sitios web seleccionados. Cada adquisici√≥n realizada en una fecha dada se considera una versi√≥n. El contenido es obtenido a trav√©s del rastreador Heritrix, el cual genera archivos en formato WARC por cada versi√≥n de un sitio web rastreado en una fecha dada. ‚Ä¢ El m√≥dulo de almacenamiento e indexaci√≥n: encargado de almacenar de manera hist√≥rica las versiones de los sitios web adquiridos y generar un √≠ndice para su b√∫squeda. Recibe los archivos WARC, los asocia a una URL y los indexa para permitir b√∫squedas por palabra clave [URL] o por colecciones [agrupaciones de sitios web de acuerdo con una categor√≠a determinada] que da como resultado un listado de los archivos WARC correspondientes a las versiones del sitio web que corresponde a dicha URL. ‚Ä¢ El m√≥dulo de acceso: permite recuperar las versiones de los sitios web almacenados de manera que se pueden visualizar y navegar de la misma forma en que se realiz√≥ originalmente. Accede a los contenidos almacenados en formato WARC, permitiendo que los usuarios puedan buscar las versiones de un sitio y seleccionar la versi√≥n que desean visitar. 1.1. El m√≥dulo de adquisici√≥n El m√≥dulo de adquisici√≥n es la entrada del sistema. Es el primer paso del proceso de preservaci√≥n. En la Fig. 3 podemos observar las tareas principales este m√≥dulo e identificar sus componentes principales. Cap√≠tulo I. FIGURA 3 COMPONENTES DEL M√ìDULO DE ADQUISICI√ìN (Carabali & Casanova, 2014) Heritrix es un rastreador web, una herramienta que busca preservar objetos digitales con el fin de disponer de ellos en el futuro con fines culturales o fuentes de investigaci√≥n. Existen actualmente tres m√°quinas virtuales con esta aplicaci√≥n. El objetivo es poder realizar rastreos simult√°neos en varios sitios. Los datos generados por los rastreadores son transferidos a una m√°quina central donde se almacena la salida de los rastreos para luego ser transferidos al m√≥dulo de almacenamiento. Para hacer funcionar el rastreador del archivo web sin participaci√≥n del usuario (en segundo plano), es necesario que se ejecuten una serie de shell scripts los cuales se pueden observar en los anexos que llaman al API REST de Heritrix, los cuales pueden observarse . Actualmente, el Archivo Web de la UCV cuenta con un sencillo m√≥dulo de predicci√≥n implementado en Python. Este m√≥dulo, como su nombre lo dice, es el responsable de inferir cu√°ndo un sitio que ha sido rastreado ha sufrido cambios suficientes para considerar su estado actual como uno nuevo, diferente al almacenado previamente. Este m√≥dulo fue desarrollado como parte del Trabajo Especial de Grado de Marco Casanova y Willibert Caraballi. Su funci√≥n es ejecutar los rastreos sucesivos o versiones de los sitios web que se desean preservar, buscando minimizar los rastreos innecesarios, es decir de sitios que no han cambiado. Caraballi y Casanova desarrollaron el m√≥dulo de predicci√≥n basado en la distribuci√≥n Bernoulli para modelar la situaci√≥n de cada p√°gina. Se plante√≥ el siguiente escenario. Sea T el tiempo transcurrido entre dos mediciones consecutivas de un mismo sitio web. Inicialmente T =24h indica el valor m√≠nimo que puede tomar T. Si en estas mediciones consecutivas no se detectan cambios en el sitio, entonces se procede a aumentar gradualmente T, mediante el c√°lculo T = T +24 (hasta un m√°ximo de T =720, Cap√≠tulo I. que representa 30 d√≠as). En caso de detectar alg√∫n cambio en una medici√≥n de dicho sitio, debemos reducir T por medio de la funci√≥n T =Min(T,24). Figura 4 Algoritmo de predicci√≥n simple (Carabali & Casanova, 2014) En base a este planteamiento, Carabali y Casanova desarrollaron un algoritmo de predicci√≥n simple que puede ser observado en la Figura 4. Este algoritmo sirvi√≥ como base para su trabajo. A partir de dicho algoritmo, implementaron otros que les permitieran cubrir la mayor cantidad de casos posibles. Mediante el uso de este algoritmo, crearon una clasificaci√≥n que puede ser observada en la Figura 5para los sitios web que basada en la frecuencia de los cambios de manera tal que se puedan desarrollar pol√≠ticas de rastreo basadas en el estudio realizado minimizando as√≠ la cantidad de rastreos duplicados y de cambios perdidos Cap√≠tulo I. Figura 5 Clasificaci√≥n de Sitios Web basado en el Algoritmo Simple de Predicci√≥n (Carabali & Casanova, 2014) Actualmente, el predictor del archivo web est√° completamente separado del m√≥dulo de adquisici√≥n. A menos que el administrador verifique los registros de la aplicaci√≥n, no hay manera de saber si se tom√≥ la decisi√≥n de generar un nuevo rastreo pues no existe una comunicaci√≥n entre este componente y el m√≥dulo de administraci√≥n. La aplicaci√≥n administrativa es el punto de entrada del sistema. Un visitante debe ser capaz de crear una cuenta de usuario y de acceder a la informaci√≥n est√°tica del sitio como, por ejemplo, el objetivo del sistema, los responsables del proyecto, las preguntas frecuentes, etc. Un usuario del archivo web, debe ser capaz de iniciar sesi√≥n, agregar sitios que desee preservar al archivo, consultar los sitios archivados y gestionar sus datos de usuario. Un administrador del archivo web, debe ser capaz de acceder a toda la informaci√≥n p√∫blica de los usuarios, al contenido del archivo y, principalmente, debe poder configurar par√°metros de b√∫squeda, de rastreo y detecci√≥n de cambios, as√≠ como programar trabajos del sistema. Cap√≠tulo I. 1.2. Justificaci√≥n Actualmente, los componentes principales del m√≥dulo de adquisici√≥n presentan una serie de fallas que limitan su labor y minimizan los resultados que se pueden obtener del m√≥dulo. ‚Ä¢ No existe una interfaz donde el administrador pueda modificar los par√°metros de detecci√≥n. ‚Ä¢ La detecci√≥n de cambios realizada no est√° siendo automatizada. ‚Ä¢ El usuario es el que debe comparar ambos archivos, ya sea mediante revisi√≥n de c√≥digo o visualizaci√≥n de ambos sitios web luego de su respectiva carga en el navegador. 1.3. Objetivos Los objetivos que se desean alcanzar con el presente trabajo se especifican a continuaci√≥n. 1.3.1. Objetivo General Implementar una aplicaci√≥n de detecci√≥n automatizada de cambios en p√°ginas web para el prototipo del Archivo Web de Venezuela. 1.3.2. Objetivos Espec√≠ficos 1. Desarrollar los componentes que conformar√≠an la aplicaci√≥n de detecci√≥n de cambios, usando como base m√©todos matem√°ticos, estad√≠sticos y visuales. 2. Elaborar una interfaz administrativa que permita al usuario acceder y monitorear los cambios, as√≠ como la importancia de cada uno respectivo al resto. 3. Establecer una clasificaci√≥n temporal de acuerdo con la importancia de cada uno de los cambios dependiendo de su densidad de texto y ubicaci√≥n espacial dada la renderizaci√≥n del sitio web. 4. Realizar pruebas funcionales. 1.4. Alcance Esta investigaci√≥n desarrolla una aplicaci√≥n que permite la detecci√≥n de cambios en p√°ginas web y una medida para su importancia. Para ello se usar√°n t√©cnicas de detecci√≥n de cambio basadas en segmentaci√≥n, las cuales ser√°n detalladas en el Cap√≠tulo 2, tales como la densidad de texto de los diferentes elementos, la ubicaci√≥n espacial del cambio en la p√°gina renderizada, y el principio de Pareto. Tambi√©n se ubican las m√©tricas relevantes recolectadas durante la adquisici√≥n y el almacenamiento del contenido, para realizar los c√°lculos cuyos resultados ser√°n mostrados en la aplicaci√≥n de consulta. En este estudio un cambio es considerado importante si la suma de la importancia cuantitativa (determinada por el an√°lisis del texto) y la importancia cualitativa (la cual se calcula tomando como base la posici√≥n del bloque cambiado en el visualizador) da como resultado un valor entre cero punto cinco (0.5) y uno (1), es decir, si cumple con la siguiente condici√≥n: Cap√≠tulo I. Sea ùêº(ùë•) una funci√≥n que retorna un valor donde 0 < ùêº(ùë•) < 1, sea ùêºùëê(ùë¶) una funci√≥n que retorna un valor donde 0 < ùêºùëê(ùë¶) < 1 y cuyo valor sea la importancia cuantitativa (importancia que se obtiene al calcular la diferencia basada en la densidad del texto), sea Œ± la importancia relativa de los cambios cuantitativos con respecto a la importancia total, sea ùêºùëû(ùëß) la funci√≥n que retorna un valor donde 0 < ùêºùëû(ùëß) < 1 y cuyo valor sea la importancia cualitativa (la cual se obtiene al calcular el impacto del cambio dependiendo de su ubicaci√≥n respecto al visualizador), sea Œ≤ la importancia relativa de los cambios cualitativos respecto a la importancia total de los mismos. La Figura 6 determina si un cambio es importante: ùëÜùëñ 0.5 ‚â§ ùêº(ùë•) = ùõºùêºùëê + ùõΩùêºùëû ‚â§ 1, ùëíùëõùë°ùëúùëõùëêùëíùë† ùëíùë† ùë¢ùëõ ùëêùëéùëöùëèùëñùëú ùëñùëöùëùùëúùëüùë°ùëéùëõùë°ùëí Figura 6 Cambio Importante La investigaci√≥n se limita al desarrollo de las siguientes actividades: ‚Ä¢ Estudio de m√©todos de detecci√≥n de cambios previamente desarrollados dependiendo del enfoque de cada uno. ‚Ä¢ Selecci√≥n de los m√©todos que se consideraron m√°s apropiados para el desarrollo de la aplicaci√≥n del Archivo Web de Venezuela. ‚Ä¢ Obtenci√≥n del c√≥digo HTML de diferentes tipos de sitios web para realizar el an√°lisis necesario. ‚Ä¢ Separaci√≥n del c√≥digo HTML de cada uno de los sitios web luego de su renderizaci√≥n completa en bloques de texto. ‚Ä¢ An√°lisis y comparaci√≥n de los bloques de texto de una versi√≥n del sitio web contra la versi√≥n anterior para determinar si hubo cambios. ‚Ä¢ C√°lculo de la importancia cuantitativa asociada a cada sitio web, basado en la densidad de texto de cada uno de los bloques. ‚Ä¢ C√°lculo de la importancia cualitativa asociada a cada sitio web, basado en la posici√≥n relativa de los bloques con respecto a lo que el navegador puede visualizar al momento de la carga, dada la resoluci√≥n y tama√±o de la ventana de este. ‚Ä¢ C√°lculo de la importancia total basado en heur√≠sticas que determinan los valores a usar de las importancias cualitativas y cuantitativas. ‚Ä¢ Aplicaci√≥n administrativa basada en web realizada con el fin de observar los cambios de acuerdo con cada uno de los bloques y la posici√≥n de √©stos, comparando a su vez con la versi√≥n anterior del sitio web. Cap√≠tulo II. Cap√≠tulo 2 MARCO TE√ìRICO En este cap√≠tulo se describen las teor√≠as, conceptos procesos relacionados con la preservaci√≥n web y los conceptos relacionados con la soluci√≥n propuesta. 2.1. Preservaci√≥n Web La preservaci√≥n Web hace referencia al proceso de recolectar informaci√≥n disponible en la World Wide Web y almacenarla en un formato de archivo digital, para as√≠ garantizar que el contenido pueda ser consultado posteriormente (Masan√®s, 2006) De acuerdo con el Internet World Stats (Internet World Stats, 2017) aproximadamente el 49% de la poblaci√≥n mundial tiene acceso a internet. A diario se producen millones de bytes de informaci√≥n que se encuentran en internet disponibles para todo el mundo. Este conocimiento generalmente persiste en el tiempo, debido a la estructura misma de la Web. Cuando se genera contenido, este est√° disponible para ser consultado por cualquier usuario de la red. Muchos investigadores consideran a la Web un medio auto-preservable. El contenido valioso ser√° conservado y el que no, ser√° destruido con el tiempo. Y cuando algo desaparece de internet, lo hace para siempre. Por lo tanto, surge la necesidad de un sistema dedicado exclusivamente a la preservaci√≥n del conocimiento en la Web. Un sistema que refuerce la capacidad de perdurar en el tiempo de dicho contenido y que facilite su acceso a los usuarios de la red. Para llevar a cabo este procedimiento, se han creado archivadores digitales, destinados a almacenar tanta informaci√≥n como sea posible. Existen distintos tipos de sistema de informaci√≥n cuyo objetivo es siempre el mismo. Es de nuestro inter√©s estudiar un tipo espec√≠fico de sistema de informaci√≥n cuyo prop√≥sito es preservar la web. 2.2. Archivo Web Para llevar a cabo el proceso de preservaci√≥n web se han venido desarrollando sistemas de informaci√≥n cuyo objetivo es almacenar de manera hist√≥rica contenidos de la Web, mediante la replicaci√≥n y/o migraci√≥n de su formato original a otra representaci√≥n en ambientes seguros los cuales se les denomina Archivos Web o iniciativas de preservaci√≥n web (Ospina, Martinez, Leon, & Kabchi, 2014) Como ejemplo de esto tenemos el Internet Archive, una organizaci√≥n sin fines de lucro que resguarda libros, pel√≠culas, m√∫sica, software y otros tipos de contenido Web desde hace m√°s de 15 a√±os. Los usuarios pueden acceder sin restricciones a todo el contenido del archivo y pueden crear y preservar colecciones de contenido digital utilizando Archive-It (Archive-it, 2006). Los Archivos Web deben llevar a cabo un conjunto de tareas que hagan factible la preservaci√≥n. A continuaci√≥n, se presenta una breve descripci√≥n de estas tareas (Ospina, Martinez, Leon, & Kabchi, 2014) Cap√≠tulo II. ‚Ä¢ La selecci√≥n permite limitar el √°mbito del Archivo pudiendo preservar contenidos locales, o de un tipo en particular, por ejemplo, contenidos de un pa√≠s, o educativos solamente. ‚Ä¢ La adquisici√≥n logra que se puedan almacenar los cambios que se generan sobre los contenidos que se preservan a trav√©s del tiempo. ‚Ä¢ El almacenamiento requiere estrategias que permitan preservar grandes vol√∫menes de: informaci√≥n (del orden de los Terabytes), millones de archivos y diferentes formatos. Para este fin se han desarrollado formatos de archivos contenedores espec√≠ficos, cuyo objetivo principal es superar la limitaci√≥n de los sistemas de archivos propios de los sistemas operativos donde se alojan los Archivos Web, siendo los m√°s usados el formato ARC, desarrollado por Internet Archive, y el formato WARC un est√°ndar reconocido desarrollado por el IIPC para la preservaci√≥n web como una mejora del formato ARC. ‚Ä¢ El acceso o recuperaci√≥n de los contenidos est√° estrechamente ligado a la forma en que se encuentran almacenados, pero debido a la naturaleza hipertextual y multimedia de la web, se espera que el usuario final pueda acceder a este contenido de manera similar a cuando lo hace en los servidores originales. Estas tareas requieren de una serie de herramientas para ser llevadas a cabo. 2.3.Principio de Pareto El Principio de Pareto, tambi√©n conocido como ‚Äúla regla del 80/20‚Äù o la ‚ÄúLey de los pocos vitales‚Äù es una relaci√≥n que describe causalidad y resultados. Predica que el ochenta por ciento (80%) de la salida de un sistema es resultado del veinte por ciento (20%) de la entrada. La primera observaci√≥n de este fen√≥meno fue realizada en 1906 por el economista italiano Vilfredo Pareto, en honor a quien se nombra este concepto, con relaci√≥n a la tierra y la poblaci√≥n, su an√°lisis mostr√≥ que el 20% de la poblaci√≥n italiana era due√±a el 80% de los terrenos; Pareto confirm√≥ este principio al analizar las vainas de guisantes en su jard√≠n, donde tambi√©n observ√≥ que el 20% de las vainas produc√≠a el 80% de los guisantes totales, luego de esto decidi√≥ realizar encuestas en diferentes pa√≠ses donde, de nuevo, confirm√≥ los resultados recabados en su pa√≠s natal. El principio de Pareto ha sido aplicado a una variedad de campos, desde econom√≠a y negocios (observando que el 80% de las ganancias de una empresa provienen del 20% de los clientes, as√≠ como el 80% de las quejas del negocio tambi√©n son obtenidas del 20% de los clientes), hasta biolog√≠a y criminolog√≠a, no s√≥lo con el fin de explicar las observaciones realizadas en el campo, sino tambi√©n con la idea de ajustar las pr√°cticas en el mismo para mejorar la eficacia. (Akunda, 2011) Un ejemplo claro de la aplicaci√≥n de este principio en √°reas relacionadas con el presente trabajo es en el Desarrollo R√°pido de Aplicaciones (cuyas siglas en ingl√©s son RAD) y se determin√≥ que era una manera eficiente de dividir el tiempo de investigaci√≥n y desarrollo en diferentes modelos r√°pidos. (Rizwan & Iqbal, 2011) Debido a la gran cantidad de estudios en diferentes campos que se han basado en esta regla y que han comprobado su solidez, se decidi√≥ aplicar durante el desarrollo del presente T.E.G., asumiendo que el 80% de la importancia del cambio provendr√° del 20% de las divisiones que se realizar√°n sobre el texto. Luego de subdividir el texto del c√≥digo Cap√≠tulo II. en base a las etiquetas <div> se asignar√° cada secci√≥n a un bloque los cuales ser√°n ordenados en base a la cantidad de caracteres que contengan, mientras m√°s caracteres contenga, ser√° colocado m√°s cerca del inicio, luego de esto, se tomar√° una cantidad de bloques que se aproxime al 20% del total y, √©stos tendr√°n una ponderaci√≥n final del 80% sobre el c√°lculo de las importancias. El resto de los bloques tendr√°n el 20% restante de esta ponderaci√≥n. 2.4.Herramientas tecnol√≥gicas 2.4.1. Python Python es un lenguaje de programaci√≥n din√°mico, orientado a objetos y multiprop√≥sito. Es multiplataforma por lo que puede ser ejecutado en la mayor√≠a de los sistemas operativos modernos. Es distribuido bajo una licencia de c√≥digo abierto gracias a la cual cuenta con una comunidad muy amplia a nivel mundial. Fue creado por Guido van Rossum y lanzado en 1991. Es notable por su sintaxis elegante orientada a facilitar la lectura y escritura de los programas, su gran cantidad de librer√≠as que brindan soporte a muchas tareas comunes de programaci√≥n como conexi√≥n a bases de datos, conexi√≥n a servidores, b√∫squedas avanzadas haciendo uso de expresiones regulares y muchas otras (Python Software Foundation, 2017). Actualmente, la √∫ltima versi√≥n estable es la 3.6.1, lanzada a la comunidad el 17 de diciembre de 2016. Los usuarios de Python se refieren a menudo a la Filosof√≠a Python que es bastante an√°loga a la filosof√≠a de Unix. El c√≥digo que sigue los principios de Python de legibilidad y transparencia se dice que es "pythonico". Contrariamente, el c√≥digo opaco u ofuscado es bautizado como "no pythonico" ("unpythonic" en ingl√©s). Estos principios (Peters, 2004) son: ‚Ä¢ Bello es mejor que feo. ‚Ä¢ Expl√≠cito es mejor que impl√≠cito. ‚Ä¢ Simple es mejor que complejo. ‚Ä¢ Complejo es mejor que complicado. ‚Ä¢ Plano es mejor que anidado. ‚Ä¢ Disperso es mejor que denso. ‚Ä¢ La legibilidad cuenta. ‚Ä¢ Los casos especiales no son tan especiales como para quebrantar las reglas. ‚Ä¢ Los errores nunca deber√≠an dejarse pasar silenciosamente. ‚Ä¢ Frente a la ambig√ºedad, rechaza la tentaci√≥n de adivinar. ‚Ä¢ Deber√≠a haber una y preferiblemente s√≥lo una manera obvia de hacerlo. ‚Ä¢ Ahora es mejor que nunca. ‚Ä¢ Si la implementaci√≥n es dif√≠cil de explicar, no est√° bien ideada. ‚Ä¢ Si la implementaci√≥n es f√°cil de explicar, puede que sea una buena idea. ‚Ä¢ Los espacios de nombres (namespaces) son una gran idea. ¬°Hagamos m√°s de esos! Vemos entonces que Python tiene est√°ndares bien definidos orientados a optimizar el c√≥digo creado por los programadores y que sirven como criterio para solventar ambig√ºedades de dise√±o. Cap√≠tulo II. 2.4.2. Flask Es un framework de peso ligero para desarrollo de aplicaciones web, fue desarrollado bajo la especificaci√≥n WSGI (siglas en ingl√©s de Interfaz de Puerta de Enlace de Servidor Web). Est√° dise√±ado para ser f√°cil de entender y con el que se puede iniciar a trabajar r√°pidamente, con la capacidad de escalar hacia aplicaciones complejas. Inici√≥ como un empaquetador simple usado alrededor de Wrezkreug y Jinja y se ha convertido en uno de los entornos m√°s populares para desarrollo de aplicaciones web en Python. (The Pallets Projects, 2019) Flask ofrece sugerencias, pero no hace cumplir dependencias o estructura al proyecto. El desarrollador es el que se encarga de escoger las herramientas y librer√≠as que quiere usar. Existe una inmensa cantidad de extensiones a√±adidas por la comunidad que hacen que agregar nuevas funcionalidades sea relativamente sencillo. 2.4.3. MVC MVC es un patr√≥n de dise√±o de arquitectura para la implementaci√≥n de la interfaz de usuario. Consiste en tres tipos de objetos. El modelo es el objeto de aplicaci√≥n, la vista es la pantalla de presentaci√≥n y el controlador define la manera en la que la interfaz de usuario reacciona a la entrada por parte del usuario. (Gamma, Helm, Johnson, & Vlissides, 1994). FIGURA 7 PATR√ìN MVC (Patr√≥n Modelo Vista Controlador, n.d.) Antes de la aplicaci√≥n de este patr√≥n las aplicaciones Web caracterizaban por la existencia de componentes encargados de m√∫ltiples responsabilidades, una integraci√≥n entre los objetos que atienden las solicitudes del usuario con los que se encargan de los datos. Es com√∫n a√∫n hoy en d√≠a encontrar sitios web donde la l√≥gica de negocio est√° fuertemente ligada al modelo de datos. Si se realiza un cambio en dicho modelo, toda la Cap√≠tulo II. aplicaci√≥n debe ser reescrita. La ausencia de este patr√≥n (u otros patrones de dise√±o de aplicaciones) usualmente conlleva a ignorar el principio DRY y dificulta la reutilizaci√≥n del c√≥digo. El flujo b√°sico de una aplicaci√≥n que sigue el patr√≥n MVC es el siguiente. Cuando un usuario hace una solicitud a trav√©s de la interfaz la solicitud es enviada al controlador. Este se encarga de procesar la solicitud, ya sea solicitando al modelo datos requeridos por el usuario o procesando cambios en los datos y asegurando la persistencia de dichos cambios en el modelo. Una vez procesada la solicitud, se env√≠a el resultado de esta a la donde son consumidos por el usuario. En programaci√≥n orientada a objetos (OOP) cada modelo de datos es representada por una clase. De igual forma cada controlador. Generalmente las vistas son archivos html planos o con alg√∫n motor de plantillas que permite inyectar contenido manteniendo la sintaxis externa al m√≠nimo. Este patr√≥n fue introducido por primera vez en los a√±os 70 por Trygve Reenskaug. Sin embargo, el primer documento significativo al respecto no fue publicado sino hasta 1988 por Glenn Krasner y Stephen Pope (Cunningham, 2014). En la actualidad es la arquitectura m√°s usada por los m√°s notables lenguajes de programaci√≥n para proyectos Web y cada lenguaje tiene uno o varios frameworks orientados a trabajar con esta arquitectura. La mayor parte de ellos ubican la l√≥gica de negocio del lado del servidor. Sin embargo, a medida que las tecnolog√≠as del lado del cliente han mejorado, se han creado algunos frameworks que permiten a sus componentes ejecutarse del lado del cliente. Las principales ventajas de utilizar MVC son las siguientes (Patr√≥n Modelo Vista Controlador, n.d.): ‚Ä¢ Permite la reutilizaci√≥n del c√≥digo ‚Ä¢ Facilita el desarrollo en paralelo ‚Ä¢ Permite la agrupaci√≥n de tareas relacionadas en un mismo controlador. ‚Ä¢ Hay un bajo nivel de acoplamiento entre los componentes. Es decir, el modelo cada componente es capaz de llevar a cabo sus responsabilidades sin participaci√≥n de las otras. ‚Ä¢ El bajo acoplamiento permite que sea m√°s sencillo el desarrollo modular ‚Ä¢ Facilita el mantenimiento de los componentes ‚Ä¢ Minimiza los riesgos de reemplazar o reescribir clases o m√©todos 2.4.4. MTV Como establecimos previamente, el patr√≥n MVC es un patr√≥n de dise√±o de arquitectura para aplicaciones con interfaz de usuario ampliamente utilizado en aplicaciones Web. El patr√≥n separa las tareas del sistema en tres componentes principales. El modelo representa la data y permite su manipulaci√≥n. La vista representa la capa de presentaci√≥n del modelo. Es lo que los usuarios ven y con lo que interact√∫an. El controlador se encarga de manejar el flujo de informaci√≥n entre el modelo y la vista. Recibe las solicitudes hechas por el usuario a trav√©s de la vista y las env√≠a al modelo. Luego, toma la respuesta producida por el modelo y la env√≠a a la vista (George, 2017). Cap√≠tulo II. Sin embargo, cada framework implementa este patr√≥n de manera diferente. Por lo que a veces no queda claro qu√© responsabilidades corresponden a cada componente. Django es un framework que se rige en t√©rminos generales por el patr√≥n MVC, pero usa su propia l√≥gica de implementaci√≥n. El framework se encarga de ser el intermediario entre las vistas y los modelos por lo que el controlador es absorbido por la aplicaci√≥n. De all√≠ surge el patr√≥n Modelo Plantilla Vista o (Model Template View en ingl√©s). En este patr√≥n de arquitectura los componentes se encargan de las siguientes tareas (Django Software Foundation, 2012): ‚Ä¢ El modelo representa la capa de acceso a los datos. Esta capa contiene todo lo relacionado a los datos. C√≥mo accederlos, c√≥mo validarlos, qu√© comportamiento tienen, c√≥mo se relacionan, etc. ‚Ä¢ La plantilla representa la capa de presentaci√≥n. Define c√≥mo se debe mostrar cualquier cosa en la Web. ‚Ä¢ La vista contiene la l√≥gica de acceso a los modelos y distingue las plantillas apropiadas para cada modelo. 2.4.5. Servicios Web De acuerdo con la W3, un servicio web es un sistema de software dise√±ado para permitir la interacci√≥n punto a punto entre dos m√°quinas conectadas a trav√©s de una red. Generalmente se utiliza para establecer conexiones con equipos remotos y realizar un intercambio de informaci√≥n a trav√©s de la World Wide Web. Utiliza tecnolog√≠as como el protocolo HTTP para establecer comunicaci√≥n entre las m√°quinas y para transferir archivos. El concepto de servicio web es una noci√≥n abstracta que debe ser implementada por un agente concreto, es decir, por el software que se encarga de enviar o recibir los mensajes. De esta manera, se puede escribir el mismo servicio utilizando distintos agentes, como navegadores o lenguajes de programaci√≥n (W3C, 2004). El objetivo de un servicio web es proveer funcionalidades en nombre de un proveedor, es decir a la persona u organizaci√≥n que implementa el servicio. Por ejemplo, compa√±√≠as como Facebook, o Twitter crean servicios web para permitir a aplicaciones externas acceder a los datos alojados en sus servidores. As√≠ como existe un proveedor de servicios, existe un solicitante. Esta persona u organizaci√≥n desea hacer uso de la implementaci√≥n de un servicio web ofrecido por un proveedor. Para describir el funcionamiento de los servicios web, es necesario especificar en lenguaje entendible por la m√°quina c√≥mo se puede llamar el servicio web, qu√© par√°metros espera y qu√© tipo de datos retornar√°. El m√©todo m√°s b√°sico es haciendo uso de un archivo WSDL (Web Service Definition Language). Este es un archivo en formato XML que permite especificar la informaci√≥n requerida por un servicio para establecer la comunicaci√≥n entre m√°quinas y el respectivo intercambio que se producir√° entre ellas. Haciendo uso este se puede intercambiar informaci√≥n a trav√©s de protocolos comunes de la Web como HTTP, FTP, SFTP y SOAP. Cap√≠tulo II. FIGURA 8 FLUJO WEB SERVICE (W3C, 2004) 2.4.5.1. Servicios REST Un servicio web es un sistema de software dise√±ado para dar soportar interacciones m√°quina a m√°quina sobre una red. (W3C, 2004).Contiene una interfaz descrita en un formato que puede ser procesado por una m√°quina. Otros sistemas interact√∫an con estos servicios de acuerdo con lo especificado por la interfaz en forma de intercambio de mensajes. Por lo general, estos mensajes son enviados a trav√©s de HTTP o XML. Cuando se habla de operaciones sin estado (stateless en adelante) quiere decir que cada solicitud hecha por el cliente debe contener toda la informaci√≥n necesaria para entender la solicitud, y no puede tomar ventaja de ning√∫n contexto almacenado en el servidor (Fielding, 2000). De igual manera, el servidor no conserva informaci√≥n sobre la solicitud realizada. Un cliente realiza una petici√≥n y no espera una confirmaci√≥n de recepci√≥n. 2.4.5.2. M√©todos HTTP Las operaciones que se pueden realizar con un servicio Web vienen definidas por los m√©todos HTTP. Estas son palabras reservadas enviadas en cada solicitud hecha por un cliente. De acuerdo con la W3C, el organismo internacional encargado de los est√°ndares para la WWW es importante que tomar en cuenta que el software representa la interacci√≥n de los usuarios en internet y es necesario que un usuario sea consciente del significado de sus acciones en la web (W3C, 1999). Es decir, un usuario debe ser capaz de reconocer qu√© tipo de acci√≥n est√° realizando y la respuesta del software debe Cap√≠tulo II. ser realizar exactamente la acci√≥n requerida. De acuerdo con este principio existen dos tipos de m√©todos. Los m√©todos seguros (Safe Methods) y los m√©todos idempotentes (Idempotent Methods). Los m√©todos seguros son aquellos m√©todos que no representan una acci√≥n insegura. En este caso, hace referencia a los m√©todos dedicados a recuperar informaci√≥n. Los m√©todos GET y HEAD se consideran m√©todos seguros ya su principal funci√≥n es y siempre debe ser recuperar informaci√≥n. Los m√©todos idempotentes son aquellos m√©todos que cumplen con la propiedad de que, a excepci√≥n de los errores o expiraciones, los resultados de ejecutar muchas veces la misma solicitud son id√©nticos a los obtenidos al realizar una sola solicitud. Los m√©todos GET, HEAD, PUT, DELETE, OPTIONS y TRACE son m√©todos idempotentes. GET es un m√©todo que recupera cualquier informaci√≥n, en la forma de una entidad, identificada en la URL de la petici√≥n. Existen modificadores que pueden ser agregados a una solicitud GET que alteran la sem√°ntica de esta: ‚Ä¢ Si el mensaje de la solicitud contiene un modificador (If-Modified-Since, If- Unmodified-Since, If-Match, If-None-Match, or If-Range), se convierte en un GET condicional. En este caso, la respuesta ser√° transferida s√≥lo bajo las condiciones impuestas por el modificador. Su objetivo es reducir el uso de la red permitiendo que las entidades en cach√© se refresquen sin requerir m√∫ltiples solicitudes ‚Ä¢ SI el mensaje de la solicitud contiene un encabezado de rango (Range), se convierte en un GET parcial. En este caso, la respuesta s√≥lo contendr√° la parte del mensaje solicitado. Su objetivo es reducir el uso de la red al permitir a recursos parcialmente recuperados ser completados sin tener que transmitir data que ya contiene el cliente nuevamente. HEAD es un m√©todo id√©ntico a GET con la excepci√≥n de que el servidor no debe devolver un cuerpo del mensaje en la respuesta. √önicamente deben ser transmitidos los metadatos contenidos en los encabezados HTTP. Este m√©todo puede ser utilizado para recuperar los metadatos de una entidad impl√≠cita en una solicitud sin la necesidad de enviar el cuerpo de la entidad como tal. OPTIONS es un m√©todo para solicitar informaci√≥n sobre las opciones de comunicaci√≥n disponibles. Permite al cliente saber de qu√© manera puede comunicarse con el servidor sin necesidad de hacer una solicitud de una entidad. Este m√©todo es usando, por ejemplo, en aplicaciones m√≥viles y otros sistemas para identificar si el intercambio de recursos de distintos or√≠genes (CORS) est√° habilitado. Un cliente enviar√° una consulta con OPTIONS antes de enviar una solicitud de cualquier otro tipo. Si el servidor no acepta solicitudes de or√≠genes distintos, entonces las subsecuentes solicitudes no ser√°n realizadas. POST es el m√©todo utilizado para solicitar que el servidor acepte una entidad encapsulada en la solicitud, es decir, preservar nuevo contenido o procesar datos. El mejor ejemplo de un POST es el env√≠o de un formulario de datos. Un usuario llena los Cap√≠tulo II. campos con la informaci√≥n solicitada. Este formulario representa los campos de una entidad. Cuando la solicitud es enviada, se incluye en la misma dicha entidad para ser almacenada. PUT es un m√©todo parecido a POST. La solicitud incluye una entidad. La principal diferencia radica en el objetivo del m√©todo y en el tipo de URL asociada. En el caso de un POST, la URL describe la acci√≥n que se quiere realizar e indica al servidor que un nuevo elemento debe ser creado, bajo un nuevo identificador. En el caso del PUT, la URL incluye un identificador, de manera tal que el m√©todo lo que le indica al servidor es que la entidad que se est√° enviando debe ser guardada bajo ese identificador. Si el identificador incluido en la URL existe, entonces la entidad contenida en la solicitud debe ser considerada una versi√≥n modificada de la entidad existente. En caso contrario, se considera como una nueva entidad y el m√©todo se comporta como un POST DELETE es el m√©todo para solicitar al servidor la eliminaci√≥n de un recurso identificado por la URL. El cliente no puede estar seguro de que la operaci√≥n ha sido ejecutada, aun cuando el c√≥digo de estado retornado lo indica de esta manera (W3C, 1999). Finalmente, existen otros dos m√©todos HTTP. TRACE y CONNECT. El primero es un m√©todo utilizado al depurar el c√≥digo ya que su funci√≥n es devolver al usuario la solicitud enviada. El receptor debe devolver exactamente el mismo mensaje recibido de vuelta al cliente. El segundo, es un m√©todo utilizado con un proxy que puede convertirse din√°micamente en un t√∫nel (SSL, por ejemplo). 2.4.5.3. Objetivo de la arquitectura REST para servicios Web Los principales objetivos de REST son: ‚Ä¢ Permitir la escalabilidad de la interacci√≥n entre los componentes ‚Ä¢ Ofrecer una interfaz que permita a cualquier cliente interactuar con cualquier servidor a trav√©s de HTTP sin ning√∫n tipo de implementaci√≥n acoplada. ‚Ä¢ Ofrecer una interfaz aut√≥noma que no requiera supervisi√≥n y permita la comunicaci√≥n entre clientes y servidores durante largos per√≠odos de tiempo. REST logra satisfacer estos objetivos aplicando tres restricciones de acuerdo con lo establecido en (Navarro, 2007) ‚Ä¢ Identificaci√≥n de recursos y manipulaci√≥n de ellos a trav√©s de representaciones: Identificaci√≥n de recursos y manipulaci√≥n de ellos a trav√©s de representaciones. Esto se consigue mediante el uso de URIs. HTTP es un protocolo centrado en URIs. Los recursos son los objetos l√≥gicos a los que se le env√≠an mensajes. Los recursos no pueden ser directamente accedidos o modificados. ‚Ä¢ Mensajes autodescriptivos: REST dicta que los mensajes HTTP deber√≠an ser tan descriptivos como sea posible. Esto hace posible que los intermediarios interpreten los mensajes y ejecuten servicios en nombre del usuario. Uno de los modos que HTTP logra esto es por medio del uso de varios m√©todos est√°ndares, muchos encabezamientos y un mecanismo de direccionamiento. Por ejemplo, las cach√©s. Cap√≠tulo II. ‚Ä¢ Hipermedia como un mecanismo del estado de la aplicaci√≥n: El estado actual de una aplicaci√≥n Web deber√≠a ser capturada en uno o m√°s documentos de hipertexto, residiendo tanto en el cliente como en el servidor. El servidor conoce sobre el estado de sus recursos, aunque no intenta seguirles la pista a las sesiones individuales de los clientes. Esta es la misi√≥n del navegador, √©l sabe c√≥mo navegar de recurso a recurso, recogiendo informaci√≥n que el necesita o cambiar el estado que el necesita cambiar. 2.4.6. M√≥dulos Python Si el int√©rprete Python se cierra y se inicializa de nuevo, las definiciones que se hab√≠an creado (funciones y variables) se pierden. Por lo tanto, si se quiere escribir un programa m√°s largo y complejo, es mejor usar un editor de texto para preparar la entrada para el int√©rprete y as√≠ ejecutarlo con ese archivo de entrada. Este proceso se conoce como crear un ‚Äúscript‚Äù. Mientras m√°s largo sea el programa, m√°s se recomienda separar el c√≥digo en diferentes archivos para facilitar el mantenimiento. Para apoyar esto, Python tiene una manera de colocar las definiciones en un archivo y usarlas en el script o en una instancia interactiva del int√©rprete. Este archivo es conocido como ‚Äúm√≥dulo‚Äù (o librer√≠a); las definiciones pertenecientes a un m√≥dulo pueden ser ‚Äúimportadas‚Äù hacia otros m√≥dulos o hacia el c√≥digo principal haciendo uso de la instrucci√≥n import. Un m√≥dulo es un archivo que contiene definiciones y sentencias en Python, el nombre de este archivo debe ser el nombre del m√≥dulo seguido por el sufijo .py (Python Software Foundation, 2019), para la realizaci√≥n de este proyecto se usaron los siguientes m√≥dulos Python: 2.4.6.1. BeautifulSoup Librer√≠a que facilita la recuperaci√≥n de informaci√≥n de p√°ginas web. Se asienta sobre un analizador (en ingl√©s ‚Äúparser‚Äù) XML o HTML, proveyendo modismos pit√≥nicos (de Python) para iterar, buscar y modificar el √°rbol DOM del sitio. (Python Software Foundation, 2019) 2.4.6.2. DiffLib Este m√≥dulo provee clases y funciones para comparaci√≥n de secuencias. Puede ser usado para comparar distintos archivos y producir diferentes tipos de informaci√≥n en formatos variados, incluyendo (pero no limit√°ndose a) HTML. (Python Software Foundation, 2019) 2.4.6.3. Math Este m√≥dulo otorga acceso a las funciones matem√°ticas definidas por el est√°ndar C. No puede ser usado con n√∫meros complejos, esta distinci√≥n se hace debido a que la mayor√≠a de los usuarios no quieren aprender las matem√°ticas necesarias para comprender los n√∫meros complejos. Recibir una excepci√≥n en lugar del resultado complejo permite detecci√≥n m√°s √°gil del n√∫mero complejo inesperado que se usa como par√°metro, para que el programador determine c√≥mo y por qu√© fue generado en primer lugar. (Python Software Foundation, 2019) Cap√≠tulo II. 2.4.6.4. Statistics Este m√≥dulo provee funciones para la realizaci√≥n de c√°lculos estad√≠sticos de data num√©rica con valores reales. (Python Software Foundation, 2019) 2.4.6.5. NumPy NumPy es el m√≥dulo fundamental para computaci√≥n cient√≠fica en Python, contiene entre otras cosas: ‚Ä¢ Un poderoso objeto para manipular arreglos de N dimensiones. ‚Ä¢ Funciones sofisticadas de transmisi√≥n. ‚Ä¢ Herramientas para integrar c√≥digo en C/C++ y Fortran. ‚Ä¢ Capacidad de manejar √°lgebra lineal, transformadas de Fourier y n√∫meros aleatorios. Adem√°s de sus obvios usos cient√≠ficos, NumPy tambi√©n puede ser usado como un contenedor multidimensional eficiente de data gen√©rica. Tipos arbitrarios de datos pueden ser definidos, lo que permite a NumPy integrarse de manera r√°pida y perfecta con una amplia variedad de bases de datos. Est√° licenciado bajo la licencia BSD, permitiendo su reutilizaci√≥n con pocas restricciones. (NumPy, 2019) 2.4.6.6. Matplotlib Es un m√≥dulo de graficaci√≥n en dos dimensiones (2D) que produce figuras de calidad en una gran variedad de formatos y ambientes interactivos entre plataformas. Puede ser usada tanto en scripts de Python como en consolas IPython, servidores de aplicaciones web y cuatro (4) kits de herramientas de interfaz gr√°fica. Matplotlib trata de lograr que tanto las cosas f√°ciles como las dif√≠ciles sean posibles de realizar. Se pueden generar tramas, histogramas, gr√°ficos de barras, diagramas de error, etc., con s√≥lo unas l√≠neas de c√≥digo. (Matplotlib, 2019) 2.4.6.7. Selenium Conjunto de herramientas usadas alrededor de diferentes plataformas con el fin de automatizar los clientes web. Principalmente se usa para automatizaci√≥n de pruebas de aplicaciones web, pero no se limita solamente a esa tarea. Actividades de administraci√≥n basadas en web tambi√©n pueden ser automatizadas. No s√≥lo tiene el soporte de los m√°s grandes vendedores de browsers, sino que tambi√©n es la tecnolog√≠a n√∫cleo en incontables herramientas de automatizaci√≥n, APIs y entornos de trabajo. (SeleniumHQ, 2019) 2.4.7. Detecci√≥n de cambios en p√°ginas web De acuerdo con el diccionario de Oxford, ‚Äúdetecci√≥n‚Äù se puede definir como: La acci√≥n o el proceso de identificar la presencia o existencia de algo. (Oxford, 2019) Cap√≠tulo II. De la misma manera, el diccionario de Oxford tambi√©n define ‚Äúcambios‚Äù de la siguiente manera: Un acto o proceso a trav√©s del cual algo se convierte en otro elemento distinto. (Oxford Dictionary, 2019) Usando estas definiciones como base, la detecci√≥n de cambios puede ser explicada como la identificaci√≥n de las transformaciones realizadas por diferentes elementos en un contexto dado. Esto es aplicable a los sitios web, sobre los cuales podemos identificar dichos cambios mediante una diversidad de t√©cnicas que se dividen en dos grandes grupos, las pertenecientes a la detecci√≥n basadas en el texto obtenido del c√≥digo de estos y las t√©cnicas pertenecientes a la segmentaci√≥n de los sitios web de acuerdo con la ubicaci√≥n espacial de las alteraciones. 2.4.7.1. Detecci√≥n de Cambios basada en Texto El enfoque basado en texto no toma en cuenta la estructura del sitio web visualizada luego de que √©ste sea renderizado por el navegador, sino el contenido escrito en el c√≥digo de este, el cual trata como un archivo de texto plano. Los algoritmos pertenecientes a esta aproximaci√≥n s√≥lo observan al contenido textual y analizan ciertas caracter√≠sticas como densidad de texto o densidad de enlaces de ciertas partes de una p√°gina. Estas t√©cnicas se basan en resultados de ling√º√≠sticas cuantitativas que indican que, estad√≠sticamente, bloques de texto con caracter√≠sticas similares probablemente pertenezcan al mismo grupo y por lo tanto pueden ser unidos en un solo bloque. La tolerancia √≥ptima depende del nivel de granularidad y debe ser determinada experimentalmente. 2.4.7.2. Detecci√≥n por Segmentaci√≥n Web La segmentaci√≥n web es el proceso de tomar una p√°gina web y particionarla en bloques llamados ‚Äúbloques sem√°nticos‚Äù (o ‚Äúsegmentos‚Äù) que definimos como: Un fragmento contiguo HTML que es renderizado como un bloque gr√°ficamente consistente y cuyo contenido est√° unido sem√°nticamente. (Kreuzer, Hage, & Feelders, 2014) Los bloques sem√°nticos pueden, en principio, estar profundamente anidados, aunque en la pr√°ctica, raramente se consideran los anidamientos mayores a dos o tres niveles. Hay diferentes algoritmos que se usan para la segmentaci√≥n web, y son demasiados como para considerarlos todos, as√≠ que se opt√≥ por observar los que m√°s se aproximan a aquellos que trabajar√≠an mejor la segmentaci√≥n con sitios web actuales. Los algoritmos por analizar son los siguientes: 2.4.7.3. Segmentaci√≥n de P√°ginas (PageSegmenter) Una aproximaci√≥n DOM se basa en observar el √°rbol DOM creado al analizar el c√≥digo HTML buscando se√±ales de c√≥mo segmentar el sitio web, sin tomar en cuenta las Cap√≠tulo II. propiedades a√±adidas por archivos externos, como por ejemplo archivos CSS, ya que √©stos se consideran es en el √°rbol renderizado. La idea es que la estructura HTML deber√≠a reflejar las sem√°nticas de la p√°gina web. La calidad de este tipo de aproximaciones, por ende, depender√° de que tan cierto sea este caso. Para realizar este tipo de segmentaci√≥n se debe confiar en la detecci√≥n de patrones recurrentes, como listas y tablas; as√≠ como en heur√≠sticas, como el uso de etiquetas de cabecera siendo usadas como separadores o enlaces siendo parte del texto circundante. Este enfoque es sencillo de implementar y eficiente al ejecutar, ya que s√≥lo debe analizar el HTML en vez de cargar la p√°gina. Las complicaciones que pueden presentarse es que hay diferentes maneras de construir una estructura HTML para el mismo contenido; adicionalmente, el estilo y la informaci√≥n de estructurado son ignorados por completo, tampoco se trabajar√° de inmediato cuando hay presencia de c√≥digo JavaScript a menos que el DOM sea serializado a priori. El algoritmo PageSegmenter es un ejemplo claro del enfoque mencionado cuya idea principal es que los caminos ra√≠z-hoja de nodos extremos (hojas) pueden ser analizados en b√∫squeda de similitudes para encontrar nodos que son posibles que pertenezcan al mismo bloque sem√°ntico. Un ejemplo de tal camino ser√≠a /html/body/p/ul/li. Ahora, si m√∫ltiples nodos hermanos pertenecen a un camino muy similar es seguro asumir que sem√°nticamente deben estar contenidos juntos, ya que estructuralmente son parte de la misma lista. (Kreuzer, Hage, & Feelders, 2014) Algoritmo de Segmentaci√≥n de P√°gina basado en Visi√≥n (VIPS) Las aproximaciones visuales son las que m√°s se parecen a como un humano segmentar√≠a una p√°gina de manera natural, es decir, operan sobre el sitio web ya renderizado y como se ver√≠a en el browser. Por lo tanto, los algoritmos que pertenecen a este tipo de enfoque son los que tienen m√°s informaci√≥n disponible al momento de realizar su an√°lisis, pero tambi√©n son los m√°s costosos computacionalmente debido al proceso de renderizaci√≥n mismo. Usualmente dividen el sitio web en separadores tales como l√≠neas, espacios en blanco, im√°genes y contenido; luego de esto construyen una estructura a partir de toda esta informaci√≥n. Tambi√©n pueden considerar caracter√≠sticas √∫nicamente visuales como color de fondo, estilo, dise√±o, tama√±o de fuente, y tipo y ubicaci√≥n en la p√°gina. Para realizar el renderizado necesitamos acceso al motor de un browser, lo que complica la implementaci√≥n del algoritmo, adem√°s que requiere elementos externos para funcionar de manera correcta (como archivos CSS o im√°genes). (Kreuzer, Hage, & Feelders, 2014) De esta manera se escogi√≥ analizar el algoritmo m√°s popular de los que son derivados de este enfoque, llamado VIPS y que, como su nombre lo indica, est√° basado en la renderizaci√≥n completa de un sitio web. Analiza el DOM despu√©s de que toda la informaci√≥n de estilo proveniente del CSS ha sido aplicada y luego de que se ejecuten todos los archivos JavaScript que son parte del sitio y que potencialmente modificaron el √°rbol. Est√° estrictamente integrado con el motor de renderizado del browser ya que necesita consultar informaci√≥n tal como las dimensiones en pantalla de un elemento determinado. Por lo tanto, es necesario que se determine el tama√±o del visualizador previo a la ejecuci√≥n del algoritmo. En concreto, VIPS construye una estructura de contenido basada en lo que se visualiza, independiente del documento HTML Cap√≠tulo II. subyacente, decidi√©ndose durante un recorrido desde el tope hacia el piso si algo representa un bloque visual o si debiese ser subdividido a√∫n m√°s, usando heur√≠sticas tales como ‚Äúsi un sub√°rbol contiene una etiqueta separadora <hr>, realiza la subdivisi√≥n‚Äù. 2.4.7.4. Fusi√≥n de Bloques (BlockFusion) El enfoque basado en texto difiere de los dos anteriores en que no toma en cuenta la estructura del HTML en lo absoluto. Los algoritmos pertenecientes a esta aproximaci√≥n s√≥lo observan al contenido textual y analizan ciertas caracter√≠sticas como densidad de texto o densidad de enlaces de ciertas partes de una p√°gina. Estas t√©cnicas se basan en resultados de ling√º√≠sticas cuantitativas que indican que, estad√≠sticamente, bloques de texto con caracter√≠sticas similares probablemente pertenezcan al mismo grupo y por lo tanto pueden ser unidos en un solo bloque. La tolerancia √≥ptima depende del nivel de granularidad y debe ser determinada experimentalmente. Este tipo de algoritmos suelen ser r√°pidos y sencillos de implementar ya que trabajan de manera independiente del DOM, pero, al igual que el enfoque basado en DOM, no trabajar√° con JavaScript (a menos que se serialice primero el DOM), no toma en cuenta caracter√≠sticas visuales o estructurales, y la extracci√≥n de los subbloques requiere de cambios locales al umbral de tolerancia de densidad de texto (ya que no podemos emplear la estructura del documento). (Kreuzer, Hage, & Feelders, 2014) El algoritmo BlockFusion se basa en que el token de densidad de un elemento puede ser una heur√≠stica valiosa para segmentar documentos de texto. Este token puede ser calculado simplemente tomando el n√∫mero de palabras en el texto y dividido entre el n√∫mero de l√≠neas, donde cada l√≠nea tiene un m√°ximo de 80 caracteres. Un documento HTML es primeramente preprocesado en una lista de bloques at√≥micos de texto, separ√°ndolos con alg√∫n tipo de indicador, los cuales son las etiquetas HTML a excepci√≥n de la etiqueta <a>. Por cada bloque se calcula el token de densidad. Una estrategia de mezcla es usada entonces para unir bloques en bloques progresivamente mayores, siempre que la diferencia de los valores del token de dos bloques adyacentes est√© dentro de l√≠mites ya establecidos. Se repite el proceso de fusi√≥n hasta que ya no queden bloques restantes que puedan ser unidos. Debido a este dise√±o, BlockFusion no soporta m√∫ltiples niveles de bloques por defecto, pero si extendemos el algoritmo de manera que localmente introduzcamos un segundo valor l√≠mite m√°s peque√±o, y luego llamamos al algoritmo en cada uno de los bloques ya unidos, podemos conseguir una jerarqu√≠a de dos niveles. (Kreuzer, Hage, & Feelders, 2014) 2.4.7.5. Terreno Web (WebTerrain) Este algoritmo no pertenece a ninguno de los enfoques tratados previamente, fue desarrollado por Robert Kreuzer, Hage Jurriaan y Ad Feelders como su contribuci√≥n al problema de la segmentaci√≥n. La idea principal era determinar si era posible combinar las diferentes aproximaciones realizadas por los algoritmos analizados para mejorar los resultados obtenidos mediante el uso de las caracter√≠sticas positivas de los mismos. WebTerrain est√° basado en una heur√≠stica que ellos consideraron novedosa, la cual adem√°s le dio nombre al algoritmo y cuya inspiraci√≥n provino del navegador Firefox, el cual contiene una funcionalidad poco conocida que le permite al usuario observar una renderizaci√≥n en tres dimensiones (3D) de cualquier sitio web que sea cargado. El Cap√≠tulo II. resultado es similar a un mapa geogr√°fico de un terreno cualquiera. Esta funcionalidad agrega un valor adicional de profundidad a cada elemento visible, el cual simplemente es el valor de profundidad del elemento inspeccionado en el √°rbol. Experimentos realizados demostraron que el perfil de elevaci√≥n corresponde de manera satisfactoria con lo que consideraron los bloques sem√°nticos de un sitio web. La heur√≠stica a la que llegaron mediante esa observaci√≥n tiene la interesante propiedad de que combina un enfoque de estructura plana con un enfoque basado en la renderizaci√≥n, ya que no s√≥lo toma en cuenta el √°rbol DOM sino tambi√©n la visibilidad y las dimensiones de cada elemento. (Kreuzer, Hage, & Feelders, 2014) Cap√≠tulo III. 34 Cap√≠tulo 3 MARCO PROCEDIMENTAL Uno de los pasos necesarios para llevar a buen t√©rmino la realizaci√≥n de un proyecto de desarrollo de software se debe escoger un m√©todo y establecer un plan de trabajo en conjunto con el fin de regular las actividades diarias, establecer metas y definir lapsos de tiempo para los cuales √©stas deben ser completadas, en otras palabras, para definir una estrategia de trabajo que permita completar las tareas establecidas de manera eficiente. A continuaci√≥n, se proceder√° a realizar una explicaci√≥n de algunas metodolog√≠as establecidas, as√≠ como a realizar una comparaci√≥n entre ellas con el fin de escoger la que sea m√°s acorde al proyecto establecido, de no haber alguna que se adapte completamente al trabajo, se tomar√° la m√°s eficaz y se proceder√° a hacer las modificaciones que se consideren pertinentes. 3.1. Metodolog√≠as de Desarrollo de Software Una metodolog√≠a de desarrollo de software puede ser definido como un conjunto estandarizado de conceptos, pr√°cticas y criterios con la finalidad de estructurar, planear y controlar el proceso de desarrollo de software de calidad, a menudo son vinculados a alg√∫n tipo de organizaci√≥n, la cual promueve el uso y hace refinamientos a la metodolog√≠a. 3.1.1. Metodolog√≠as Tradicionales Se empezaron a desarrollar en la d√©cada de 1960 para desarrollar a una enorme escala funcional de sistemas de negocios, sus procesos son muy planificados y met√≥dicos, es necesarios describir herramientas de An√°lisis y Dise√±o Orientados a Objetos. En la actualidad son llamadas Metodolog√≠as ‚ÄúTradicionales‚Äù o ‚ÄúPesadas‚Äù a aquellas que pongan un mayor √©nfasis en la planificaci√≥n y control del proyecto, esto es, una especificaci√≥n muy precisa de los requerimientos y el modelado del sistema. Entre ellas podemos mencionar: RUP (del ingl√©s Rational Unified Process): Desarrollado por la empresa Rational Software es parte de la metodolog√≠a m√°s usada para el an√°lisis, dise√±o, documentaci√≥n e implementaci√≥n de sistemas orientados a objetos en conjunto con el Lenguaje Unificado de Modelado (UML por sus siglas en ingl√©s). M√°s que un conjunto de pasos establecidos es un conjunto de ideas y metodolog√≠as adaptables a cada organizaci√≥n. Est√° basado en seis (6) principios clave: ‚Ä¢ Adaptar el proceso. ‚Ä¢ Equilibrar prioridades. ‚Ä¢ Demostrar valor iterativamente. ‚Ä¢ Colaboraci√≥n entre equipos. ‚Ä¢ Enfoque en la calidad. Cap√≠tulo III. 35 ‚Ä¢ Elevar el nivel de abstracci√≥n. De igual manera establece un conjunto de fases que determinan el ciclo de vida de la metodolog√≠a (inicio, elaboraci√≥n, desarrollo y transici√≥n) y un conjunto de artefactos de software utilizados para la mejor comprensi√≥n del producto en cada una de las fases (como los diagramas de secuencia, estado o clases y los modelos de dominio o, de ser requerido, entidad-relaci√≥n). (Rational Software , 2001) 3.1.1.1. MSF (viene de Microsoft Solution Framework): Desarrollado por Microsoft, es definido como ‚Äúun enfoque personalizable para entregar con √©xito soluciones tecnol√≥gicas de manera m√°s r√°pida, con menos recursos humanos y menos riesgos, pero con resultados de m√°s calidad.‚Äù (Microsoft Corporation, 2006) MSF est√° centrado en: ‚Ä¢ Alinear los principios del negocio y la tecnolog√≠a. ‚Ä¢ Establecer objetivos, roles y responsabilidades de manera clara y espec√≠fica. ‚Ä¢ Implementar un proceso iterativo regulado por puntos de control. ‚Ä¢ Gestionar los riesgos de manera activa. ‚Ä¢ Responder con eficacia ante los cambios. Al igual que RUP, establece un conjunto de fases divididas en lo que llaman ‚ÄúPistas de ejecuci√≥n‚Äù superpuestas entre s√≠ y reguladas por una persistente que las abarca todas llamada ‚ÄúPista de Gobernanza‚Äù. FIGURA 9 FASES DEL MSF (Microsoft Corporation, 2006) Cap√≠tulo III. 36 La Pista de Gobernanza se centra en equilibrar el uso de los recursos del proyecto, as√≠ como la mejora continua de cada uno de los procesos, siempre respetando las restricciones que hayan sido definidas por la organizaci√≥n; tiene tres (3) objetivos principales, los cuales son: ‚Ä¢ Guiar las actividades de ejecuci√≥n para entregar una soluci√≥n con resultados repetibles y confiables. ‚Ä¢ Optimizar y mejorar continuamente el rendimiento y la capacidad del equipo, la calidad de las soluciones y la mejora de los procesos. ‚Ä¢ Obtener aprobaci√≥n de los Usuarios, las Operaciones y el Cliente. Las pistas de ejecuci√≥n son las que ayudan al equipo a llegar a un acuerdo de alto nivel sobre el futuro del proyecto y crear opciones de enfoque para hacerlo realidad (pista de visi√≥n); evaluar dichas opciones y planear la seleccionada (pista de planeaci√≥n); compilar la soluci√≥n desarrollada (pista de compilaci√≥n); asegurarse que la soluci√≥n es entregada de acuerdo con lo planeado (pista de estabilizaci√≥n); y realizar la implementaci√≥n de la soluci√≥n (pista de implementaci√≥n). 3.1.2. Metodolog√≠as √Ågiles Con el uso de las metodolog√≠as tradicionales, no se tomaba en cuenta el factor humano presente en cada actividad del desarrollo de software, as√≠ como tampoco se hac√≠a √©nfasis en los problemas y cambios que pudiesen surgir a lo largo del proyecto, por este motivo en 2001, durante una reuni√≥n de 17 expertos celebrada en Utah (EE. UU.), nace el t√©rmino ‚Äú√°gil‚Äù aplicado al desarrollo de software. El objetivo principal de √©sta fue esbozar un nuevo grupo de valores y principios que permitieran una respuesta r√°pida a los problemas surgidos durante el desarrollo. Tras esta reuni√≥n fue creada The Agile Alliance, una organizaci√≥n sin √°nimo de lucro dedicada a promover los conceptos relacionados con el desarrollo √°gil del software, su punto de partida fue el Manifiesto √Ågil, un documento que resume esta filosof√≠a y que enumera sus principios b√°sicos. (Beck, y otros, 2001) La Tabla 1 mostrada a continuaci√≥n, ofrece una comparaci√≥n detallada entre las caracter√≠sticas principales de las metodolog√≠as tradicionales y las metodolog√≠as √°giles: Tabla 1 Comparativo entre enfoques metodol√≥gicos Metodolog√≠as √Ågiles Metodolog√≠as Tradicionales Pocos artefactos de modelado son prescindibles y desechables. El modelado es esencial, hay gran presencia de artefactos de software. Pocos roles, gen√©ricos y flexibles. Gran cantidad de roles definidos que se destacan por su especificidad. Cap√≠tulo III. 37 El contrato debe ser flexible. El contrato es fijado con anterioridad y debe ser seguido al pie de la letra. El cliente es parte del equipo de desarrollo. El cliente no es parte del equipo de trabajo, interact√∫a con √©ste mediante reuniones agendadas. Est√° orientada a equipos con pocos integrantes y entregas frecuentes y peque√±as. Se pueden aplicar a proyectos de cualquier tama√±o, pero suelen ser usadas para proyectos de gran tama√±o con equipos muy dispersos. Entregas grandes y poco frecuentes. La arquitectura se define y mejora a lo largo del proyecto. La arquitectura debe ser definida en las primeras fases del proyecto. Se hace √©nfasis en el aspecto humano. El √©nfasis est√° en las fases y roles del proyecto. Se basan en heur√≠sticas provenientes de la pr√°ctica de producci√≥n de c√≥digo Se basa en normas provenientes de est√°ndares seguidos por el entorno de desarrollo. Los cambios en el proyecto son esperados y deseables. Los cambios de gran impacto en el proyecto no son esperados. 3.1.2.1. Extreme Programming (XP) Es el m√©todo de desarrollo √°gil m√°s popular debido a varios factores, entre los que podemos mencionar la presencia del cliente dentro del equipo de trabajo, la reutilizaci√≥n de c√≥digo y el desarrollo de pruebas como parte de sus valores fundamentales y la simplicidad de c√≥digo como la caracter√≠stica principal. Los defensores de XP consideran que los cambios de requisitos sobre la marcha no s√≥lo son inevitables, sino deseables, as√≠ que deben estar preparados para realizar las modificaciones necesarias durante el proceso de desarrollo y por lo tanto ser capaz de adaptarse a √©stos es una cualidad indispensable para un desarrollador. De acuerdo con la segunda edici√≥n del libro mencionado, XP tiene cinco (5) valores fundamentales: (Beck K. , 1999) ‚Ä¢ Simplicidad. ‚Ä¢ Comunicaci√≥n. Cap√≠tulo III. 38 ‚Ä¢ Retroalimentaci√≥n. ‚Ä¢ Coraje (o valent√≠a). ‚Ä¢ Respeto. Debido a la gran agilizaci√≥n requerida para el proyecto y el tama√±o tan peque√±o del equipo de programaci√≥n, XP fue la metodolog√≠a escogida para ser usada como gu√≠a durante el desarrollo de la aplicaci√≥n, por supuesto fue necesaria adaptarla para el trabajo individual, a pesar de que XP fue desarrollada con la idea de una pareja de programadores, lo que no ocurri√≥ en este caso. 3.1.2.1.1. Fases del Desarrollo ‚Ä¢ Planeaci√≥n: es planteada como una comunicaci√≥n constante entre las partes involucradas, incluye a todo el equipo de trabajo. Inicia recopilando historias de usuario, que sustituir√°n a los casos de uso tradicionales. Luego de ser definidas las historias, los programadores eval√∫an el tiempo de desarrollo de cada una. Los conceptos b√°sicos manejados en esta fase son: o Historias de Usuarios: escritas por el cliente en lenguaje natural, son descripciones de las tareas a realizar. o Plan de Entregas: establece qu√© historias ser√°n agrupadas para cada entrega y el orden de ellas. o Plan de Iteraciones: cada historia seleccionada en el plan es desarrollada y probada en el ciclo de iteraci√≥n correspondiente de acuerdo con el orden ya decidido. o Reuniones de seguimiento: mantener la comunicaci√≥n dentro del equipo con el objetivo de compartir los problemas que se generaron y sus posibles soluciones. ‚Ä¢ Dise√±o: la metodolog√≠a XP hace especial √©nfasis en que los dise√±os deben de ser los m√°s sencillos posibles. ‚Ä¢ Codificaci√≥n: esta es la fase en la que se realiza el proceso de creaci√≥n del software, sus conceptos principales los podemos resumir de la siguiente manera: o Disponibilidad del cliente: el cliente debe estar trabajando en conjunto con el equipo de programadores en todo momento, proporcionando y discutiendo con los programadores los detalles sobre las historias de usuarios que no surgieron durante la fase de planeaci√≥n. o Uso de Est√°ndares: es promovido el uso de est√°ndares durante la programaci√≥n para facilitar el entendimiento del c√≥digo de parte de todo el equipo de trabajo. o Ritmo Sostenido: se debe llevar un ritmo constante y razonable de trabajo, de manera que no se sobrecargue al equipo Cap√≠tulo III. 39 ‚Ä¢ Pruebas: es la √∫ltima fase, determinan con su √©xito si la historia del usuario ha sido correctamente implementada. Los conceptos principales que se manejan aqu√≠ son: o Pruebas Unitarias: cada m√≥dulo desarrollado debe ser probado antes de su entrega, como se mencion√≥ con anterioridad, es recomendable que las pruebas sean escritas antes del desarrollo del c√≥digo. o Detecci√≥n y correcci√≥n de errores: de ser encontrado cualquier tipo de error, debe de corregirse de manera inmediata y se deben establecer medidas para que no vuelva a ocurrir ning√∫n error parecido. Nuevas pruebas deben generarse para realizar la verificaci√≥n de la soluci√≥n correcta del error. o Pruebas de Aceptaci√≥n: creadas en base a las historias de los usuarios durante cada iteraci√≥n del desarrollo, son provistas por el cliente, quien especificar√° uno o m√°s escenarios con el fin de comprobar la correcta implementaci√≥n de la historia. En caso de fallar varias pruebas, el cliente se encargar√° de especificar el orden de resoluci√≥n a seguir, al momento de pasar de manera correcta todas las pruebas de aceptaci√≥n, la historia de usuario se considerar√° terminada 3.1.2.1.2. Roles A pesar de que XP especifica pr√°cticas particulares para que el equipo siga durante el trabajo, realmente no establece roles espec√≠ficos, √©stos var√≠an de acuerdo con la fuente a la que uno se adhiera, sin embargo, se encuentra que los proyectos desarrollados en XP usualmente contienen roles definidos de la siguiente manera: (Agile Alliance, 2019) ‚Ä¢ Cliente: es el rol responsable de la toma de decisiones del negocio en lo relacionado al proyecto incluyendo, pero no limit√°ndose a o ¬øQu√© debe hacer el sistema (qu√© caracter√≠sticas tiene y qu√© logra cada una)? o ¬øC√≥mo se conoce que el sistema est√° listo (cu√°les son los criterios de aceptaci√≥n)? o ¬øCu√°nto se puede gastar (presupuesto disponible)? o ¬øQu√© se debe hacer luego (en qu√© orden se realiza cada tarea)? Se espera que el cliente est√© activamente integrado al proyecto, idealmente se convertir√° en parte del equipo. Se asume que el cliente es una sola persona, sin embargo, la experiencia ha demostrado que una persona no puede proveer toda la informaci√≥n relacionada al negocio de manera adecuada, por lo que esto puede variar. (Agile Alliance, 2019) Para el presente Trabajo Especial de Grado, la tutora asumi√≥ el rol de cliente. ‚Ä¢ Desarrollador: debido a que XP no tiene necesidad de roles, cada miembro del equipo es asignado este rol a excepci√≥n del cliente, el ‚Äútracker‚Äù y el coach. Los desarrolladores se encargan de realizar las historias descritas por el cliente. (Agile Alliance, 2019) Cap√≠tulo III. 40 Este fue el rol asumido por el bachiller durante la realizaci√≥n del Trabajo Especial de Grado. ‚Ä¢ Tracker: tambi√©n llamado ‚ÄúEncargado de Seguimiento‚Äù, es un rol que no siempre es necesario, incluso es usual que uno de los desarrolladores del equipo sea el que cumpla con las tareas asignadas a √©ste. Su prop√≥sito principal es (como su nombre lo dice), llevar el seguimiento de las m√©tricas que el equipo considere relevantes e identificar √°reas que necesiten mejor√≠a. (Agile Alliance, 2019) Las tareas asignadas a este rol fueron asumidas por la tutora durante el desarrollo del presente trabajo. ‚Ä¢ Coach: si el equipo empez√≥ a aplicar XP recientemente, es √∫til tener alguien asignado a este rol, usualmente es un consultor externo al equipo que ha usado la metodolog√≠a con anterioridad y su trabajo es ayudar y ense√±ar al resto de los miembros sobre las pr√°cticas de XP. Su valor principal es que reduce la cantidad de errores en el desarrollo gracias al conocimiento que obtuvo durante sus experiencias previas. (Agile Alliance, 2019) Este rol fue considerado innecesario y, por lo tanto, no se tom√≥ en cuenta para este T.E.G. 3.1.2.1.3. Ciclo de Vida Para describir XP en t√©rminos usados al hablar de un ciclo de vida lo m√°s apropiado es revisitar los conceptos de Ciclo Semanal y Ciclo Trimestral. Primero, se inicia describiendo los resultados deseados del proyecto mediante el uso de las historias definidas por el Cliente. Al tiempo que se crean estas historias, el equipo de trabajo estima la duraci√≥n de cada una. Este estimado junto con el beneficio relativo considerado por el cliente se usa para proveer una indicaci√≥n del valor potencial de cada historia y se toman como base para asignar un orden de prioridades a cada historia. Si el equipo identifica historias a las cuales no se les puede asignar un estimado, es recomendado a√±adir un per√≠odo adicional para la investigaci√≥n del t√≥pico y dificultades t√©cnicas que puedan presentarse. Luego, el equipo completo organiza una reuni√≥n para crear un plan de lanzamientos que sea considerado razonable por todos los miembros, incluyendo al cliente. Este plan define las historias que se esperan sean entregadas en un lanzamiento particular. El orden de entregas dentro del plan est√° definido por la importancia que les fue asignada con anterioridad. Posteriormente el equipo inicia una serie de ciclos semanales, al principio de cada ciclo, el equipo (de nuevo, incluyendo al cliente) se re√∫ne para decidir qu√© historias ser√°n hechas esa semana y las separan en tareas a ser completadas. Al final de cada ciclo, los desarrolladores y el cliente revisan el progreso hecho y el cliente decide si el proyecto debe continuar o si suficiente valor ya ha sido entregado. (Agile Alliance, 2019) Cap√≠tulo III. 41 3.2. Arquitectura de Software Basada en Componentes El Desarrollo Basado en Componentes (conocido por sus siglas en ingl√©s CBD) se puede ver de manera simple como una aplicaci√≥n de la t√©cnica dividir y vencer que se usa para reducir la complejidad durante el desarrollo de software, se basa en la idea de definir, dise√±ar e implementar diferentes elementos de software de manera independiente y luego integrarlos entre s√≠ creando un sistema de componentes d√©bilmente acoplado. Se diferencia de otros m√©todos de desarrollo en que el an√°lisis y el dise√±o se realizan dentro del mismo paradigma que la implementaci√≥n; durante su origen este enfoque se us√≥ como complemento del paradigma de Desarrollo Orientado a Objetos, cuyo objetivo principal es el reuso, por lo tanto, la idea detr√°s del desarrollo basado en componentes fue mejorar otros aspectos, siendo el m√°s importante la mantenibilidad. El reuso es un objetivo admirable, pero no siempre es f√°cil de lograr, as√≠ que los sistemas creados bajo este paradigma no son focalizados bajo el pensamiento de que ser√°n usados a posteriori en otras partes, sino que cada uno sea f√°cil de reemplazar, lo que implica que una nueva implementaci√≥n de √©stos podr√° ser usadas sin afectar el rendimiento de los dem√°s. (Vignaga & Perovich, 2014) De acuerdo con Sommerville, los fundamentos de la ingenier√≠a de software basada en componentes (o por sus siglas en ingl√©s CBSE) son los siguientes (Sommerville, Ingenier√≠a del Software, 2005): ‚Ä¢ Componentes independientes, los cuales son completamente especificados por sus interfaces con una clara separaci√≥n entre la interfaz y la implementaci√≥n, para que esta √∫ltima pueda reemplazarse de manera sencilla y sin cambiar el sistema. ‚Ä¢ Est√°ndares para los componentes, se incluyen en el modelo de componentes y definen la manera de especificar tanto los componentes como las interfaces con el fin de facilitar la integraci√≥n. Si los componentes cumplen los est√°ndares, entonces se vuelven independientes del lenguaje de programaci√≥n por lo que componentes escritos en diferentes lenguajes podr√°n integrarse sin problemas. ‚Ä¢ El middleware, que proporciona soporte a la integraci√≥n de los componentes adem√°s de manejar la asignaci√≥n de recursos, gesti√≥n de transacciones, seguridad y concurrencia. ‚Ä¢ Un proceso de desarrollo que se adapte a la ingenier√≠a de software basada en componentes y que no est√© limitada por otro paradigma de desarrollo por suposiciones inherentes a √©ste. 3.2.1. Herramientas que pertenecen al desarrollo de software basado en componentes 3.2.1.1. Componentes Un componente es una unidad de software cuya funcionalidad y dependencias est√°n completamente definidas por un conjunto de interfaces p√∫blicas. Los componentes pueden ser combinados con otros sin hacer referencia a su implementaci√≥n y pueden desplegarse como unidades ejecutables. (Sommerville, Ingenier√≠a del Software, 2005) Cap√≠tulo III. 42 En la Tabla 2 podemos observar las caracter√≠sticas esenciales definidas para los componentes en la CBSE. Tabla 2 Caracter√≠sticas de los Componentes Caracter√≠stica Descripci√≥n Estandarizado La estandarizaci√≥n significa que un componente usado en uno de los procesos de la CBSE tiene que ajustarse a alg√∫n modelo estandarizado. Este modelo debe definir interfaces de componentes, metadata de componentes, documentaci√≥n, composici√≥n y despliegue. Independiente Esto se define como que cada componente debe poder ser desplegado y compuesto sin tener que utilizar otros componentes espec√≠ficos. De requerirse servicios proporcionados de manera externa, deben ser expl√≠citos en una interfaz del tipo ‚Äúrequiere‚Äù. Componible Todas las interacciones externas deben tener lugar a trav√©s de interfaces definidas p√∫blicamente. Adem√°s, debe proporcionar acceso externo a la informaci√≥n sobre s√≠ mismo, es decir, sus m√©todos y atributos. Desplegable Debe ser capaz de funcionar como una entidad aut√≥noma o sobre una plataforma de componentes que implemente el modelo de componentes. Esto normalmente significa que el componente es binario y que no tiene que compilarse antes de ser desplegado. Documentado Cada componente debe estar correctamente documentado para que los usuarios potenciales puedan decidir si satisfacen o no sus necesidades. La sintaxis e, idealmente, la sem√°ntica de cada una de las interfaces debe ser especificada. Fuente: (Sommerville, Ingenier√≠a del Software, 2005) 3.2.1.2. Interfaces de componentes Cada componente es definido por sus interfaces y, en los casos m√°s generales, puede considerarse que tienen dos interfaces relacionadas, como muestra la Figura 10. Cap√≠tulo III. 43 Figura 10 Interfaces de componentes (Sommerville, Ingenier√≠a del Software, 2005) Una interfaz es, fundamentalmente, el API del componente y define los m√©todos que pueden ser llamados por un usuario del componente. 3.2.1.3. Modelo de componentes Un modelo de componentes es una definici√≥n de los est√°ndares para la definici√≥n, documentaci√≥n y despliegue de los componentes. Estos est√°ndares son utilizados para asegurar la interoperabilidad de los componentes y por los programadores de los middlewares, quienes proporcionan soporte en forma de infraestructuras de comunicaci√≥n entre componentes. (Sommerville, Ingenier√≠a del Software, 2005) La Figura 11 muestra las posibles clasificaciones de elementos dentro de un modelo de componentes, as√≠ como los procesos y m√©todos incluidos en cada uno de ellos. Figura 11 ELEMENTOS DEL MODELO DE COMPONENTES (Sommerville, Ingenier√≠a del Software, 2005) 3.2.1.4. Composici√≥n de componentes Se describe como el proceso de ensamblar componentes para la creaci√≥n de un sistema, lo que no es una simple tarea; existen diversos tipos de composiciones, entre los que tenemos: (Sommerville, Ingenier√≠a del Software, 2005) ‚Ä¢ Composici√≥n Secuencial: tiene lugar cuando los componentes pertenecientes al dise√±o general se ejecutan en una secuencia establecida. Es requerido alg√∫n c√≥digo adicional para el enlace entre ellos. ‚Ä¢ Composici√≥n Jer√°rquica: este caso es dado cuando un componente realiza una llamada de manera directa a los servicios ofrecidos por otro, es decir, cuando un componente depende de otro. Cap√≠tulo III. 44 ‚Ä¢ Composici√≥n Aditiva: esto tiene lugar cuando las interfaces de dos componentes se unen para crear un componente nuevo. Su interfaz es creada uniendo las interfaces de los componentes que forman parte de ella, eliminando operaciones duplicadas. Figura 12 TIPOS DE COMPOSICI√ìN DE COMPONENTES (Sommerville, Ingenier√≠a del Software, 2005) Gracias a que los componentes son independientes entre s√≠, es posible usar uno o m√°s tipos de composiciones en el mismo sistema sin que eso afecte el rendimiento o la integridad de este. Cap√≠tulo IV. 45 Cap√≠tulo 4 MARCO APLICATIVO A continuaci√≥n, se presenta el desarrollo de la aplicaci√≥n automatizada de Detecci√≥n de Cambios, siguiendo la metodolog√≠a de Extreme Programming (XP) como se mencion√≥ en el cap√≠tulo anterior, as√≠ como tambi√©n las tecnolog√≠as utilizadas en cada actividad del proyecto. 4.1. Definici√≥n de Requerimientos En el presente Trabajo Especial de Grado se agrega una soluci√≥n a un sistema que actualmente se encuentra en funcionamiento, el cual preserva p√°ginas web venezolanas, pero no detecta cambios de manera automatizada, este proceso actualmente se realiza de manera manual por el administrador del proyecto. El requerimiento principal, por lo tanto, es la creaci√≥n de una aplicaci√≥n que permita realizar este proceso, usando una mezcla de t√©cnicas de detecci√≥n cuantitativas basada en el texto del sitio web a analizar y t√©cnicas cualitativas basadas en la posici√≥n espacial del cambio de acuerdo con lo mostrado en el navegador durante la carga inicial. 4.2. Objetivo de la aplicaci√≥n El objetivo de la aplicaci√≥n desarrollada para el presente Trabajo Especial de Grado es continuar con la implementaci√≥n del Prototipo para el Archivo Web de Venezuela. El M√≥dulo de Adquisici√≥n actualmente permite realizar suscripciones de rastreos para cosechar sitios web y almacenarlos de forma indexada. Con la inclusi√≥n de la Aplicaci√≥n de Detecci√≥n de Cambios ser√° posible determinar si la nueva versi√≥n del sitio web posee cambios lo suficientemente significativos como para realizar el almacenamiento de esta de manera automatizada, mejorando el uso de los recursos y proveyendo una base sobre la cual construir un modelo de predicci√≥n con el cual sea factible realizar optimizaciones sobre el flujo de trabajo del rastreador. 4.3. Arquitectura de la soluci√≥n propuesta La arquitectura propuesta para el Prototipo de Archivo Web de Venezuela, luego de la implementaci√≥n y a√±adidura de la aplicaci√≥n de Detecci√≥n de Cambios se muestra a continuaci√≥n en la Figura 13: Cap√≠tulo IV. 46 Figura 13 Arquitectura del Prototipo del AWV Mientras que la arquitectura propuesta para el desarrollo final de la aplicaci√≥n se muestra a continuaci√≥n en la Figura 14: Figura 14 Arquitectura de la aplicaci√≥n 4.4.Metas de la aplicaci√≥n ‚Ä¢ Proporcionar una interfaz al componente de software conformado por la aplicaci√≥n de detecci√≥n de cambios. ‚Ä¢ Crear la aplicaci√≥n de detecci√≥n de cambios en sitios web. Cap√≠tulo IV. 47 ‚Ä¢ Definir la segmentaci√≥n del c√≥digo del sitio web a analizar en bloques de texto con el fin de realizar una comparaci√≥n modular. ‚Ä¢ Detectar los cambios de manera cuantitativa mediante el uso de t√©cnicas basadas en texto. ‚Ä¢ Detectar los cambios de manera cualitativa mediante el uso de t√©cnicas basadas en posicionamiento espacial de los bloques que han tenido cambios. ‚Ä¢ Cuantificar los cambios, tanto de manera cualitativa como cuantitativa para determinar la importancia absoluta de √©stos. ‚Ä¢ Especificar el rango de importancia absoluta con el fin de determinar si la relevancia del cambio es lo suficientemente significativa como para almacenar la nueva versi√≥n. ‚Ä¢ Emplear las tecnolog√≠as existentes para el desarrollo de la aplicaci√≥n. ‚Ä¢ Permitir la observaci√≥n de los cambios y su importancia al cliente mediante la creaci√≥n de una interfaz gr√°fica. 4.5. Adaptaci√≥n de la metodolog√≠a eXtreme Programming (XP) usando una Arquitectura de Software Basada en Componentes Durante el desarrollo de la aplicaci√≥n de detecci√≥n se implementaron los procesos involucrados en la metodolog√≠a XP, como se mencion√≥ con anterioridad, esta metodolog√≠a no s√≥lo cree que los cambios en los requerimientos son inevitables, sino deseables y, en pro del beneficio del equipo, se decidi√≥ asumir que esto ser√≠a cierto durante el desarrollo del presente trabajo, lo que fue beneficial ya que, efectivamente, se presentaron cambios y a√±adiduras que no fueron contempladas desde el principio. En este mismo orden de ideas se usaron diferentes artefactos pertenecientes a XP entre los cuales podemos mencionar las Historias de Usuario, Pruebas de Aceptaci√≥n y, por √∫ltimo, las Tarjetas de Tareas (del ingl√©s ‚ÄúTask Cards‚Äù) dise√±adas con el fin de llevar a cabo un seguimiento del trabajo que se estaba realizando. Las iteraciones que tuvieron lugar para la culminaci√≥n del presente trabajo fueron las siguientes: 4.5.1. Primera Iteraci√≥n (Investigaci√≥n): Esta iteraci√≥n tuvo una duraci√≥n de cuatro (4) semanas, se realiz√≥ debido a los cambios de requerimientos detectados con respecto al trabajo anterior. Se realizaron los siguientes procesos 4.5.1.1. Planeaci√≥n En un principio se contemplaba como objetivo el desarrollar un prototipo del m√≥dulo de predicci√≥n de cambios, cuyo fin era la creaci√≥n de un modelo predictivo basado en los tipos de p√°ginas web a estudiar (blogs, sitios de noticias, wikis, sitios de empresas y sitios de almacenamiento de media digital), de modo que el rastreo se hiciera de acuerdo con el estimado originado por ese desarrollo. Sin embargo, al hacer el an√°lisis previo al inicio del desarrollo, se encontr√≥ que la detecci√≥n de cambios no estaba automatizada, por lo que era necesario analizar individualmente cada rastreo realizado Cap√≠tulo IV. 48 para determinar si el cambio era lo suficientemente sustancial como para tomarlo en cuenta dentro del modelo predictivo. En base al estudio realizado se determin√≥ que el m√©todo correcto a seguir era detener la creaci√≥n del modelo predictivo y, en cambio darle prioridad a la creaci√≥n de una aplicaci√≥n que automatizase el proceso previamente explicado. Se realiz√≥ la creaci√≥n de las Historias de Usuario tal y c√≥mo est√°n descritas a continuaci√≥n en la Tabla 3 y Tabla 4. Tabla 3 Historia de Usuario 1. Iteraci√≥n 1 Historia de Usuario N√∫mero: 1 Usuario: Mercy Ospina Nombre de Historia: Investigaci√≥n de t√©cnicas de detecci√≥n de cambios Prioridad (Alta/Media/Baja): Alta Riesgo (Alto/Medio/Bajo): Bajo Puntos estimados: 1 Iteraci√≥n asignada: 1 Programador responsable: Luis Aguiar Descripci√≥n: Realizar una exhaustiva investigaci√≥n y estudio de las t√©cnicas de detecci√≥n de cambios que han sido desarrolladas, incluyendo, pero no limit√°ndose a las t√©cnicas basadas en texto e im√°genes, de igual forma, realizar un an√°lisis superficial para determinar si es factible combinar diferentes m√©todos en un mismo an√°lisis. Validaci√≥n: El programador demuestra que conoce las t√©cnicas de detecci√≥n de cambios que investig√≥ y es capaz de determinar cu√°les deben ser usadas o descartadas para el √©xito del desarrollo de la aplicaci√≥n. Tabla 4 Historia de Usuario 2. Iteraci√≥n 1 Historia de Usuario N√∫mero: 2 Usuario: Mercy Ospina Nombre de Historia: Preparaci√≥n de entorno de desarrollo con los elementos necesarios para la construcci√≥n de la aplicaci√≥n. Prioridad (Alta/Media/Baja): Alta Riesgo (Alto/Medio/Bajo): Bajo Puntos estimados: 1 Iteraci√≥n asignada: 1 Cap√≠tulo IV. 49 Programador responsable: Luis Aguiar Descripci√≥n: Realizar la instalaci√≥n de las herramientas necesarias para el desarrollo de la aplicaci√≥n. Validaci√≥n: El programador crea un ambiente de que contenga las herramientas necesarias para la construcci√≥n de la aplicaci√≥n. 4.5.1.2. Dise√±o No fue necesaria la elaboraci√≥n de un dise√±o en la presente iteraci√≥n. 4.5.1.3. Codificaci√≥n Para la configuraci√≥n del entorno de desarrollo, es necesario realizar la instalaci√≥n de diversas herramientas. En primer lugar, se realiza la instalaci√≥n de Python, que ser√° la herramienta principal por usar durante el desarrollo de la aplicaci√≥n, esto se realiza de la siguiente manera: ‚Ä¢ Se realiza la descarga del instalador correspondiente a la versi√≥n del sistema operativo adecuada desde el sitio web https://www.python.org/downloads/ ‚Ä¢ Se ejecuta el instalador descargado. o Es necesario verificar que Python se agrega al PATH para asegurar la correcta ubicaci√≥n del int√©rprete, como muestra la Figura 15. ‚Ä¢ Por √∫ltimo, se hace clic en el bot√≥n de ‚ÄúSiguiente‚Äù y se espera a que la instalaci√≥n se realice. https://www.python.org/downloads/ Cap√≠tulo IV. 50 Figura 15 Instalaci√≥n Python No es necesario realizar una instalaci√≥n adicional del manejador de paquetes de Python (conocido como Pip), ya que est√° incluido en la instalaci√≥n de Python a partir de su versi√≥n 2.7.9 (en el caso de Python 2) y 3.4 (en el caso de Python 3). 4.5.1.4. Pruebas A continuaci√≥n, se muestran las pruebas realizadas durante esta iteraci√≥n: Tabla 5 Caso de Prueba 1. Iteraci√≥n 1 Caso de Prueba N√∫mero de Caso de Prueba: 1 N√∫mero de Historia de Usuario: 2 Descripci√≥n: Comprobar la instalaci√≥n de Python mediante la impresi√≥n por consola de la versi√≥n correspondiente. Resultado: Cap√≠tulo IV. 51 Tabla 6 Caso de Prueba 2. Iteraci√≥n 1 Caso de Prueba N√∫mero de Caso de Prueba: 2 N√∫mero de Historia de Usuario: 2 Descripci√≥n: Comprobar la instalaci√≥n del manejador de paquetes Pip de Python mediante la impresi√≥n por consola de la versi√≥n correspondiente. Resultado: 4.5.2. Segunda Iteraci√≥n (Cambio cuantitativo): Esta iteraci√≥n tuvo una duraci√≥n de dos (2) semanas, se realiz√≥ inmediatamente al terminar la anterior y fue el per√≠odo durante el cual se cre√≥ el c√≥digo encargado de realizar el an√°lisis cuantitativo de los cambios mediante el uso de t√©cnicas de an√°lisis de texto, tomando como base el m√≥dulo DiffLib de Python. 4.5.2.1. Planeaci√≥n Luego de que el equipo de trabajo discutiese los resultados logrados en la primera iteraci√≥n, se definieron los requisitos funcionales m√≠nimos que se necesitaban para determinar que la aplicaci√≥n operase de manera satisfactoria, √©stos fueron descritos en una √∫nica Historia de Usuario descrita en la Tabla 7, que se muestra a continuaci√≥n: Tabla 7 Historia de Usuario 1. Iteraci√≥n 2 Historia de Usuario N√∫mero: 2 Usuario: Mercy Ospina Nombre de Historia: Creaci√≥n de aplicaci√≥n de detecci√≥n de cambios mediante el uso de t√©cnicas cuantitativas basada en m√©todos de an√°lisis de texto. Prioridad (Alta/Media/Baja): Alta Riesgo (Alto/Medio/Bajo): Medio Puntos estimados: 1 Iteraci√≥n asignada: 2 Programador responsable: Luis Aguiar Cap√≠tulo IV. 52 Descripci√≥n: Crear un c√≥digo que parametriza los cambios de texto, tomando el c√≥digo fuente de la p√°gina web a analizar y compar√°ndolo con el c√≥digo fuente de una versi√≥n anterior del mismo sitio, separ√°ndolos en bloques de texto con el fin de comparar cada uno de los bloques de manera directa, luego de asignarles un valor de identificaci√≥n √∫nico a cada uno. Luego de esto, obtener un valor final entre cero (0) y cien (100), tomando en cuenta el Principio de Pareto, donde la mayor ponderaci√≥n ser√° otorgada a los bloques que contengan trozos de texto con la mayor cantidad de caracteres. Validaci√≥n: El programador desarrolla un trozo de c√≥digo cuya entrada es un par de direcciones URL donde una de √©stas est√° enlazada con la versi√≥n almacenada del sitio web y la segunda dirige al sitio en su versi√≥n m√°s reciente y devuelve un valor entre cero (0) y cien (100), tomando en cuenta que la mayor ponderaci√≥n debe estar sobre los bloques de texto que contengan la mayor cantidad de caracteres, y la divisi√≥n de ponderaci√≥n debe ser basada en el Principio de Pareto. 4.5.2.2. Dise√±o Se hizo seguimiento de la doctrina fundamental de dise√±o en XP, la que dice que √©ste debe ser lo m√°s simple posible, por lo tanto, se cre√≥ un modelo de caja negra, donde para el usuario lo que ocurre dentro del c√≥digo no es observado, se introducen los datos requeridos por la consola y se leen los resultados arrojados en la misma ventana, este dise√±o se puede observar en la Figura 16 mostrada a continuaci√≥n: Figura 16 Dise√±o Historia de Usuario 1. Iteraci√≥n 2 4.5.2.3. Codificaci√≥n En primer lugar, se realiz√≥ la importaci√≥n e instalaci√≥n de las dependencias necesarias para realizar un proceso de ‚Äúscraping‚Äù de sitios web, entre las que est√°n los m√≥dulos Selenium, BeautifulSoup y os de Python, as√≠ como el m√≥dulo DiffLib, que ser√° usado para el an√°lisis de variaci√≥n de texto. Adicionalmente es necesaria la importaci√≥n de los m√≥dulos math y statistics, que hacen m√°s expeditos los c√°lculos a efectuar, las importaciones se realizan de manera muy sencilla, s√≥lo es necesario agregar las l√≠neas de c√≥digo mostradas en la Figura 17 al principio del script. Cap√≠tulo IV. 53 Figura 17 Importaci√≥n de dependencias Al ya tener esto, se procede a la definici√≥n de la funci√≥n, que acepta como par√°metros los dos elementos mencionados anteriormente y se hace uso de las dependencias Selenium y BeautifulSoup para abrir una ventana del navegador, cargar el sitio web, obtener una copia del c√≥digo HTML luego de realizar la renderizaci√≥n completa de la p√°gina, separarlo usando las etiquetas <div> navegando a trav√©s del √°rbol DOM renderizado y almacenar cada bloque en un elemento de una lista de diccionarios para su posterior an√°lisis. El c√≥digo encargado de este proceso puede ser observado en la Figura 18. Figura 18 Scraping y almacenamiento del c√≥digo HTML Cap√≠tulo IV. 54 Los diccionarios son elementos que, en este caso, tienen dos (2) partes; cada una conformada por un par clave valor. El primer elemento est√° conformado por un par con la estructura ‚Äúid: <entero>‚Äù donde entero es un n√∫mero √∫nico mayor o igual a cero (0) que ser√° usado como identificador al momento de realizar la reconstrucci√≥n del sitio web, y el segundo par est√° definido de la manera ‚Äúvalue: <string>‚Äù, donde <string> es el c√≥digo del bloque en cuesti√≥n. El siguiente paso es verificar que no haya elementos con valor None, situaci√≥n que es posible que ocurra dada la manera en que BeautifulSoup maneja los elementos extra√≠dos (asignando valores nulos a bloques de texto vac√≠os), en caso de haber, simplemente se sustituyen por cadenas de caracteres vac√≠as para poder realizar m√©todos que se ejecuten sobre texto en √©stas. Luego de esto se procede a ordenar ambas listas por la cantidad de caracteres que tengan sus bloques (en el alcance de esta aplicaci√≥n se asume que los bloques con mayor cantidad de caracteres son los m√°s importantes y que si hubo al menos un bloque donde la diferencia es tan extrema que alter√≥ el orden entre las versiones √©ste siempre ser√° significativo) al momento de realizar la comparaci√≥n usando el m√©todo SequenceMatcher del m√≥dulo DiffLib, el cual elimina texto basura (se define como texto basura cualquier cadena de caracteres que se repita tanto que conforme m√°s del uno por ciento de toda la secuencia) y devuelve un n√∫mero entre cero (0) y uno (1) que se interpreta as√≠: mientras mayor sea el valor, mayor igualdad existe entre los textos analizados, se resta el resultado del valor m√°ximo 1 y se multiplica por cien con el fin de adquirir un valor porcentual de diferenciaci√≥n, por lo que esto arroja como resultado final una lista de enteros entre cero (0) y cien (100) que se leen como el porcentaje de diferencias entre los bloques analizados; esto lo podemos ver en la Figura 19. Figura 19 Porcentaje de diferenciaci√≥n entre bloques Por √∫ltimo, aplicamos el Principio de Pareto sobre el arreglo de resultados, as√≠ que para facilitar esto lo dividimos en dos listas diferentes, la primera tendr√° el veinte por ciento (20%) de los resultados (√©stos son los porcentajes de diferencias entre los bloques con mayor cantidad de texto) y la segunda, tendr√° el ochenta por ciento (80%) restante. Cap√≠tulo IV. 55 Debido a que necesitamos una lista de enteros y esta divisi√≥n cre√≥ una lista de listas similar a lo siguiente: [ [a, b, c, ‚Ä¶] ]; es necesario realizar un proceso conocido como ‚Äúaplanamiento‚Äù, donde simplemente trasladamos los elementos de las listas internas a otra para que queden de la manera [ a, b, c, ‚Ä¶] y procedemos a realizar la ponderaci√≥n de sus valores. Sobre la primera lista (que contiene el veinte por ciento de los elementos) se ejecuta el m√©todo mean del m√≥dulo statistics y se multiplica por cero punto ocho (0.8) con lo que se obtiene la ponderaci√≥n del promedio de sus valores y sobre la segunda lista se realiza un proceso similar pero el factor de ponderaci√≥n ser√° cero punto dos (0.2), realizados ambos c√°lculos, se suman los valores y se imprimen por consola. El c√≥digo que realiza todo esto puede ser observado en la Figura 20. Figura 20 Ponderaci√≥n cuantitativa seg√∫n el Principio de Pareto 4.5.2.4. Pruebas A continuaci√≥n, se muestran las pruebas realizadas durante esta iteraci√≥n: Tabla 8 Caso de Prueba 1. Iteraci√≥n 2 Caso de Prueba N√∫mero de Caso de Prueba: 1 N√∫mero de Historia de Usuario: 1 Descripci√≥n: Comprobar el funcionamiento correcto del c√°lculo del an√°lisis cuantitativo mediante la impresi√≥n del resultado por consola. Resultado: Cap√≠tulo IV. 56 4.5.3. Tercera Iteraci√≥n (Desarrollo de la Interfaz): La presente iteraci√≥n tuvo una duraci√≥n de cuatro (4) semanas, se inici√≥ al terminar la anterior y fue el per√≠odo durante el cual se cre√≥ la interfaz gr√°fica de la aplicaci√≥n mediante el uso del framework Flask. 4.5.3.1. Planeaci√≥n Durante la reuni√≥n inicial que se realiza al empezar cada iteraci√≥n, fue definido que se necesitar√≠a una interfaz gr√°fica con la cual el usuario pudiese interactuar y que mostrase los resultados de la comparaci√≥n de texto entre versiones de la manera descrita en las Historias de Usuario mostradas a continuaci√≥n: Tabla 9 Historia de Usuario 1. Iteraci√≥n 3 Historia de Usuario N√∫mero: 1 Usuario: Mercy Ospina Nombre de Historia: Creaci√≥n de Interfaz de Entrada de la aplicaci√≥n de Detecci√≥n de Cambios Prioridad (Alta/Media/Baja): Alta Riesgo (Alto/Medio/Bajo): Bajo Puntos estimados: 2 Iteraci√≥n asignada: 3 Programador responsable: Luis Aguiar Descripci√≥n: Realizar la instalaci√≥n del framework Flask con el fin de usarlo para construir las interfaces web que ser√°n usadas por el usuario para interactuar con la aplicaci√≥n. Crear una interfaz sencilla en donde se inserten las direcciones URL o rutas locales donde est√©n almacenados los sitios web y ejecute el c√≥digo creado con anterioridad al hacer clic en un bot√≥n. Cap√≠tulo IV. 57 Validaci√≥n: Luego de hacer clic sobre el bot√≥n correspondiente, se imprimen los resultados por la consola del servidor comprobando que efectivamente se realiz√≥ la ejecuci√≥n del c√≥digo de manera satisfactoria. Tabla 10 Historia de Usuario 2. Iteraci√≥n 3 Historia de Usuario N√∫mero: 2 Usuario: Mercy Ospina Nombre de Historia: Creaci√≥n de interfaz descriptiva de salida que muestre los resultados obtenidos. Prioridad (Alta/Media/Baja): Alta Riesgo (Alto/Medio/Bajo): Medio Puntos estimados: 1 Iteraci√≥n asignada: 3 Programador responsable: Luis Aguiar Descripci√≥n: Se debe realizar una interfaz que contenga una captura de la renderizaci√≥n de la versi√≥n almacenada del sitio web, una captura de la versi√≥n contra la que se est√° comparando con los bloques que contengan cambios resaltados de alguna forma (por ejemplo, un borde de color rojo alrededor de este) y una gr√°fica que muestre el porcentaje de cambios por cada uno de los bloques junto a una leyenda que explique los resultados de la gr√°fica. Adicionalmente, se requiere un bot√≥n que realice un retorno a la interfaz descrita en la Historia de Usuario previa, en caso de ser necesaria otra comparaci√≥n. Validaci√≥n: La interfaz de salida es renderizada luego de la ejecuci√≥n del c√≥digo descrita en la Historia de Usuario anterior y se muestran, de manera legible, los elementos solicitados. 4.5.3.2. Dise√±o Continuando la filosof√≠a de XP, se decidi√≥ mantener un dise√±o simple al momento de dise√±ar cada una de las interfaces solicitadas en las Historias de Usuario previamente descritas, bosquejos simples fueron creados para describir una idea de c√≥mo deb√≠a ser construida cada interfaz, los cuales mostraremos a continuaci√≥n: Cap√≠tulo IV. 58 Figura 21 Dise√±o Historia de Usuario 1. Iteraci√≥n 3 Figura 22 Dise√±o Historia de Usuario 2. Iteraci√≥n 3 4.5.3.3. Codificaci√≥n Se inici√≥ con la instalaci√≥n del framework Flask, el cual ser√° usado para llevar a cabo diversos procesos que forman parte del desarrollo de la interfaz web de la aplicaci√≥n, como son el inicio del servidor web y el direccionamiento correcto de las rutas donde se encuentren los archivos html y los scripts. La instalaci√≥n se ejecut√≥ el comando ‚Äúpip install flask‚Äù desde la consola de comandos de la manera que muestra la Figura 23: Cap√≠tulo IV. 59 Figura 23 Historia de Usuario 1. Iteraci√≥n 1. Instalaci√≥n Flask Posterior a esto se cre√≥ un directorio con la estructura usada en el est√°ndar de Flask, la cual est√° conformada por un archivo llamado app.py que es el principal de la aplicaci√≥n, una carpeta static, la cual contendr√° los elementos est√°ticos de la aplicaci√≥n (im√°genes, videos, archivos de sonido, etc.) y una carpeta llamada templates, que es d√≥nde se almacenar√°n los archivos html que conforman las interfaces. El siguiente paso es la creaci√≥n de los archivos html que contendr√°n el c√≥digo que ser√° renderizado por el navegador al momento de iniciar el servidor, iniciamos con la interfaz dise√±ada en la Historia de Usuario 1, d√≥nde es importante resaltar que ambos elementos ‚Äútextbox‚Äù deben encontrarse en un formulario html y el bot√≥n debe ser un elemento de tipo ‚Äúsubmit‚Äù, de no ser as√≠, no se podr√° enviar el contenido de cada textbox como par√°metro a la funci√≥n creada en la iteraci√≥n previa; a este archivo lo nombramos ‚Äúindex.html‚Äù. Luego de este proceso, se inicia la creaci√≥n de la interfaz descrita en la Historia de Usuario 2, durante esta creaci√≥n es importante recalcar el uso de lo que Flask llama ‚Äúplantillas‚Äù, que son trozos de c√≥digo que se insertan en las etiquetas html y que permiten al int√©rprete de Flask ubicar los recursos ubicados en el directorio del proyecto y que ser√°n cargados al momento de renderizar el sitio web. Podemos observar un ejemplo de esto a continuaci√≥n: Figura 24 Ejemplo de uso de plantillas en Flask Donde el c√≥digo que se est√° asignando al par√°metro src es interpretado por Flask como ‚Äúruta del archivo con nombre ‚Äòold_screenshot.png‚Äô ubicado en la carpeta static‚Äù. Este √∫ltimo archivo tiene como nombre ‚Äúresultados.html‚Äù. Luego de realizado este proceso, se modifica el archivo app.py con el fin de se√±alar al int√©rprete de Flask cu√°l es el archivo html que se renderizar√° al momento de ser iniciado, as√≠ como de cu√°les elementos ser√°n los par√°metros de la funci√≥n a ejecutar y la ruta del archivo ‚Äúresultados.html‚Äù. Esto se observa a continuaci√≥n: Cap√≠tulo IV. 60 Figura 25 Archivo app.py Finalmente, se modifica el c√≥digo de la funci√≥n de detecci√≥n de cambios para que reconstruya el sitio web a partir de los bloques en los que se dividi√≥ el c√≥digo obtenido de la versi√≥n actualizada del sitio durante la iteraci√≥n previa a√±adiendo un borde a los bloques que contienen alg√∫n cambio, adicionalmente se a√±ade la creaci√≥n del gr√°fico que ser√° mostrado con el porcentaje de cambio por cada uno de los bloques, la renderizaci√≥n de esta reconstrucci√≥n, captura de √©ste en una imagen y guardado de cada elemento en la carpeta static para que el int√©rprete de Flask los inserte correctamente en la interfaz. Este proceso se divide en varias partes, que ser√°n explicadas a continuaci√≥n: ‚Ä¢ Se inyecta una cadena de caracteres que contenga las instrucciones para la carga de JavaScript, en caso de que sea necesario. ‚Ä¢ Se reordenan los bloques usando como base su n√∫mero de id √∫nico, agregado durante la iteraci√≥n anterior. ‚Ä¢ Se concatena el texto contenido dentro de cada elemento de la lista de bloques en una variable de salida. ‚Ä¢ De haberse detectado cambios en alg√∫n bloque, se inyecta una cadena de caracteres, agregando un borde de color rojo al par√°metro ‚Äústyle‚Äù del bloque (de tenerlo, en caso contrario, se a√±ade el par√°metro y su contenido) ‚Ä¢ Se crea un archivo en modo de escritura cuyo nombre y ruta ser√°n similares al del archivo que contiene la versi√≥n previa, a√±adi√©ndole la cadena ‚Äú_updated.html‚Äù al nombre. ‚Ä¢ Se escribe el contenido de la variable de salida en este nuevo archivo y se cierra. El proceso hasta este punto ejecuta el c√≥digo que se muestra en la Figura 26, mostrada a continuaci√≥n: Cap√≠tulo IV. 61 Figura 26 Reconstrucci√≥n y captura del sitio web actualizado ‚Ä¢ Usando Selenium renderizamos el archivo recientemente construido y el archivo que contiene la versi√≥n almacenada y se toma una captura de pantalla de ambos elementos, ambas capturas son almacenadas en la carpeta static del proyecto. ‚Ä¢ Se importan los m√≥dulos matplotlib y numpy de Python, los cu√°les se usar√°n para la creaci√≥n del gr√°fico de barras y la leyenda de este, se guarda un archivo de imagen del gr√°fico en la carpeta static del proyecto, la descripci√≥n del c√≥digo que realiza este trabajo se puede observar en la Figura 27: Cap√≠tulo IV. 62 Figura 27 Creaci√≥n gr√°fico de barras con resultados 4.5.3.4. Pruebas A continuaci√≥n, se muestran las pruebas realizadas durante esta iteraci√≥n: Tabla 11 Caso de Prueba 1. Iteraci√≥n 3 Caso de Prueba N√∫mero de Caso de Prueba: 1 N√∫mero de Historia de Usuario: 1 Descripci√≥n: Comprobar la instalaci√≥n de Flask mediante la impresi√≥n por consola de la versi√≥n correspondiente. Resultado: Cap√≠tulo IV. 63 Tabla 12 Caso de Prueba 2. Iteraci√≥n 3 Caso de Prueba N√∫mero de Caso de Prueba: 2 N√∫mero de Historia de Usuario: 1 Descripci√≥n: Comprobar la creaci√≥n y muestra correcta de la interfaz de inicio descrita en la Historia de Usuario 1 Resultado: Tabla 13 Caso de Prueba 3. Iteraci√≥n 3 Caso de Prueba N√∫mero de Caso de Prueba: 1 N√∫mero de Historia de Usuario: 2 Cap√≠tulo IV. 64 Descripci√≥n: Comprobar la creaci√≥n y muestra correcta de la interfaz de salida descrita en la Historia de Usuario 2, as√≠ como de los resultados correctos luego de la ejecuci√≥n de la aplicaci√≥n. Resultado: 4.5.4. Cuarta Iteraci√≥n (Cambio cualitativo): Esta iteraci√≥n tuvo una duraci√≥n de dos (2) semanas, se agreg√≥ la funcionalidad a la aplicaci√≥n de detectar la posici√≥n de los cambios con respecto a lo que visualiza el navegador al momento de cargar la p√°gina web y acorde a esto, se le asigna un valor dependiendo de lo visible que sea durante la renderizaci√≥n inicial y se ponder√≥ con el valor obtenido por el an√°lisis cuantitativo obtenido durante la segunda iteraci√≥n. 4.5.4.1. Planeaci√≥n Luego de ser terminada y revisada la iteraci√≥n anterior se observ√≥ que era posible obtener los datos de la ubicaci√≥n espacial de los bloques que poseen cambios, por lo que fue decidido agregar un elemento m√°s al an√°lisis, con el objetivo de realizar una ponderaci√≥n de cambios a√∫n m√°s precisa ya que los cambios realizados en el √°rea visible para el usuario durante la carga inicial de una p√°gina web son m√°s relevantes que aquellos que se realicen en un √°rea no visible, por lo que se deben evaluar ambos casos de manera distinta. Los requerimientos fueron descritos en la Historia de Usuario que se muestra en la Tabla 14: Tabla 14 Historia de Usuario 1. Iteraci√≥n 4 Historia de Usuario Cap√≠tulo IV. 65 N√∫mero: 1 Usuario: Mercy Ospina Nombre de Historia: Agregaci√≥n de c√°lculos cualitativos de importancia de cambio basados en la posici√≥n del bloque. Prioridad (Alta/Media/Baja): Alta Riesgo (Alto/Medio/Bajo): Alto Puntos estimados: 1 Iteraci√≥n asignada: 4 Programador responsable: Luis Aguiar Descripci√≥n: Se debe agregar un elemento de an√°lisis cualitativo a la aplicaci√≥n de detecci√≥n de cambios, basando √©ste en la posici√≥n espacial del bloque donde est√° ubicado cada cambio con respecto a lo que se puede visualizar al iniciar un sitio web, ya que no s√≥lo importa el tama√±o del cambio en t√©rminos de texto, sino tambi√©n en t√©rminos de si el usuario puede observarlo a simple vista o no. Validaci√≥n: Se debe analizar la posici√≥n espacial del (o los) bloque(s) donde se encuentren cambios y agregar el valor obtenido como resultado de esto a la ponderaci√≥n de importancia de un cambio. 4.5.4.2. Dise√±o Para poder realizar el c√°lculo de la importancia cualitativa es necesario colocarle un valor a cada posici√≥n de lo que se puede observar en el navegador al momento de su carga inicial, ya que los elementos visibles tendr√°n un mayor grado de importancia en comparaci√≥n con los no visibles. Adaptando el modelo descrito por (Sanoja, 2015), el cual separa el contenido del sitio web en bloques y los representa por medio de una estructura de dos dimensiones, donde cada celda ser√° un valor asignado de acuerdo con el √°rea donde se ubique. El contenido del sitio web renderizado se divide en un n√∫mero n de subsecciones, a cada subsecci√≥n se le asigna un valor que depende de dos elementos principales: el primero es el tipo de contenido que se quiere visualizar, donde si es contenido principal se le asigna un puntaje mayor a las celdas centrales de la matriz (a la que llamaremos Matriz de Posici√≥n), ya que es la ubicaci√≥n usual de √©ste dentro de los sitios web, mientras que si por el contrario, lo que se quiere es evaluar la publicidad, se le asignar√≠an los puntajes mayores a las celdas borde de la matriz, de nuevo, porque es el sitio usual donde est√°n ubicados en la mayor√≠a de los sitios web. El segundo elemento que evaluar al momento de colocar el puntaje es que tan alejados est√°n de la celda con el mayor valor, los elementos adyacentes tendr√°n el valor del elemento mayor menos la distancia con respecto a √©ste. El n√∫mero n se escoge de manera arbitraria, dependiendo de la precisi√≥n con la que se quiera evaluar cada elemento, mientras m√°s alto sea, m√°s precisa ser√° la evaluaci√≥n, pero tambi√©n tendr√° una complejidad m√°s alta. Para este proyecto se escogi√≥ n = 5 como la base de la cual partir para la evaluaci√≥n, y se cre√≥ un dise√±o que est√° representado en la Figura 28, la cual ser√° mostrada a continuaci√≥n: Cap√≠tulo IV. 66 Figura 28 Representaci√≥n de Sitio Web en una Matriz de Posici√≥n La cual representa cada elemento que interact√∫a de manera visual con el sitio web, descrito de la forma siguiente: ‚Ä¢ El √°rea rodeada por la l√≠nea negra s√≥lida representa el contenido del sitio web luego de la renderizaci√≥n. ‚Ä¢ El √°rea rodeada por la l√≠nea roja s√≥lida representa lo que el navegador muestra en un momento determinado (en este caso luego de la carga inicial del sitio web). ‚Ä¢ Las √°reas divididas por las l√≠neas punteadas negras son las n secciones en las que se dividi√≥ el contenido del sitio web, tanto de manera vertical como de manera horizontal, por lo que la Matriz de Posici√≥n ser√° una matriz cuadrada. ‚Ä¢ Los n√∫meros en azul representan el valor asignado a cada una de las √°reas dependiendo de la importancia que tienen de acuerdo con su posici√≥n durante la carga inicial. N√≥tese que el valor m√°s alto se le fue asignado a la celda central y de ah√≠ se coloc√≥ un valor menor dependiendo de la distancia que se encuentra con respecto al centro. 4.5.4.3. Codificaci√≥n El primer paso fue la creaci√≥n de la matriz descrita en el dise√±o de la presente iteraci√≥n, para asegurar una adecuada correspondencia con el visualizador, se procedi√≥ a obtener los valores de altura y anchura de la ventana del navegador, as√≠ como los del sitio completo luego de su renderizaci√≥n, incluyendo el espacio que no es posible visualizar durante la carga inicial del sitio, esto se realiz√≥ mediante el uso de Selenium Cap√≠tulo IV. 67 (para realizar el renderizado, al igual que en iteraciones anteriores) e inyecciones de c√≥digo JavaScript mediante la funci√≥n ‚Äúexecute_script‚Äù, as√≠ mismo, se procedi√≥ a la creaci√≥n de un arreglo que contuviese los valores de las coordenadas donde se ubican los separadores definidos en el dise√±o (siendo designado un arreglo para los valores de la coordenada X y otro para los valores de la coordenada Y), como se muestra en la Figura 29, a continuaci√≥n: Figura 29 Definici√≥n de Segmentos en el Sitio Web El siguiente elemento trabajado fue el ajuste de la Matriz de Posici√≥n, en principio separadas. Para esto fue necesario realizar una comparaci√≥n entre las coordenadas que definen los bloques en el sitio y el visualizador, esta modificaci√≥n se realiza individualmente por cada una de las filas que contiene la matriz, como se muestra en la Figura 30: Figura 30 Modificaci√≥n de filas en Matriz de Posici√≥n Este proceso es repetido cinco (5) veces debido a que fue el n escogido durante el desarrollo del dise√±o. Cap√≠tulo IV. 68 Luego se realiz√≥ la obtenci√≥n de las coordenadas X e Y del bloque (o de los bloques) donde se encuentren los cambios, esto se consigue mediante la b√∫squeda de elementos que contengan el estilo agregado durante la iteraci√≥n previa, como representa la Figura 31: Figura 31 Localizaci√≥n espacial de Bloques con Cambios Posteriormente se calcula la importancia cualitativa, basando este proceso en la posici√≥n que tenga el bloque (o los bloques) que contenga(n) cambios junto con su anchura, asignando los valores de los √≠ndices de la Matriz de Posici√≥n entre los que est√° ubicado el bloque con el fin de obtener los elementos que ser√°n sumados entre s√≠ dentro de esta matriz, esto est√° ilustrado por la : Figura 32 Correlaci√≥n de posici√≥n entre Bloques con Cambios y Matriz de Posici√≥n La suma de los valores que est√©n correlacionados al bloque (o los bloques) con cambios, ser√° su importancia cualitativa. Cap√≠tulo IV. 69 Finalmente, se modific√≥ el trozo de c√≥digo que calculaba la importancia creado durante la segunda iteraci√≥n para que tambi√©n se ponderase la importancia cualitativa en dicho proceso, en principio se le asign√≥ un cuarenta por ciento (40%) del valor final a la importancia cuantitativa y el sesenta por ciento (60%) restante a la importancia cualitativa reci√©n obtenida (este c√°lculo se sigue realizando para cada uno de los bloques que contengan cambios) y se agreg√≥ este resultado final tambi√©n a la gr√°fica definida en la iteraci√≥n previa, como se puede observar en la Figura 33. Estos valores se esperan ser modificados dependiendo de la data obtenida durante las pruebas funcionales de la aplicaci√≥n. Figura 33 Ponderaci√≥n de Importancias Cualitativa y Cuantitativa 4.5.4.4. Pruebas Tabla 15 Caso de Prueba 1. Iteraci√≥n 4 Caso de Prueba N√∫mero de Caso de Prueba: 1 N√∫mero de Historia de Usuario: 1 Descripci√≥n: Comprobar que el resultado ahora toma en cuenta la importancia cualitativa calculada durante esta iteraci√≥n Resultado: Cap√≠tulo IV. 70 4.5.5. Quinta Iteraci√≥n (Pruebas funcionales del sistema): Esta iteraci√≥n tuvo una duraci√≥n de cuatro (4) semanas, se realizaron las pruebas funcionales de la versi√≥n final de la aplicaci√≥n, con el fin de verificar de que es una aplicaci√≥n funcional, con tolerancia a fallos y que cumple con el comportamiento esperado para finalmente ponerla en el ambiente de producci√≥n acopl√°ndola con el resto del Archivo Web de Venezuela. 4.5.5.1. Planeaci√≥n Se decidi√≥ aplicar la detecci√≥n sobre cinco (5) tipos de sitios web, los cuales son Blogs, Foros, Wikis, Sitios web Empresariales y Cat√°logos de im√°genes, con el fin de comprobar que, efectivamente, la aplicaci√≥n es lo suficientemente gen√©rica para procesar una alta variabilidad en el contenido que ser√° analizado, as√≠ como tambi√©n se decidi√≥ tomar varios sitios por cada uno de los tipos y analizarlas luego de que sufriesen diferentes tipos de cambio, las distintas pruebas a realizar fueron descritas en la Historias de Usuario de la siguiente manera: Tabla 16 Historia de Usuario 1. Iteraci√≥n 5 Historia de Usuario N√∫mero: 1 Usuario: Mercy Ospina Nombre de Historia: Realizaci√≥n de pruebas funcionales de la Aplicaci√≥n de Detecci√≥n de Cambios. Prioridad (Alta/Media/Baja): Alta Riesgo (Alto/Medio/Bajo): Alto Cap√≠tulo IV. 71 Puntos estimados: 5 (uno por cada tipo de sitio web) Iteraci√≥n asignada: 5 Programador responsable: Luis Aguiar Descripci√≥n: Tomando como base diversos sitios web usando como base los tipos acordados con antelaci√≥n (Blogs, Foros, Sitios web Empresariales y Cat√°logos de Im√°genes) realizar diferentes modificaciones a cada uno, incluyendo, pero no limit√°ndose a: modificaci√≥n de un bloque, modificaci√≥n de m√°s de un bloque, eliminaci√≥n de un bloque, agregaci√≥n de contenido. Luego proceder a aplicar la detecci√≥n de cambios desarrollada a cada uno y realizar una observaci√≥n de resultados, as√≠ como el apropiado ajuste de los valores de las importancias cualitativas o cuantitativas, de acuerdo con el caso estudiado. Validaci√≥n: Se debe obtener el resultado esperado de acuerdo con las funcionalidades de la aplicaci√≥n para todos los casos descritos en el punto anterior, 4.5.5.2. Dise√±o Se decidi√≥ mantener un dise√±o simple de los casos de prueba, tratando la aplicaci√≥n como una caja negra, de manera similar a lo mostrado anteriormente en la Figura 16 y, de acuerdo con los resultados obtenidos se produjeron diversos an√°lisis 4.5.5.3. Codificaci√≥n Para la realizaci√≥n de cada uno de los casos de prueba se realiz√≥ el almacenamiento de diversas p√°ginas web obtenidas del repositorio ubicado en la direcci√≥n http://bom.ciens.ucv.ve/dataset/ y, dependiendo de la prueba se modific√≥ el c√≥digo html de estos sitios de diversas maneras, ya sea eliminando bloques de texto, alterando el contenido que se muestra en texto plano, el c√≥digo propiamente escrito de la p√°gina web o incluso no se realiz√≥ ning√∫n cambio en lo absoluto con el fin de observar tambi√©n el comportamiento de la aplicaci√≥n en dicho entorno. 4.5.5.4. Pruebas Los resultados de las pruebas se muestran a continuaci√≥n. http://bom.ciens.ucv.ve/dataset/ Cap√≠tulo IV. 72 Tabla 17 Caso de Prueba 1. Iteraci√≥n 5 Caso de Prueba N√∫mero de Caso de Prueba: 1 N√∫mero de Historia de Usuario: 1 Descripci√≥n: Prueba de Blogs, cambio en un bloque Resultado: Resultado obtenido, de acuerdo con el resultado que se esperaba de este caso de prueba. Tabla 18 Caso de Prueba 2. Iteraci√≥n 5 Caso de Prueba Cap√≠tulo IV. 73 N√∫mero de Caso de Prueba: 2 N√∫mero de Historia de Usuario: 1 Descripci√≥n: Prueba de Blogs, agregaci√≥n y eliminaci√≥n de un bloque. Resultado: Debido a las limitaciones de la aplicaci√≥n, s√≥lo es posible dibujar el marco del primer bloque que haya cambiado, limitando la usabilidad del c√°lculo cualitativo, esto se da debido a que se coloc√≥ un l√≠mite de un elemento a remarcar ya que alg√∫n n√∫mero mayor dibujar√≠a tantos cuadros que se dificultar√≠a la visualizaci√≥n porque la funci√≥n compara los cambios de manera recursiva y de haber trabajado de otra manera, se habr√≠an remarcado no s√≥lo el bloque que contiene el cambio sino cada elemento de su contenido . Cap√≠tulo IV. 74 Tabla 19 Caso de Prueba 3. Iteraci√≥n 5 Caso de Prueba N√∫mero de Caso de Prueba: 3 N√∫mero de Historia de Usuario: 1 Descripci√≥n: Prueba de sitio de Empresas, no hay cambios Resultado: El resultado obtenido est√° acorde con el resultado que se esperaba de este caso de prueba. Cap√≠tulo IV. 75 Tabla 20 Caso de Prueba 4. Iteraci√≥n 5 Caso de Prueba N√∫mero de Caso de Prueba: 4 N√∫mero de Historia de Usuario: 1 Descripci√≥n: Prueba de sitio de Empresas, eliminaci√≥n de un bloque Resultado: El resultado obtenido est√° acorde con el resultado que se esperaba de este caso de prueba. Cap√≠tulo IV. 76 Tabla 21 Caso de Prueba 5. Iteraci√≥n 5 Caso de Prueba N√∫mero de Caso de Prueba: 5 N√∫mero de Historia de Usuario: 1 Descripci√≥n: Prueba de Foro, sin cambios. Resultado: El resultado obtenido est√° acorde con el resultado que se esperaba de este caso de prueba. Cap√≠tulo IV. 77 Tabla 22 Caso de Prueba 6. Iteraci√≥n 5 Caso de Prueba N√∫mero de Caso de Prueba: 6 N√∫mero de Historia de Usuario: 1 Descripci√≥n: Prueba de Wiki n√∫mero 1, cambio m√≠nimo en un bloque de contenido. Cap√≠tulo IV. 78 Resultado: El resultado obtenido est√° acorde con el resultado que se esperaba de este caso de prueba. Tabla 23 Caso de Prueba 7. Iteraci√≥n 5 Caso de Prueba N√∫mero de Caso de Prueba: 7 N√∫mero de Historia de Usuario: 1 Cap√≠tulo IV. 79 Descripci√≥n: Prueba de Wiki, cambios en m√°s de un bloque sin eliminaci√≥n Resultado: Similar a los casos 1 y 2, ya que s√≥lo es posible dibujar el marco del primer bloque que haya cambiado, no se puede realizar la comparaci√≥n de las listas de cambio cuantitativo y cambio cualitativo por tener diferente cantidad de elementos. Tabla 24 Caso de Prueba 8. Iteraci√≥n 5 Caso de Prueba Cap√≠tulo IV. 80 N√∫mero de Caso de Prueba: 8 N√∫mero de Historia de Usuario: 1 Descripci√≥n: Prueba de Wiki n√∫mero 3, eliminaci√≥n y cambios de bloques de contenido. Resultado: Al ser eliminado un bloque, todo el sitio web sufre modificaciones de acuerdo al nivel actual de granularidad. Esto coincide con el resultado esperado. Cap√≠tulo IV. 81 Tabla 25 Caso de Prueba 9. Iteraci√≥n 5 Caso de Prueba N√∫mero de Caso de Prueba: 9 N√∫mero de Historia de Usuario: 1 Descripci√≥n: Prueba de Cat√°logo n√∫mero 1, eliminaci√≥n de una imagen. Resultado: El resultado obtenido est√° acorde con el resultado que se esperaba de este caso de prueba. Cap√≠tulo IV. 82 Tabla 26 Caso de Prueba 10. Iteraci√≥n 5 Caso de Prueba N√∫mero de Caso de Prueba: 10 N√∫mero de Historia de Usuario: 1 Descripci√≥n: Prueba de Cat√°logo n√∫mero 3, sin cambios. Resultado: El resultado obtenido est√° acorde con el resultado que se esperaba de este caso de prueba. Conclusiones y recomendaciones 83 CONCLUSIONES Y RECOMENDACIONES Al culminar este Trabajo Especial de Grado (T.E.G.), se desarroll√≥ una soluci√≥n de C√°lculo de Importancia para la Detecci√≥n de Cambios en P√°ginas Web, basada tanto en texto como en la ubicaci√≥n espacial del elemento que fue modificado (este √∫ltimo aspecto condicionado a la cantidad de bloques que sufrieron cambios), luego de analizar las herramientas disponibles en el mercado para poder construir la aplicaci√≥n acorde a las necesidades de los usuarios del Prototipo del Archivo Web de Venezuela. Debido al uso de elementos no tradicionales encontrados durante el desarrollo y el tama√±o del equipo de trabajo, fue necesario realizar una adaptaci√≥n de la metodolog√≠a eXtreme Programming (o por sus siglas XP), la cual permiti√≥ establecer una serie de actividades que sirvieron como gu√≠a para la construcci√≥n de los componentes que forman parte de la aplicaci√≥n. De esta manera se pudo avanzar en el desarrollo de forma r√°pida y ordenada, lo que dio como resultado un producto usable y que satisface las necesidades definidas por los usuarios, adem√°s de hacer al Prototipo de Archivo Web un sistema de tecnolog√≠a innovador, debido a que, a la fecha, no se encontr√≥ informaci√≥n de otros Archivos Web que combinen t√©cnicas de detecci√≥n basadas tanto en el texto como en la ubicaci√≥n del bloque posterior al renderizado del sitio web. De acuerdo con los resultados obtenidos al finalizar el desarrollo del presente T.E.G. es posible determinar que se cumplieron los objetivos de acuerdo al alcance establecido, debido a que se logr√≥ el desarrollo de la aplicaci√≥n de detecci√≥n de cambios, sin embargo, √©sta muestra un alto margen de error al momento de calcular la importancia de los cambios en los casos estudiados cuando el cambio se analiza de manera visual, el problema observado es que mostrar los cambios en bloques de textos posterior al primero le dar√≠a poca informaci√≥n al usuario, por lo que se program√≥ una limitaci√≥n necesaria para la presentaci√≥n del presente trabajo, de otra manera, cada elemento que hubiese cambiado ser√≠a enmarcado lo cual hubiese complicado la visualizaci√≥n durante la toma de la captura de pantalla, esto se da ya que, si un bloque es modificado de alguna manera, eliminado o un nuevo bloque es agregado, se determina que los bloques subsiguientes son partes del cambio. A pesar de esta limitaci√≥n, el desarrollo de la interfaz se realiz√≥ de manera exitosa de acuerdo con el objetivo planteado, facilitando el uso de la aplicaci√≥n y el an√°lisis de la informaci√≥n adquirida con √©sta por parte del usuario final. De acuerdo con los resultados obtenidos se estableci√≥ una clasificaci√≥n para precisar la importancia de cada cambio, determinando una ponderaci√≥n para estos dependiendo de la ubicaci√≥n d√≥nde estuviese ubicado en el visualizador y el contenido de este. Esta soluci√≥n ofrece a los usuarios una serie de indicadores que ayudar√°n al Prototipo a tomar decisiones basadas en la importancia de las modificaciones realizadas sobre los sitios web de manera automatizada, asistiendo as√≠ a la optimizaci√≥n del almacenamiento de nuevas versiones. Actualmente el an√°lisis manual toma entre 30 segundos hasta 4 minutos, sin tomar en cuenta el tiempo de carga de ambos sitios web. Conclusiones y recomendaciones 84 Esta variaci√≥n se da de acuerdo con el tipo de cambio realizado y del tama√±o de la p√°gina. La aplicaci√≥n de detecci√≥n de cambios desarrollada logra realizar una detecci√≥n pr√°cticamente instant√°nea luego de la realizaci√≥n de las renderizaciones de ambas versiones del sitio web. Durante el desarrollo de la soluci√≥n se presentaron diversas limitantes, siendo la principal la relativamente escasa documentaci√≥n sobre algunas de las t√©cnicas de an√°lisis visual debido a que los due√±os de las patentes decidieron bloquear el acceso a su documentaci√≥n por la duraci√≥n de √©stas, espec√≠ficamente VIPS que es propiedad de Microsoft. A trav√©s de pruebas con el cliente realizadas al final de cada una de las iteraciones, se obtuvieron diversos comentarios y sugerencias sobre la aplicaci√≥n, las cuales fueron tomadas en cuenta por el equipo de trabajo con el fin de obtener un software de calidad y alta funcionalidad que agregase algo de valor al Prototipo de Archivo Web. Las limitaciones de la aplicaci√≥n, junto con otras ideas presentadas por el equipo de trabajo de la Aplicaci√≥n de Detecci√≥n de Cambios, son elementos que recomendamos realizar en trabajos futuros para la mejora de la aplicaci√≥n, √©stas son: ‚Ä¢ Refinamiento de la aplicaci√≥n para que se logre el enmarcado visual de los bloques que presentan cambios (si una interfaz no es requerida, esto no supondr√≠a ning√∫n problema). ‚Ä¢ Creaci√≥n de una aplicaci√≥n de predicci√≥n que use los datos provistos como resultados de este trabajo para facilitar la automatizaci√≥n de los rastreos hechos por el m√≥dulo correspondiente. ‚Ä¢ Utilizaci√≥n de herramientas de virtualizaci√≥n como Docker para convertir al Prototipo de Archivo Web en una aplicaci√≥n modularizada y completamente portable. ‚Ä¢ Realizar la integraci√≥n de la Aplicaci√≥n de Detecci√≥n de Cambios con el M√≥dulo de Adquisici√≥n del Prototipo de Archivo Web de Venezuela. Anexos 85 ANEXOS 5.1.Scripts de Heritrix Las siguientes figuras muestran los principales scripts que deben ser ejecutados para realizar un rastreo. Primero, se ejecuta el shell script para crear el trabajo en el servidor remoto. Este script crea un nuevo trabajo indicando qu√© m√°quina virtual ser√° utilizada. FIGURA 34 SCRIPT CREAR_JOB_EN_REMOTO.SH (Carre√±o, 2016) Luego, se copia el archivo de configuraci√≥n de Heritrix y el archivo de semilla (seeds en adelante) en el directorio del rastreo. Toda la salida del rastreo ser√° temporalmente almacenada en este directorio. El siguiente paso es agregar el nuevo trabajo de rastreo al archivo crontab, que contiene la lista de trabajos agendados, o cron jobs, del sistema. Esto se hace con el script ‚Äúagregar_cron‚Äù. De esta manera, el rastreo ser√° ejecutado en una fecha determinada, con la finalidad de capturar cualquier nuevo cambio realizado en la p√°gina desde el √∫ltimo rastreo. FIGURA 35 SCRIPT MOVER_ARCHIVO.SH (Carre√±o, 2016) Luego, se ejecuta el rastreo. Este script se encarga de invocar los comandos de ejecuci√≥n y posterior almacenamiento de la salida del rastreo. Con esto, concluye el proceso de crear un nuevo rastreo. Anexos 86 FIGURA 36 SCRIPT MOVER_ARCHIVO.SH (Carre√±o, 2016) Si bien estos scripts permiten utilizar Heritrix hay una serie de inconvenientes con su ejecuci√≥n. Para comenzar, los scripts deben ser ejecutados por un usuario. Esto hace que la responsabilidad de detectar cambios caiga sobre el administrador del sitio y no sobre el sistema, incrementando la probabilidad de que un error humano interfiera con el buen funcionamiento del archivo. Un ejemplo de esto ser√≠a la omisi√≥n de cambios importantes por no realizar rastreos en el momento oportuno. Otra falla de este sistema se aprecia en el momento en el que se ejecuta el rastreo. La ejecuci√≥n de los scripts no da informaci√≥n al usuario ni al sistema con respecto a la ejecuci√≥n del rastreo. Es imposible para el administrador saber cu√°ndo un script comenzar√°, a menos que revise la tabla cron (crontab). Tampoco se puede saber el estado del rastreo y qu√© caus√≥ que terminara su ejecuci√≥n. Si el rastreo termina, podr√° verse en la tabla cron haciendo uso de otro script (verificar_finalizados.sh). El problema es, que este archivo s√≥lo informa de la finalizaci√≥n de la ejecuci√≥n, no del estado de esta. Si se presenta un error que interrumpi√≥ el rastreo, el administrador no ser√° notificado y no podr√° reprogramar el rastreo comprometiendo as√≠ la misi√≥n del sistema de resguardar los cambios del sitio rastreado. Finalmente, desde el punto de vista de UI/ UX, ejecutar tareas importantes a trav√©s de un conjunto de scripts no es aceptable. Esto limita el sistema a personas con cierto conocimiento tecnol√≥gico y deja la detecci√≥n y recuperaci√≥n de errores completamente en manos del usuario, faltando as√≠ a varios principios b√°sicos del dise√±o de UI. Otro componente fundamental del m√≥dulo de adquisici√≥n es el predictor de cambios. La aplicaci√≥n debe ser capaz de manejar de manera aut√≥noma los rastreos de los sitios web que se est√°n archivando. Rastreos muy frecuentes pueden ocasionar un volumen de datos duplicados que sobrecargue r√°pidamente la capacidad de Anexos 87 almacenamiento del sistema. Rastreos muy espaciados en el tiempo conllevan a p√©rdidas de contenido y, por lo tanto, a fallar en la misi√≥n del sistema de preservar un sitio web. Referencias Bibliogr√°ficas y Electr√≥nicas 88 REFERENCIAS BIBLIOGR√ÅFICAS Y ELECTR√ìNICAS Agile Alliance. (29 de Agosto de 2019). Extreme Programming. Obtenido de What is Extreme Programming (XP)? - Agile Alliance: agilealliance.org/glossary/xp/#q=~(infinite~false~filters~(postType~(~'post~'aa_b ook~'aa_event_session~'aa_experience_report~'aa_glossary~'aa_research_pap er~'aa_video)~tags~(~'xp))~searchTerm~'~sort~false~sortDirection~'asc~page~ 1) Akunda, K. (19 de Octubre de 2011). The Application of the Pareto Principle in Software Engineering. Ruston, Luisiana, Estados Unidos de Am√©rica. Archive-it. (2006). Home: Archive-it. Recuperado el 2012, de Archive-it Web site: http://www.archive-it.org/ Arsanjani, A., Thomas, E., McKendrick, J., & Otros. (2013). SOA Manifesto. Obtenido de SOA Manifesto: http://www.soa-manifesto.org/ Bayer, F., & Harald, K. (2013). Prozessmanagement f√ºr Experten - Impulse f√ºr aktuelle und wiederkehrende Themen. Beck, K. (1999). Extreme Programming Explained: Embrace Change. Boston: Addison- Wesley Longman Publishing Co., Inc. Beck, K., Beedle, M., van Bennekum, A., Cockburn, A., Cunningham, W., Fowler, M., . . . Thomas, D. (2001). Principles behind the Agile Manifesto. Obtenido de http://agilemanifesto.org/principles.html Boehm, B. (1986). A Spiral Model of Software Development and Enhancement. Southern California, United States of America. Burner, M., & Kahle, B. (15 de Sep de 1996). Archivos WARC. Obtenido de Web Archive Jira: https://webarchive.jira.com/wiki/spaces/Heritrix/pages/459199/ARC+File+Format Calzarossa, M., & Daniele, T. (2015). Modeling and predicting temporal patterns of web content chages. Journal of Network and Computer Applications. Carabali, W., & Casanova, M. (2014). COMPARACI√ìN DE T√âCNICAS DE PREDICCI√ìN PARA EL DESARROLLO DE UN COMPONENTE DE PREDICCI√ìN DE CAMBIOS DE SITIOS WEB PARA UN PROTOTIPO DE ARCHIVO WEB. Caracas: UCV. Carabali, W., & Casanova, M. (2014). Desarrollo e implementaci√≥n del m√≥dulo de predicci√≥n de cambios de sitios web para un prototipo de Archivo Web. Caracas. Carre√±o, A. (2016). Informaci√≥n de los shell script para ejecutar un rastreo nuevo. Caracas. Club BPM. (3 de November de 2009). Club BPM. Obtenido de Club BPM: http://www.club-bpm.com/ApuntesBPM/ApuntesBPM01.pdf Referencias Bibliogr√°ficas y Electr√≥nicas 89 CONCISA. (2014). Memorias de la Segunda Conferencia Nacional de Computaci√≥n. Universidad Cat√≥lica Andr√©s Bello, Caracas - Venezuela. Cunningham, W. (26 de Diciembre de 2014). Model View Controller History. Obtenido de http://wiki.c2.com/?ModelViewControllerHistory Da Silva, M., & Matos, A. (2017). Estudio de una soluci√≥n basada en Gesti√≥n de Procesos de Negocio que permita visualizar y orquestar los m√≥dulos del Sistema de Preservaci√≥n de Archivos Web. Caracas: UCV. Diazaraque, J. (08 de Marzo de 2001). Series Temporales. Obtenido de http://halweb.uc3m.es/esp/Personal/personas/jmmarin/esp/EDescrip/tema7.pdf Django Software Foundation. (2012). Django Project. Recuperado el Diciembre de 2012, de https://docs.djangoproject.com/en/1.4/ Django Software Foundation. (2017). FAQ: General. Obtenido de Django Project: https://docs.djangoproject.com/en/dev/faq/general/#what-does-django-mean- and-how-do-you-pronounce-it Django Software Fundation. (2017). Design Philosophies. Obtenido de Django Project: https://docs.djangoproject.com/en/1.11/misc/design-philosophies/ Docker Inc. (2018). Docker Documentation. Obtenido de Docker Docs: https://docs.docker.com/ Dumas, M., Marcello, L. R., Jan, M., & Reijers, H. (2013). Fundamentals of Business Process Management. Springer. Endrei et al. (2004). Patterns: Service-Oriented Architecture and Web. Fielding, R. T. (2000). Architectural Styles and. Obtenido de www.ics.uci.edu: https://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm Galvis-Lista, E., Gonz√°lez-Zabala, M. P., & Vera, P. (December de 2011). Tecnolog√≠as de informaci√≥n para acercar al ciudadano a los servicios de justicia en Colombia: El caso del mapa de oferta de justicia. Obtenido de ResearchGate: https://www.researchgate.net/publication/305301468_Tecnologias_de_informaci on_para_acercar_al_ciudadano_a_los_servicios_de_justicia_en_Colombia_El_c aso_del_mapa_de_oferta_de_justicia Gamma, E., Helm, R., Johnson, R., & Vlissides, J. (1994). Design Patterns: Elements of Reusable Object-Oriented Software. Addison-Wesley. Garcia, J., & Rivero, L. (2013). Desarrollo de prototipo para el Archivo Web de Venezuela. (Tesis de pregrado). Universidad Central de Venezuela, Caracas - Venezuela. Garimella, K., Lees, M., & Williams, B. (2008). Introduccion a BPM para Dummies. Indianapolis: Wiley Publishing. George, N. (2017). The Model-View-Controller Design Pattern. Obtenido de The Django Book: https://djangobook.com/model-view-controller-design-pattern/ Referencias Bibliogr√°ficas y Electr√≥nicas 90 Guti√©rrez G√≥mez, I., & Ot√≥n Tortosa, S. (s.f.). Arquitecturas Orientadas a Servicios. Arquitecturas Orientadas a Servicios. Alcal√°, Espa√±a: Universidad de Alcal√°, Departamento de Ciencias de la Computaci√≥n. Haight, F. (1967). Handbook of the Poisson Distribution. New York: John Wiley & Sons. Hamilton Institute. (10 de Oct de 2010). The Binomial Distribution. Obtenido de Hamilton Institute: http://www.hamilton.ie/ollie/EE304/Binom.pdf Heritrix. (2014). Obtenido de https://webarchive.jira.com/wiki/display/Heritrix/Heritrix Heritrix. (s.f.). New Features in Heritrix 3.0 and 3.1. Obtenido de Web Archive Jira: https://webarchive.jira.com/wiki/spaces/Heritrix/pages/5735559/New+Features+i n+Heritrix+3.0+and+3.1 IIPC. (2012). Obtenido de http://netpreserve.org/working-groups IIPC. (2014). Obtenido de http://netpreserve.org/about-us/members Iniciativas de Archivo Web. (Junio de 2014). Obtenido de http://en.wikipedia.org/wiki/List_of_Web_archiving_initiatives#mediaviewer/File:M ap_of_Web_archiving_initiatives_worldwide.png Intenert Archive. (2001). Storage and Preservation. Obtenido de https://archive.org/about/ Internet Archive. (s.f.). Heritrix. Recuperado el 2013, de Heritrix: http://crawler.archive.org/ Internet Archive. (2013). Internet Archive. Recuperado el 2014, de http://crawler.archive.org/ Internet Memory Foundation. (2010). Web Archiving in Europe. Obtenido de http://internetmemory.org/images/uploads/Web_Archiving_Survey.pdf, 2010. Internet World Stats. (30 de June de 2017). Internet World Stats. Obtenido de Internet World Stats: http://www.internetworldstats.com/stats.htm ISO. (2009). ISO. 28500 Information and documentation-WARC file format. Nueva Zelanda. Jack, P., & Binns, A. (2012). Web Archive - Heritrix. Obtenido de https://webarchive.jira.com/wiki/display/Heritrix/Heritrix Jacobson, I. (1998). Applying UML in the Unified Process. Obtenido de http://www.powershow.com/view/f2189- ZTk1N/Applying_UML_in_The_Unified_Process_Ivar_Jacobson_Rational_Softw are_email_ivar_rationalcom_powerpoint_ppt_presentation Kreuzer, R., Hage, J. H., & Feelders, A. (16 de Junio de 2014). A Quantitative Comparison of Semantic Web Page Segmentation Approaches. A Quantitative Comparison of Semantic Web Page Segmentation Approaches. Utrecht, Holanda: Departamento de Informaci√≥n y Ciencias de la Computaci√≥n, Universidad de Utrecht. Referencias Bibliogr√°ficas y Electr√≥nicas 91 Kroll, P., & Royce, W. (15 de October de 2005). IBM Developer Works. Obtenido de IBM Web Site: https://www.ibm.com/developerworks/rational/library/oct05/kroll/index.html Lambert, K. (2012). Fundamentals of Python: First Programs. Canada: Course Technology. Library of Congress Web Archives. (2000). Home: Library of Congress Web Archives. Recuperado el 2012, de Library of Congress Web Archives Web site: http://lcweb2.loc.gov/diglib/lcwa/html/lcwa-home.html Mantura, K., & Martinez, M. (2014). Definici√≥n de las estrategias para el desarrollo del M√≥dulo de Acceso de los contenidos Preservados en Formato WARC para el Prototipo de Archivo Web en Venezuela. (Tesis de Pregrado). Caracas. Universidad Central de Venezuela, Caracas - Venezuela. Masan√®s, J. (2006). Web Archive. New York: ISBN-10 3-540-23338-5. Matplotlib. (08 de Agosto de 2019). matplotlib version 3.1.1. Obtenido de Matplotlib: Python Plotting -- Matplotlib 3.1.1 Documentation: https://matplotlib.org/ Meyer, P. (1992). Probabilidad y Aplicaciones Estad√≠sticas. Addison-Wesley . Microsoft Corporation. (01 de Septiembre de 2006). Descripci√≥n general de Microsoft Solutions Framework (MSF). Obtenido de Microsoft: https://msdn.microsoft.com/es-es/library/jj161047(v=vs.110).aspx Mohr, G. (09 de Ago de 2010). WARC (Web ARChive). Obtenido de Web Archive Jira: https://webarchive.jira.com/wiki/spaces/Heritrix/pages/4817/WARC+Web+ARChi ve National Library of New Zealand; British Library; IIPC. (2012). Web Curator. Obtenido de http://webcurator.sf.net/ Navarro, R. (2007). Rest vs Web Services. Obtenido de Universidad Polit√©cnica de Valencia: Departamento de Sistemas Inform√°ticos y Computaci√≥n: http://users.dsic.upv.es/~rnavarro/NewWeb/docs/RestVsWebServices.pdf NumPy. (2019). NumPy. Obtenido de NumPy -- NumPy: https://www.numpy.org/ Open Group. (2016). Service-Oriented Architecture ‚Äì What Is SOA? Obtenido de Open Group: http://www.opengroup.org/soa/source-book/soa/p1.htm#soa_definition Organizaci√≥n de las Naciones Unidas para la Educaci√≥n, l. C. (2003). DIRECTRICES PARA LA PRESERVACI√ìN DEL PATRIMONIO DIGITAL. Australia : Biblioteca Nacional de Australia. Ospina, M. (2014). Un marco de referencia para la implementaci√≥n de Archivos Web. Trabajo de Grado de Maestr√≠a. Universidad Central de Venezuela. Caracas - Venezuela. Ospina, Martinez, Leon, & Kabchi. (2014). Desarrollo de una Aplicaci√≥n para Acceder a Contenidos de un Archivo Web en Formato. Universidad Central de Venezuela, Facultad de Ciencias, Escuela de Computaci√≥n. Referencias Bibliogr√°ficas y Electr√≥nicas 92 Oxford. (8 de Octubre de 2019). Detect | Definition of Detect. Obtenido de Detect | Definition of Detect by Lexico: https://www.lexico.com/en/definition/detect Oxford Dictionary. (8 de Octubre de 2019). Change | Definition of Change. Obtenido de Change | Definition of Change by Lexico: https://www.lexico.com/en/definition/change PANDORA. (1996). Obtenido de http://pandora.nla.gov.au/ PANDORA Australia's Web Archive. (s.f.). About PANDORA DIGITAL ARCHIVING SYSTEM (PANDAS): Overview. Recuperado el 2012, de PANDORA Australia's Web Archive Web site: http://pandora.nla.gov.au/pandas.html Patr√≥n Modelo Vista Controlador. (s.f.). Obtenido de Junta de Andalucia: http://www.juntadeandalucia.es/servicios/madeja/contenido/recurso/122 Patr√≥n Modelo Vista Controlador. (s.f.). Obtenido de Junta de Andaluc√≠a: http://www.juntadeandalucia.es/servicios/madeja/contenido/recurso/122 Percy, S. (2014). Phyton. Obtenido de Web Frameworks. Obtenido de https://wiki.python.org/moin/WebFrameworks Peters, T. (2004). The Zen of Python. Obtenido de www.python.org: https://www.python.org/dev/peps/pep-0020/#id3 Portuguese Web Archive. (s.f.). Home: Portuguese Web Archive. Recuperado el 2012, de Portuguese Web Archive Web site: http://sobre.arquivo.pt/ Python Software Foundation. (20 de Nov de 2017). What is Python. Obtenido de Python Org: https://docs.python.org/3/faq/general.html#what-is-python Python Software Foundation. (20 de Julio de 2019). beautifulsoup4. Obtenido de beautifulsoup4 - PyPi: https://pypi.org/project/beautifulsoup4/ Python Software Foundation. (14 de Agosto de 2019). difflib ‚Äî Helpers for computing deltas. Obtenido de difflib ‚Äî Helpers for computing deltas ‚Äî Python 3.7.4 documentation: https://docs.python.org/3/library/difflib.html Python Software Foundation. (14 de Agosto de 2019). math ‚Äî Mathematical functions. Obtenido de math ‚Äî Mathematical functions ‚Äî Python 3.7.4 Documentation: https://docs.python.org/3/library/math.html Python Software Foundation. (14 de Agosto de 2019). Modules. Obtenido de Modules -- Python 3.7.4 Documentation: https://docs.python.org/3/tutorial/modules.html Python Software Foundation. (14 de Agosto de 2019). statistics ‚Äî Mathematical statistics functions. Obtenido de statistics ‚Äî Mathematical statistics functions ‚Äî Python 3.7.4 Documentation: https://docs.python.org/3/library/statistics.html Rational Software . (November de 2001). Rational Unified Process Best Practices for Software Development Teams. Obtenido de https://www.ibm.com/developerworks/rational/library/content/03July/1000/1251/1 251_bestpractices_TP026B.pdf REBUIN. (2009). Preservaci√≥n digital: Gu√≠a de recursos. Espa√±a. Referencias Bibliogr√°ficas y Electr√≥nicas 93 S√°nchez, L., & Milano, G. (2014). Definici√≥n de las estrategias para el desarrollo del M√≥dulo de Administraci√≥n a los Contenidos Preservados en formato WARC para el Prototipo de Archivo Web de Venezuela. Caracas: UCV. Sanoja, A. (19 de Marzo de 2015). Web page segmentation, evaluation and applications. Par√≠s, Francia. Schwaber, K., & Sutherland, J. (November de 2017). The Scrum Guide. Obtenido de Scrum Alliance: http://www.scrumguides.org/docs/scrumguide/v2017/2017- Scrum-Guide-US.pdf#zoom=100 SeleniumHQ. (14 de Agosto de 2019). SeleniumHQ Browser Automation. Obtenido de Selenium - Web Browser Automation: https://www.seleniumhq.org/ Sommerville, I. (2005). Ingenier√≠a del Software. Madrid: Pearson Educaci√≥n S.A. Sommerville, I. (2005). Ingenier√≠a del Software. Madrid: Pearson Educaci√≥n S.A. Sutherland, J. (22 de October de 2011). Takeuchi and Nonaka: The Roots of Scrum. Obtenido de Scrum Inc.: https://www.scruminc.com/takeuchi-and-nonaka-roots- of-scrum/ The Pallets Projects. (2019). Flask | The Pallets Projects. Obtenido de The Pallets Projects Web Site: https://palletsprojects.com/p/flask/ Troeger, V. E. (2013). Warwick Department of Economics. Obtenido de Warwick Department of Economics Web Site: https://warwick.ac.uk/fac/soc/economics/staff/vetroeger/teaching/po906_week89 10.pdf UNESCO. (2003). Charter on the Preservation of the Digital Heritage. Australia. UNESCO. (2003). Directrices para la preservaci√≥n del patrimonio digital. Australia. UNESCO. (2003). Noci√≥n de preservaci√≥n digital. Obtenido de http://www.unesco.org/new/es/communication-and-information/access-to- knowledge/preservation-of-documentary-heritage/digital-heritage/concept-of- digital-preservation/ UNESCO. (16 de January de 2009). Charter on the Preservation of the Digital Heritage. Obtenido de Charter on the Preservation of the Digital Heritage - UNESCO Biblioteca Digital: https://unesdoc.unesco.org/ark:/48223/pf0000179529.page=2 Universidad Sim√≥n Bol√≠var. (julio de 2009). Universidad Sim√≥n Bol√≠var. Obtenido de http://ldc.usb.ve/~abianc/materias/ci4713/metodologiasagiles.pdf Vignaga, A., & Perovich, D. (15 de Mayo de 2014). Enfoque Metodol√≥gico para el Desarrollo Basado en Componentes. Obtenido de ResearchGate Web Site: https://www.researchgate.net/publication/228766936_Enfoque_Metodologico_pa ra_el_Desarrollo_Basado_en_Componentes W3 Consortium. (11 de Feb de 2004). Web Services Architechture. Obtenido de W3.orw: https://www.w3.org/TR/ws-arch/ Referencias Bibliogr√°ficas y Electr√≥nicas 94 W3C. (June de 1999). Hypertext Transfer Protocol -- HTTP/1.1. Obtenido de W3C Org: https://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html W3C. (11 de Febrero de 2004). Web Services Architecture. Obtenido de W3C: https://www.w3.org/TR/2004/NOTE-ws-arch-20040211/#relwwwrest Walpole, R., Myers, R., & Myers, S. (2002). Probabilidad y estad√≠stica para ingenier√≠a y ciencias. M√©xico: Pearson. Wikipedia. (s.f.). Binomial Distribution. Obtenido de Wikipedia: https://en.wikipedia.org/wiki/Binomial_distribution XP Extreme Programming. What is Agile. (2006). Obtenido de http://www.objectmentor.com/omSolutions/agile_what.html