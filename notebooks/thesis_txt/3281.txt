Universidad Central de Venezuela Facultad de Ciencias Escuela de Computaci√≥n Centro de Computaci√≥n Gr√°fica 1. 2. 3. 4. 5. 6. Trabajo Especial de Grado Trabajo Especial de Grado presentado ante la Ilustre Universidad Central de Venezuela por la Bachiller Adriana Desir√©e Urdaneta Medina para optar al t√≠tulo de Licenciado en Computaci√≥n Tutor: Prof. Ernesto Coto Caracas, 26 de Abril 2013 Simulaci√≥n del desag√ºe de agua de lluvia en un sistema de techos utilizando PhysX II Universidad Central de Venezuela Facultad de Ciencias Escuela de Computaci√≥n Centro de Computaci√≥n Gr√°fica ACTA DEL VEREDICTO Quienes suscriben, miembros del jurado designado por el Consejo de la Escuela de Computaci√≥n para examinar el Trabajo Especial de Grado, presentado por la Bachiller Adriana Urdaneta, C.I.: 18.233.140, con el t√≠tulo ‚ÄúSimulaci√≥n del desag√ºe de agua de lluvia en un sistema de techos utilizando PhysX‚Äù, a los fines de cumplir con el requisito legal para optar al t√≠tulo de Licenciado en Computaci√≥n, dejan constancia de lo siguiente: Le√≠do el trabajo por cada uno de los miembros del jurado, se fij√≥ el d√≠a 26 de Abril de 2013, a las 10:00 am, para que su autor lo defendiera en forma p√∫blica, en el Centro de Computaci√≥n Gr√°fica de la Escuela de Computaci√≥n, lo cual esta realiz√≥ mediante una exposici√≥n oral de su contenido, y luego respondi√≥ satisfactoriamente a las preguntas que le fueron formuladas por el Jurado, todo ello conforme a lo dispuesto en la Ley de Universidades y dem√°s normativas vigentes de la Universidad Central de Venezuela. Finalizada la defensa p√∫blica del Trabajo Especial de Grado, el jurado decidi√≥ APROBARLO. En fe de lo cual se levanta la presente acta, en Caracas el 26 de Abril de 2013, dej√°ndose tambi√©n constancia de que actu√≥ como Coordinador del Jurado el Profesor Ernesto Coto, tutor del trabajo. Prof. Ernesto Coto (Tutor) Prof. Rhadam√©s Carmona Prof. Jaime Blanco (Jurado Principal) (Jurado Principal) III RESUMEN T√≠tulo: Simulaci√≥n del desag√ºe de agua de lluvia en un sistema de techos utilizando PhysX Autor: Adriana Desir√©e Urdaneta Medina Tutor: Prof. Ernesto Coto PhysX SDK es un API de Nvidia para el c√°lculo de la f√≠sica que permite simular, entre otras cosas, el comportamiento de un fluido por medio del algoritmo Smoothed Particle Hydrodynamics (SPH). En este trabajo se hace uso del API de PhysX para simular el comportamiento del agua de lluvia y su comportamiento f√≠sico en un sistema de drenaje para diferentes tipos de techos y canaletas. El desarrollo de diversos proyectos arquitect√≥nicos puede ser muy variable y existen muchos est√°ndares que se adaptan a ellos en cuanto al control del drenaje de aguas de lluvia. Este trabajo contempl√≥ la disponibilidad de una serie de modelos variados para el sistema de canaletas y techos, con el fin de poder construir diferentes estructuras y evaluar el comportamiento del flujo al momento del drenaje, as√≠ como determinar la mejor configuraci√≥n de los elementos que intervienen en el despliegue final para obtener un render eficiente y de calidad. Palabras Claves: PhysX, part√≠culas, sistema de techos y canaletas, fluido, simulaci√≥n de lluvia. IV AGRADECIMIENTOS A Dios, a quien debo todo cuanto tengo en la vida, incluida la vida misma. Dios que me ha dado todas mis capacidades y quien me ha dado la fuerza para superar obst√°culos y alcanzar cada una de las metas de mi vida. A mi familia que me apoy√≥ durante toda mi carrera y me orientaron para poder estudiar en esta casa de estudios, la UCV de la cual me lleno de orgullo y le doy gracias a Dios el haberme permitido estudiar aqu√≠. Mis padres, que me han apoyado siempre en todos los aspectos de la vida, y aunque en este tramo final a veces parec√≠an perder la paciencia, siempre me acompa√±aron y me ayudaron. A √âdgar, que me ha ayudado en todo momento, no solo en lo acad√©mico sino tambi√©n en aquellos momentos en que estaba muy deprimida y sent√≠a que nunca iba a poder terminar, √©l supo darme √°nimos para seguir adelante, para continuar e incluso a veces siento que se tom√≥ la molestia de esperarme‚Ä¶ A mi tutor quien me orient√≥ en el desarrollo de este TEG cuando no sab√≠a ya que hacer, me ayud√≥ a mantener la calma, me tuvo mucha paciencia y me presion√≥ cuando lo necesit√©. A todos los profesores de la universidad que tanto me ense√±aron, a los profesores, compa√±eros y amigos del CCG y de la universidad de quienes tanto aprend√≠ y con quienes tanto compart√≠ y sigo compartiendo, con especial cari√±o agradezco a Kijam, Pedro, Alex y √âdgar. A mis otros amigos, que a√∫n cuando a veces no entend√≠an nada de lo que yo estaba haciendo en la tesis ni porque me tardaba tanto, siempre supieron comprenderme e incluso buscaban la manera de ayudarme. En definitiva a todos, much√≠simas gracias. V Tabla de Contenido AGRADECIMIENTOS ....................................................................................................................... IV Tabla de Contenido ......................................................................................................................... V √çndice de Figuras .......................................................................................................................... VIII √çndice de Tablas ............................................................................................................................. XI Introducci√≥n .....................................................................................................................................1 CAP√çTULO I.Planteamiento del TEG .................................................................................................3 1. Planteamiento del Problema ............................................................................................ 3 2. Objetivo General ............................................................................................................... 4 3. Objetivos Espec√≠ficos ........................................................................................................ 4 4. Metodolog√≠a...................................................................................................................... 4 5. Plataforma de hardware y software ................................................................................. 4 6. Alcances y limitaciones de este trabajo............................................................................ 5 CAP√çTULO II.Fluidos ..........................................................................................................................6 1. Conceptos Fundamentales de Mec√°nica de Fluidos ........................................................ 6 a) Compresibilidad ............................................................................................................... 7 b) Continuidad ...................................................................................................................... 8 c) Fluido Newtoniano y no Newtoniano ............................................................................ 10 d) Viscosidad ....................................................................................................................... 11 2. Ecuaciones de Navier-Stokes .......................................................................................... 12 a) Ecuaci√≥n del momentum ............................................................................................... 13 b) Incompresibilidad ........................................................................................................... 16 3. Smoothed Particle Hydrodynamics ................................................................................ 17 CAP√çTULO III.Simulaci√≥n de aguas de lluvia utilizando PhysX ...................................................... 22 1. Lluvias ............................................................................................................................. 22 2. Simulaci√≥n de lluvia con PhysX ....................................................................................... 23 a) Creaci√≥n del fluido ......................................................................................................... 25 3. Actores de PhysX ............................................................................................................ 27 a) Creaci√≥n del Actor .......................................................................................................... 27 VI CAP√çTULO IV.Fundamentos Arquitect√≥nicos para Sistemas de Techos y Canaletas .................... 28 1. Terminolog√≠a de Techos .................................................................................................. 28 2. Detalles Arquitect√≥nicos de Implementaci√≥n ................................................................ 28 3. M√©todos de c√°lculo para aguas de lluvia ....................................................................... 30 4. Sistema de Canaletas ...................................................................................................... 32 CAP√çTULO V.Render ...................................................................................................................... 35 1. Modelos 3D ..................................................................................................................... 35 2. Texturizado ..................................................................................................................... 36 3. Modelo de Iluminaci√≥n ................................................................................................... 36 a) Oclusi√≥n ambiental (Ambiental Occlusion) .................................................................... 37 4. Render del Agua.............................................................................................................. 38 a) Splatting.......................................................................................................................... 39 b) Adaptative Curvature Flow Filtering .............................................................................. 39 c) SkyBox ............................................................................................................................ 42 d) Mapeo de Entorno Est√°tico ............................................................................................ 43 e) Espesor y coeficiente de Fresnel .................................................................................... 45 CAP√çTULO VI.Dise√±o e Implementaci√≥n ....................................................................................... 47 1. Detalles de implementaci√≥n ........................................................................................... 47 a) Transformaciones afines a los techos ............................................................................ 49 b) Transformaciones afines al sistema de canaletas .......................................................... 50 c) Estructura del Edificio .................................................................................................... 53 2. Clases de la aplicaci√≥n .................................................................................................... 57 a) Camara ........................................................................................................................... 58 b) canaletas......................................................................................................................... 59 c) glwidget .......................................................................................................................... 61 d) Librerias .......................................................................................................................... 61 e) qtopengl ......................................................................................................................... 62 f) roofSettings .................................................................................................................... 64 g) HelperActor .................................................................................................................... 65 h) DrawObjects ................................................................................................................... 66 i) Fluido .............................................................................................................................. 66 j) Escena ............................................................................................................................. 71 k) ObjMesh ......................................................................................................................... 76 l) Shader............................................................................................................................. 76 m) Matrix ......................................................................................................................... 77 VII n) UserAllocator .................................................................................................................. 78 o) DepthShader................................................................................................................... 78 p) FluidShader ..................................................................................................................... 79 q) ThicknessShader ............................................................................................................. 79 3. Shaders ........................................................................................................................... 80 a) Phong .............................................................................................................................. 80 b) Depth .............................................................................................................................. 80 c) Downsample ................................................................................................................... 82 d) Smooth ........................................................................................................................... 82 e) Passing ............................................................................................................................ 82 f) Thickness ........................................................................................................................ 83 g) Composite ...................................................................................................................... 84 h) Rain ................................................................................................................................. 86 i) DebugTexture ................................................................................................................. 87 CAP√çTULO VII.Pruebas de rendimiento ......................................................................................... 88 1. Pruebas Cuantitativas ..................................................................................................... 88 2. Pruebas Cualitativas........................................................................................................ 92 a) Grosor del fluido y tama√±o de las part√≠culas ................................................................. 93 b) Espesor de refracci√≥n ..................................................................................................... 95 c) Escala de atenuaci√≥n ...................................................................................................... 95 d) Brillo especular ............................................................................................................... 96 e) Iteraciones de suavizado y tama√±o de kernel de suavizado .......................................... 97 f) Umbral de densidad ....................................................................................................... 99 g) Artefactos visuales ....................................................................................................... 100 CAP√çTULO VIII.Conclusiones y trabajos futuros .......................................................................... 103 Referencias .................................................................................................................................. 106 VIII √çndice de Figuras Figura 1: Diagrama de Mec√°nica de fluido continuo. ..................................................................... 7 Figura 2: La figura (a) muestra el fluido como un continuo. En la figura (b) se pueden apreciar las part√≠culas r√°pidas que se muestran en color amarillo (claro), las part√≠culas m√°s lentas en rojo (oscuro). .......................................................................................................................................... 9 Figura 3: Comparaci√≥n de las formas de una llama para diferentes grados de expansi√≥n de gases. De izquierda a derecha se puede apreciar como el fluido se hace m√°s turbulento en la simulaci√≥n [4]. ............................................................................................................................... 12 Figura 4: Modelo computacional Smoothed Particle Hydrodynamics (a). Algunas part√≠culas y su n√∫cleo de inferencia con el radio ùíâ (b). ........................................................................................ 17 Figura 5: Remolino en un vaso producido por un campo de fuerza de rotaci√≥n [6]. La imagen (a) muestra las part√≠culas. La imagen (b) muestra la superficie renderizada con la t√©cnica point splatting y la imagen (c) muestra la superficie triangulada con Marching Cubes. ....................... 21 Figura 6: Diagrama de la arquitectura de PhysX SDK ................................................................... 25 Figura 7: Comportamiento de un fluido utilizando emisores y drenajes. .................................... 25 Figura 8: Diagrama de los elementos b√°sicos de un sistema de canaletas. ................................. 33 Figura 9: Funci√≥n de proyecci√≥n para convertir el vector de vista (x,y,z) reflejado en una textura (u,v) de la imagen creada a partir de la proyecci√≥n. .................................................................... 44 Figura 10: Rotaci√≥n de las canaletas en un √°ngulo de pendiente m√≠nima. .................................. 50 Figura 11: Vista lateral de un techo inclinado .............................................................................. 52 Figura 12: Vista lateral de la estructura modificada a partir de un convexMesh. ........................ 54 Figura 13: Principio de tri√°ngulos semejantes para deducir el valor de deformidad. ................. 55 Figura 14: Vista lateral de la estructura para techo a dos aguas modificada a partir de un convexMesh. ................................................................................................................................. 56 Figura 15: Creaci√≥n de los v√©rtices de la estructura a nivel de c√≥digo. ........................................ 57 Figura 16: Diagrama de clases de la aplicaci√≥n............................................................................. 58 IX Figura 17: Diagrama de clases de la clase Camara. ...................................................................... 59 Figura 18: Diagrama de clases de la clase canaletas. ................................................................... 60 Figura 19: Ventana de interfaz para configurar el sistema de canaletas. .................................... 60 Figura 20: Diagrama de clases de la clase glwidget. ..................................................................... 61 Figura 21: Diagrama de clases de la clase QTOpenGL. ................................................................ 62 Figura 22: Captura de la aplicaci√≥n con la interfaz principal. ....................................................... 63 Figura 23: Ventana de interfaz para configurar el sistema de techos. ......................................... 64 Figura 24: Diagrama de clases de la clase roofSettings. ............................................................... 65 Figura 25: Diagrama de clases de la clase HelperActor. ............................................................... 66 Figura 26: Diagrama de clases de la clase DrawObjetcs. .............................................................. 66 Figura 27: Diagrama de clases de la clase Fluido. ......................................................................... 67 Figura 28: Diagrama de clases de la clase Escena. ........................................................................ 71 Figura 29: Diagrama de secuencia del proceso de despliegue. .................................................... 74 Figura 30: Pipeline de despliegue. ................................................................................................ 75 Figura 31: Diagrama de clases de la clase ObjMesh. .................................................................... 76 Figura 32: Diagrama de clases de la clase Shader. ....................................................................... 77 Figura 33: Diagrama de clases de la clase Matrix. ........................................................................ 77 Figura 34: Diagrama de clases de la clase UserAllocator.............................................................. 78 Figura 35: Diagrama de clases de la clase DepthShader. ............................................................. 78 Figura 36: Diagrama de clases de la clase FluidShader. ................................................................ 79 Figura 37: Diagrama de clases de la clase ThicknessShader. ........................................................ 79 Figura 38: Textura Sprite para el despliegue del fluido. ............................................................... 81 X Figura 39: Kernel de Splatting utilizado para simular el grosor del agua. A la izquierda se muestra una sola part√≠cula. A la derecha una captura de una capa de fluido con el c√°lculo de espesor. ......................................................................................................................................... 83 Figura 40: Diagrama de proceso del shader "Composite". ........................................................... 84 Figura 41: Diferentes texturas para la representaci√≥n de una gota de agua de lluvia. ............... 87 Figura 42: Resultados de las pruebas cualitativas efectuados en los diferentes equipos de prueba para cada una de las configuraciones. ............................................................................. 90 Figura 43: Pruebas visuales con diferentes valores de grosor del fluido y tama√±o de part√≠cula. (A) Acercamiento al fluido con grosor 1 y tama√±o de part√≠culas 2. (B) Vista semicompleta de la estructura con grosor del fluido 1 y tama√±o de part√≠culas 2. (C) Vista semicompleta de la estructura con configuraci√≥n predeterminada (grosor 0,7 y tama√±o de part√≠culas 0,6). (D) Acercamiento con valor m√°ximo de grosor de fluido (2,047) y de tama√±o de part√≠cula (5,128). 94 Figura 44: Capturas con diferentes valores de espesor de refracci√≥n. (A) Valor predeterminado 0,4. (B) Valor m√°ximo 4,78. .......................................................................................................... 95 Figura 45: Capturas de la aplicaci√≥n con diferentes valores para la escala de atenuaci√≥n. (A) Valor predeterminado 0.03. (B) Valor m√°ximo 0,67. ................................................................... 96 Figura 46: Captura de la aplicaci√≥n con diferentes valores de brillo especular. (A) Valor por defecto 80. (B) Valor m√≠nimo 10. (C) Despliegue de capa intermedia componente especular en el pipeline del render. ................................................................................................................... 97 Figura 47: Capturas del fluido suavizado con diferentes valores de tama√±o de kernel e iteraciones de suavizado. (A) Despliegue con par√°metros predeterminados. (B) Despliegue de capa intermedia "normal" con valores predeterminados. (C) Despliegue con par√°metrosde suavizado en sus valores m√°ximos. (D) Despliegue de capa intermedia "normal" con valores m√°ximos. ....................................................................................................................................... 98 Figura 48: Captura de las part√≠culas con diferentes valores de umbral de densidad. (A) Umbral de densidad m√≠nimo 0.0. (B) Umbral de densidad predeterminado 200.0. (C) Umbral de densidad m√°ximo 300.0. ............................................................................................................... 99 Figura 49: Artefacto visual de desbordamiento de part√≠cula. .................................................... 100 Figura 50: Artefacto visual de parches de fluido en el despliegue. ............................................ 101 Figura 51: Flickering en algunas zonas del fluido. ...................................................................... 102 XI √çndice de Tablas Tabla 1: Coeficientes de viscosidad din√°mica del agua [3]. .......................................................... 10 Tabla 2: Pendientes est√°ndar en techos inclinados [16]. ............................................................. 29 Tabla 3: Coeficientes de rugosidad para distintos materiales [15]. ............................................. 31 Tabla 4: √Åreas m√°ximas de proyecci√≥n horizontal en metros cuadrados que pueden ser drenadas por bajantes de aguas de lluvia de diferentes di√°metros para varias intensidades de lluvia [15]....................................................................................................................................... 32 Tabla 5: Pendientes para el punto de bajada ............................................................................... 34 Tabla 6: Di√°metro del bajante pluvial (cm) de acuerdo a las √°reas de proyecci√≥n horizontal generadas y a diferentes valores de intensidad de lluvia. ............................................................ 48 Tabla 7: Relaci√≥n Part√≠culas ‚Äì Intensidad media de precipitaci√≥n generadas en la simulaci√≥n. . 68 Tabla 8: Equipos utilizados en las pruebas de rendimiento. ........................................................ 88 Tabla 9: Configuraciones de prueba en Frames Por Segundo (FPS). ............................................ 89 Tabla 10: Resultados de prueba de FPS. ....................................................................................... 90 1 Introducci√≥n En un proyecto arquitect√≥nico intervienen una serie de elementos fundamentales que han de ser el sustento del dise√±o, planificaci√≥n y construcci√≥n de cualquier tipo estructura. Cuando se habla de esto de inmediato se piensa en los cimientos, el techo, los muros, ventanas, acabado, sistemas el√©ctricos y sanitarios, entre otras muchas cosas que ya cuentan con un conjunto de reglas generales de arquitectura e ingenier√≠a que van conduciendo la ejecuci√≥n de la obra m√°s all√° de la diversidad de estilos y dise√±os que englobe el proyecto. El sistema sanitario es una de las piezas claves de la construcci√≥n, por el hecho de tratar aspectos tan fundamentales como el acceso al agua en la estructura, as√≠ como la conducci√≥n de aguas residuales o de lluvia. En este caso, la recolecci√≥n, conducci√≥n y disposici√≥n de las aguas de lluvia en un edificio es un problema no menos relevante, para el cual la arquitectura plantea una diversidad de soluciones estrechamente relacionadas al sistema de techos utilizado y la regi√≥n geogr√°fica que incide directamente en la intensidad de precipitaciones que la estructura debe soportar y por ende a la cantidad de agua de lluvia que recibir√°. En este trabajo se desarrolla una aplicaci√≥n interactiva para la simulaci√≥n del flujo del agua de lluvia sobre diversos tipos de techos y su drenaje, utilizando diferentes sistemas de desag√ºes con canaletas y tuber√≠as. El documento est√° estructurado en cap√≠tulos. El Cap√≠tulo I plantea la propuesta del Trabajo Especial de Grado, la cual describe el planteamiento del problema, los objetivos, la metodolog√≠a y la plataforma que ha de utilizarse durante el desarrollo del trabajo. El Cap√≠tulo II expone brevemente los conceptos te√≥ricos b√°sicos de la Mec√°nica de Fluidos, se presentan las ecuaciones diferenciales de Navier-Stokes que simulan la din√°mica de fluidos y el algoritmo Smoothed Particle Hydrodynamics que se basa en estas ecuaciones para simular el comportamiento del fluido. En el Cap√≠tulo III se exponen todos los aspectos referentes a la simulaci√≥n de la lluvia y de las estructuras con PhysX. El Cap√≠tulo IV muestra el basamento te√≥rico a partir del cual est√°n sustentadas las operaciones arquitect√≥nicas utilizadas en la construcci√≥n de las estructuras, especialmente en la conformaci√≥n del sistema de techos y canaletas. 2 El Cap√≠tulo V expone las consideraciones te√≥ricas de despliegue y en el Cap√≠tulo VI se explican todos los detalles de dise√±o e implementaci√≥n utilizados en el TEG. El Cap√≠tulo VII muestra todo lo referente a las pruebas de rendimiento cuantitativo y cualitativo a la cual fue sometida la aplicaci√≥n y el an√°lisis de los resultados obtenidos de las mismas. Finalmente el Cap√≠tulo VIII expone las conclusiones y los trabajos futuros planteados en este TEG. 3 CAP√çTULO I. Planteamiento del TEG En este cap√≠tulo se presenta el planteamiento del TEG, los objetivos, la metodolog√≠a utilizada, el alcance y las limitaciones de este trabajo. 1. Planteamiento del Problema En el mundo del dise√±o arquitect√≥nico y la construcci√≥n existen muchas variables que deben ser tomadas en cuenta a la hora de realizar un proyecto. M√∫ltiples factores influyen en el hecho de que un dise√±o se adec√∫e correctamente al prop√≥sito para el que ha de construirse, e incluso en que el proyecto sea factible o no. Para la elaboraci√≥n de un proyecto arquitect√≥nico es necesario dise√±ar detalladamente el sistema de construcci√≥n (cimentaci√≥n, muros, pisos, etc.), instalaciones el√©ctricas e instalaciones sanitarias. El sistema de instalaciones sanitarias abarca tanto la dotaci√≥n de agua a la estructura, como el drenaje de aguas de lluvia y aguas servidas, negras o cloacales. Al igual que en los otros sistemas que engranan un proyecto arquitect√≥nico, la recolecci√≥n, conducci√≥n y disposici√≥n de las aguas de lluvia en un edificio puede ser tratada de diversas maneras. Dependiendo del dise√±o creado por el arquitecto ser√° necesario aplicar la soluci√≥n m√°s adecuada. Por ello, a pesar de que existen est√°ndares y soluciones que se adaptan a cada proyecto arquitect√≥nico, el sistema utilizado para el drenaje de aguas de lluvias estar√° muy ligado al dise√±o elegido y a la cantidad de agua de lluvia que ha de recibir el techo de acuerdo a la intensidad de precipitaci√≥n habitual en dicha regi√≥n. Para la elecci√≥n del sistema de drenaje se calculan todas estas variables y, junto al dise√±o del arquitecto, es posible determinar as√≠ la morfolog√≠a del techo, el material que ha de utilizarse, las canaletas o tuber√≠as necesarias para desaguar la cantidad m√°xima de lluvia estimada, su di√°metro y longitud, etc. Todos estos c√°lculos ser√°n expresados en tablas que permiten justificar la viabilidad del proyecto. A√∫n cuando el proyecto puede ser modelado en 3D con la ayuda de aplicaciones y herramientas computacionales, ser√≠a interesante desde el punto de vista pedag√≥gico simular f√≠sicamente las condiciones clim√°ticas a las que puede estar sometido dicho dise√±o. 4 Para el TEG se quiere desarrollar una aplicaci√≥n interactiva que permita simular el flujo del agua de lluvia sobre diversos tipos de techos y su drenaje utilizando diferentes sistemas de desag√ºes con canaletas y tuber√≠as. 2. Objetivo General Simular el flujo del agua de lluvia y su drenaje sobre diversos sistemas de techo. 3. Objetivos Espec√≠ficos ‚Ä¢ Utilizar el SDK de PhysX para simular el comportamiento f√≠sico del agua de lluvia con diferentes intensidades de precipitaci√≥n. ‚Ä¢ Desarrollar una interfaz que permita configurar diferentes tipos de techos y sistemas de drenaje para el agua de lluvia. ‚Ä¢ Realizar un estudio del rendimiento de la aplicaci√≥n desarrollada y de la calidad visual de la simulaci√≥n. 4. Metodolog√≠a ‚Ä¢ Se utilizar√° una estrategia de programaci√≥n orientada a objetos para el desarrollo del simulador. ‚Ä¢ Se utilizar√° el m√©todo Smoothed Particles Hydrodynamics que provee el API1 de PhysX[1] para la simulaci√≥n. ‚Ä¢ Con el fin de que la simulaci√≥n sea lo m√°s realista posible, se utilizar√°n diversas t√©cnicas de visualizaci√≥n y se ajustar√°n los par√°metros del fluido, para asemejarlo a la lluvia lo m√°s posible. 5. Plataforma de hardware y software ‚Ä¢ Tarjeta de video Nvidia¬Æ de la serie GeForce 8000 en adelante (con soporte para PhysX) ‚Ä¢ Sistema operativo Windows XP o superior ‚Ä¢ Microsoft Visual C++ 2010 ‚Ä¢ QT 4.7[2] para el desarrollo de la interfaz ‚Ä¢ OpenGL 2.0 en adelante para el despliegue gr√°fico 1Application Programming Interface, en espa√±ol Interfaz de programaci√≥n de aplicaciones. 5 ‚Ä¢ PhysX SDK 2.8 para el procesamiento de los c√°lculos relacionados con f√≠sica 6. Alcances y limitaciones de este trabajo En urbanismo, el sistema de drenaje de aguas de lluvia en edificaciones no contempla √∫nicamente la disposici√≥n de agua que recibe el techo sino tambi√©n la conducci√≥n de esas aguas hasta su destino final, una planta potabilizadora o un r√≠o no contaminado. El alcance de este trabajo solo contempla el drenaje de agua de lluvia en una edificaci√≥n a trav√©s de un sistema de canaletas o drenes. La construcci√≥n de edificaciones es muy variante y compleja. Una estructura puede tener una o m√°s estructuras de techo, pueden combinar techos inclinados con techos planos a diferentes alturas, se pueden utilizar diversos materiales con o sin revestimiento y m√∫ltiples extremos inclinados y lados que se intersecan en un √°ngulo inclinado que se proyecta. Para este trabajo solo se construyen estructuras simples de un solo m√≥dulo con techos planos, inclinados √≥ a dos aguas. El tipo de techo y el material con el que est√© hecho o del que est√© revestido influye tambi√©n en el drenaje del agua. Lo mismo ocurre con la permeabilidad y las capas aislantes para protegerse de la humedad, la rugosidad que afecta el roce del agua, entre otras cosas. En este trabajo no son tomados en cuenta los materiales del techo porque no es posible emular con PhysX la porosidad de los materiales y la absorci√≥n del agua. La rugosidad es considerada definiendo una media entre varios materiales como coeficiente de roce din√°mico. El √°rea servida a considerar va desde los 36m2 hasta 400m2 en el caso de los techos planos o inclinados, lisos o corrugados. Cuando el techo inclinado tiene revestimiento de tejas alcanza √∫nicamente hasta los 256m2 por la complejidad del mallado. Los techos a dos aguas pueden ser vistos como dos techos inclinados que convergen en un brocal de techo, por lo que pueden alcanzar un √°rea de 800m2, desaguados por dos sistemas de canaletas (uno para cada lado). 6 CAP√çTULO II. Fluidos En este cap√≠tulo se explican brevemente los aspectos m√°s resaltantes de la mec√°nica de fluidos y las caracter√≠sticas m√°s importantes de un fluido. As√≠ mismo, se explican brevemente el modelo matem√°tico de Navier-Stokes que permite simular la din√°mica de fluidos y el algoritmo Smoothed Particle Hydrodynamics, basado en dicho modelo matem√°tico. 1. Conceptos Fundamentales de Mec√°nica de Fluidos De acuerdo a [3], un fluido es una sustancia que se deforma continuamente en el tiempo, al ser sometida a un esfuerzo cortante (esfuerzo tangencial), sin importar cu√°n peque√±o sea. Todos los fluidos est√°n compuestos de mol√©culas que se encuentran en movimiento constante. La caracter√≠stica fundamental que define a los fluidos es su incapacidad para resistir esfuerzos cortantes (lo que provoca que carezcan de forma definida). En la naturaleza, existen varios estados de agregaci√≥n de la materia, que van desde el m√°s libre (aquellos en donde sus part√≠culas pr√°cticamente no interact√∫an entre s√≠) hasta el m√°s est√°tico: gases, plasma y l√≠quidos; respectivamente. Todos ellos cumplen las propiedades de los fluidos en mayor o menor medida. Se denomina gas al estado de agregaci√≥n de la materia que no tiene forma ni volumen propio. Este tipo de fluido tiene como caracter√≠stica principal una composici√≥n basada en mol√©culas no unidas, expandidas y con poca fuerza de atracci√≥n, haciendo que no tenga volumen ni forma definida, provocando que este se expanda para ocupar todo el volumen del recipiente que la contiene. Con respecto a los gases, las fuerzas gravitatorias y de atracci√≥n entre part√≠culas resultan insignificantes. De acuerdo a [4], en f√≠sica y qu√≠mica se denomina plasma a un fluido en forma gaseosa constituido por part√≠culas cargadas de iones libres y cuya din√°mica presenta efectos colectivos dominados por las interacciones electromagn√©ticas de largo alcance entre las mismas. Con frecuencia se habla del plasma como un estado de agregaci√≥n de la materia con caracter√≠sticas propias, diferenci√°ndolo de este modo del estado gaseoso, en el que no existen efectos colectivos importantes. Este elemento se encuentra presente en las auroras boreales, los bombillos fluorecentes, las pantallas de televisor, etc. 7 El l√≠quido es un estado de agregaci√≥n de la materia en forma de fluido altamente incompresible. Esto significa que su volumen es, muy aproximadamente, constante en condiciones de temperatura y presi√≥n moderadas. La mec√°nica de fluidos es la rama de la f√≠sica que estudia el comportamiento de estos fluidos, su movimiento y las fuerzas que influyen en ellos. Tambi√©n estudia las interacciones entre el fluido y el contorno que lo limita, bas√°ndose en todas las hip√≥tesis referentes a los medios continuos. Dado que existen bastantes coincidencias entre unos y otros tipos de fluidos, no existe una clasificaci√≥n exacta de los mismos. La Figura 1 intenta mostrar una clasificaci√≥n general de la mec√°nica de fluidos sobre la base de las caracter√≠sticas f√≠sicas observables de los campos de flujo. Figura 1: Diagrama de Mec√°nica de fluido continuo. A continuaci√≥n se describen las propiedades m√°s importantes de un fluido. a) Compresibilidad La compresibilidad es una propiedad existente en todos los fluidos que est√° determinada b√°sicamente por el cambio de densidad. En un fluido usualmente hay cambios en la presi√≥n, Mec√°nica de Fluido Continuo Compresible Viscoso Laminar Turbulento Incompresible No Viscoso 8 asociados con cambios en la velocidad. En general, estos cambios de presi√≥n inducir√°n a cambios de densidad, los cuales influyen en el fluido. Cuando es posible que el volumen de un fluido cambie dr√°sticamente, se dice que el fluido es compresible. En este caso, las variaciones de densidad dentro del fluido no son depreciables. Algunos fluidos tienen una tasa de compresibilidad muy baja, en cuyo caso el cambio de densidad es insignificante por lo que se considera al fluido incompresible. La mayor√≠a de los gases son fluidos compresibles, mientras que los l√≠quidos, generalmente son incompresibles. Para determinar si un fluido es compresible o no, es necesario evaluar la velocidad del fluido en relaci√≥n a la velocidad del sonido en el fluido. El par√°metro utilizado para evaluar esto se denomina n√∫mero de Mach ùëÄ: ùëÄ = ùëâ/ùëê (2.1) En donde ùëÄ es la raz√≥n de la velocidad del flujo ùëâ, a la velocidad del sonido ùëê. Para que el flujo pueda ser considerado incompresible, debe cumplirse que ùëÄ < 0.3. A efectos de este trabajo de investigaci√≥n solo trabajaremos con flujo incompresible, por ser el agua, el objeto de estudio, un fluido incompresible. b) Continuidad En la naturaleza los materiales no son perfectamente continuos, sino que cada elemento que conforma un material es discreto en magnitudes de escalas muy peque√±as. Sin embargo, en los fluidos la continuidad se presenta en mayor escala. Un fluido est√° compuesto por millones de mol√©culas que interact√∫an entre s√≠ de acuerdo a un conjunto de fuerzas externas e internas. Gracias a la acci√≥n de dichas fuerzas, las mol√©culas se encuentran en constante movimiento. 9 En muchas aplicaciones de ingenier√≠a, es relevante √∫nicamente lo que ocurre a nivel global entre las mol√©culas que conforman el fluido, es decir, lo que realmente podemos percibir y visualizar. Debido a esto, se considera que el fluido est√° idealmente compuesto de una sustancia infinitamente divisible (es decir, como un continuo) y se pasa por alto el comportamiento de las mol√©culas individuales. En otras palabras, cuando analizamos el fluido externamente, la velocidad de cada mol√©cula es depreciable, por lo que podemos asumir que todas las mol√©culas tienen una velocidad media. Esta es la base de la mec√°nica de fluidos cl√°sica. Sin embargo, al analizar el fluido de cerca, ser√≠a un error asumir que todas las mol√©culas se desplazan a la misma velocidad. En este caso, la hip√≥tesis del continuo no es v√°lida. En la Figura 2.a se muestra el fluido como un continuo, pero al hacer un acercamiento en la Figura 2.b podemos apreciar las part√≠culas que se desplazan a diferentes velocidades. La hip√≥tesis de un continuo resulta v√°lida para estudiar el comportamiento de los fluidos en condiciones normales. (a) (b) Figura 2: La figura (a) muestra el fluido como un continuo. En la figura (b) se pueden apreciar las part√≠culas r√°pidas que se muestran en color amarillo (claro), las part√≠culas m√°s lentas en rojo (oscuro). Una de las consecuencias de la hip√≥tesis del continuo es que cada una de las propiedades de un fluido debe tener un valor definido en cada punto del espacio. De esta manera, propiedades como la densidad, temperatura, velocidad, etc; pueden considerarse como funciones continuas de la posici√≥n y del tiempo. Al considerar al fluido como un continuo en materia, entonces es posible estudiar sus propiedades como un continuo tambi√©n. As√≠ es posible evaluar su valor en un punto determinado en el espacio y en un momento dado, a pesar de que var√≠en constantemente en ambas. 10 c) Fluido Newtoniano y no Newtoniano Cuando no es aplicado sobre el fluido un esfuerzo cortante, no existe deformaci√≥n. Seg√∫n la relaci√≥n que existe entre el esfuerzo cortante aplicado y la rapidez de deformaci√≥n resultante, los fluidos se pueden clasificar en: ‚Ä¢ Fluidos Newtonianos: Aquellos fluidos donde el esfuerzo cortante es directamente proporcional a la rapidez de deformaci√≥n. ‚Ä¢ Fluidos no Newtonianos: Fluidos donde el esfuerzo cortante no es directamente proporcional a la rapidez de deformaci√≥n. En este caso, la deformaci√≥n depende de otros factores, como la viscosidad, por lo que cuando el fluido sea afectado por una fuerza externa se comportar√° como un s√≥lido por peque√±os instantes de tiempo. En un fluido no newtoniano la viscosidad no es constante, sino que var√≠a seg√∫n el gradiente de presi√≥n que se aplique sobre √©l. Todos los fluidos tienen un valor de viscosidad, algunos m√°s peque√±os que otros. El agua tiene un valor de viscosidad bastante bajo por lo que se considera un fluido newtoniano. El valor de viscosidad var√≠a de acuerdo a la temperatura del fluido. En la Tabla 1 podemos apreciar la variaci√≥n en el valor de viscosidad del agua a diferentes temperaturas. ùíï(ùë™¬∞) ùùÅ(ùíéùë∑ùíÇ ‚àô ùíî) 0 1,8 20 1 25 0,894 60 0,65 Tabla 1: Coeficientes de viscosidad din√°mica del agua [5]. Para este trabajo no se tomar√° en cuenta los efectos termodin√°micos de los fluidos, se asumir√° una temperatura ambiental constante de 20¬∞ y por lo tanto un valor de viscosidad de 1 ùëöùëÉùëé ‚àô ùë†. En el SI (Sistema Internacional de unidades), la unidad de viscosidad din√°mica est√° representada por ùëÉùëé ‚àô ùë†, donde ùë† representa un segundo y ùëÉùëé, una unidad de presi√≥n que recibe el nombre de pascal, la cu√°l es equivalente a un newton por metro cuadrado ùëÅ/ùëö2. El coeficienciente de viscosidad din√°mica que se presenta en un fluido homog√©neo puede entenderse como una diferencia de velocidad de un metro (ùëö) por segundo (ùë†) entre dos 11 planos paralelos separados a una distancia de un metro, el movimiento rectil√≠neo y uniforme de una superficie plana de un metro cuadrado provoca una fuerza retardatriz de un newton[5]. d) Viscosidad Si evaluamos la deformaci√≥n de dos fluidos newtonianos distintos, es probable que se deformen con diferente rapidez para una misma fuerza cortante. Esto ocurre porque la viscosidad de uno es mayor que la del otro. A mayor viscosidad, mayor ser√° la resistencia que imponga el fluido a la deformaci√≥n. La viscosidad es una manifestaci√≥n del movimiento molecular dentro del fluido. Las mol√©culas de regiones con alta velocidad global chocan con las mol√©culas que se mueven con una velocidad global menor, y viceversa. Estos choques permiten transportar cantidad de movimiento de una regi√≥n del fluido a otra (advecci√≥n). Como la energ√≠a se conserva, al chocar las mol√©culas entre s√≠, parte de la energ√≠a se transfiere de unas a otras y esto se traduce en una variaci√≥n en la velocidad y en la temperatura. Ya que los movimientos moleculares aleatorios se ven afectados por la temperatura del medio, la viscosidad resulta ser una funci√≥n de la temperatura. En la mec√°nica de fluidos se emplea muy frecuentemente la viscosidad cinem√°tica ùë£: ùë£ = ùúá ùúå (2.2) en donde ùúá es el coeficiente de viscosidad din√°mico y ùúå la densidad de la part√≠cula. Un fluido viscoso puede clasificarse como laminar o turbulento de acuerdo a la estructura interna del mismo. Se dice que es laminar cuando su estructura se caracteriza por el movimiento de l√°minas o capas, mientras que en el fluido turbulento su estructura se caracteriza por los movimientos tridimensionales aleatorios de las part√≠culas de fluido, superpuestos al movimiento promedio. En la Figura 3 se puede apreciar un fluido turbulento. 12 Figura 3: Comparaci√≥n de las formas de una llama para diferentes grados de expansi√≥n de gases. De izquierda a derecha se puede apreciar como el fluido se hace m√°s turbulento en la simulaci√≥n [6]. Dependiendo de las condiciones f√≠sicas o ambientales en las que se encuentre el agua podr√≠a comportarse como un fluido turbulento o laminar. En el caso del agua de lluvia podemos observar un comportamiento turbulento generado por la colisi√≥n de m√∫ltiples gotas de agua, sobre peque√±as masas de agua acumuladas como charcos o fluyendo por canales. Para simular esta propiedad f√≠sica se desarrollan algoritmos que tomen en cuenta propiedades como la tensi√≥n superficial, refracci√≥n de la luz, c√°ustica, entre otros. 2. Ecuaciones de Navier-Stokes A continuaci√≥n se explica el modelo te√≥rico planteado por Navier-Stokes para la simulaci√≥n de fluidos. La descripci√≥n que se incluye en este cap√≠tulo est√° basada en las notas de curso de Matthias M√ºller y Robert Bridson [7]. Claude-Louis Navier y George Gabriel Stokes desarrollaron una serie de ecuaciones en derivadas parciales no lineales que simulan el comportamiento f√≠sico de un fluido y describen el movimiento del mismo, a partir de algunos principios de conservaci√≥n de la energ√≠a mec√°nica y de la termodin√°mica. 13 a) Ecuaci√≥n del momentum Una forma sencilla de imaginar el comportamiento de un fluido es como una colecci√≥n muy grande de part√≠culas que se mueven conducidas por una serie de fuerzas externas. Para analizar como el fluido se acelera debido a la influencia de las fuerzas externas que act√∫an sobre √©l, partimos de la tercera ley de Newton F = ma, en donde ùêπ es la sumatoria de todas las fuerzas, ùëö es la masa del fluido y ùëé la aceleraci√≥n. Como ocurre con todos los cuerpos, la principal fuerza que act√∫a sobre ellos es la gravedad ÔøΩ‚ÉóÔøΩ. Esta fuerza ha de afectar a cada una de las part√≠culas que conforman el fluido. A su vez, el fluido tiene una serie de elementos que influyen directamente en su comportamiento, como son la presi√≥n y la viscosidad. As√≠ mismo, cada una de las part√≠culas que componen el fluido, ha de tener una masa ùëö, un volumen ùëâ y una velocidad ùë¢ÔøΩ‚Éó . La primera de las fuerzas que influyen en el comportamiento de un fluido es la presi√≥n, denotada por el vector ÔøΩ‚ÉóÔøΩ, el cual representa la fuerza normal de cada una de las part√≠culas del fluido. Sin embargo, lo que realmente importa es la fuerza neta en una part√≠cula, pero si la presi√≥n es igual en todas direcciones la fuerza neta ser√° cero. Por lo tanto, se considera √∫nicamente el desequilibrio de presi√≥n en una part√≠cula en donde a un lado de ella se encuentra un campo de mayor presi√≥n que en el otro. En otras palabras, ÔøΩ‚ÉóÔøΩ apunta a las zonas de baja presi√≥n y es contraria a aquellas de alta presi√≥n. Una manera de medir este desbalance en la presi√≥n es tomando el gradiente negativo de la presi√≥n ‚àí‚àáÔøΩ‚ÉóÔøΩ. As√≠ podremos destacar aquellos puntos en donde la presi√≥n var√≠a entre regiones de alta presi√≥n a regiones de baja presi√≥n. Las regiones de alta presi√≥n de un fluido han de desplazar a aquellas de menor presi√≥n. Para obtener la fuerza de presi√≥n es necesario multiplicar por el volumen ùëâ de cada part√≠cula: ‚àíùëâ‚àáÔøΩ‚ÉóÔøΩ. Otra de las fuerzas que tienen que ver con el comportamiento del fluido es la viscosidad ÔøΩ‚ÉóÔøΩ, la cual permite a un fluido resistirse a la deformaci√≥n, en mayor o menor medida. Esta fuerza intenta hacer que el movimiento de cada part√≠cula se acerque a la velocidad promedio de las part√≠culas cercanas. El operador diferencial Laplaciano ‚àá ‚àô ‚àá medir√° qu√© tanto dista la velocidad de una part√≠cula en relaci√≥n con el promedio. Al aplicarlo al coeficiente de viscosidad din√°mico ùúá y multiplicarlo por el volumen de cada part√≠cula obtenemos la fuerza de viscosidad ùëâùúá‚àá ‚àô ‚àáùë¢ÔøΩ‚Éó . De esta manera, podemos reescribir la ecuaci√≥n de Newton de la siguiente manera: 14 ùêπ = ùëöùëé = ùëöÔøΩ ùúïùë¢ÔøΩ‚Éó ùúïùë° ÔøΩ = (ùëöÔøΩ‚ÉóÔøΩ ‚àí ùëâ‚àáÔøΩ‚ÉóÔøΩ + ùëâùúá‚àá ‚àô ‚àáùë¢ÔøΩ‚Éó ) (2.3) Si se toma un n√∫mero muy peque√±o de part√≠culas la aproximaci√≥n puede tener muchos errores. Por esta raz√≥n la cantidad de part√≠culas tiende a infinito y el tama√±o de ellas tiende a cero. Sin embargo, esto har√≠a que el volumen y la masa de las part√≠culas tambi√©n tiendan a cero. Para evitar este problema se divide toda la ecuaci√≥n por el volumen ùëâ. Tomando en cuenta que la densidad ùúå = ùëö ùëâ se tiene que: ùúå ÔøΩ ùúïùë¢ÔøΩ‚Éó ùúïùë° ÔøΩ = (ùúåÔøΩ‚ÉóÔøΩ ‚àí ‚àáÔøΩ‚ÉóÔøΩ + ùúá‚àá ‚àô ‚àáùë¢ÔøΩ‚Éó ) (2.4) Ahora se divide por la densidad y se reordenan los t√©rminos: ÔøΩ ùúïùë¢ÔøΩ‚Éó ùúïùë° ÔøΩ + 1 ùúå ‚àáÔøΩ‚ÉóÔøΩ = ÔøΩ‚ÉóÔøΩ + ùúá ùúå ‚àá ‚àô ‚àáùë¢ÔøΩ‚Éó (2.5) Para simplificar esto se define la viscosidad cinem√°tica como ùë£ = ùúá ùúå‚ÅÑ y se obtiene la ecuaci√≥n del momentum: ÔøΩ ùúïùë¢ÔøΩ‚Éó ùúïùë° ÔøΩ + 1 ùúå ‚àáÔøΩ‚ÉóÔøΩ = ÔøΩ‚ÉóÔøΩ + ùë£‚àá ‚àô ‚àáùë¢ÔøΩ‚Éó (2.6) Sin embargo, para obtener la forma tradicional de la ecuaci√≥n del momentum de Navier- Stokes se debe agregar el material derivativo a la ecuaci√≥n. Para ello es necesario comprender los dos enfoques existentes en el estudio del comportamiento del fluido: el enfoque lagrangiano y el enfoque euleriano. En el enfoque euleriano el fluido se estudia desde un punto fijo externo al fluido. Los elementos del fluido (como densidad, temperatura, velocidad, etc.) son medidos en aquellos puntos que van cambiando en el tiempo en ubicaciones fijas en el espacio. El enfoque euleriano considera al fluido como un todo, en lugar de estudiar el comportamiento aislado de cada part√≠cula. 15 El enfoque lagrangiano estudia al fluido como un sistema de part√≠culas, en donde cada mol√©cula del fluido se trata como una part√≠cula. Cada una de estas part√≠culas tiene sus propios valores de densidad, temperatura, etc. La clave para conectar ambos puntos de vista es el material derivativo. En el punto de vista lagrangiano, cada part√≠cula tiene su posici√≥n ÔøΩ‚ÉóÔøΩ y su velocidad ùë¢ÔøΩ‚Éó . Si queremos determinar el valor de alg√∫n elemento ùëû de manera general (ùëû puede ser temperatura, velocidad, densidad, etc.) simplemente evaluamos la funci√≥n ùëû en el tiempo y el espacio: ùëû(ùë°, ÔøΩ‚ÉóÔøΩ), as√≠ podemos considerar a ùëû una variable euleriana. Por otro lado, cada part√≠cula tiene un valor para ùëû. Para saber que tan r√°pido cambia ùëû en cada part√≠cula tomamos la derivada de ùëû: ùëë ùëëùë° ùëû(ùë°, ÔøΩ‚ÉóÔøΩ) = ùúïùëû ùúïùë° + ‚àáùëû ‚àô ùëëÔøΩ‚ÉóÔøΩ ùëëùë° (2.7) ùëë ùëëùë° ùëû(ùë°, ÔøΩ‚ÉóÔøΩ) = ùúïùëû ùúïùë° + ‚àáùëû ‚àô ùë¢ÔøΩ‚Éó ‚â° ùê∑ùëû ùê∑ùë° (2.8) El primer t√©rmino, ùúïùëû ùúïùë°‚ÅÑ indica que tan r√°pido cambia ùëû en el tiempo (medida euleriana), mientras que el segundo t√©rmino indica cu√°nto est√° cambiando de manera general. De esta manera, podemos ver como ùëû se mueve en funci√≥n de un campo de velocidad ùë¢ÔøΩ‚Éó . Esto es conocido como advecci√≥n o transporte. Si evaluamos la ecuaci√≥n de advecci√≥n en la velocidad, veremos al vector ùë¢ÔøΩ‚Éó aparecer dos veces, como el campo de velocidad que est√° moviendo al fluido y como el valor ùëû que est√° siendo movido. Tenemos as√≠ la advecci√≥n de la velocidad ùë¢ÔøΩ‚Éó = (ùë¢,ùë£,ùë§). ùê∑ùë¢ÔøΩ‚Éó ùê∑ùë° = ÔøΩ ùê∑ùë¢ ùê∑ùë°‚ÅÑ ùê∑ùë£ ùê∑ùë°‚ÅÑ ùê∑ùë§ ùê∑ùë°‚ÅÑ ÔøΩ = ÔøΩ ùúïùë¢ ùúïùë°‚ÅÑ + ùë¢ÔøΩ‚Éó ‚àô ‚àáùë¢ ùúïùë£ ùúïùë°‚ÅÑ + ùë¢ÔøΩ‚Éó ‚àô ‚àáùë£ ùúïùë§ ùúïùë°‚ÅÑ + ùë¢ÔøΩ‚Éó ‚àô ‚àáùë§ ÔøΩ = ùúïùë¢ÔøΩ‚Éó ùúïùë° + ùúïùë¢ÔøΩ‚Éó ‚àô ‚àáùë¢ÔøΩ‚Éó (2.9) 16 Se agrega el t√©rmino de la advecci√≥n de la velocidad que indica la cantidad de velocidad cambiante a la Ecuaci√≥n 2.6 y as√≠ se obtiene la ecuaci√≥n tradicional del momentum planteada por Navier-Stokes con el material derivativo, v√°lida para ambos enfoques: ùúïùë¢ÔøΩ‚Éó ùúïùë° + ùë¢ÔøΩ‚Éó .‚àáùë¢ÔøΩ‚Éó + 1 ùúå ‚àáùëù = ÔøΩ‚ÉóÔøΩ + ùë£‚àá.‚àáùë¢ÔøΩ‚Éó (2.10) b) Incompresibilidad A√∫n cuando ning√∫n fluido es netamente incompresible, para efectos de animaci√≥n y simulaci√≥n se asume que todos lo son por razones de simplicidad. Supongamos que tomamos un trozo de fluido en un instante de tiempo. Al volumen de este trozo le llamamos y a su superficie l√≠mite ùúï‚Ñ¶. Si medimos que tan r√°pido el volumen de este trozo est√° cambiando, integramos la componente normal de su velocidad a su alrededor: ùëë ùëëùë° ùëâùëúùëôùë¢ùëöùëí(‚Ñ¶) = ÔøΩ ùë¢ÔøΩ‚Éó ‚àô ùëõÔøΩ ùúï‚Ñ¶ (2.11) En un fluido incompresible, el volumen ha de permanecer constante, por lo tanto su tasa de cambio debe ser cero. ÔøΩ ùë¢ÔøΩ‚Éó ‚àô ùëõÔøΩ ùúï‚Ñ¶ = 0 (2.12) Por el Teorema de Divergencia: ÔøΩ ‚àá ‚àô ùë¢ÔøΩ‚Éó ‚Ñ¶ = 0 (2.13) 17 Esta ecuaci√≥n debe cumplirse para alg√∫n que forme parte del fluido, y la integral de una constante es la constante misma. Tenemos as√≠ la condici√≥n de incompresibilidad de Navier- Stokes: ‚àá.ùë¢ÔøΩ‚Éó = 0 (2.14) 3. Smoothed Particle Hydrodynamics El m√©todo Smoothed Particle Hydrodynamics (SPH) es un m√©todo lagrangiano que, entre otras aplicaciones, es com√∫nmente utilizado para representar fluidos en movimientos. De esta forma, el mallado que representa el fluido no es una red fija o est√°tica sino que se mueve de acuerdo al comportamiento del fluido. El SPH trabaja dividiendo el fluido en un conjunto de elementos discretos llamados part√≠culas. Esto es gobernado por una funci√≥n kernel ùëä, la cual incluye com√∫nmente la funci√≥n Gaussiana y un spline c√∫bico (los kernels m√°s habituales son funciones exponenciales o splines). Esta √∫ltima funci√≥n es exactamente igual a cero para las part√≠culas m√°s all√° de dos longitudes de suavizado (a diferencia de la de Gauss, donde hay una peque√±a contribuci√≥n a cualquier distancia finita). Esto es una ventaja desde el punto de vista computacional, ya que la contribuci√≥n de las part√≠culas distantes no son tomadas en cuenta al considerarse irrelevantes. Figura 4: Modelo computacional Smoothed Particle Hydrodynamics (a). Algunas part√≠culas y su n√∫cleo de inferencia con el radio ùíâ (b). h kernel (a) (b) 18 Las contribuciones de cada part√≠cula a una propiedad se ponderan de acuerdo a su distancia en relaci√≥n a la part√≠cula de inter√©s, y su densidad. Estas part√≠culas tienen una distancia espacial conocida como longitud de suavizado, representada t√≠picamente en las ecuaciones con la variable ‚Ñé. Esto significa que la cantidad f√≠sica de una part√≠cula puede ser obtenida por la sumatoria de las propiedades relevantes de todas las part√≠culas que se encuentran dentro del rango del kernel[8], tal como se indica en la Figura 4. En analog√≠a con la interpolaci√≥n mediante elementos finitos, la aproximaci√≥n espacial en el m√©todo SPH original puede escribirse en t√©rminos de ‚Äúfunciones de forma SPH‚Äù. Esta aproximaci√≥n se construye a partir del concepto de estimaci√≥n ‚Äútipo kernel‚Äù (kernel estimate), inspirada por la siguiente propiedad de la funci√≥n delta de Dirac [9]: ùë¢(ùíô) = ÔøΩ ùë¢(ùíö)ùõø(ùíô ‚àí ùíö)ùëëùõ∫ ùíö‚ààùõ∫ (2.15) La estimaci√≥n kernel ‚å©ùë¢(ùíô)‚å™ de una cierta funci√≥n ùë¢(ùíô) se define como: ‚å©ùë¢(ùíô)‚å™ = ÔøΩ ùë¢(ùíö)ùëä(ùíô ‚àí ùíö,ùùÜ)ùëëùõ∫ ùíö‚ààùõ∫ (2.16) y su correlato SPH discreto, ùë¢ÔøΩ(ùíô), es: ùë¢ÔøΩ(ùíô) = ÔøΩùë¢ùëóùëä(ùë• ‚àí ùë•ùëó , ‚Ñé)ùëâùëó ùëõ ùëó=1 (2.17) d√≥nde ùõ∫ es el dominio del problema, discretizado en un conjunto de ùëõ nodos o part√≠culas, ùëä(ùë• ‚àí ùë•ùëó ,‚Ñé) es un kernel o funci√≥n de suavizado (smoothing function) centrado en la part√≠cula ùëó y ùëâùëó es el volumen asociado a la part√≠cula ùëó y ùúå la densidad. An√°logamente a lo que ocurre en el m√©todo de elementos finitos, la aproximaci√≥n dada por (2.17) puede escribirse en t√©rminos de ‚Äúfunciones de forma SPH‚Äù, de la forma [7]: 19 ùë¢ÔøΩ(ùíô) = ÔøΩùë¢ùëóùëÅùëó(ùíô) ùëõ ùëó=1 (2.18) ùëÅùëó(ùíô) = ùëäÔøΩùë• ‚àí ùë•ùëó ,ùúåÔøΩùëâùëó (2.19) El gradiente de ùë¢ÔøΩ(ùíô) puede evaluarse como: ‚àáùíôùë¢ÔøΩ(ùíô) = ÔøΩùë¢ùëó‚àáùíôùëÅùëó(ùíô) ùëõ ùëó=1 = ÔøΩùë¢ùëó‚àáùíôùëäùëó(ùíô) ùëõ ùëó=1 ùëâùëó (2.20) En la pr√°ctica, suelen emplearse expresiones alternativas para calcular ‚àáùíôùë¢ÔøΩ(ùíô), imponi√©ndose determinadas propiedades de conservaci√≥n en las ecuaciones discretas. An√°logamente a lo expuesto m√°s arriba se podr√≠an obtener estimaciones de las derivadas de orden superior de la funci√≥n. N√≥tese que los valores reconstruidos de la funci√≥n ùë¢(ùë•) y sus derivadas en un determinado punto se obtienen empleando solamente los valores de dicha funci√≥n en nodos vecinos y cierta informaci√≥n de ‚Äúbajo nivel‚Äù acerca de la distribuci√≥n de nodos (distancias entre nodos), sin referencia alguna a una estructura de datos tipo malla. La ecuaci√≥n para cualquier cantidad ùê¥ en cualquier punto ùë• est√° dada por: ùê¥(ùë•) = ÔøΩùëöùëó ùê¥ùëó ùúåùëó ùëäÔøΩÔøΩùë• ‚àí ùë•ùëóÔøΩ,‚ÑéÔøΩ ùëó (2.21) donde ùëöùëó es la masa de la part√≠cula ùëó y ùúåùëó es su densidad, ùê¥ùëó es el valor de cantidad ùê¥ en la part√≠cula ùëó, ùë• es la posici√≥n de cada part√≠cula y W es la funci√≥n kernel. La resoluci√≥n del m√©todo se puede ajustar f√°cilmente a otras variables como la densidad. Por ejemplo, la densidad de una part√≠cula podemos obtenerla a trav√©s de: ùúå(ùë•) = ÔøΩÔøΩùëöùëó ÔøΩùëäÔøΩÔøΩùë• ‚àí ùë•ùëóÔøΩÔøΩÔøΩ ùëó (2.22) 20 As√≠, la densidad ùúåùëñ de una part√≠cula ùëñ es simplemente ùúåùëñ = ùúå(ùë•ùëñ) y puede ser expresada como: ùúåùëñ = ÔøΩÔøΩùëöùëó ùúåùëó ùúåùëó ùëäÔøΩÔøΩùë• ‚àí ùë•ùëóÔøΩ,‚ÑéÔøΩÔøΩ ùëó = ÔøΩÔøΩùëöùëóùëäÔøΩùë• ‚àí ùë•ùëó ,‚ÑéÔøΩÔøΩ ùëó (2.23) Del mismo modo, la derivada espacial de una cantidad se puede obtener mediante la integraci√≥n por partes del gradiente para la cantidad f√≠sica de la funci√≥n kernel. Una de las ventajas de esta formulaci√≥n es que el gradiente de un kernel se puede calcular f√°cilmente mediante la sustituci√≥n del kernel por el gradiente del mismo: El m√©todo SPH es muchas veces preferido antes que las tradicionales t√©cnicas basadas en malla por las ventajas que tiene sobre estos. En principio, garantiza la conservaci√≥n de masa sin la necesidad de hacer c√°lculos extras, debido a que las part√≠culas representan la masa en s√≠ mismas. Adem√°s, podemos calcular la presi√≥n a partir de la contribuci√≥n en peso proveniente de las part√≠culas vecinas sin necesidad de resolver un sistema lineal de ecuaciones. Finalmente, a diferencia de los m√©todos basados en malla que deben realizar un seguimiento del fluido de las fronteras, SPH crea una superficie libre de los fluidos que interact√∫an en dos fases directamente, las part√≠culas que representan el fluido m√°s denso (normalmente agua) y el espacio vac√≠o que constituye el fluido m√°s ligero (por lo general aire). Por esta raz√≥n es posible utilizar SPH para simular movimiento de fluidos en tiempo real. Al igual que en los m√©todos basados en malla, SPH requiere de alguna t√©cnica que permita generar una superficie geom√©trica, usando alguna t√©cnica de poligonizaci√≥n como Marching Cubes [10], como se puede ver en la Figura 5. En desventaja con los m√©todos basados en malla, SPH requiere de una gran cantidad de part√≠culas para producir simulaciones equivalentes en resoluci√≥n a las basadas en malla, de las cuales muchas no han de ser renderizadas. Por esta raz√≥n, el m√©todo SPH es preferido antes que las t√©cnicas basadas en malla, en aquellas aplicaciones en donde la interactividad tiene m√°s importancia que la exactitud. ‚àáùê¥ùë†(ùë•) = ÔøΩùëöùëó ùê¥ùëó ùúåùëó ‚àáùëäÔøΩÔøΩùë• ‚àí ùë•ùëóÔøΩ,‚ÑéÔøΩ ùëó (2.24) 21 Figura 5: Remolino en un vaso producido por un campo de fuerza de rotaci√≥n[8]. La imagen (a) muestra las part√≠culas. La imagen (b) muestra la superficie renderizada con la t√©cnica point splatting y la imagen (c) muestra la superficie triangulada con Marching Cubes. Aunque el tama√±o de la longitud de suavizado se puede fijar en el espacio y el tiempo, esto no se aprovecha al m√°ximo en SPH. La resoluci√≥n de la simulaci√≥n puede ser adaptada autom√°ticamente a s√≠ misma dependiendo de las condiciones locales, mediante la asignaci√≥n a cada part√≠cula de su longitud de suavizado propia y par√°metros de variaci√≥n en el tiempo. Por ejemplo, en una zona muy densa donde varias part√≠culas est√°n muy cerca una de otra la longitud de suavizado puede hacerse relativamente corta, obteniendo una alta resoluci√≥n espacial. Por el contrario, en regiones de baja densidad donde las part√≠culas individuales est√°n bien apartadas y la resoluci√≥n es baja, la longitud de suavizado puede incrementarse optimizando los c√°lculos en la regi√≥n de inter√©s. Conjuntamente con la ecuaci√≥n de estado y un integrador, SPH puede simular flujos hidrodin√°micos eficientemente. Sin embargo, la formulaci√≥n de viscosidad artificial tradicionalmente usada en SPH tiende a disminuir los choques y la discontinuidad del contacto mucho m√°s que los esquemas basados en malla. 22 CAP√çTULO III. Simulaci√≥n de aguas de lluvia utilizando PhysX En este cap√≠tulo explicaremos todo lo relacionado a la simulaci√≥n del fluido con PhysX y otros detalles relevantes de la construcci√≥n de la escena. As√≠ mismo se mencionar√°n aspectos generales de las precipitaciones que han de ser tomados en cuenta para simular aguas de lluvia. 1. Lluvias En el √°rea de la meteorolog√≠a, la precipitaci√≥n es cualquier forma de hidrometeoro que cae del cielo en forma de lluvia, llovizna, nieve o granizo y llega a la tierra. La cantidad de precipitaci√≥n sobre un punto de la superficie terrestre es llamada pluviosidad, o monto pluviom√©trico[11]. Seg√∫n la definici√≥n oficial de la Organizaci√≥n Meteorol√≥gica Mundial[12] la lluvia es la precipitaci√≥n de part√≠culas l√≠quidas de agua, de di√°metro mayor de 0,5 mm o de gotas menores, pero muy dispersas. Cuando el agua se condensa, producto de la evaporaci√≥n, se acumulan en forma de nubes de vapor de agua que, al saturarse caen en forma de precipitaci√≥n. La precipitaci√≥n se mide en mil√≠metros de agua, o litros ca√≠dos por unidad de superficie (m¬≤), lo que es equivalente al agua que se acumular√≠a en una superficie horizontal e impermeable de 1 metro cuadrado durante el tiempo que dure la precipitaci√≥n. N√≥tese que hay dos elementos primordiales en la medici√≥n de la pluviosidad: La intensidad y la duraci√≥n de la lluvia. Ambos est√°n asociados por el hecho de que durante un mismo per√≠odo de tiempo, al aumentarse la duraci√≥n de la lluvia disminuye su intensidad media. Dicho de otra forma, si estudiamos dos precipitaciones diferentes pero de la misma magnitud y ocurridas en el mismo tiempo de retorno, la intensidad media aumentar√° cuanto menor sea la duraci√≥n de dicha precipitaci√≥n. Dicha formulaci√≥n se conoce como Curvas IDF (Intensidad-Duraci√≥n- Frecuencia), las cuales son determinadas, para cada sitio particular, con procedimientos estad√≠sticos basados en observaciones de larga duraci√≥n [13]. Las precipitaciones en Venezuela var√≠an de acuerdo a la distribuci√≥n espacial (hay regiones del pa√≠s en donde la intensidad de precipitaci√≥n es mayor que en otras) y al per√≠odo del a√±o (per√≠odo de lluvias o de sequ√≠a). Incluso pueden verse afectadas por fen√≥menos atmosf√©ricos que alteran la intensidad de precipitaci√≥n normal con respecto a la √©poca del a√±o. 23 En per√≠odo lluvioso (Junio y Julio) las precipitaciones pueden superar incluso los 600mm en la cuenca alta del Caron√≠, mientras que en la temporada de sequ√≠a (Febrero y Marzo) la mayor parte del pa√≠s presenta una media de precipitaci√≥n menor a los 50mm [14]. Para este trabajo se tomaran en cuenta precipitaciones desde los 50mm hasta los 200mm, lo equivalente a la media de precipitaci√≥n a nivel nacional durante el tiempo de transici√≥n entre los per√≠odos de lluvia y sequ√≠a. 2. Simulaci√≥n de lluvia con PhysX PhysX surgi√≥ como un chip capaz de elaborar simulaciones f√≠sicas que por su complejidad no pueden ser realizadas por un CPU en tiempo real. Este fue creado por la compa√±√≠a AGEIA Technologies, la cual posteriormente fue comprada por Nvidia Corporation, y es cuando se le da realmente inter√©s a la aceleraci√≥n de f√≠sica por hardware. Esta conocida empresa estadounidense fabricante de procesadores gr√°ficos, incluy√≥ esta tecnolog√≠a en sus tarjetas gr√°ficas de la serie GeForce 8000 en adelante. El procesador PhysX puede ser programado para la mayor√≠a de c√°lculos de la f√≠sica cl√°sica a trav√©s del PhysX SDK, el cual incluye: gravedad, colisiones, presi√≥n, tensi√≥n, deformaciones, etc. El API de PhysX ofrece tecnolog√≠a de simulaci√≥n para un n√∫mero arbitrario de escenas de la f√≠sica. En particular con la f√≠sica de fluidos tenemos dos alternativas: ‚Ä¢ Creaci√≥n volum√©trica de fluidos. ‚Ä¢ PhysX FX, que utiliza sistemas de part√≠culas inteligentes que permiten simular el fuego, el humo y la niebla de una manera natural, como el humo encerrado en una habitaci√≥n que se eleva hasta el techo, llen√°ndola por completo hasta que se filtre por las ventanas. Para utilizar PhysX se emplea el PhysX SDK (Software Development Kit), el cual est√° implementado en C++, e internamente est√° organizado como una jerarqu√≠a de clases, ver [15]. Cada clase tiene una clase base abstracta, desde donde el usuario puede usar una serie de funcionalidades de acceso, implementadas en el descriptor (la clase concreta). Adem√°s, algunas funciones de utilidad se exportan como funciones de C. Las clases de interfaz han de seguir algunas convenciones de codificaci√≥n: 24 ‚Ä¢ Todas las clases tienen un archivo de cabecera con el mismo nombre de archivo del nombre de la clase ‚Ä¢ Los tipos y las clases comienzan con una letra may√∫scula ‚Ä¢ Las clases de interfaz siempre empiezan con ‚ÄúNx‚Äù ‚Ä¢ Los m√©todos y variables comienzan con letras min√∫sculas ‚Ä¢ Los valores de retorno y par√°metros en lugares donde el valor es NULL, son aceptables si el c√≥digo utiliza sintaxis de apuntadores (*) ‚Ä¢ Los valores de retorno y par√°metros en lugares donde el valor es NULL, son inaceptables si el c√≥digo utiliza sintaxis de referencia (&) ‚Ä¢ Si alguna funcionalidad definida por el usuario depende de la ejecuci√≥n, es necesario implementar una interfaz para este prop√≥sito (por ejemplo el manejo de memoria). La clase NxPhysicsSDK es una clase abstract singleton factory usada para instanciar objetos y acceder variables globales que sean afectadas en diferentes clases. Para tener acceso a esta clase debe invocarse el m√©todo NxCreatePhysicsSDK() de la siguiente forma: NxPhysicsSDK * myWorld = NxCreatePhysicsSDK(NX_PHYSICS_SDK_VERSION); Para cada simulaci√≥n es necesario crear una escena, es decir, una instancia de la clase NxScene(). Una escena es una colecci√≥n de cuerpos, fuerzas y efectos que interact√∫an entre s√≠. La escena simula el comportamiento de los objetos presentes en ella en el tiempo. Pueden existir varias escenas al mismo tiempo pero cada cuerpo, fuerza o efecto es espec√≠fico a una escena, no puede ser compartido. PhysX Fluids permite la simulaci√≥n de l√≠quidos y gases utilizando un sistema de part√≠culas y emisores, utilizando el m√©todo SPH (Smoothed Particle Hydrodynamics) o sistemas de part√≠culas simples. En este √∫ltimo caso no se le da al usuario la posibilidad de controlar la simulaci√≥n, es decir, la simulaci√≥n se rige por un comportamiento f√≠sico y no ha de ser una simulaci√≥n guiada para animaci√≥n [1]. Para este trabajo utilizamos el m√©todo SPH para la simulaci√≥n puesto que lo que queremos es el comportamiento f√≠sico del agua. Una escena puede tener varios tipos objetos, entre ellos los fluidos como se muestra en la Figura 6. 25 Figura 6: Diagrama de la arquitectura de PhysX SDK a) Creaci√≥n del fluido Existen dos maneras de crear fluidos. Es posible generar un sistema de part√≠culas para simular el fluido a trav√©s de un emisor (emitter) o simplemente instanciar las part√≠culas con sus par√°metros inicializados. Para eliminar las part√≠culas es posible absorber el fluido restante a trav√©s de un drenaje (drain) o darles un tiempo de vida a cada part√≠cula. La Figura 7 ilustra el ciclo de vida de un fluido generado por el emisor y absorbido por un drenaje. Figura 7: Comportamiento de un fluido utilizando emisores y drenajes. En este trabajo la creaci√≥n de los fluidos se hace a partir de emisores para simular con m√°s precisi√≥n el origen de las precipitaciones a partir de la condensaci√≥n y saturaci√≥n de vapor de agua en una nube. Adem√°s el emisor permite la emisi√≥n constante de part√≠culas del fluido, manteniendo el mismo n√∫mero de part√≠culas por cada frame de la simulaci√≥n. Esta tasa puede NxScene PhysX SDK NxActor NxJoint NxFluid NxCloth NxSoftBody NxForceField Varios tipos de mallado: ‚Ä¢ Convex (Convexa) ‚Ä¢ Triangle Mesh (Mallado triangular) ‚Ä¢ HeightField (Mapa de altura) ‚Ä¢ Cloth (Telas) ‚Ä¢ SoftBody (Cuerpos blandos) NxShape Referencia Instancia Emisor Drenaje 26 ser ajustada din√°micamente, modificando en tiempo de ejecuci√≥n el estado del atributo NxFluidEmitterDesc::rate. El emitter est√° asociado directamente a un shape, al cual se le adjunta un emitter, es decir, tendr√° las propiedades y el comportamiento de un emitter. El emitter tendr√° un frameShape, un apuntador al actor NxShape al cual el emitter est√° asociado. En este caso el shape asociado es un NxBoxShape cuya dimensi√≥n ser√° un poco m√°s grande que el √°rea del techo, la idea es que la ‚Äúnube‚Äù simulada por el emitter cubra la estructura en su totalidad. Los drains no son objetos propiamente dichos, son shapes con la bandera NX_SF_FLUID_DRAIN aplicada al atributo NxShapeDesc::shapeFlags, causando que las part√≠culas colisionen con ellos para ser removidas de la simulaci√≥n. Un drain puede tomar la forma de cualquier primitiva de PhysX. Los drains son un m√©todo importante para mantener el conteo de las part√≠culas y su difusi√≥n bajo control. Los drains han de situarse en la zona alrededor de la cual las part√≠culas del fluido deben detenerse, para evitar que sigan expandi√©ndose de manera innecesaria contrarrestando el rendimiento. Idealmente el agua de lluvia colectada por un sistema de drenes y canaletas debe ser dirigida a un sistema de drenaje de aguas de lluvias a trav√©s de canales separados de las aguas servidas. Su disposici√≥n final debe ser una planta potabilizadora o cualquier curso natural de aguas no contaminado [16]. El conocimiento de las lluvias intensas, de corta duraci√≥n, es muy importante para dimensionar el drenaje urbano, y as√≠ evitar inundaciones en los centros poblados. Adem√°s si el agua de lluvia no es drenada correctamente, m√°s all√° de lo que ocurre en los techos y de las inundaciones que puedan suscitarse, el agua ser√° absorbida por el suelo, da√±ando las capas asf√°lticas o erosionando el suelo donde est√°n los cimientos de las edificaciones y provocar hundimientos o derrumbes. Sin embargo, este trabajo no contempla el sistema de drenaje de las aguas de lluvia m√°s all√° de lo pertinente a una edificaci√≥n. Solo se est√° considerando el drenado del agua de lluvia de un techo a trav√©s de un sistema de canaletas o drenes. 27 3. Actores de PhysX PhysX cuenta con una clase para crear los diferentes elementos que ser√°n parte de la escena. Estos son los actores, instancias de la clase NxActor, el objeto principal en la simulaci√≥n de Physics SDK, los cuales son instanciados y est√°n contenidos por la escena como puede apreciarse en la Figura 6. Los actores (NxActors) no son m√°s que geometr√≠as a la cuales se le a√±aden ciertas propiedades para que puedan interactuar de acuerdo a las leyes f√≠sicas implementadas por el motor de PhysX. Un actor puede opcionalmente encapsular el comportamiento de un cuerpo r√≠gido din√°mico al agregarle un cuerpo al descriptor del actor en el momento en que es creado, de lo contrario el actor ser√° un objeto est√°tico, fijo en el espacio. Para este trabajo se utilizan solo objetos est√°ticos. Cada actor est√° asociado a una forma (NxShape) a partir de la cual se hace la detecci√≥n de colisiones, lo que hace PhysX es asegurarse de que una forma no intercepte a otra. PhysX SDK simula las formas de acuerdo a leyes f√≠sicas que sostienen que, un cuerpo puede ser representado perfectamente por una tensi√≥n de inercia y un punto de masa localizado en el centro de masa del objeto. a) Creaci√≥n del Actor Para crear un actor se hace una llamada a NxScene::createActor(), al cual se le asignar√° luego un descriptor NxActorDesc que salva el estado del actor, luego se crea un NxActorDescBase sobre quien se configuran todas las propiedades relativas del actor. Algunos de los atributos importantes en NxActorDescBase son: ‚Ä¢ globalPose: Indica la posici√≥n del actor en coordenadas de mundo. ‚Ä¢ body: Es un atributo de tipo NxBodyDesc que determina el tipo de actor (est√°tico o din√°mico). Si el actor es est√°tico su valor ser√° nulo. ‚Ä¢ density: Densidad del actor utilizada en el c√°lculo masa/inercia. ‚Ä¢ flags: Conjunto de banderas que pueden ser activada a trav√©s de un NxActorFlags para activar algunas propiedades de los actores. Dependiendo del tipo de NxShape asociado al actor ser√° necesario configurar algunos otros par√°metros relativos a su forma. Para eliminar un actor se llama a NxScene::releaseActor(). 28 CAP√çTULO IV. Fundamentos Arquitect√≥nicos para Sistemas de Techos y Canaletas En este cap√≠tulo describiremos, de manera general, los aspectos m√°s resaltantes en la construcci√≥n de un sistema de techos y algunos de los elementos que permiten drenar el agua de lluvia. El sistema de techo funciona como el elemento primario de resguardo para los espacios interiores de un edificio. La forma y la inclinaci√≥n del techo deben ser compatibles con el tipo de techumbre que se usa para desviar el agua pluvial hacia un sistema de canaletas y desag√ºes. 1. Terminolog√≠a de Techos ‚Ä¢ Cumbrera o brocal de techo: Es la l√≠nea horizontal de intersecci√≥n de la parte superior de dos planos inclinados de un techo. ‚Ä¢ Voladizo: Es la parte de techo que sobresale a una pared externa o pared maestra en una estructura o edificaci√≥n. ‚Ä¢ Alero: Es el borde inferior en voladizo de un techo. Tambi√©n existen aleros inclinados, que corresponden a la orilla inclinada, generalmente proyectante, de un techo inclinado. 2. Detalles Arquitect√≥nicos de Implementaci√≥n Los techos pueden ser clasificados seg√∫n su morfolog√≠a de la siguiente manera: ‚Ä¢ Techos planos: Requieren un material de techumbre continuo de membrana y no llevan revestimiento. Los techos planos deben tener una inclinaci√≥n hacia los drenes del techo que se ubican en los puntos inferiores y que pueden conectarse al sistema de drenaje pluvial del edificio. La pendiente m√≠nima recomendada es de 1:50, lo cual ser√≠a equivalente a un √°ngulo de 1,15¬∞ con respecto a los muros. 29 ‚Ä¢ Techos Inclinados: Descargan f√°cilmente el agua pluvial a las canaletas de los aleros. La altura y el √°rea de un techo inclinado aumentan con sus dimensiones horizontales, lo que permite clasificarlos en techos de baja pendiente (hasta 3:12) o techos de pendiente media ‚Äì alta (4:12 a 12:12), de acuerdo a una proporci√≥n elevaci√≥n ‚Äì longitud. Para este trabajo solo se tomar√°n en cuenta las escalas indicadas en la Tabla 2: Tipo de Techo Inclinado Proporci√≥n Equivalente en √°ngulos Baja Pendiente 3:12 14¬∞ Pendiente media a alta 4:12 18¬∞ 7:12 30¬∞ 12:12 45¬∞ Tabla 2: Pendientes est√°ndar en techos inclinados [17]. La pendiente del techo afecta la elecci√≥n del material con que ha de hacerse el mismo. Las pendientes medias o altas pueden llevar revestimiento de tejas de madera o baldosas, o materiales en hoja para techumbre corrugada, como l√°minas de zinc, losacero, etc. En el caso de las pendientes bajas es necesario un techado prearmado o preparado de membrana continua. Se pueden usar tejas de madera o materiales en hoja para pendientes de 3:12. ‚Ä¢ Techos a dos aguas: El techo se divide en dos partes iguales que se inclinan hacia abajo a partir de una cumbrera central o brocal de techo. ‚Ä¢ Techos a cuatro aguas: Tienen extremos inclinados y lados que se intersecan en un √°ngulo inclinado que se proyecta. Existen otras variedades en la morfolog√≠a de los sistemas de techos, sin embargo, las antes mencionadas son las m√°s sencillas y comunes. Para este trabajo solo se considerar√°n techos planos, techos inclinados y techos a dos aguas. 30 3. M√©todos de c√°lculo para aguas de lluvia La cantidad de lluvia que un techo y su sistema de drenaje deben manejar es una funci√≥n de: el √°rea de techado que conduce a los drenes o a las canaletas del techo y la frecuencia y la intensidad de precipitaci√≥n de acuerdo a la regi√≥n. La precipitaci√≥n se mide en mil√≠metros de agua, o litros ca√≠dos por unidad de superficie (ùëö¬≤), es decir, la altura de la l√°mina de agua recogida en una superficie plana es medida en mm o ùëô/ùëö¬≤. N√≥tese que un mil√≠metro de agua de lluvia equivale a 1 ùëô de agua por ùëö¬≤. La cantidad de lluvia que cae en un lugar se mide con un instrumento llamado pluvi√≥metro y se expresa en mil√≠metros de agua. La intensidad de precipitaci√≥n puede ser entendida como la velocidad del caudal, siendo que la velocidad se expresa como ùëâ = ùë• ùë°ÔøΩ podr√≠amos decir que, la cantidad de agua que se acumular√≠a en una superficie horizontal e impermeable ùê¥ de 1 ùëö¬≤ por 100mm de altura ùë•, durante el tiempo ùë° que dure la precipitaci√≥n. En otras palabras, si tenemos una precipitaci√≥n de 100 mm/hora, ser√≠a equivalente a llenar en una hora una caja de 1 ùëö¬≤ por 100mm de altura. El c√°lculo de la cantidad de lluvia depende de la duraci√≥n y la intensidad de la precipitaci√≥n pluvial y del √°rea de drenaje. Los datos de dise√±o para estimar el gasto ùëÑ son la intensidad de lluvia ùëâexpresada en mm/hora y el √°rea servida ùê¥ en metros cuadrados: ùëÑ = ùê¥ √ó ùëâ (4.1) Para el c√°lculo de la velocidad del agua en canales abiertos se utiliza la f√≥rmula de Ch√©zy ùëâ = ùê∂‚àöùëÖùëÜ en d√≥nde ùëÜ es la pendiente y ùê∂ es un coeficiente que seg√∫n la f√≥rmula de Manning[18] se expresa de la siguiente manera: ùê∂ = 1 ùúÇ ‚àöùëÖ6 (4.2) En d√≥nde ùúÇ es un coeficiente de rugosidad, para el cual se han definido algunos est√°ndares expresados en la Tabla 3, que la mayor√≠a de los autores aceptan. 31 Material Coeficiente de Rugosidad ùúº Asbesto y PVC 0,010 Metal Liso 0,011 Concreto ùúô < 55 cms. 0,015 Concreto ùúô > 55 cms. 0,013 Canales de concreto 0,015 Canales de tierra 0,025 Tabla 3: Coeficientes de rugosidad para distintos materiales [16]. La velocidad ùëâ expresada en ùëö/ùë†ùëíùëî ser√≠a expresada en este caso de la forma: ùëâ = 1 ùúÇ ‚àöùëÖ3 √ó ‚àöùëÜ2 (4.3) Para evitar la acumulaci√≥n de sedimentos dentro de una tuber√≠a, la velocidad m√≠nima del agua ha de ser de 0,60 ùëö/ùë†ùëíùëî, mientras que la velocidad m√°xima contemplada para evitar el ruido generado por el flujo del agua dentro de las tuber√≠as, oscila entre 3,00 y 9,5 ùëö/ùë†ùëíùëî dependiendo del material de la superficie por donde se desplaza el agua. As√≠ mismo, la cantidad de agua ùëÑ puede ser calculada a partir de: ùëÑ = ùê¥ ùúÇ ‚àöùëÖ √ó ‚àöùëÜ2 (4.4) Siendo ùëÖ es el radio hidr√°ulico, expresado por: ùëÖ = ùê¥ ùëÉ (4.5) En donde ùê¥ es el √°rea del colector en ùëö¬≤ y ùëÉ es el per√≠metro mojado en ùëö. Todos estos c√°lculos pueden resultar bastante laboriosos por lo que el problema de selecci√≥n de di√°metros, pendiente y secci√≥n en el caso de canales, se aproximan mediante la utilizaci√≥n de tablas, que permiten adem√°s adaptar los resultados a ciertas medidas est√°ndar que coincidan con los productos ofrecidos en el mercado, para el caso de tuber√≠as y canaletas. En la 32 Tabla 4 podemos apreciar una tabla tabulada para el c√°lculo de tuber√≠as, con una duraci√≥n de 10 minutos, 5 a√±os de frecuencia y una intensidad asumida de 150 mm/hora. Di√°metro del bajante pluvial Intensidad de Precipitaci√≥n (mm/h) 50 75 100 125 150 200 Cent√≠metros Pulgadas √Åreas M√°ximas de proyecci√≥n horizontal drenadas (m2) 5,08 2 140 90 65 50 45 30 6,35 2 ¬Ω‚Äô‚Äô 240 160 120 100 80 60 7,62 3‚Äô‚Äô 400 270 200 160 135 100 10,16 4‚Äô‚Äô 850 570 425 340 285 210 12,70 5‚Äô‚Äô 1600 1070 800 640 535 400 15,24 6‚Äô‚Äô 2510 1670 1250 1000 835 630 20,32 8‚Äô‚Äô 5390 3590 2690 2155 1759 1350 Tabla 4: √Åreas m√°ximas de proyecci√≥n horizontal en metros cuadrados que pueden ser drenadas por bajantes de aguas de lluvia de diferentes di√°metros para varias intensidades de lluvia [16]. 4. Sistema de Canaletas El agua pluvial recolectada por los techos inclinados debe ser desalojada por un sistema de canaletas para evitar la erosi√≥n del suelo y el deterioro de muros y paredes de una edificaci√≥n. Cuando las precipitaciones son escasas o las √°reas de techos son peque√±as, se puede prescindir del sistema de canaletas utilizando voladizos adecuados y un lecho de grava o un list√≥n de mamposter√≠a en el terreno debajo de la l√≠nea del alero [17]. El di√°metro o secci√≥n de los colectores de aguas de lluvia provenientes de techos y azoteas se determina de acuerdo al √°rea que debe ser desaguada, de su pendiente y la intensidad de lluvia registrada en la zona. Si no se conoce la intensidad de lluvia en la regi√≥n se asume el valor por defecto: 100 litros por metro cuadrado (100mm/hora) [16]. El sistema de canaletas est√° compuesto por varias partes que pueden ser apreciadas en la Figura 8. 33 Figura 8: Diagrama de los elementos b√°sicos de un sistema de canaletas. ‚Ä¢ Canaleta o canal: Es el conducto por donde se desplaza el agua que viene del techo hasta llegar al punto de bajada. Para que el agua fluya a trav√©s de la canaleta en lugar de quedarse empozada, esta debe tener una pendiente m√≠nima en direcci√≥n rectil√≠nea es de 1 16ÔøΩ ‚Ä≤‚Ä≤ por pie (1:200), lo que es equivalente a 0,29¬∞. Para unir las canaletas entre s√≠ y con el segmento final se debe traslapar y soldar o sellar las juntas con macilla. Se deben colocar juntas de dilataci√≥n para tramos de m√°s de 12 m (40‚Äô) de longitud. ‚Ä¢ Tapa terminal: Se coloca al extremo de una canaleta para cerrar el paso de agua 34 ‚Ä¢ Segmento final: Secci√≥n terminal con salida. Los modelos 3d realizados para esta pieza incluyen la tapa terminal y no se utiliza la uni√≥n del bajante pluvial por razones de simplicidad. ‚Ä¢ Rejilla: Es una tela de alambre que se adhiere en la parte superior de la canaleta para protegerla de las hojas. No se utiliza en el trabajo porque no se est√° considerando la ca√≠da de hojas o cualquier otro elemento que pueda ser arrastrado por advecci√≥n junto con el agua a las canaletas. ‚Ä¢ Sujetadores: Permiten colgar la canaleta del alero o de la pared. No se considera en el trabajo puesto que las canaletas se mantienen est√°ticos en la posici√≥n adecuada. ‚Ä¢ Punto de bajada: Conduce el agua recogida por la canaleta al alcantarillado pluvial. Su √°rea depender√° de la pendiente. En este trabajo se est√°n considerando solo las tres pendientes indicadas en la Tabla 5. Proporci√≥n Equivalente en √Ångulos 12:12 45¬∞ 7:12 30¬∞ 5:12 22,6¬∞ Tabla 5: Pendientes para el punto de bajada ‚Ä¢ Bajante Pluvial: Tubo de descenso vertical del agua que se adhiere al segmento final y descarga en el codo bajante. ‚Ä¢ Codo Bajante: Recibe el agua drenada y la descarga a un bloque salpicador o se conecta a un sistema de drenado pluvial. Los sistemas de tuber√≠as pl√°sticas adoptaron en un principio los est√°ndares de medici√≥n de las tuber√≠as met√°licas, puesto que fueron las primeras tuber√≠as industriales existentes. Hoy d√≠a la mayor√≠a de las tuber√≠as pl√°sticas tienen dimensiones que concuerdan con est√°ndares como IPS (Iron Pipe Size) o CTS (Cooper Tube Size), sin embargo hay dos sistemas b√°sicos para el dise√±o de tuber√≠as: Schedule Number (C√©dula Schedule) o RDE (Relaci√≥n Di√°metro Espesor). Para el modelado del sistema de canaletas se han tomado en cuenta las dimensiones que habitualmente se encuentran en el mercado bajo los est√°ndares antes nombrados. Como referencia se tiene la hoja t√©cnica del manual de PAVCO [19] en el que se especifican diversas caracter√≠sticas de cada pieza que integra el sistema de canaletas. 35 CAP√çTULO V. Render Para poder entender mejor lo que ocurre f√≠sicamente entre el fluido y los dem√°s elementos existentes en la escena, es conveniente emplear t√©cnicas que permitan visualizar al fluido lo m√°s parecido posible al agua de lluvia, y los elementos r√≠gidos con quienes colisiona, como todas aquellas estructuras y elementos que forman parte del sistema de drenaje y protecci√≥n contra la humedad en una edificaci√≥n. En este cap√≠tulo se explican una serie de t√©cnicas que fueron utilizadas para mejorar la visualizaci√≥n de la simulaci√≥n. Algunas de ellas han sido realizadas previamente al despliegue, como las texturas, y otras se realizan en tiempo real utilizando varios shaders con diferentes t√©cnicas visuales aplicadas a la escena. 1. Modelos 3D En una escena se pueden encontrar diversos elementos que pueden interactuar entre s√≠ o permanecer est√°ticos. Algunas librer√≠as permiten crear primitivas geom√©tricas (esferas, cubos, toroides, c√°psulas, etc.) que formar√°n parte de la escena. Sin embargo, muchas veces necesitaremos crear elementos m√°s complejos que no pueden ser representados a partir de una primitiva geom√©trica y deben ser creados en alguna otra aplicaci√≥n para el dise√±o de modelos 3D. PhysX permite la creaci√≥n de algunas primitivas como NxBoxShape (cubos) o NxPlaneShape (planos) que se utilizan en este trabajo para representar techos de superficie lisa o el suelo, respectivamente. Hay elementos un poco m√°s complejos como la estructura de la base de la edificaci√≥n que no puede ser representado con una primitiva pura sino con una primitiva modificada, para lo cual se utiliza una clase que provee PhysX: NxConvexShape [1]. Sin embargo hay elementos m√°s complejos a√∫n que necesitan ser modelados con m√°s detalle como es el caso de los techos corrugados, los techos planos, las tejas y el sistema de canaletas en su totalidad. Para ello se utiliz√≥ el programa de modelado 3ds Max y se export√≥ cada modelo 36 3D como un archivo .obj de manera independiente. Estos modelos estaban basados en tri√°ngulos y ya inclu√≠an la configuraci√≥n de normales y coordenadas de textura. 2. Texturizado Para lograr un efecto m√°s realista en los objetos de una escena con frecuencia se aplican a los modelos t√©cnicas de texturizado. Esto constituye una pr√°ctica com√∫n para a√±adir detalles a una superficie. El patr√≥n de texturas puede estar dado por una matriz de valores de color o por un procedimiento que modifique los colores del objeto. En este trabajo se utilizan ambos enfoques en varios patrones de textura superficial, para lo cual se definen matrices bidimensionales trabajando con dos √≠ndices (s,t). Como C++ no tiene soporte para el manejo de archivos de imagen, se utiliza la clase ‚ÄúQImage‚Äù de QT, con la cual podremos cargar im√°genes con formato: bmp, gif, jpg, jpeg, png, etc. La clase ‚ÄúQImage‚Äù proporciona una representaci√≥n de imagen independiente del hardware que permite el acceso directo a los datos de p√≠xeles, y se puede utilizar como un dispositivo de pintura [2]. La configuraci√≥n de las coordenadas de texturas para los modelos utilizados en este proyecto ha sido preestablecida desde 3ds Max. En algunos casos se utiliz√≥ un mapeado planar o c√∫bico, y en otros el mapeado fue hecho utilizando una t√©cnica de mapeado por atlas de textura (unwrap de 3ds Max). 3. Modelo de Iluminaci√≥n Aplicar modelos de iluminaci√≥n a la escena permite dar una sensaci√≥n m√°s realista y ayuda a comprender mejor la morfolog√≠a de los elementos y la posici√≥n en la que est√°n ubicados. En este trabajo se puede alternar entre dos m√©todos de iluminaci√≥n local, el modelo de iluminaci√≥n Gouraud y Phong. Tambi√©n se utilizan algunas aproximaciones basadas en im√°genes para la iluminaci√≥n global. 37 La iluminaci√≥n basada en im√°genes es un tipo de IBR (Image-based rendering), que son t√©cnicas para el despliegue basado en im√°genes. Este conjunto t√©cnicas tratan de resolver el problema del alto costo computacional que acarrea la ejecuci√≥n en tiempo real de un algoritmo de visualizaci√≥n fotorrealista, mediante la sustituci√≥n de un objeto por alguna entidad que conserve las caracter√≠sticas visuales importantes de manera eficiente y que adem√°s simplifique las tareas de despliegue vali√©ndose del uso de im√°genes como primitiva de despliegue. En el caso de la iluminaci√≥n basada en im√°genes, es precisamente el c√°lculo de la iluminaci√≥n lo que es aproximado por medio de la utilizaci√≥n de im√°genes. En este trabajo se utiliza la t√©cnica de mapeo de entorno, una aproximaci√≥n para simular las reflexiones presentes en la escena, en lugar de utilizar el m√©todo cl√°sico de Ray Casting con el cual se obtiene m√°s exactitud en reflexiones pero a un alto costo computacional. Del mismo modo se utiliza el m√©todo de oclusi√≥n ambiental para producir sombras suaves en los objetos de la escena, producto de la iluminaci√≥n ambiental como una aproximaci√≥n, evitando una vez m√°s el Ray Casting. a) Oclusi√≥n ambiental (Ambiental Occlusion) La oclusi√≥n ambiental es un m√©todo de iluminaci√≥n global que se utiliza para producir sombras r√°pidas, suaves y difusas en espacios abiertos mediante el ‚Äútrazado de rayos‚Äù (Ray Tracing) o con alguna aproximaci√≥n a trav√©s de otros m√©todos menos costosos. A trav√©s de esta t√©cnica se puede a√±adir realismo a una escena, tomando en cuenta la atenuaci√≥n de la luz en algunas partes de un modelo 3D debido a la oclusi√≥n de otros objetos o de ciertas partes del mismo [20]. Cuando se habla de oclusi√≥n en t√©cnicas de iluminaci√≥n y sombreado, se refiere a la capacidad que tienen ciertos objetos de una escena para obstruir el paso de la luz parcial o totalmente. En este sentido, es posible determinar √°reas claras y oscuras en funci√≥n de las dem√°s geometr√≠as en la escena y la proximidad de las superficies. Esta t√©cnica permite tener una mejor percepci√≥n de la forma que tiene cada uno de los objetos 3D desplegados en la escena. As√≠ puede entenderse mejor la geometr√≠a de cada uno de los techos y los elementos que conforman el sistema de canaletas. 38 Para calcular la oclusi√≥n ambiental se emiten varios rayos a partir de un punto de luz incidental, los cuales al rebotar en la superficie de las geometr√≠as hacen una contribuci√≥n de sombreado en ese punto. Cada rayo emitido puede entenderse como un fot√≥n que, a mayor cantidad de rebotes, mayor ser√° la oscuridad y a menor cantidad de rebotes, m√°s clara podr√° percibirse la superficie [21]. Hay dos formas de realizar esta t√©cnica: a trav√©s de una textura o en tiempo real. Cuando la escena tiene luz uniforme y objetos est√°ticos es m√°s habitual utilizar texturas para calcular la oclusi√≥n ambiental, de lo contrario es preferible hacer el c√°lculo en tiempo real, en cuyo caso los tiempos de renderizaci√≥n ser√°n mayores pero los resultados m√°s exactos. En este trabajo solo se tiene un punto de luz incidental est√°tico y los modelos tambi√©n permanecen est√°ticos, por lo cual se utilizan texturas donde ya ha sido calculada previamente la iluminaci√≥n global con oclusi√≥n ambiental. 4. Render del Agua Como el m√©todo SPH utilizado por PhysX para la simulaci√≥n del fluido es un m√©todo basado en part√≠culas, debe utilizarse una t√©cnica de extracci√≥n de superficie acorde a este enfoque para dar una apariencia realista. En este caso, t√©cnicas de extracci√≥n de superficie como marching cubes no son las m√°s adecuadas, al contrario, ser√≠a favorable utilizar t√©cnicas no basadas en poligonizaci√≥n. Por lo tanto, conviene usar t√©cnicas basadas en primitivas de punto (point rendering). Una buena opci√≥n ser√≠a utilizar splatting. Sin embargo, por la naturaleza esf√©rica del splatting se producen artefactos que le dan una apariencia gelatinosa a las superficies, haciendo que su aspecto final sea irreal y que el fluido no se perciba como un continuo. Por esto debe utilizarse alg√∫n filtro de suavizado que aligere los cambios bruscos de curvatura entre las part√≠culas y cree una superficie continua y lisa. Finalmente es necesario acoplar otras t√©cnicas que le den un mejor acabado al fluido. Para lograr que un fluido se vea real es necesario agregar ciertos efectos √≥pticos como la reflexi√≥n, refracci√≥n y c√°ustica. A continuaci√≥n se describen brevemente las t√©cnicas utilizadas en el despliegue del agua. 39 a) Splatting Bagar[22] presenta un enfoque para el despliegue directo de fluidos basado en part√≠culas utilizando splatting en lugar de despliegues poligonales y permitiendo as√≠ la reducci√≥n de los artefactos propios de los enfoques basados en mallado. De acuerdo a Zwicker et al. [23], el despliegue de superficies utilizando splatting surgi√≥ como una alternativa de despliegue diferente a las t√©cnicas comunes basadas en mallados de pol√≠gonos. Con esta t√©cnica se realiza el despliegue basado en primitivas de punto, con lo que se podr√≠an desplegar im√°genes de alta calidad de objetos geom√©tricos a partir de un conjunto suficientemente denso de puntos que constituyan la superficie de los mismos. La idea es aproximar regiones locales de puntos en elipses planares en el espacio objeto y con la acumulaci√≥n y mezcla de estas elipses crear la superficie en el espacio imagen[24]. Cada punto o splat es asociado con un vector normal que permitir√° m√°s adelante ser utilizado para calcular la iluminaci√≥n local, entre otras cosas. b) Adaptative Curvature Flow Filtering El m√©todo de filtrado adaptativo para la curvatura del flujo en espacio de pantalla (screen space curvature flow filtering) planteado por Wladimir van der Laan et al. [25], es utilizado para disimular la geometr√≠a esf√©rica de las part√≠culas e impedir que el fluido tenga esa apariencia gelatinosa caracter√≠stica del splatting. Todo el procesamiento, despliegue y pasos de sombreado se hacen directamente en la tarjeta gr√°fica y el m√©todo logra un alto rendimiento en tiempo real. Este filtro trabaja con un mapa de profundidades a nivel de shaders. La idea general consiste en desplazar cada valor de profundidad a partir de su vector normal en una posici√≥n de curvatura media con respecto a sus vecinos. Este proceso se repite por varias iteraciones hasta obtener resultados m√°s refinados. 40 Una curvatura media es definida como la divergencia existente entre el vector normal de cada splat y el vector normal de la superficie del fluido. El proceso de suavizado se hace de forma iterativa, de forma tal que en cada iteraci√≥n el valor de profundidad en el mapa de profundidad del agua ser√° desplazado proporcionalmente de acuerdo al valor de curvatura media. Esto lo podemos expresar en la Ecuaci√≥n 5.1. ùêª = ùúïùëß ùúïùë° (5.1) donde ùëß es el valor de profundidad, ùë° es el n√∫mero de iteraci√≥n y ùêª es el valor de la curvatura media. Para una superficie en el espacio 3D, el valor de curvatura media es definido de acuerdo a la Ecuaci√≥n 5.2: 2ùêª = ‚àá ‚àô ùëõÔøΩ (5.2) donde ùëõÔøΩ es el vector unitario de la superficie. La normal es calculada a partir del producto cruz entre las derivadas de la posici√≥n ùëÉ en el espacio, vista en la direcci√≥n (ùë•,ùë¶), lo cual es expresado en la Ecuaci√≥n 5.3: ùëõÔøΩ(ùë•,ùë¶) = ùëõ(ùë•,ùë¶) |ùëõ(ùë•,ùë¶)| = (‚àíùê∂ùë¶ ùúïùëß ùúïùë• ,‚àíùê∂ùë• ùúïùëß ùúïùë¶ ,‚àíùê∂ùë¶ùëß) ùëá ‚àöùê∑ (5.3) donde ùê∑, se ve expresada en la ecuaci√≥n 5.4 como: ùê∑ = ùê∂ùë¶2 ÔøΩ ùúïùëß ùúïùë• ÔøΩ 2 + ùê∂ùë•2 ÔøΩ ùúïùëß ùúïùë¶ ÔøΩ 2 + ùê∂ùë•2ùê∂ùë¶2ùëß2 (5.4) La diferencia finita es usada para calcular la derivada espacial, ùê∂ùë• y ùê∂ùë¶ constituyen las coordenadas del punto de vista, mientras que ùë• e ùë¶ se refieren a la direcci√≥n. Esto se calcula para obtener las dimensiones del √°rea de visi√≥n (viewport), expresadas en las Ecuaciones 5.5 y 5.6 como el ùêπùëÇùëâ. ùê∂ùë• = 2 tan ÔøΩùêπùëÇùëâ2 ÔøΩ ‚àó ùëâùë• (5.5) 41 ùê∂ùë¶ = 2 tan ÔøΩùêπùëÇùëâ2 ÔøΩ ‚àó ùëâùë¶ (5.6) El vector unitario ùëõÔøΩ de la Ecuaci√≥n 5.3 es sustituido en la Ecuaci√≥n 5.2 de forma tal que ùêª pueda ser derivada, lo que conduce a: 2ùêª = ‚àÇùëõÔøΩx ‚àÇx + ‚àÇùëõÔøΩy ‚àÇy = ùê∂ùë¶ùê∏ùë• + ùê∂ùë•ùê∏ùë¶ ùê∑ 2 3 (5.7) en la cual ùê∏ùë• y ùê∏ùë¶ quedan definidas en las Ecuaciones 5.8 y 5.9, respectivamente: ùê∏ùë• = 1 2 ‚àÇz ‚àÇx ‚àÇùê∑ ‚àÇx ‚àí ‚àÇ2z ‚àÇx2 D (5.8) ùê∏ùë¶ = 1 2 ‚àÇz ‚àÇy ‚àÇùê∑ ‚àÇy ‚àí ‚àÇ2z ‚àÇy2 D (5.9) En resumen, la Ecuaci√≥n 5.1 es una simple integraci√≥n euleriana utilizada para modificar el valor de profundidad en cada iteraci√≥n. La derivada espacial de ùëß es calculada usando diferencias finitas. La superficie puede ser discontinua por el hecho de que puedan percibirse varias siluetas de fluido en el espacio de pantalla. Para evitar unir estos parches de superficie de fluido que est√°n realmente separados, es importante asegurarse de que las condiciones de borde sean las adecuadas. Podr√≠a definirse un umbral que descarte los grandes cambios de profundidad entre p√≠xeles contiguos. En estos casos, as√≠ como en los que se encuentran fuera de la pantalla, al valor de la derivada espacial se le asigna el valor de cero de manera arbitraria, para impedir que se haga el suavizado en esas √°reas. El n√∫mero de iteraciones elegidas depender√° del valor de suavizado final esperado. Mientras m√°s iteraciones se hagan, la superficie quedar√° m√°s suavizada pero el costo computacional ser√° m√°s alto. 42 c) SkyBox Para mejorar la apariencia y la percepci√≥n realista de los objetos presentes en una escena, podemos aplicar diversas t√©cnicas que alteren la forma, el relieve y la profundidad, entre otras cosas, para este fin. A√∫n cuando la escena sea din√°mica e interactiva, se puede hacer uso de texturas, t√©cnicas de iluminaci√≥n, shaders, etc.; que estilicen el despliegue final. Sin embargo, todo esto tiene un alto costo computacional, por lo que todas estas t√©cnicas deben ser usadas con moderaci√≥n para que solo se ejecuten cuando realmente han de ser visualmente percibidas. Cuando los elementos se encuentran muy distantes del punto de visi√≥n dif√≠cilmente se percibe alg√∫n cambio visual al desplazarse en la escena y es posible que jam√°s se interact√∫e con dichos elementos, por esta raz√≥n se puede impedir que se realicen c√°lculos para la mejora del despliegue de los mismos. As√≠ mismo, es posible crear la ilusi√≥n de tener una serie de objetos tridimensionales muy distantes del centro de inter√©s con buenos efectos visuales pero que en realidad no existen. Esto permite dar una sensaci√≥n de amplitud y grandeza a una escena, o simplemente mostrar el entorno que la rodea, en lugar de mantener un fondo unicolor que de una sensaci√≥n de vac√≠o o de abismo. Con este prop√≥sito surge la t√©cnica conocida como SkyBox, la cual no es m√°s que encerrar la escena en un cubo lo suficientemente grande, con las normales invertidas para poder mapear dentro de √©l o bien seis texturas (una por cada cara), o una √∫nica textura que contenga el entorno de forma tal que pueda utilizarse un mapeado c√∫bico. Un Skybox contiene t√≠picamente elementos que nos den la sensaci√≥n de encontrarnos en un espacio abierto, tales como: el cielo, el sol, el suelo, algunas monta√±as o construcciones lejanas, etc. Sin embargo tambi√©n puede utilizarse para ilustrar un espacio cerrado, como las paredes de una habitaci√≥n, un galp√≥n o una discoteca. Para que un SkyBox luzca bien la resoluci√≥n de la textura debe ser lo suficientemente grande manteniendo una proporci√≥n de un texel por p√≠xel de pantalla [21]. La f√≥rmula para calcular la resoluci√≥n aproximada podemos expresarla a trav√©s de la Ecuaci√≥n 5.10: ùëüùëíùë†ùëúùëôùë¢ùëêùëñ√≥ùëõ ùëëùëí ùë°ùëíùë•ùë°ùë¢ùëüùëé = ùëüùëíùë†ùëúùëôùë¢ùëêùëñ√≥ùëõ ùëëùëí ùëùùëéùëõùë°ùëéùëôùëôùëé tan(ùêπùëÇùëâ 2‚ÅÑ ) (5.10) 43 d√≥nde el ùêπùëÇùëâ representa el campo de visi√≥n. En el caso de que se utilicen seis texturas se ha de tener cuidado que las texturas est√©n compaginadas. Es posible tener diferentes texturas para el SkyBox en el caso de que se est√©n utilizando diferentes escenas, como por ejemplo en los videojuegos que tienen diferentes escenarios, mapas o niveles. Para este trabajo se utiliz√≥ un SkyBox est√°tico, es decir, un SkyBox en el que la textura siempre es la misma puesto que la escena nunca cambia. Otro detalle importante acerca del SkyBox es el desplazamiento que este hace junto con la c√°mara en escenas con navegaci√≥n. Esto se hace para evitar que el usuario atraviese el SkyBox al desplazarse por la escena y mantener la sensaci√≥n de lejan√≠a de los objetos est√°ticos simulados por el SkyBox. d) Mapeo de Entorno Est√°tico Algunos de los efectos visuales presentes en una escena pueden realizarse mediante una t√©cnica de mapeo de entorno (Environment Mapping) que permite precisamente mapear en una textura uno o m√°s efectos visuales relacionados con el entorno que rodea al objeto. La reflexi√≥n es uno de los efectos visuales que pueden ser aplicados con esta t√©cnica, que en este caso se tratar√≠a espec√≠ficamente de mapeo de reflexi√≥n (Reflection Mapping). Estos t√©rminos en ocasiones son usados indistintamente, sin embargo el mapeo de reflexi√≥n tiene un significado espec√≠fico. Cuando las propiedades del material de la superficie son usadas para modificar un mapa de entorno existente, se genera una textura que es ahora un mapa de reflexi√≥n. Se denomina Reflexi√≥n al fen√≥meno en el cual ondas de cualquier tipo inciden sobre una barrera plana generando nuevas ondas que se mueven en otra direcci√≥n, alej√°ndose de la barrera [5]. Esta barrera puede entenderse como un l√≠mite entre dos medios distintos, como el aire y un vidrio, el agua, o cualquier otro tipo de superficie. Debido a que el c√°lculo de la ecuaci√≥n de reflectancia completa en tiempo real es muy compleja se tiende a usar aproximaciones m√°s simples, como: ùêø0(ùë£) = ùëÖùêπ(ùúÉ0)ùêøùëñ(ùëü) (5.11) 44 donde ùëÖùêπ representa el t√©rmino de Fresnel, ùëü es el vector de reflexi√≥n, ùêøùëñ el vector de incidencia y ùúÉùëñ el √°ngulo formado entre el vector de incidencia y el vector normal de la superficie. Si consideramos √∫nicamente la direcci√≥n de la luz en el c√°lculo de la radiancia, esto puede ser almacenado en un espacio bidimensional a trav√©s de una tabla. Esto permitir√° la iluminaci√≥n eficiente en una superficie reflectante de cualquier forma con una distribuci√≥n arbitraria de energ√≠a lum√≠nica, con s√≥lo calcular ùëü en cualquier punto de la tabla de radiancia. A esta tabla la conocemos como mapa de entorno y su uso durante el despliegue se conoce como mapeo de entorno, tal como ilustra la Figura 9. Para que ùêøùëñ s√≥lo dependa de la direcci√≥n es necesario que el punto de la luz venga de muy lejos y que el reflector no se refleje a s√≠ mismo. Figura 9: Funci√≥n de proyecci√≥n para convertir el vector de vista (x,y,z) reflejado en una textura (u,v) de la imagen creada a partir de la proyecci√≥n. Los pasos que constituyen el algoritmo para el mapeo de entorno son: ‚Ä¢ Generar o cargar una imagen en dos dimensiones que represente el entorno de una escena. ‚Ä¢ Para cada p√≠xel contenido en un objeto reflectante se debe calcular la normal en la ubicaci√≥n en la superficie del objeto. ‚Ä¢ Calcular el vector de reflexi√≥n con el vector vista y el vector normal. Punto de vista Superficie reflectiva r v n œ¥ œ¥ Textura de imagen 45 ‚Ä¢ Usar el vector de reflexi√≥n para calcular un √≠ndice en el mapa de entorno que representa el valor de energ√≠a lum√≠nica o radiancia entrante en la direcci√≥n del vector de reflexi√≥n. ‚Ä¢ Usar los datos de t√©xel para correlacionarlo con un valor del mapa de entorno de acuerdo al √≠ndice antes calculado. Los mapas de entorno pueden almacenar otras propiedades adem√°s de la reflexi√≥n, por esta raz√≥n tienden a ocupar m√°s espacio que una textura normal. A partir de t√©cnicas como el normal mapping o el bump mapping puede ser calculado un mapa de entorno con resultados visuales muy ricos. Cuando en una escena los elementos permanecen est√°ticos el c√°lculo de la reflexi√≥n a partir del mapeo de entorno puede hacerse una sola vez debido a que este entorno no ha de cambiar. Como los elementos de la escena en este trabajo permanecen siempre est√°ticos, se utiliza un mapeo de entorno est√°tico (Static Environment Mapping) para el c√°lculo de la reflexi√≥n. e) Espesor y coeficiente de Fresnel Adem√°s de las t√©cnicas antes mencionadas es conveniente configurar algunos otros par√°metros de visualizaci√≥n que mejoren la apariencia final del fluido. Este es el caso del espesor (thickness) y el coeficiente de Fresnel. El espesor se utiliza para calcular correctamente los atributos visuales como la atenuaci√≥n del color, la transparencia y la refracci√≥n. Para ello las part√≠culas del fluido son consideradas como esferas de tama√±o constante en el espacio y se despliegan de manera similar a como se hace en el m√©todo de filtrado adaptativo para la curvatura del flujo, la diferencia es que en lugar de almacenar valores de profundidad se guardan los valores de espesor en el p√≠xel proyectado [22]. El espesor del fluido ser√° calculado de acuerdo a lo expresado en la Ecuaci√≥n 5.12: ùëá(ùë•,ùë¶) = ÔøΩùëëÔøΩ ùë• ‚àí ùë•ùëñ œÉùëñ , ùë¶ ‚àí ùë¶ùëñ œÉùëñ ÔøΩ ùëõ ùëñ=0 (5.12) donde ùëë representa la profundidad de la funci√≥n kernel, ùë•ùëñ e ùë¶ùëñ son las componentes de la posici√≥n de proyecci√≥n de la part√≠cula, ùë• e ùë¶ las coordenadas de pantalla y finalmente œÉùëñ es el tama√±o de proyecci√≥n. Esta sumatoria utiliza mezclado aditivo para ir escribiendo el color del espesor del fluido en lugar de la profundidad, y las part√≠culas son desplegadas con el test de 46 profundidad habilitado y la escritura de profundidades deshabilitada para asegurar una correcta visibilidad de la geometr√≠a presente detr√°s del fluido. El coeficiente de Fresnel indica qu√© cantidad de luz se refracta y cu√°nto se refleja a partir de las conocidas ecuaciones de Fresnel, las cuales describen el comportamiento de la luz al atravesar dos medios con diferentes √≠ndices de refracci√≥n. Estas ecuaciones constituyen un conjunto de relaciones matem√°ticas entre la amplitud de la onda reflejada, la onda refractada y la onda incidente. Benjamin Peters y Martin Sch√§f [26] expresan el coeficiente de Fresnel con la Ecuaci√≥n 5.13 y obtienen un valor entre 0 y 1: ùêπ = 1 2 ÔøΩ sin2(ùúÉùëñ ‚àí ùúÉùë°) sin2(ùúÉùëñ + ùúÉùë°) ÔøΩ + tan2(ùúÉùëñ ‚àí ùúÉùë°) ‚àó tan2(ùúÉùëñ + ùúÉùë°) (5.13) donde ùúÉùëñ es el √°ngulo del rayo incidente y ùúÉùëñ el √°ngulo del rayo refractado, ambos con respecto a la normal. Tambi√©n se puede obtener el valor de contribuci√≥n del coeficiente de Fresnel en el reflejo especular de la luz con la Ecuaci√≥n 5.14, conocida como aproximaci√≥n de Schlick: ùêπ(ùúÉ) = ùêπ0 + ÔøΩ(1 ‚àí cos ùúÉ)(1‚àí ùêπ0)ÔøΩ 5 (5.14) donde ùúÉ constituye la mitad del √°ngulo entre la direcci√≥n de luz entrante y saliente y ùêπ0 es la cantidad de reflexi√≥n generada, lo cual expresamos de acuerdo a la Ecuaci√≥n 5.15: ùêπ0 = (ùëü ‚àí 1)2 (ùëü + 1)2 (5.15) en la cual ùëü constituye el √≠ndice de refracci√≥n del medio. Finalmente, las propiedades √≥pticas del fluido estar√°n basadas en la ecuaci√≥n de Fresnel y el valor especular de Phong, lo cual se indica en la Ecuaci√≥n 5.16 [22]: ùê∂ = ùëéÔøΩ1 ‚àí ùêπ(ùëõÔøΩ‚Éó ‚àô ÔøΩ‚ÉóÔøΩ)ÔøΩ + ùëèùêπ(ùëõÔøΩ‚Éó ‚àô ÔøΩ‚ÉóÔøΩ) + ùëòùë†ÔøΩùëõÔøΩ‚Éó ‚àô ‚ÑéÔøΩ‚Éó ÔøΩ ùõø (5.16) donde ùëé es el color del fluido, que incluye adem√°s el color de fondo refractado, ùëè es el color de reflexi√≥n obtenido por medio del mapa de entorno, ùëòùë† y ùõø son constantes para el valor especular, ùêπ es el coeficiente de Fresnel, ùëõÔøΩ‚Éó es la normal de la superficie en el espacio de pantalla, ‚ÑéÔøΩ‚Éó la mitad del √°ngulo entre la c√°mara y la luz y finalmente ÔøΩ‚ÉóÔøΩ es el vector director de la c√°mara. 47 CAP√çTULO VI. Dise√±o e Implementaci√≥n En este cap√≠tulo se explican detenidamente cada uno de los detalles de implementaci√≥n a considerar. Las especificaciones con respecto al tipo de techo, estructura, dimensiones, fluido, simulaci√≥n, t√©cnicas y efectos visuales implementados, etc. As√≠ como las clases que conforman la aplicaci√≥n y como est√°n relacionadas entre s√≠, los elementos que conforman la interfaz gr√°fica y la navegaci√≥n de la escena utilizando mouse y teclado. 1. Detalles de implementaci√≥n A continuaci√≥n se explican en detalle cada uno de los aspectos considerados en la simulaci√≥n y en la creaci√≥n de la escena. Entre ellos, todo lo referente a los detalles arquitect√≥nicos de implementaci√≥n, simulaci√≥n de aguas de lluvias utilizando PhysX y los efectos visuales que le dan una apariencia m√°s realista al fluido. Las dimensiones del techo est√°n disponibles en un rango limitado. Se dise√±√≥ una interfaz que permita la configuraci√≥n del largo y ancho del techo, desde el tama√±o m√°s peque√±o 6m, incrementando en 2m hasta el tama√±o m√°s grande de 20m. En el caso de los techos de tejas, el ancho y largo m√°s grande es de 16m por la complejidad del mallado. Dado que las dimensiones del techo son conocidas y que el c√°lculo de tuber√≠as puede ser discretizado en tablas (ver Tabla 4) es posible tabular las dimensiones del sistema de canaletas de acuerdo a las especificaciones del proyecto. En este caso, al conocer todos los tama√±os configurables de techo, se pueden calcular de antemano todas las √°reas de techo, y obtener a partir de all√≠ el di√°metro del bajante pluvial. A continuaci√≥n se muestra la Tabla 6, en funci√≥n de la intensidad de precipitaci√≥n y algunos valores de √°rea m√°xima de proyecci√≥n horizontal existentes en la Tabla 4, acordes al rango de √°reas posibles en este trabajo. Tanto los modelos de techos como todas las partes que conforman el sistema de canaletas, han sido hechos, morfol√≥gicamente a escalas reales y de proporciones id√©nticas entre s√≠. Lo √∫nico que no se ha mantenido a escala real son los tama√±os en los que generalmente son 48 comercializados, esto para reducir la cantidad de modelos y simplificar el algoritmo por el cual cada pieza habr√≠a de encajar en un edificio, es decir, armar la estructura final basada en todas las variantes elegidas por el usuario. √Åreas de proyecci√≥n horizontal drenadas (m2) Intensidad de Precipitaci√≥n (mm/h) 200 150 125 100 75 50 45 6,35 5,08 5,08 5,08 5,08 5,08 50 6,35 6,35 5,08 5,08 5,08 5,08 60 6,35 6,35 6,35 5,08 5,08 5,08 65 7,62 6,35 6,35 5,08 5,08 5,08 80 7,62 6,35 6,35 6,35 5,08 5,08 90 7,62 7,62 6,35 6,35 5,08 5,08 100 7,62 7,62 6,35 6,35 6,35 5,08 120 10,16 7,62 7,62 6,35 6,35 5,08 135 10,16 7,62 7,62 7,62 6,35 5,08 140 10,16 10,16 7,62 7,62 6,35 5,08 160 10,16 10,16 7,62 7,62 6,35 6,35 200 10,16 10,16 10,16 7,62 7,62 6,35 210 10,16 10,16 10,16 10,16 7,62 6,35 240 12,70 10,16 10,16 10,16 7,62 6,35 270 12,70 10,16 10,16 10,16 7,62 7,62 285 12,70 10,16 10,16 10,16 10,16 7,62 340 12,70 12,70 10,16 10,16 10,16 7,62 400 12,70 12,70 12,70 10,16 10,16 7,62 Tabla 6: Di√°metro del bajante pluvial (cm) de acuerdo a las √°reas de proyecci√≥n horizontal generadas y a diferentes valores de intensidad de lluvia. Por esta raz√≥n las canaletas siempre tienen una tapa terminal, bien sean segmentos finales o simplemente canaletas. Ambas partes se trasladar√°n de acuerdo al tama√±o del techo y la canaleta se escalar√° a lo largo para completar al segmento final, que no puede ser escalado para preservar su morfolog√≠a. Del mismo modo, las techumbres corrugadas no tendr√°n el tama√±o convencional de las l√°minas en que son vendidas (los largos est√°ndar son de 1,83m; 2,44m; 3,05m y 3,66m; los anchos est√°ndar oscilan entre los 0,8m y 0,9m), sino el ancho y largo elegido por el usuario, correspondiente al tama√±o final del techo. Igualmente, los techos de tejas corresponder√≠an a 49 un mallado de c√≥mo se ver√≠a un tejado completo, para evitar armar un tejado cargando varios modelos de tejas de 255√ó485 mm, necesarias para revestir un techo de 36m2, por ejemplo. Es necesario destacar que ninguna de estas dos diferencias altera la morfolog√≠a real de los modelos, puesto que solo se estar√≠a generando un mallado de lo que ser√≠a colocar perfectamente varias l√°minas de techumbre corrugada sobre un techo, hacer un tejado o colocar varias canaletas hasta completar la longitud necesaria. Los modelos son instanciados en las coordenadas (0,0,0). Armar la estructura es posible haciendo una serie de escalamientos, traslaciones y rotaciones, dependientes de las caracter√≠sticas elegidas por el usuario y de los modelos en s√≠ mismos. a) Transformaciones afines a los techos Los techos son cargados de antemano en el tama√±o elegido previamente por el usuario, por lo cual no es necesaria una operaci√≥n de escalamiento, que podr√≠a deformar el modelo. En el caso de los techos inclinados y techos a dos aguas, siempre se har√° una rotaci√≥n. Los techos planos, tienen tambi√©n una ligera pendiente, pero al funcionar su sistema de drenaje de una manera distinta a como lo hacen los antes mencionados, esa pendiente viene incluida ya en el mallado. El √°ngulo de rotaci√≥n es determinado por la pendiente elegida por el usuario a trav√©s de la interfaz (v√©ase la Tabla 3). En el caso de los techos a dos aguas, se cargan dos techos del mismo tipo y las mismas dimensiones. En este caso, la rotaci√≥n se hace en uno de los techos en ùõº y en el otro en ‚Äìùõº. Todas estas rotaciones se hacen en el eje ùë•. Ambos techos han de ser desplazados la mitad de su longitud en el eje ùëß, de esta forma el brocal del techo se extender√° exactamente sobre el eje ùë•. Por el contrario los techos planos e inclinados se mantienen en la coordenada en que han sido instanciados (0,0,0), por lo cual no es necesario hacer traslaci√≥n alguna. 50 b) Transformaciones afines al sistema de canaletas La pendiente m√≠nima en direcci√≥n rectil√≠nea es de ùõº = 0,29¬∞, lo equivalente a una relaci√≥n por pie (1:200). Este √°ngulo de rotaci√≥n aplica tanto para las canaletas como para los segmentos finales, sin embargo, la diferencia de longitud no permite que coincidan en altura, como se aprecia en la Figura 10, por lo cual es necesario desplazar un poco hacia abajo el segmento final. Figura 10: Rotaci√≥n de las canaletas en un √°ngulo de pendiente m√≠nima. El c√°lculo del desplazamiento del segmento final sobre el eje ùë¶ para corregir el defecto producto de la rotaci√≥n, se hace en base a la Ecuaci√≥n 6.1: ùëë = ùëêùëú ‚àí ùëêùëú‚Ä≤ = ùë†ùëñùëõ(ùõº) ‚àó (‚Ñé ‚àí ‚Ñé‚Ä≤) (6.1) donde ‚Ñé = 3ùëö. corresponde a la longitud de la canaleta mientras que ‚Ñé‚Ä≤ = 0,3ùëö. corresponde a la longitud del segmento final. Los segmentos derechos rotar√°n en ùõº y los izquierdos en ‚Äìùõº. Las canaletas han de tener un di√°metro espec√≠fico de acuerdo a la cantidad de agua servida que deben drenar. Esto depender√° del √°rea del techo y la intensidad de precipitaci√≥n, valores que ser√°n indicados por el usuario a trav√©s de la interfaz, y de los cuales ya se conoce el di√°metro de canaleta correspondiente (v√©ase la Tabla 6). Para ello se utiliza una ‚Äúmatriz esparcida‚Äù, en donde las diferentes √°reas de techo posible est√°n indicadas por las filas y las intensidades m√°ximas de precipitaci√≥n consideradas son representadas por las columnas. h‚Äô h co‚Äô co Œ± Œ± d 51 Como la canaleta ya tiene un valor ancho-alto que viene con el modelo, el escalamiento no ser√° exactamente el indicado por la Tabla 6. Para cada canaleta, se ha calculado previamente el valor de escalamiento que ha de tener de acuerdo a su dimensi√≥n original (dimensi√≥n del modelo) y a las cinco dimensiones est√°ndar (di√°metros de canaletas ofrecidas en el mercado) que est√°n siendo consideradas de acuerdo a las √°reas de techos posibles de obtener. Estos valores de escalamiento est√°n almacenados en una matriz de flotantes. A su vez, la intersecci√≥n fila-columna en la matriz esparcida indica el √≠ndice que en la matriz de flotantes contiene la dimensi√≥n de escalamiento de la canaleta correspondiente a dicha combinaci√≥n. Este escalamiento ser√° aplicado a los ejes ùë¶ y ùëß de las canaletas y los segmentos finales. Al punto de bajada y el bajante pluvial, se le escalar√° en los ejes ùë• y ùëß. Los segmentos finales no se escalan en el eje ùë• para evitar deformar el modelo y que pierda la correspondencia con las dem√°s piezas que conforman el sistema de canaletas (de lo contrario perder√≠a la dimensi√≥n est√°ndar del orificio que ha de encajar con el punto de bajada para drenar el agua). S√≥lo se escalar√° la canaleta para cubrir la longitud total del alero, correspondiente al ancho del techo. Este escalamiento se calcula a partir de la Ecuaci√≥n 6.2: ùëéùëõùëê‚Ñéùëúùëáùëíùëê‚Ñéùëú ‚àí ùëôùëúùëõùëîùëñùë°ùë¢ùëëùëÜùëíùëîùëöùëíùëõùë°ùëúùêπùëñùëõùëéùëô ùëôùëúùëõùëîùëñùë°ùë¢ùëëùê∂ùëéùëõùëéùëôùëíùë°ùëé (6.2) donde la longitud del segmento final y la longitud de la canaleta son constantes con valor 0.3mts y 3mts, respectivamente. Cuando el segmento de desag√ºe est√© en el centro del alero, el escalamiento de las canaletas se calcular√° de acuerdo a la Ecuaci√≥n 6.3: (ùëéùëõùëê‚Ñéùëúùëáùëíùëê‚Ñéùëú 2‚ÅÑ ) ‚àí (ùëôùëúùëõùëîùëñùë°ùë¢ùëëùëÜùëíùëîùëöùëíùëõùë°ùëúùêπùëñùëõùëéùëô 2‚ÅÑ ) ‚àí ùëôùëúùëõùëîùëñùë°ùë¢ùëëùê∂ùëéùëõùëéùëôùëíùë°ùëé ùëôùëúùëõùëîùëñùë°ùë¢ùëëùê∂ùëéùëõùëéùëôùëíùë°ùëé (6.3) Con respecto a la traslaci√≥n, todos los elementos que constituyen el sistema de canaletas deben ubicarse a lo largo de los aleros. El sistema de canaletas s√≥lo estar√° presente en los 52 techos inclinados o a dos aguas, por esta raz√≥n se conoce ya que el techo siempre ha de estar rotado. Para determinar el desplazamiento en ùëß y en ùë¶, es necesario deducir una ecuaci√≥n a partir de una vista transversal de la estructura. La Figura 11 representa el techo inclinado visto lateralmente, en donde ùëÉ representa al techo, ùêø es su longitud y ùõº el √°ngulo de inclinaci√≥n elegido por el usuario. De esta manera, desplazaremos ùêø 2 cosùõº + ùëë 2 la(s) canaleta(s) y al segmento final en el eje ùëß, donde ùëë es el di√°metro de la canaleta. En el eje ùë¶ el desplazamiento ser√° de ùêø 2 sinùõº + ‚Ñé 2 , donde ‚Ñé es la altura de la canaleta. Figura 11: Vista lateral de un techo inclinado El desplazamiento en ùë• es opuesto en los elementos izquierdos y derechos. Es decir, para las piezas izquierdas, el desplazamiento ser√° de ùëô 2 ‚àí‚ÅÑ ùëé 2‚ÅÑ , mientras que para las derechas el desplazamiento ser√° de ùëé 2 ‚àí‚ÅÑ ùëô 2‚ÅÑ , donde ùëé es el ancho del techo y ùëô la longitud de la canaleta. ùëÉ = ÔøΩ ùêø 2 cosùõº ,‚àí ùêø 2 sinùõºÔøΩ ùêø 2 cosùõº ùêø 2 (1 ‚àí cosùõº) ùêø 2 sinùõº ùêø 2‚ÅÑ ùëÉ ùë¶ ùëß ùõº 53 Cuando el segmento de desag√ºe est√° en el centro del alero, es necesario colocar canaletas tanto del lado derecho como del lado izquierdo. En este caso el desplazamiento ser√° el antes descrito para ambas canaletas. Sin embargo, el segmento de desag√ºe no se desplazar√° en ùë•. En el caso del punto de bajada, el desplazamiento en ùëß ser√° de ùêø 2 cosùõº + ùëê, en donde ùëê es una constante con valor 0,009m que representa la distancia entre el borde de la canaleta y el orificio de desag√ºe. En el eje ùë¶ el desplazamiento ser√° de ‚àíùêø 2 sinùõº ‚àí ‚Ñé. El bajante pluvial ser√° desplazado ‚Ñéùëêùëéùëõùëéùëôùëíùë°ùëé ‚àí ‚Ñéùëùùë¢ùëõùë°ùëú ùëëùëí ùëèùëéùëóùëéùëëùëé ‚àí ùêø 2 sinùõº ‚àí ùë† en el eje ùë¶, donde ùë† es una constante de valor 0,375m, que representa la mitad de la dimensi√≥n del bajante pluvial. En el eje ùëß el desplazamiento ser√° de ùêø 2 cosùõº + ùëê ‚àí ùëí/2 + ùëè, donde ùëí es el ancho del punto de bajada y ùëè el di√°metro o el ancho del bajante pluvial, que corresponde a 0,21m. Para ambos, el desplazamiento en ùë• ser√° el mismo de las canaletas, restando la distancia existente entre el borde del segmento de desag√ºe y el orificio del mismo, una constante de 0,295m. c) Estructura del Edificio Al construir una edificaci√≥n de cualquier tipo es importante la existencia del voladizo del techo para evitar la erosi√≥n del suelo y el deterioro de las paredes. En este trabajo, tanto las dimensiones de la estructura como del voladizo est√°n determinadas por el tama√±o del techo y el sistema de canaletas. Para determinar las dimensiones y la posici√≥n de la estructura del edificio es necesario tomar varios factores en cuenta, como el √°ngulo de inclinaci√≥n del punto de bajada y las dimensiones del techo y su inclinaci√≥n. Una de las razones por las que el punto de bajada necesita un codo inclinado, es para que el bajante pluvial pueda aferrarse a la pared. Dependiendo de la distancia que hay entre el techo y las paredes se elige la longitud e inclinaci√≥n de dicho codo. Para este trabajo se utilizan solo 6 modelos predeterminados, 3 circulares y 3 rectangulares, en ambos casos se cuenta con 3 54 √°ngulos de inclinaci√≥n: 22,6¬∞, 30¬∞ y 45¬∞ cuyas longitudes son tambi√©n una constante. Por esta raz√≥n, la distancia que ha de haber entre el alero y el techo se calcula en funci√≥n del punto de bajada elegido por el usuario Como la estructura esta siempre centrada en el origen, lo que se hace es restar al largo del techo la distancia que ha de haber entre el borde del techo inclinado (previamente calculada para ubicar las canaletas) y el ancho del punto de bajada. Esa dimensi√≥n ser√° exactamente la mitad de la estructura, en los casos de techo inclinado, tanto en ancho como en largo. Para los techos a dos aguas, la dimensi√≥n a lo largo se duplicar√°. Para crear la estructura se utiliza un convexMesh de PhysX de ocho v√©rtices. El convexMesh permite modificar una primitiva, en este caso se editan los valores de los v√©rtices de un box, una geometr√≠a b√°sica de PhysX. La idea es modificar la cara superior del box de forma tal que se ajuste a la inclinaci√≥n del techo, para ello se le resta una constante a dos de sus v√©rtices superiores y a los otros dos se les suma la misma constante como se indica en la Figura 12. Figura 12: Vista lateral de la estructura modificada a partir de un convexMesh. De esta forma se tienen dos variables: la dimensi√≥n del box y la constante de deformidad. Para calcular la dimensi√≥n se resta al tama√±o del techo el largo del punto de bajada con la Ecuaci√≥n 6.4: ‚àÜùëßùëÉùêµ ‚àí ùëíùë†ùëêùëéùëôùëé ‚àó ùëí/2 (6.4) Box original dimension.y-deformidad dimension.y+deformidad 55 donde ‚àÜùëßùëÉùêµ representa el desplazamiento en el eje ùëß del punto de bajada y ùëí corresponde al ancho del punto de bajada, que al multiplicar por la escala de di√°metro correspondiente de acuerdo al c√°lculo de tuber√≠as se obtiene el tama√±o real del mismo. Por estar todos los modelos ubicados por defecto en el origen, es necesario desplazar siempre la mitad de su dimensi√≥n en cada uno de sus posicionamientos. Este desplazamiento inicial del punto de bajada ya hab√≠a sido incluido en ‚àÜùëßùëÉùêµ, por lo que para anularlo se divide entre dos la constante ùëí. Este c√°lculo define la dimensi√≥n en los ejes ùë• y ùëß, el valor para el eje ùë¶ es una constante de 3mts. Ahora es necesario deformar el box para que la cara superior del mismo se adecue a la inclinaci√≥n del techo. Para calcular el valor de deformidad se hace uso de los criterios de semejanza de tri√°ngulos rect√°ngulos [27]. En la Figura 13 vemos como, en una vista transversal, el plano sobre el que se extiende el techo, el plano de la cara superior del box (sobre el eje ùëß) y el plano que pasa por el eje ùë¶ forman un tri√°ngulo rect√°ngulo semejante al tri√°ngulo conformado por la distancia que hab√≠a entre la mitad del techo inclinado hasta el alero. Estas distancias ya son conocidas (posZ,posY), puesto que han sido previamente calculadas a partir del √°ngulo ùõº y la longitud del techo, para aplicar sobre el sistema de canaletas las transformaciones afines antes mencionadas. Figura 13: Principio de tri√°ngulos semejantes para deducir el valor de deformidad. ùë¶ ùëß ùõº ùõº A B C ùõº posY posZ ùëëùëñùëö/2 BOX ùëëùëñùëö deformidad 56 Por el principio de tri√°ngulos semejantes [27], podemos afirmar que el √°ngulo ùõº es el mismo para los tri√°ngulos A, B y C. Adem√°s conocemos la dimensi√≥n del box, por lo que podemos calcular el valor de deformidad a trav√©s de la Ecuaci√≥n 6.5: ùëëùëñùëö/2 ‚àó tanùõº (6.5) Para crear la estructura de los techos a dos aguas se utiliza un convexMesh de diez v√©rtices. En este caso los v√©rtices superiores ser√°n seis y los inferiores solo cuatro (los cuatro que constituyen la base de la estructura). A los cuatro v√©rtices superiores que se encuentran en los extremos (los m√°s alejados y los m√°s cercanos en el eje ùëß) se les restar√° el valor de deformidad, mientras que a los dos v√©rtices superiores centrales (ubicados en cero en el eje ùëß) se les sumar√° dicho valor de deformidad. En la Figura 14 se pueden apreciar las transformaciones aplicadas sobre los v√©rtices superiores del convexMesh. Figura 14: Vista lateral de la estructura para techo a dos aguas modificada a partir de un convexMesh. El c√°lculo de la deformidad se hace exactamente igual al caso del techo inclinado, con la diferencia que el valor del cateto opuesto ya no ser√° ùëëùëñùëö/2 sino ùëëùëñùëö puesto que la dimensi√≥n en este caso se duplica. A nivel de c√≥digo, lo que hacemos es crear los v√©rtices de la estructura con estas modificaciones ya incluidas para ser encolados posteriormente en un vector de v√©rtices. Se crear√°n ocho o diez v√©rtices, seg√∫n sea el caso, de acuerdo a lo anteriormente explicado. En la Figura 15 podemos observar el c√≥digo referente a la configuraci√≥n de los v√©rtices para la creaci√≥n de la estructura. Box original dimension.y-deformidad dimension.y+deformidad dimension.y-deformidad 57 Figura 15: Creaci√≥n de los v√©rtices de la estructura a nivel de c√≥digo. 2. Clases de la aplicaci√≥n A continuaci√≥n se explicar√°n en detalle cada una de las clases que conforman la aplicaci√≥n y como est√°n relacionadas entre s√≠. La aplicaci√≥n contiene una serie de clases que controlan la interfaz, la creaci√≥n y manipulaci√≥n de elementos de PhysX, la navegaci√≥n, manejo de la escena, control del programa, y la utilizaci√≥n de shaders que mejoran el render final de la escena. En la Figura 16 podemos ver el diagrama de clases de dicha aplicaci√≥n. // Estructura del edificio if(morfologia==2){ verts.pushBack(NxVec3(dimension.x, -dimension.y, dimension.z)); verts.pushBack(NxVec3(-dimension.x, -dimension.y, dimension.z)); verts.pushBack(NxVec3(dimension.x, -dimension.y, -dimension.z)); verts.pushBack(NxVec3(-dimension.x, -dimension.y, -dimension.z)); verts.pushBack(NxVec3(dimension.x, dimension.y+deformidad, 0.0f)); verts.pushBack(NxVec3(-dimension.x, dimension.y+deformidad, 0.0f)); verts.pushBack(NxVec3(dimension.x, dimension.y-deformidad, -dimension.z)); verts.pushBack(NxVec3(-dimension.x, dimension.y-deformidad, -dimension.z)); verts.pushBack(NxVec3(dimension.x, dimension.y-deformidad, dimension.z)); verts.pushBack(NxVec3(-dimension.x, dimension.y-deformidad, dimension.z)); }else{ verts.pushBack(NxVec3(dimension.x, -dimension.y, dimension.z)); verts.pushBack(NxVec3(-dimension.x, -dimension.y, dimension.z)); verts.pushBack(NxVec3(dimension.x, -dimension.y, -dimension.z)); verts.pushBack(NxVec3(-dimension.x, -dimension.y, -dimension.z)); verts.pushBack(NxVec3(dimension.x, dimension.y+deformidad, -dimension.z)); verts.pushBack(NxVec3(-dimension.x, dimension.y+deformidad, -dimension.z)); verts.pushBack(NxVec3(dimension.x, dimension.y-deformidad, dimension.z)); verts.pushBack(NxVec3(-dimension.x, dimension.y-deformidad, dimension.z)); } 58 Figura 16: Diagrama de clases de la aplicaci√≥n. Las clases que controlan la interfaz gr√°fica y el control de la aplicaci√≥n son: a) Camara Controla la c√°mara de la aplicaci√≥n y captura los eventos de teclado y mouse para la navegaci√≥n en la escena. Es posible desplazarse hacia adelante o hacia atr√°s con las flechas de arriba y abajo en el teclado, as√≠ mismo es posible desplazarse hacia los lados con las flechas de izquierda y derecha. Con el mouse es posible cambiar el punto de vista de la c√°mara. La c√°mara est√° hecha con OpenGL y la captura de eventos se hace con las clases QEvent de QT. En la Figura 17 se pueden ver en detalle los elementos que conforman esta clase. 59 Figura 17: Diagrama de clases de la clase Camara. b) canaletas Controla la ventana ‚ÄúInsertar canaleta‚Äù, ver Figura 19. Permite la selecci√≥n de un √∫nico tipo de canaleta (Biselada, Semicircular, Estilo K y Pecho Paloma) por medio de botones. A trav√©s del comboBox ‚ÄúPuntera de desag√ºe‚Äù se puede elegir hacia qu√© lado va a quedar el segmento final (derecha, izquierda o central). Se puede elegir el √°ngulo de inclinaci√≥n del punto de bajada (45¬∞, 30¬∞ o 22,6¬∞). La clase hereda de ‚ÄúQMainWindow‚Äù quien gestiona la captura de eventos de interfaz. Es instanciado por la clase ‚ÄúQTOpenGL‚Äù como se aprecia en la Figura 18. 60 Figura 18: Diagrama de clases de la clase canaletas. Figura 19: Ventana de interfaz para configurar el sistema de canaletas. 61 c) glwidget Establece todas las configuraciones b√°sicas de OpenGL. Esta clase hereda de ‚ÄúQGLWidget‚Äù una clase de la librer√≠a QT que permite crear un lienzo de OpenGL. Adem√°s es en esta clase en donde se crea una instancia del singleton ‚ÄúEscena‚Äù y se crea la c√°mara (instancia de la clase Camara) , como se aprecia en la Figura 20. Figura 20: Diagrama de clases de la clase glwidget. d) Librerias Incluye todas las librer√≠as de PhysX y los Helpers de Nvidia que han de ser utilizados. Es un archivo √∫nicamente de cabecera que se incluye en todas las clases de la aplicaci√≥n. 62 e) qtopengl Es una clase de control que permite capturar todos los eventos de la interfaz gr√°fica y a partir de ello ejecutar acciones o darle valor a algunos atributos de control. Esta clase hereda de ‚ÄúQMainWindow‚Äù que es la clase principal en la librer√≠a de QT para el manejo de aplicaciones de ventana, tal como se aprecia en la Figura 21. Figura 21: Diagrama de clases de la clase QTOpenGL. 63 La Figura 22 muestra una captura de la aplicaci√≥n en tiempo de ejecuci√≥n. All√≠ pueden apreciarse los elementos que forman parte de la interfaz principal: el men√∫ ‚ÄúSimulaci√≥n‚Äù, desde donde se crean los techos y el sistema de canaletas; el men√∫ ‚ÄúVistas‚Äù que permite mover la c√°mara a posiciones predeterminadas. Los botones que controlan la iluminaci√≥n con el modelo de sombreado Phong o Gouraud, seg√∫n sea el caso. Una serie de sliders y botones para la edici√≥n de todos los par√°metros que intervienen en el proceso de despliegue y visualizaci√≥n del agua, as√≠ como la posibilidad de elegir el tipo de despliegue que se har√° (ComboBox ‚ÄúModo de Despliegue‚Äù) y de reiniciar los par√°metros a su valor por defecto. Tambi√©n hay un slide que nos permite editar la intensidad de precipitaci√≥n y finalmente se encuentran unos botones que inician el proceso de generaci√≥n de la lluvia o lo detiene. Se puede pausar la simulaci√≥n o simplemente reiniciarla. Figura 22: Captura de la aplicaci√≥n con la interfaz principal. 64 f) roofSettings Controla la interfaz de la ventana ‚ÄúInsertar Techo‚Äù, ver Figura 24. Desde all√≠ es posible configurar el largo y ancho del techo, expresado en metros; la morfolog√≠a del techo (techo plano, techo inclinado o techo a dos aguas) y el tipo de techo (superficie lisa, revestimiento de tejas o techo corrugado). Si en tipo de techo se elige la opci√≥n de techo corrugado, se habilitar√°n cuatro botones que permitir√°n seleccionar el tipo de techo corrugado. Finalmente es posible elegir la proporci√≥n (alto:ancho) que determina la inclinaci√≥n del techo si se ha elegido la opci√≥n de techo inclinado o a dos aguas. Figura 23: Ventana de interfaz para configurar el sistema de techos. 65 Esta clase hereda de ‚ÄúQMainWindow‚Äù quien le permite la captura de eventos tal como se observa en la Figura 23. Al igual que en el caso de la clase ‚Äúcanaleta‚Äù, es la clase ‚ÄúQTOpenGL‚Äù quien crea la instancia de esta clase. Figura 24: Diagrama de clases de la clase roofSettings. La clase base de toda la aplicaci√≥n es la clase ‚ÄúEscena‚Äù. Sin embargo hay otros elementos relacionados a la creaci√≥n y manejo de los elementos de PhysX que deben ser controlados por otras clases diferentes a la Escena. Las clases que controlan los elementos de PhysX son: g) HelperActor Esta clase controla la creaci√≥n de actores en la escena utilizando diferentes shapes. Es posible crear los shapes nativos: box, capsule y plane y tambi√©n un actor basado en un convexMesh o un NxTriangleMesh. Para la creaci√≥n de los techos inclinados o techos a dos aguas de superficie lisa se utilizan elementos de tipo box. Para la creaci√≥n del suelo, que adem√°s es un drain, la clase fluido utiliza a la clase ‚ÄúHelperActor‚Äù para crear un actor con forma NxPlaneShape. La estructura de la edificaci√≥n se crea utilizando un NxConvexMesh y los techos corrugados, tejas y canaletas se cargan como un NxTriangleMesh a partir de un archivo .obj. 66 Para la creaci√≥n de estos elementos, la clase ‚ÄúHelperActor‚Äù cuenta con los m√©todos: ‚ÄúCreateBox‚Äù, ‚ÄúCreateCapsule‚Äù, ‚ÄúCreateGroundPlane‚Äù, ‚ÄúcrearTriangleMesh‚Äù y finalmente ‚ÄúcrearConvexMesh‚Äù; tal como se observa en la Figura 25. Figura 25: Diagrama de clases de la clase HelperActor. h) DrawObjects Despliega los actores en forma de mallado o de geometr√≠a. Todos los actores, a excepci√≥n de los NxTriangleMesh son desplegados desde la escena por medio de esta clase. La Figura 26 muestra los atributos y m√©todos m√°s importantes que forman parte de esta clase. Figura 26: Diagrama de clases de la clase DrawObjetcs. i) Fluido Para la gesti√≥n del fluido se instancia desde la clase ‚ÄúEscena‚Äù una clase llamada ‚ÄúFluido‚Äù, que se encargar√° de controlar la creaci√≥n y eliminaci√≥n de dicho fluido. Esta clase tiene seis m√©todos: ‚ÄúCrearFluidEmitter‚Äù, ‚ÄúCrearFluido‚Äù, ‚ÄúCrearDrain‚Äù, ‚ÄúbindVBO‚Äù, ‚ÄúunbindVBO‚Äù y ‚ÄúUpdateVBO‚Äù, como se aprecia en la Figura 27. 67 Figura 27: Diagrama de clases de la clase Fluido. El m√©todo ‚ÄúCrearFluidEmitter‚Äù crea una instancia de la clase NxFluidEmitterDesc e inicializa algunos de sus atributos. Desde all√≠ se crea tambi√©n el fluido invocando al m√©todo ‚ÄúCrearFluido‚Äù. Este m√©todo recibe como par√°metro la posici√≥n y la dimensi√≥n del emisor, as√≠ como una referencia a la escena. El actor del emisor es creado por la clase ‚ÄúHelperActor‚Äù como un NxActor est√°tico, al cual se le adjunta un emitter, es decir, tendr√° las propiedades y el comportamiento de un emitter. Algunos atributos importantes del NxFluidEmitterDesc creado por el m√©todo ‚ÄúCrearFluidEmitter‚Äù son: ‚Ä¢ rate: Cantidad de part√≠culas que son emitidas por segundo. La tasa s√≥lo es considerada durante la simulaci√≥n si es del tipo NX_FE_CONSTANT_FLOW_RATE. Este valor se calcula dividiendo la cantidad m√°xima de part√≠culas entre la constante 300. ‚Ä¢ randomAngle: Indica la desviaci√≥n aleatoria en la que han de ser generadas las part√≠culas desde el emitter. Este √°ngulo es relativo a la orientaci√≥n del emitter con respecto al eje ùëß. Este valor ha sido fijado en 0,1. ‚Ä¢ randomPos: Es la variaci√≥n aleatoria de la posici√≥n de las part√≠culas relativa a la posici√≥n del emitter con respecto al eje ùëß. El valor que recibe este par√°metro es del tipo NxVec3, en este caso ha sido un vector de valor 0 en todas sus coordenadas. ‚Ä¢ fluidVelocityMagnitude: Magnitud de la velocidad de las part√≠culas del fluido generadas por el emitter. Note que la velocidad m√°xima de part√≠culas est√° limitada por el atributo NxFluid::motionLimitMultiplier. En este caso las part√≠culas inician con velocidad 0, puesto que caen por gravedad. 68 ‚Ä¢ repulsionCoefficient: Define un factor de transferencia del impulso con que son despedidas las part√≠culas desde el emisor. Como las part√≠culas de lluvia se precipitan en forma de ca√≠da libre sin ninguna fuerza o velocidad inicial, este valor ha sido inicializado en cero. ‚Ä¢ maxParticles: Determina la cantidad m√°xima de part√≠culas que han de ser generadas por el emitter. El emitter detendr√° la creaci√≥n de part√≠culas cuando este l√≠mite sea alcanzado y comenzar√° de nuevo una vez que el n√∫mero de part√≠culas del fluido est√© por debajo del l√≠mite. Si se establece en 0, el n√∫mero de part√≠culas emitidas es libre (hasta el m√°ximo para fluidos). En la Tabla 7 podemos apreciar la cantidad de part√≠culas utilizadas para la simulaci√≥n de diferentes intensidades de precipitaci√≥n en este trabajo. Nro. de Part√≠culas Intensidad media (mm/h) 50000 50 100000 75 150000 100 250000 125 350000 150 600000 200 Tabla 7: Relaci√≥n Part√≠culas ‚Äì Intensidad media de precipitaci√≥n generadas en la simulaci√≥n. ‚Ä¢ particleLifetime: Tiempo de vida en segundos de las part√≠culas que genera el emitter. Si se coloca en cero, las part√≠culas vivir√°n hasta llegar a un drain. En este caso las part√≠culas han sido configuradas con un tiempo de vida largo de 50 segundos, para evitar que desaparezcan antes de llegar al suelo, pero garantizando su eliminaci√≥n en caso de quedar atascadas en alg√∫n lugar que les impida llegar al drain. ‚Ä¢ type: Tipo de emisor que puede ser constante de presi√≥n (NX_FE_CONSTANT_PRESSURE) o constante de tasa de flujo (NX_FE_CONSTANT_FLOW_RATE), siendo este √∫ltimo el elegido en este trabajo. ‚Ä¢ shape: Forma del emitter. Existen dos opciones: Rectangular (NX_FE_RECTANGULAR) o El√≠ptica (NX_FE_ELLIPSE). Para este trabajo se utiliza un emisor rectangular. ‚Ä¢ flags: |= NX_FEF_FORCE_ON_BODY; 69 El m√©todo ‚ÄúCrearFluido‚Äù invoca al m√©todo NxScene::createFluid() con su descriptor apropiado para crear el fluido. Luego se asignan todos los par√°metros al fluido: ‚Ä¢ kernelRadiusMultiplier: Controla el radio de la esfera de influencia para la interacci√≥n de part√≠culas. El valor utilizado es 2,0. ‚Ä¢ restDensity: Densidad esperada para el fluido. Para el agua la densidad aproximada es 1000. ‚Ä¢ restParticlesPerMeter: Este par√°metro est√° relacionado a la densidad del fluido, se refiere a la cantidad de part√≠culas por metro lineal, medido cuando el fluido est√° en su estado de reposo. El valor utilizado es 0,7. Cuando se simula un fluido, la masa de cada part√≠cula es constante, sin embargo la densidad var√≠a a trav√©s del tiempo debido a la compresibilidad del fluido. Por lo tanto, el cambio de densidad es logrado a trav√©s del movimiento de part√≠culas. Un √°rea del fluido con alta densidad ser√° producto de un conjunto de part√≠culas que se encuentran muy cercanas las unas de las otras en un momento dado. ‚Ä¢ stiffness: Especifica la rigidez de las part√≠culas, relacionadas con la presi√≥n. En este caso el valor asignado es 1,0. ‚Ä¢ viscosity: Define el comportamiento viscoso del fluido. Se toma como valor 1, lo correspondiente a la viscosidad del agua a 20¬∞C, que es un estimado de la media de la temperatura cuando llueve. ‚Ä¢ damping: Constante global de velocidad de amortiguaci√≥n para todas las part√≠culas. El valor utilizado es 0,2. Este par√°metro ayuda a simular la resistencia de las part√≠culas al caer o moverse en otras direcciones, debido a la fuerza de la gravedad o al viento. ‚Ä¢ surfaceTension: La tensi√≥n superficial es modelada a trav√©s de una fuerza de atracci√≥n entre part√≠culas. En el interior del fluido, las fuerzas de tensi√≥n superficial se equilibran entre s√≠. Sin embargo, en la superficie del fluido ellos act√∫an en la direcci√≥n opuesta a la normal de la superficie, la cual tiende a reducir la curvatura de la superficie del fluido. ‚Ä¢ motionLimitMultiplier: Distancia m√°xima en la que una particular podr√≠a desplazarse en un instante de tiempo. Este valor est√° configurado en 16. ‚Ä¢ packetSizeMultiplier: Permite paralelizar el fluido en diferentes paquetes, en este caso la cantidad de paquetes ha sido limitada a 8. ‚Ä¢ collisionDistanceMultiplier: Define la distancia de la colisi√≥n entre las part√≠culas y la superficie de la geometr√≠a, este valor est√° configurado en 0.5 para que al interceptarse las part√≠culas con la superficie de la geometr√≠a se simule un poco la forma en la que una gota de agua se esparce al colisionar con un cuerpo r√≠gido con permeabilidad nula o poca. 70 ‚Ä¢ dynamicFrictionForStaticShapes: Coeficiente de fricci√≥n din√°mico con respecto a cuerpos est√°ticos. Su valor es 0. ‚Ä¢ dynamicFrictionForDynamicShapes: Coeficiente de fricci√≥n din√°mico con respecto a cuerpos din√°micos. Su valor es 0. ‚Ä¢ staticFrictionForDynamicShapes: Coeficiente de fricci√≥n est√°tico con respecto a cuerpos din√°micos. Su valor es 0,5. ‚Ä¢ staticFrictionForStaticShapes: Coeficiente de fricci√≥n est√°tico con respecto a cuerpos est√°ticos. Su valor es 0,5. ‚Ä¢ restitutionForStaticShapes: Define el coeficiente de restituci√≥n usado par alas colisiones de las part√≠culas del fluido con formas est√°ticas. En este caso el valor asignado es cero. ‚Ä¢ collisionResponseCoefficient: Define el factor de transferencia del impulso cu√°ndo las part√≠culas del fluido colisionan con un cuerpo r√≠gido, este valor est√° configurado en 0,2. ‚Ä¢ collisionMethod: Es una bandera que indica si la colisi√≥n con el entorno, bien sea est√°tica o din√°mica, ha de realizarse. En este caso se activan ambas asignado los valores NX_F_STATIC y NX_F_DYNAMIC. ‚Ä¢ flags: Bandera que permite definir con exactitud el conjunto de propiedades activas en el fluido. En este caso se activa la colisi√≥n de las part√≠culas con otros actores y viceversa por medio del valor NX_FF_COLLISION_TWOWAY. El m√©todo ‚ÄúCrearDrain‚Äù recibe como par√°metro la escena y la posici√≥n donde ha de ser creado el drain. La primitiva de PhysX utilizada como forma para este drain, es un NxPlaneShape que viene a ser el suelo donde se sostiene la estructura. Al elegir un plano que simule el suelo, no solo se est√° creando un drain que mantenga bajo control la cantidad de part√≠culas sino que adem√°s simula lo que realmente ocurre, que el agua es absorbida por el suelo hasta desaparecer por efecto de la percolaci√≥n. El m√©todo ‚ÄúbindVBO‚Äù verifica la dimensi√≥n de los paquetes del fluido para copiar los bloques de memoria de PhysX a OpenGL. Luego estos bloques de memoria ser√°n desplegados haciendo uso del Vertex Buffer Object (VBO) de OpenGL. Cuando el Vertex Buffer Object de OpenGL no va a ser utilizado nuevamente, el m√©todo ‚ÄúunbindVBO‚Äù lo desenlaza. Este m√©todo desvincula todos los arreglos inherentes a las propiedades de las part√≠culas (posici√≥n, densidad, velocidad) del VBO. El m√©todo ‚ÄúUpdateVBO‚Äù establece los arreglos de posici√≥n, densidad y velocidad perteneciente al VBO para luego desplegar con ‚ÄúglMultiDrawArrays‚Äù. Dicho de otra forma, reserva el espacio 71 de memoria e indica los apuntadores a dichos bloques donde el m√©todo ‚ÄúbindVBO‚Äù ha de copiar la informaci√≥n de OpenGL para que el VBO pueda manejarla y desplegarla. j) Escena Es la clase principal del proyecto, casi todos los elementos son instanciados por esta clase como se aprecia en la Figura 28. Esta clase es un singleton, desde ella se crean todos los objetos de PhysX y se hace el despliegue final. Figura 28: Diagrama de clases de la clase Escena. 72 Los m√©todos de esta clase son: ‚Ä¢ Escena: Es en el constructor de la escena donde se crea el NxPhysicsSDK, clase base para trabajar con PhysX, tal como se explic√≥ en el CAP√çTULO III. Se instancian algunos par√°metros del NxPhysicsSDK y se crea el NxSceneDesc. A partir de all√≠ se pueden crear los diferentes actores de PhysX, incluyendo al fluido (ver Figura 6). Se instancian otros atributos de la escena como la gravedad, los actores y las variables de control con un valor por defecto. As√≠ mismo, se llenan las tres matrices esparcidas que contienen la relaci√≥n intensidad-√°rea de techo y las dimensiones de los puntos de bajada con relaci√≥n a la forma de los mismos (bajante circular o rectangular). ‚Ä¢ obtenerEscena: Retorna una instancia de Escena si ya existe, sino la crea por primera y √∫nica vez (singleton). ‚Ä¢ cargarTechos: Funciona como un m√©todo Factory. Utiliza varias variables de control para saber qu√© tipo de techo ha de instanciar y sus detalles de configuraci√≥n. La variable ‚Äúmorfolog√≠a‚Äù indica si el techo es plano, inclinado o a dos aguas. Cuando el techo es a dos aguas se crean dos NxActor para el techo y se trasladan de forma tal que se unan en el plano que contiene el eje ùë¶ como si fuera un espejo. La variable ‚Äútipo‚Äù indica que tipo de techo se va a cargar (superficie lisa, tejas o techo corrugado) y la variable ‚ÄútechoCorrugado‚Äù, el tipo de techo corrugado. Ambas variables determinan el archivo que la clase HelperActor ha de cargar como un triangleMesh. Si la superficie es lisa, se le indicar√° a HelperActor que debe crear un NxActor a partir de un box. ‚Ä¢ cargarCanaletas: Al igual que en el m√©todo anterior utiliza variables de control para verificar las configuraciones del sistema de canaletas que ha de cargar. Cuando la variable ‚Äúmorfolog√≠a‚Äù indica que el techo es a dos aguas, se deber√° duplicar todo el sistema de canaletas para adjuntar uno a cada alero del techo. La variable de control ‚ÄútipoCanaleta‚Äù indicar√° si el sistema de canaletas tendr√° forma Biselada, Pecho Paloma, Semicircular o Estilo K. La variable de control ‚ÄúdesagueCanaleta‚Äù indicar√° si el segmento final ha de ubicarse a la derecha, en el centro o del lado izquierdo. La variable de control ‚Äúelbow‚Äù permite saber el √°ngulo de inclinaci√≥n del punto de bajada. Adem√°s de verificar las configuraciones pertinentes a la creaci√≥n del sistema de canaletas, este m√©todo realiza todas las transformaciones afines a cada uno de los elementos de la escena para ubicarlos, rotarlos y escalarlos de manera adecuada. 73 La clase Escena tiene un ‚Äústruct posiciones‚Äù que almacena un valor de traslaci√≥n y rotaci√≥n. A trav√©s de un map se vincula una etiqueta con un elemento de este struct por cada actor creado. Tanto el m√©todo ‚ÄúcargarTechos‚Äù como ‚ÄúcargarCanaletas‚Äù se encargar√°n de etiquetar a cada actor utilizando esta estructura. Esto servir√° para que m√°s adelante el m√©todo ‚ÄúRenderScene‚Äù pueda acceder a esta informaci√≥n y aplicar las transformaciones adecuadas, ya no a nivel de actor sino a nivel de despliegue. ‚Ä¢ cargarObjetosPrincipales: Carga los objetos que han de aparecer en la escena por defecto, en este caso solo el ‚ÄúgroundPlane‚Äù y le aplica una textura llamando a la clase ‚ÄúmapearTextura‚Äù. ‚Ä¢ generarLluvia: Crea una instancia de la clase Fluido y llama al m√©todo crearFluidEmitter. ‚Ä¢ Simulacion: Crea la simulaci√≥n de NxScene. ‚Ä¢ postRender: Verifica si la simulaci√≥n ha sido reiniciada a trav√©s de un booleano antes de liberar el NxPhysicsSDK, la escena y todos los elementos que la contienen. Lo primero que elimina es el fluido en caso de que haya sido creado, los emisores y vac√≠a los arreglos que contienen las referencias a los fluidos y a los emisores. Luego elimina los actores (sistema de techos y canaletas, estructura y el ‚ÄúgroundPlane‚Äù) siguiendo un proceso similar a lo ocurrido con los fluidos. Lo √∫ltimo en liberarse es la escena y el NxPhysicsSDK. Finalmente se crea de nuevo una escena vac√≠a y se cargan los objetos principales. ‚Ä¢ SkyBox: Despliega el skyBox previamente cargado por la clase ‚Äúglwidget‚Äù. ‚Ä¢ mapearTextura: Habilita el mapeo de texturas de OpenGL y asigna la imagen y las coordenadas de textura. ‚Ä¢ Desplegar: Organiza la secuencia de despliegue de la aplicaci√≥n. La Figura 29 ilustra la secuencia que ha de seguir la aplicaci√≥n para el despliegue gr√°fico, tanto los m√©todos que son llamados directamente por el m√©todo desplegar como los que constituyen una llamada indirecta, la instancia de otras clases o la aplicaci√≥n de shaders. 74 Figura 29: Diagrama de secuencia del proceso de despliegue. ‚Ä¢ RenderScene: Se encarga del despliegue de todos los elementos de la escena a excepci√≥n del fluido. En este m√©todo, se relacionan todos los elementos a ser renderizados con la textura que le corresponde. El primer elemento que se despliega es el Skybox puesto que es lo que se encuentra m√°s distante y debe ser renderizado antes de activar el Z-buffer para el despliegue de los dem√°s elementos. Para ello se hace una llamada a la funci√≥n SkyBox. Luego se renderizan todos los modelos 3D, utilizando la etiqueta del elemento como identificador, lo cual permitir√° saber qu√© transformaciones afines y qu√© texturas ser√°n aplicadas a dicho objeto. Finalmente se despliegan todos los actores basados en primitivas de PhysX, esto incluye el suelo, un NxPlaneShape; la estructura, un NxConvexShape; y los techos inclinados de superficie lisa que utilizan como primitiva un NxBoxShape. Todo esto es plasmado en una √∫nica textura que ser√° utilizada posteriormente por la funci√≥n ‚ÄúRenderComposition‚Äù para el despliegue final como se aprecia en la Figura 30. 75 Figura 30: Pipeline de despliegue. ‚Ä¢ renderSmooth: Es invocado por el m√©todo ‚ÄúRenderFluid‚Äù. Carga el shader Smooth y retorna a RenderFluid una textura con el mapa de profundidades de las part√≠culas suavizado (Adaptative Curvature Flow Filtering). ‚Ä¢ RenderQuad: Dibuja un recuadro que cubre toda la pantalla para hacer las veces de lienzo, en donde las funciones ‚ÄúRenderComposition‚Äù y ‚ÄúrenderSmooth‚Äù van a plasmar todo lo que ha de desplegarse o alguna textura intermedia. Las posiciones de los v√©rtices del Quad est√°n en coordenadas de pantalla y est√°n normalizadas entre -1 y 1. As√≠ mismo las coordenadas de textura se encuentran normalizadas entre 0 y el tama√±o de pantalla para preservar el tama√±o de los p√≠xeles. ‚Ä¢ RenderSpray: Crea las configuraciones de lluvia para que el shader ‚ÄúRain‚Äù pueda desplegar algunas part√≠culas como lluvia. Lo primero que hace es asignar el color de las part√≠culas, luego verifica que el fluido exista antes de comenzar a configurar los valores. Una vez comprobada la existencia del fluido habilita el test de profundidad, la transparencia a partir de mezcla aditiva, y llama al shader ‚ÄúRain‚Äù para que haga los c√°lculos correpondientes. ‚Ä¢ RenderComposition: Llama al shader Composite para unir todas las texturas y generar la composici√≥n de ellas para el despliegue final. ‚Ä¢ RenderFluid: Establece las configuraciones de despliegue necesarias para ejecutar los shaders inherentes al render del fluido. Luego de ello invoca a dichos shaders. 76 k) ObjMesh Maneja toda la estructura de los modelos 3D para cargar un modelo a partir de un archivo .obj y a partir de los datos del modelo generar el mallado, exportar las coordenadas de textura, las normales, el material, etc. La Figura 31 muestra los principales m√©todos y atributos que forman parte de esta clase, as√≠ como las estructuras que utiliza y las clases con quienes se relaciona. Figura 31: Diagrama de clases de la clase ObjMesh. l) Shader Dado el nombre de un archivo de fragmento y/o de v√©rtice, esta clase carga el shader, lo compila y lo vincula a OpenGL. Adem√°s esta clase es la encargada de activar y/o desactivar el shader y de pasar por par√°metro los atributos y texturas a los diferentes shaders. La Figura 32 muestra en un diagrama los elementos que forman parte de √©l. 77 Figura 32: Diagrama de clases de la clase Shader. m) Matrix Contiene la estructura y un conjunto de operaciones sobre dicha estructura, necesarias para el c√°lculo de la rotaci√≥n de la c√°mara. La Figura 33 muestra el detalle de la clase ‚ÄúMatrix‚Äù. Figura 33: Diagrama de clases de la clase Matrix. 78 n) UserAllocator Hereda de la clase NxUserAllocator para gestionar el proceso de reserva de memoria que necesita PhysX SDK para instanciar cualquier elemento del API. Los elementos que intervienen en esta clase est√°n ilustrados en la Figura 34. Figura 34: Diagrama de clases de la clase UserAllocator. o) DepthShader Llama al Shader ‚ÄúDepth‚Äù para que haga el c√°lculo del mapa de profundidades, ver Figura 35. Figura 35: Diagrama de clases de la clase DepthShader. 79 p) FluidShader Esta clase gestiona todas las texturas intermedias que van a ser utilizadas durante el proceso de despliegue, adem√°s es quien guarda los par√°metros de despliegue del fluido, tales como: el grosor, la refracci√≥n, coeficiente de atenuaci√≥n, tama√±o de las part√≠culas, etc. Todos los atributos y m√©todos que forman parte de esta clase pueden apreciarse en la Figura 36. Figura 36: Diagrama de clases de la clase FluidShader. q) ThicknessShader Llama al Shader ‚ÄúThickness‚Äù para que haga el c√°lculo del mapa de profundidades, ver Figura 37. Figura 37: Diagrama de clases de la clase ThicknessShader. 80 3. Shaders A continuaci√≥n se describen todas las funcionalidades de los shaders utilizados en este trabajo. El Phong utilizado para calcular la iluminaci√≥n y todos los dem√°s son empleados en el render del fluido. a) Phong Este shader se encarga de calcular la iluminaci√≥n con el m√©todo de sombreado Phong en la escena. En el vertex shader se calculan los vectores ùëâ y ùêø a partir de la posici√≥n y la direcci√≥n del rayo de luz, con lo cual el fragment shader ha de calcular la luz especular y difusa respectivamente. Adem√°s se almacena en el vector ùëÅ el valor de la normal transformado a coordenadas de normales. La funci√≥n ‚Äúreflect‚Äù de GLSL permite saber la cantidad de energ√≠a luminosa especular que incide en la superficie, la cual se almacena en el vector ùëÖ. La luz ambiental se calcula a partir del color del material y la cantidad de luz ambiental que recibe la superficie. Del mismo modo ocurre con la luz difusa, con la diferencia de que estas se multiplican por el producto punto entre ùëÅ y ùêø. El c√°lculo de la luz especular se obtiene a partir del valor de luz especular multiplicado por la luz incidente en la superficie. Para obtener esto √∫ltimo se calcula el producto punto entre ùëÖ y ùëâ y se eleva por el valor de brillo del material (shininess). Para descartar la luz que incide por la parte de atr√°s de los pol√≠gonos no se toma en cuenta los valores negativos, as√≠ se evita calcular la iluminaci√≥n en las caras traseras. b) Depth Este shader se encarga b√°sicamente de calcular el mapa de profundidades de las part√≠culas aplicando splatting y adem√°s modifica el Z-buffer para que el sprite parezca una esfera. 81 En principio se debe saber que las part√≠culas del fluido son desplegadas como un sprite de OpenGL por el m√©todo ‚ÄúRenderFluid‚Äù de la clase ‚ÄúEscena‚Äù, la cual crea el shader ‚ÄúDepth‚Äù y le pasa como par√°metro todos estos sprites. A partir del sprite, cuya forma es un cuadrado el fragment shader descarta los fragmentos que no est√©n dentro de la esfera utilizando la f√≥rmula de la circunferencia. El √∫nico dato que se almacena del sprite es su centro. El sprite va de -1 a 1 por lo que el radio de una esfera contenida dentro de este deber√≠a medir 1. Si la distancia desde el centro hasta un fragmento cualquiera es mayor que uno quiere decir que se encuentra fuera de la circunferencia, con lo cual es descartado. La Figura 38 ilustra esto gr√°ficamente. Figura 38: Textura Sprite para el despliegue del fluido. Una vez que se han convertido los sprites en circunferencias se procede a aplicar el splatting, para ello se determina cu√°les son las caras delanteras de la superficie del fluido desde la posici√≥n de la c√°mara. De este modo, se renderizan todas las part√≠culas como esferas sobre un mapa de profundidades. Al utilizar este mapa de profundidades se asegura que s√≥lo los p√≠xeles m√°s cercanos al viewport sean almacenados. Antes de activar el shader el mapa de profundidad es inicializado con el valor -10000 para todos sus t√©xeles, lo cual indica un valor infinito relativo. Adem√°s, la mezcla de colores es deshabilitada y el test de profundidad por hardware es habilitado para asegurar que los valores m√°s cercanos de cada p√≠xel sean conservados. 82 c) Downsample Constituye una optimizaci√≥n para el shader ‚ÄúSmooth‚Äù que sirve para reducir el tama√±o del buffer de profundidad a la mitad antes de aplicar la t√©cnica Adaptative Curvature Flow Filtering. Esto supone sacrificar un poco la calidad de imagen para obtener una mejora en el rendimiento del algoritmo. d) Smooth Este shader est√° basado en la t√©cnica de Adaptative Curvature Flow Filtering y es ejecutado despu√©s de obtener el mapa de profundidades del fluido. Esta t√©cnica realiza una serie de iteraciones en donde cada una de ellas resuelve una integraci√≥n euleriana. Dado un fragmento se debe evaluar si su profundidad no corresponde al infinito relativo, en ese caso se procede a determinar el valor de las profundidades de dicho fragmento, calculando las diferencias finitas de dicho valor en las vecindades del fragmento. Luego se calcula la derivada direccional a partir de la cual se obtiene el valor de la curvatura media. Es importante destacar que antes de calcular el valor de la curvatura media se debe evaluar los valores resultantes del c√°lculo de la derivada direccional para determinar si pertenecen al mismo parche de superficie de fluido. Esto se consigue comparando las derivadas direccionales con el valor del coeficiente de atenuaci√≥n ‚ÄúblurDepthFalloff‚Äù, que viene a hacer las veces de umbral. La Ecuaci√≥n 5.4 se resuelve multiplicando las derivadas finitas por unas constantes calculadas a partir de algunos par√°metros del punto de vista. Con esto se calcula la curvatura media expresada en la Ecuaci√≥n 5.7 y finalmente se obtiene el color del fragmento, el cual usa el canal rojo para almacenar la profundidad desplazada. e) Passing Dado que no es posible leer y escribir una textura al mismo tiempo, se requieren dos texturas para utilizar la t√©cnica Adaptative Curvature Flow Filtering, de modo que mientras el shader ‚ÄúSmooth‚Äù se encarga de leer la textura, el shader ‚ÄúPassing‚Äù se encargar√° de guardar los valores recibidos de ‚ÄúSmooth‚Äù. 83 Esto servir√° para intercambiar las texturas en donde se desplegar√°n las profundidades desplazadas. Por cada iteraci√≥n de suavizado calculada en el shader ‚ÄúSmooth‚Äù se almacenar√° la textura resultante para poder preservar el valor de profundidad anterior correspondiente a ese fragmento antes de descartalo. f) Thickness Este shader se encarga b√°sicamente de calcular el grosor o espesor (Thickness) de las part√≠culas aplicando nuevamente splatting. En principio se despliegan el conjunto de part√≠culas del fluido de manera similar al shader ‚ÄúDepth‚Äù, con la diferencia de que en este shader se utiliza mezcla aditiva de colores para acumular la contribuci√≥n de cada part√≠cula y que el Z-buffer obtenido al desplegar la escena es utilizado para comprobar que el grosor del fluido no est√© siendo ocluido por alguna geometr√≠a de la escena, por esta raz√≥n se deshabilita la escritura del Z-buffer. Figura 39: Kernel de Splatting utilizado para simular el grosor del agua. A la izquierda se muestra una sola part√≠cula. A la derecha una captura de una capa de fluido con el c√°lculo de espesor. El c√°lculo del grosor est√° basado en una funci√≥n exponencial en la cual, las part√≠culas que son acumuladas no presentan discontinuidades o cambios bruscos en el grosor. En la Figura 39 se aprecian los resultados del c√°lculo del grosor o el espesor del fluido utilizando la t√©cnica de Splatting. 84 g) Composite Este shader se encarga de componer la imagen final mediante los c√°lculos realizados en los pasos anteriores. Este proceso es ilustrado brevemente en la Figura 40. Figura 40: Diagrama de proceso del shader "Composite". Las funciones que llevan a cabo este proceso son: ‚Ä¢ Main: Se calcula la profundidad promedio en cada fragmento a partir de los valores de profundidad que est√©n por debajo del infinito relativo en los vecinos de dicho fragmento. Luego se verifica si el fragmento forma parte del borde de la superficie del 85 fluido, si es as√≠ se realiza sobre √©l una interpolaci√≥n bilineal con el entorno para suavizar el l√≠mite de la silueta y obtener as√≠ el color del fragmento, de lo contrario se hace una llamada a la funci√≥n ‚Äúshade‚Äù para determinar dicho color. Finalmente se asigna el color calculado al fragmento. ‚Ä¢ ipnormal2: Realiza una interpolaci√≥n lineal para el c√°lculo de la normal del fragmento. Recibe por par√°metro el valor de la coordenada de textura y la direcci√≥n (ùë•,ùë¶) hacia donde se va a realizar la interpolaci√≥n. Con estos valores se calcula una muestra interpolada del fragmento actual y de dos vecinos haciendo uso de la funci√≥n texture2DRect de GLSL. Luego se obtiene la profundidad interpolada llamando a la funci√≥n ‚Äúipdepth‚Äù y finalmente se calcula una aproximaci√≥n de la normal interpolada por medio de la funci√≥n ‚ÄúuvToEyeD‚Äù. ‚Ä¢ uvToEyeD: Recibe por par√°metro la direcci√≥n del vector, la profundidad interpolada en la direcci√≥n dada y la profundidad del fragmento actual, y con estos valores calcula una aproximaci√≥n de la derivada parcial del fragmento mediante la diferencia central. ‚Ä¢ ipdepth: Recibe por par√°metro tres valores de muestreo del fragmento actual y dos de sus vecinos y con ellos calcula la interpolaci√≥n de las profundidades haciendo uso de la funci√≥n ‚Äúmix‚Äù de GLSL. ‚Ä¢ sampleFluid: Es usado para calcular la composici√≥n a los fragmentos que son bordes del fluido. Se determina el valor de la posici√≥n del fragmento en coordenadas de vista y con ello se calculan las derivadas parciales, necesarias para determinar el gradiente y con ello obtener los fragmentos que constituyen el borde del fluido. Luego se calcula el color del fragmento llamando a la funci√≥n ‚Äúshade‚Äù. ‚Ä¢ shade: Determina el color final de cada uno de los fragmentos que han de ser desplegados. Recibe por par√°metro las derivadas de ùë• e ùë¶ en ùëß, la coordenada de textura del fragmento y la posici√≥n del fragmento en coordenadas de vista. Lo primero que se hace es calcular la normal del fragmento, para ello se calcula el producto cruz de las derivadas de ùë• e ùë¶ en ùëß, y luego se normaliza el valor con la funci√≥n ‚Äúnormalize‚Äù de GLSL. Luego se configuran algunos variables relacionadas con la iluminaci√≥n de la superficie del fluido: la direcci√≥n de la luz, el vector ùë£ y ‚Ñé inherentes al c√°lculo del sombreado Phong y la especular. En los p√≠xeles que no forman parte de la superficie del fluido se deshabilita el valor especular. 86 El siguiente paso en el c√°lculo del color real del p√≠xel es el c√°lculo de la reflexi√≥n del entorno, en este caso las reflexiones est√°ticas basadas en mapeo de entorno c√∫bico y un t√©rmino de Fresnel el cual depende del √°ngulo de visi√≥n usado sobre la superficie del agua. El vector de reflexi√≥n es f√°cilmente calculado con la funci√≥n de reflexi√≥n de GLSL basada en la direcci√≥n del vector vista y la normal de la superficie. N√≥tese que el vector reflexi√≥n resultante ha sido transformado a espacio mundo porque este es el espacio nativo del mapeo de entorno. A continuaci√≥n se hace un muestreo con coordenadas enteras de la textura de grosor obtenida del shader ‚ÄúThickness‚Äù y se agrega el valor de algunos otros par√°metros del fluido como el color base del fluido y el coeficiente de atenuaci√≥n. Luego se calcula el color con la refracci√≥n en cada fragmento. La refracci√≥n se calcula perturbando las coordenadas de texturas del fragmento por la normal del fluido, con una magnitud correspondiente al grosor antes calculado. Este valor se compone luego con el color del fluido, el t√©rmino de fresnel y la luz especular que tambi√©n han sido calculadas con anterioridad. Finalmente se determina el tipo de despliegue que ha de hacerse de acuerdo a lo elegido desde la interfaz (refracci√≥n, especular, coeficiente de fresnel, normales, alpha, grosor del fluido o el despliegue completo). ‚Ä¢ getEyeSpacePos: Dadas las coordenadas de textura del fragmento se calcula la posici√≥n del fragmento en coordenadas de vista, haciendo uso de la funci√≥n ‚ÄúuvToEye‚Äù. ‚Ä¢ uvToEye: Recibe un valor de profundidad en coordenadas de pantalla y lo transforma a una posici√≥n aproximada en coordenadas de vista para el fragmento, utilizando la longitud focal de la c√°mara y las coordenadas de textura (u,v) del fragmento. h) Rain Verifica si una part√≠cula se encuentra por debajo del umbral de densidad y dado el caso modifica la part√≠cula de forma tal que pueda ser desplegada como una gota de lluvia, en lugar de mantener su forma esf√©rica propicia para el ‚ÄúSplatting‚Äù utilizado en el despliegue del resto del fluido que es percibido como un continuo. 87 El vertex shader recibe el estado de la part√≠cula (densidad, posici√≥n, velocidad y color), algunos de ellos como par√°metros ‚Äúvarying‚Äù o ‚Äúuniform‚Äù y otro haciendo uso de los diferentes canales de multitexture. Estos atributos son transmitidos al geometry shader. En este caso el geometry shader procesa un solo v√©rtice dado que la geometr√≠a con la que est√° trabajando es un sprite. De este sprite que representa la part√≠cula de fluido, recibe el estado de: densidad, posici√≥n, posici√≥n previa, direcci√≥n y color. Finalmente crea cuatro v√©rtices adicionales a la geometr√≠a, alrededor del v√©rtice original. Estos v√©rtices quedan desplazados en ùë• e ùë¶ de la posici√≥n original del sprite. El desplazamiento en ùë• corresponde al tama√±o de la part√≠cula mientras que el desplazamiento en ùë¶ es calculado a partir del tama√±o de la part√≠cula y la direcci√≥n de precipitaci√≥n de la part√≠cula, todo esto multiplicado por cuatro. En el fragment shader se muestrea una de las texturas representadas por la Figura 41 para dar apariencia de una gota y se mezcla con el color asignado para el factor de atenuaci√≥n. Por razones de simplicidad solo se eligi√≥ una de las texturas disponibles, sin embargo para mejorar el efecto visual se pueden usar varios tipos de texturas dependiendo de otros par√°metros de lluvia o del √°ngulo de visi√≥n. Figura 41: Diferentes texturas para la representaci√≥n de una gota de agua de lluvia. i) DebugTexture Recibe una textura que ha de desplegar en pantalla. Este shader es utilizado para depurar los resultados intermedios de despliegue y para desplegar el render final producido por el shader ‚ÄúRain‚Äù. 88 CAP√çTULO VII. Pruebas de rendimiento En este cap√≠tulo se detalla el conjunto de pruebas de rendimiento realizadas una vez terminada la etapa de implementaci√≥n. La Tabla 8 describe las caracter√≠sticas de los equipos utilizados en las pruebas realizadas. Equipo Sistema Operativo Procesador Memoria RAM Tarjeta gr√°fica Memoria de Video 1 Windows 7 Intel Core i3 3.07GHz 4,0 GB Nvidia GeForce GTX 550 Ti 1 GB 2 Windows 7 Intel Core i5 2.8GHz 4,0 GB Nvidia GeForce GTX 460 768 MB 3 Windows 8 Inter Core i7 2.4 GHz 8,0 GB Nvidia GTX 660M 2 GB Tabla 8: Equipos utilizados en las pruebas de rendimiento. 1. Pruebas Cuantitativas Para evaluar el rendimiento de la aplicaci√≥n se realizaron una serie de pruebas midiendo la cantidad de frames por segundo (FPS) con diferentes configuraciones del sistema de techos y canaletas, diferentes par√°metros para el despliegue del fluido y diversas configuraciones de iluminaci√≥n y de intensidad de precipitaci√≥n. De esta forma se evalu√≥ el comportamiento de la aplicaci√≥n de acuerdo a: cantidad de part√≠culas procesadas, complejidad en v√©rtices de la(s) geometr√≠a(s) desplegadas, modelo de iluminaci√≥n, tama√±o del kernel de suavizado y n√∫mero de iteraciones de suavizado. Las configuraciones utilizadas buscan explotar tres aspectos que hacen denso el procesamiento. La complejidad de la geometr√≠a en el caso de la primera configuraci√≥n asciende a los 32859 v√©rtices. En la configuraci√≥n 2 se utiliza la mayor cantidad de part√≠culas de fluido, 600000 para una intensidad de precipitaci√≥n de 200 mm/h. Finalmente la configuraci√≥n 3 pone a prueba las opciones de despliegue, utilizando el mayor tama√±o de kernel de suavizado (distancia 15) disponible y la mayor cantidad de iteraciones de suavizado (256 iteraciones). 89 En la Tabla 9 se aprecia en detalle cada una de las configuraciones utilizadas durante las pruebas de frames por segundo (FPS). V√©rtices Part√≠culas Despliegue Co nf ig ur ac i√≥ n 1 Sistema de Techos Techo inclinado de tejas 16x16 m. 32137 v√©rtices. Intensidad de precipitaci√≥n: 50 mm/h. 50000 part√≠culas. Sin iluminaci√≥n. Tama√±o de kernel de suavizado 2. 10 iteraciones de suavizado. DownSample habilitado. Sistema de Canaletas Semicircular central 30¬∞ inclinaci√≥n. 722 v√©rtices. Co nf ig ur ac i√≥ n 2 Sistema de Techos Techo a dos aguas corrugado tipo 4 10x12 m. 1268 v√©rtices. Intensidad de precipitaci√≥n: 200 mm/h. 600000 part√≠culas. Iluminaci√≥n Gouraud. Tama√±o de kernel de suavizado 4,5. 20 iteraciones de suavizado. DownSample deshabilitado. Sistema de Canaletas Pecho Paloma derecho 22,6¬∞ inclinaci√≥n. 256 v√©rtices. Co nf ig ur ac i√≥ n 3 Sistema de Techos Techo plano 6x6 m. 24 v√©rtices. Intensidad de precipitaci√≥n: 125 mm/h. 250000 part√≠culas. Iluminaci√≥n Phong. Tama√±o de kernel de suavizado 15. 256 iteraciones de suavizado. DownSample habilitado. Tabla 9: Configuraciones de prueba en Frames Por Segundo (FPS). Para determinar el rendimiento en cada uno de los equipos de prueba por cada una de las configuraciones preestablecidas, se captur√≥ la cantidad de FPS durante un minuto, obteniendo 60 valores que fueron posteriormente promediados. Esta operaci√≥n se realiz√≥ tres veces por cada prueba para obtener resultados m√°s precisos. Estos valores se pueden apreciar en la Tabla 10. N√≥tese que solo aparecen tres valores por cada prueba (Configuraci√≥n - Equipo), esto es debido a que la cantidad de Frames por Segundo capturados durante un minuto ya han sido promediados. 90 Configuraci√≥n 1 Configuraci√≥n 2 Configuraci√≥n 3 Eq ui po 1 13,41666667 7,983333333 19,03333333 13,6 7,85 19,08333333 13,76666667 7,816666667 19,15 Eq ui po 2 18,3166667 11,21666667 22,96666667 18,31666667 11,4 22,73333333 18,15 11,25 22,78333333 Eq ui po 3 11,83333333 7,05 11,13333333 11,86666667 7,05 11,16666667 11,55 7,183333333 11,18333333 Tabla 10: Resultados de prueba de FPS. De acuerdo a lo esperado, los resultados obtenidos en cada prueba por cada combinaci√≥n ‚ÄúConfiguraci√≥n ‚Äì Equipo‚Äù son similares, al promediar estos valores obtenemos un resultado m√°s preciso, el cual podemos apreciar en la Figura 42. Figura 42: Resultados de las pruebas cualitativas efectuados en los diferentes equipos de prueba para cada una de las configuraciones. De acuerdo a los resultados obtenidos, podemos notar que la configuraci√≥n que se desempe√±√≥ con m√°s alto rendimiento fue la ‚ÄúConfiguraci√≥n 3‚Äù en casi todos los equipos de prueba, a 13 ,5 9 18 ,2 6 11 ,7 5 7, 83 11 ,2 9 7, 09 19 ,0 9 22 ,8 3 11 ,1 6 0 5 10 15 20 25 Equipo 1 Equipo 2 Equipo 3 Fr am es p or s eg un do (F PS ) Configuraci√≥n 1 Configuraci√≥n 2 Configuraci√≥n 3 91 excepci√≥n del ‚ÄúEquipo 3‚Äù cuya ventaja la tiene la ‚ÄúConfiguraci√≥n 1‚Äù por s√≥lo unas pocas d√©cimas. A pesar de tener la iluminaci√≥n Phong activada (la m√°s costosa computacionalmente), el mayor tama√±o de kernel de suavizado (tama√±o 15) y realizar 256 iteraciones de suavizado, la cantidad de FPS obtenidos fue mayor que en las otras dos configuraciones. Una de las razones por las que esto podr√≠a haber ocurrido es porque la cantidad de v√©rtices cargados para esa configuraci√≥n son muy pocos (24 v√©rtices), y en comparaci√≥n con las otras dos configuraciones la diferencia es notable. Por ende, el arduo procesamiento que pudo haberse generado al ejecutarse el shader ‚ÄúSmooth‚Äù, se ve mermado por el hecho de que la cantidad de colisiones que tiene que procesar PhysX se hace contra una geometr√≠a muy sencilla y con una cantidad m√°xima de 250000 part√≠culas, que a√∫n cuando son una cantidad considerable, es menos de la mitad de lo m√°ximo soportado por PhysX o de lo que se utiliza por ejemplo en la ‚ÄúConfiguraci√≥n 2‚Äù. La ‚ÄúConfiguraci√≥n 1‚Äù present√≥ un rendimiento medio. A pesar de tener una cantidad de v√©rtices muy por encima de las otras dos configuraciones (32859 v√©rtices), s√≥lo se generaba una cantidad m√°xima de 50000 part√≠culas, no se activ√≥ ning√∫n tipo de iluminaci√≥n, y el tama√±o de kernel y de iteraciones de suavizado estuvo por debajo de la configuraci√≥n predeterminada (tama√±o 2 de kernel de suavizado y s√≥lo 10 iteraciones de suavizado). Todos estos factores permitieron que la mayor parte del procesamiento estuviera dedicado al procesamiento de los v√©rtices de forma tal que el rendimiento no decayera demasiado, por ende la cantidad de FPS obtenida en todos los equipos fue razonable. La ‚ÄúConfiguraci√≥n 2‚Äù fue la que obtuvo menor rendimiento en todos los equipos. La cantidad de v√©rtices procesados era mayor que en la ‚ÄúConfiguraci√≥n 3‚Äù pero mucho menor que en la ‚ÄúConfiguraci√≥n 1‚Äù y las configuraciones de despliegue fueron las predeterminadas (tama√±o de kernel de suavizado 4,5 y 20 iteraciones de suavizado), elegidas as√≠ para obtener un rendimiento medio, es decir, con un costo computacional moderado y sin sacrificar la calidad visual de la simulaci√≥n. La iluminaci√≥n Gouraud estuvo activada pero esta no representa un alto costo computacional. Podr√≠a decirse que lo que estuvo mermando el rendimiento fue la cantidad m√°xima de part√≠culas, 600000 para esta configuraci√≥n. Finalmente un factor decisivo en el rendimiento fue la activaci√≥n del shader ‚ÄúDownSample‚Äù en las configuraciones 1 y 3. Esta optimizaci√≥n permite que el tama√±o del buffer de profundidad sea reducido a la mitad antes de aplicar el shader ‚ÄúSmooth‚Äù, con lo cual aplicar la t√©cnica Adaptative Curvature Flow Filtering requiere de menos c√≥mputo. 92 Esto explica el hecho de que el rendimiento de la ‚ÄúConfiguraci√≥n 2‚Äù sea menor y la diferencia en la cantidad de FPS sea mucho mayor con respecto a la diferencia existente entre las otras dos configuraciones. A pesar de que todas las configuraciones fueron definidas de manera equivalente, procurando explotar el rendimiento s√≥lo en alguno de los elementos que requer√≠an m√°s procesamiento, la utilizaci√≥n del shader ‚ÄúDownSample‚Äù aventaj√≥ considerablemente a aquellas configuraciones que hac√≠an uso de √©l. Con respecto a los equipos de prueba, el equipo 3 fue el que present√≥ el peor rendimiento contrario a los pron√≥sticos. A simple vista parec√≠a ser el equipo con mayor capacidad debido al procesador, la memoria RAM y la memoria de video. Sin embargo, la mayor parte del procesamiento se hace a nivel de GPU y la tarjeta gr√°fica de este Equipo tiene algunas limitantes con respecto a las tarjetas gr√°ficas de los otros dos equipos. En principio el ancho de banda de la memoria (Memory Bandwidth en GB/seg) en el Equipo 3 es de 64.0 GB/seg, inferior a las del Equipo 1 (98.4 GB/seg) y el Equipo 2 (86.4 GB/seg). Esta caracter√≠stica est√° relacionada a la cantidad de informaci√≥n que puede ser transferida entre la memoria de video y el GPU y por ende afecta directamente a la velocidad de la memoria, desmejorando un poco el rendimiento a pesar de que la memoria de video y la capacidad del GPU puedan ser grandes. Por otro lado, la cantidad de texels que pueden desplegarse en un segundo de acuerdo a la caracter√≠stica Texture Fill Rate (1000 millones/seg), corresponde al Equipo 3 a 30.4 mil millones por segundo, lo cual es menor a lo que puede alcanzarse con el Equipo 2 que corresponde a 37.8 mil millones por segundo. Esto es muy importante porque todo el proceso de despliegue se hace utilizando texturas. 2. Pruebas Cualitativas A continuaci√≥n podemos apreciar algunos de los resultados visuales obtenidos con la aplicaci√≥n. Hay una serie de par√°metros que contribuyen directamente en el proceso de despliegue de la escena con la intenci√≥n de modificar la apariencia de las part√≠culas del fluido (originalmente un sprite) y obtener as√≠ un fluido de agua con apariencia realista, tanto las part√≠culas de agua que caen en forma de gotas de lluvia, como la masa de agua que se acumula como un flujo continuo sobre los techos y canaletas. 93 El c√≥mo intervienen todos estos elementos en el proceso de despliegue fue previamente explicado en el CAP√çTULO V: Render y CAP√çTULO VI: Dise√±o e Implementaci√≥n. Sin embargo, el valor que han de tener cada uno de estos par√°metros para lograr buenos resultados visuales en un tiempo de procesamiento aceptable, ha sido fijado luego de varias pruebas. a) Grosor del fluido y tama√±o de las part√≠culas Ambos par√°metros contribuyen al espesor de la masa del fluido, permitiendo que la capa que conforma el fluido al expandirse por una superficie se perciba m√°s o menos gruesa, al igual que las gotas de agua al caer. Mientras m√°s grande sea el tama√±o de las part√≠culas o mayor el valor de grosor del fluido, su color tiende a verse con m√°s nitidez, llegando incluso a aumentar el valor de profundidad y oscurecerlo, como se aprecia en la Figura 43(D). El no tener valores muy peque√±os para estos par√°metros ayuda a tener una mejor percepci√≥n del fluido como un continuo, tal como se aprecia en la Figura 43(A), en especial si la acumulaci√≥n de las part√≠culas es favorable y se ve desde un punto de vista cercano. Sin embargo, si las part√≠culas est√°n muy dispersas y la superficie por la cual se expanden es muy amplia y plana, la tendencia ser√° a detectar la forma esf√©rica de las part√≠culas con mayor facilidad como se puede observar en la Figura 43(B). Finalmente la Figura 43(C) nos muestra una captura de la simulaci√≥n con los valores predeterminados para el grosor del fluido y el tama√±o de las part√≠culas en donde las part√≠culas son lo suficientemente grandes para que el fluido pueda ser percibido como un continuo, pero tampoco demasiado grandes que intensifiquen de m√°s la densidad del color. 94 A B C D Figura 43: Pruebas visuales con diferentes valores de grosor del fluido y tama√±o de part√≠cula. (A) Acercamiento al fluido con grosor 1 y tama√±o de part√≠culas 2. (B) Vista semicompleta de la estructura con grosor del fluido 1 y tama√±o de part√≠culas 2. (C) Vista semicompleta de la estructura con configuraci√≥n predeterminada (grosor 0,7 y tama√±o de part√≠culas 0,6). (D) Acercamiento con valor m√°ximo de grosor de fluido (2,047) y de tama√±o de part√≠cula (5,128). 95 b) Espesor de refracci√≥n Este par√°metro controla la magnitud de refracci√≥n en las part√≠culas del fluido. El valor asignado por defecto 0,4, es un valor aproximado para obtener un buen efecto de refracci√≥n en el fluido como se aprecia en la Figura 44(A). No conviene asignar valores demasiado altos porque el efecto puede ser exagerado, como se percibe en la Figura 44(B). A B Figura 44: Capturas con diferentes valores de espesor de refracci√≥n. (A) Valor predeterminado 0,4. (B) Valor m√°ximo 4,78. c) Escala de atenuaci√≥n Este par√°metro es utilizado en el c√°lculo del grosor y modifica el color base del fluido al atenuar su valor con el valor del color de atenuaci√≥n. Por esta raz√≥n, el valor de escala de atenuaci√≥n influye en la percepci√≥n de la transparencia del fluido. Mientras m√°s grande sea la escala de atenuaci√≥n la transparencia ser√° menor. En la Figura 45(A) vemos la simulaci√≥n con los valores por defecto, en donde las part√≠culas de agua son apenas perceptibles, en la Figura 45(B) las part√≠culas pueden apreciarse con m√°s facilidad, sin embargo la apariencia de agua es totalmente irreal. 96 A B Figura 45: Capturas de la aplicaci√≥n con diferentes valores para la escala de atenuaci√≥n. (A) Valor predeterminado 0.03. (B) Valor m√°ximo 0,67. d) Brillo especular Controla la cantidad de brillo especular presente en las part√≠culas del fluido. A menor valor mayor ser√° la componente de luz especular en el fluido. El color de la luz especular es por defecto el blanco, tal como se percibe en la Figura 46 sin embargo, es posible cambiar este valor desde la interfaz gr√°fica y obtener otros resultados visuales. El valor de brillo especular para la aplicaci√≥n est√° configurado por defecto en 80, lo cual permite percibir un brillo especular moderado tal como se observa en la Figura 46(A). A√∫n as√≠ es posible conseguir m√°s especularidad disminuyendo el valor del brillo, como es el caso de la Figura 46(B). Finalmente en la Figura 46(C) se puede apreciar una captura en donde √∫nicamente se despliegan los valores de brillo especular presente en las part√≠culas. 97 A B C Figura 46: Captura de la aplicaci√≥n con diferentes valores de brillo especular. (A) Valor por defecto 80. (B) Valor m√≠nimo 10. (C) Despliegue de capa intermedia componente especular en el pipeline del render con valor por defecto 80. e) Iteraciones de suavizado y tama√±o de kernel de suavizado Estos par√°metros influyen directamente en la calidad visual que ha de proporcionar el splatting y la t√©cnica Adaptative Curvature Flow Filtering. Mientras mayor sea el tama√±o del kernel, mayor ser√° la distancia de influencia del suavizado. Este par√°metro tiene que ver con el umbral de profundidad en el que el splatting trabaja. La cantidad de veces que se aplicar√° el proceso de suavizado depender√° de la cantidad de iteraciones de suavizado elegidas por el usuario. Por ende, estos dos par√°metros controlan qu√© tanto ha de suavizarse la superficie del fluido, con lo cual mejorar√° la percepci√≥n visual de la misma, garantizando la sensaci√≥n visual del fluido como un continuo. En la Figura 47(A) y la Figura 47(B) se puede observar un suavizado moderado en la superficie al utilizar los par√°metros predeterminados, cuyos valores corresponden a 4,5 el tama√±o del kernel de suavizado y a 20 iteraciones de suavizado. En la Figura 47(C) y la Figura 47(D) se observa una superficie mucho m√°s suavizada, donde las part√≠culas casi no se perciben de manera individual sino que la superficie se aprecia bastante lisa, dando una sensaci√≥n m√°s realista al fluido al mostrarse como un continuo. En este caso los valores utilizados fueron los m√°ximos, 15 para el tama√±o de kernel y 256 iteraciones de suavizado. Es importante destacar que a√∫n cuando la calidad visual mejora conforme se incrementa el valor de estos dos par√°metros, la capacidad de procesamiento es mermada por el alto costo 98 computacional que implican las operaciones que realiza el shader ‚ÄúSmooth‚Äù en la implementaci√≥n del splatting y el suavizado con la t√©cnica Adaptative Curvature Flow Filtering. A B C D Figura 47: Capturas del fluido suavizado con diferentes valores de tama√±o de kernel e iteraciones de suavizado. (A) Despliegue con par√°metros predeterminados. (B) Despliegue de capa intermedia "normal" con valores predeterminados. (C) Despliegue con par√°metros de suavizado en sus valores m√°ximos. (D) Despliegue de capa intermedia "normal" con valores m√°ximos. 99 f) Umbral de densidad Este par√°metro determina si una part√≠cula ha de ser desplegada como una esfera o con una textura que asemeje la lluvia al caer. Si la densidad del fluido es grande en un espacio determinado, se asume que se trata de una masa de agua que se encuentra junta, por lo cual su apariencia deber√≠a ser la de una esfera para que luego pueda ser suavizada por el shader ‚ÄúSmooth‚Äù. Sin embargo, si la densidad de una porci√≥n de fluido es baja, implica que las part√≠culas en ese espacio determinado se encuentran muy separadas, y por ende se interpretan como gotas de agua aisladas, posiblemente cayendo en forma de lluvia y en este caso el shader ‚ÄúRain‚Äù le aplica una textura. El par√°metro umbral de densidad define la relaci√≥n de cantidad de part√≠culas por metros cuadrados bajo la cual se rige la decisi√≥n de desplegar las part√≠culas como esferas o con una textura. A B C Figura 48: Captura de las part√≠culas con diferentes valores de umbral de densidad. (A) Umbral de densidad m√≠nimo 0.0. (B) Umbral de densidad predeterminado 200.0. (C) Umbral de densidad m√°ximo 300.0. En la Figura 48(A) se aprecia una captura de la simulaci√≥n con el umbral de densidad en 0, con lo cual, las part√≠culas se despliegan siempre como esferas. La Figura 48(B) despliega las part√≠culas con el umbral predeterminado, en donde la mayor√≠a de las part√≠culas en el aire se ven como gotas de lluvia al caer, sin embargo se observa de vez en cuando alguna desplegada como esfera. Finalmente la Figura 48(C) utiliza el umbral de densidad m√°ximo, y de esta forma todas las part√≠culas que caen en forma de lluvia se ven como tal, sin embargo se encuentra una que otra part√≠cula aislada que ya ha colisionado con la superficie del techo que sin embargo se sigue viendo con la textura de una gota de lluvia al caer. 100 g) Artefactos visuales Durante el proceso de ajuste de par√°metros predeterminados de despliegue hechos a partir de las pruebas cualitativas se detectaron algunas deficiencias visuales en algunos momentos del despliegue. En la Figura 49, podemos apreciar a lo largo del segmento final, en especial en el extremo izquierdo del mismo, un artefacto visual en una part√≠cula que atraviesa esta superficie. Es posible que las part√≠culas se desborden visualmente, por el hecho de que conforme aumente el grosor o el tama√±o de las part√≠culas estas se ver√°n mucho m√°s grandes, aunque el c√°lculo de la colisi√≥n siga siendo calculado por PhysX a partir de la estructura que representa a la part√≠cula (en este caso un sprite) cuya posici√≥n corresponde al centro de la part√≠cula y su dimensi√≥n es simplemente ese punto. Sin embargo, no deber√≠a percibirse este desbordamiento puesto que la escena se despliega antes que el fluido y al hacerlo se determina el Z-buffer, el cual es consultado por el shader ‚ÄúDepth‚Äù para poder dibujar los sprites como esferas. Cuando lo hace, modifica el valor de profundidad si la part√≠cula se encuentra m√°s cercana al viewport, pero si hay un elemento de la escena delante de la part√≠cula este valor no se modifica, por lo que estos fragmentos del fluido no deber√≠an desplegarse. El problema ocurre cuando la superficie del objeto en la escena no se interpone entre el punto de vista y la part√≠cula, pero a√∫n as√≠ la atraviesa. En este caso el sprite ser√° modificado como una esfera y la part√≠cula ser√° desplegada atravesando la superficie. Figura 49: Artefacto visual de desbordamiento de part√≠cula. 101 En la Figura 50 se puede observar que las part√≠culas del fluido se acumulan como parches cuadrados sobre la superficie del techo cuando deber√≠a expandirse por toda la superficie de manera uniforme. Figura 50: Artefacto visual de parches de fluido en el despliegue. Esto ocurre por la distribuci√≥n alternada de los emisores para generar el fluido. Fue necesario crear varios emisores para el soporte de gran cantidad de part√≠culas, lo cual no podr√≠a haberse hecho con un solo emisor. Sin embargo esto crea tambi√©n varios paquetes de fluido que no siempre pueden agruparse y se generan artefactos de este tipo. 102 Figura 51: Flickering en algunas zonas del fluido. Finalmente se puede observar un √∫ltimo artefacto en la Figura 51 que genera un oscurecimiento intermitente en algunas zonas del fluido. La intermitencia es debido al comportamiento natural del Z-fighting, un fen√≥meno que ocurre en el despliegue 3D cuando dos o m√°s primitivas tienen valores similares en el Z-buffer, desplegando as√≠ fragmentos pertenecientes a una u otra primitiva de manera arbitraria [21]. La raz√≥n del oscurecimiento es un error en el c√°lculo del espesor del fluido, que ocurre cuando hay una capa de aire intermedia entre dos capas de fluido. Cuando el shader ‚ÄúComposite‚Äù calcula el color final en esos fragmentos, suma al c√°lculo completo del espesor del fluido el color de la capa frontal de agua, con lo que el color final se va oscureciendo de manera imprecisa. 103 CAP√çTULO VIII. Conclusiones y trabajos futuros En este Trabajo Especial de Grado se pudo desarrollar una aplicaci√≥n para la simulaci√≥n del desag√ºe de aguas de lluvia en un sistema de techos y canaletas, a partir de una diversidad de opciones de techos y drenajes regidos por un conjunto de normas y par√°metros arquitect√≥nicos que contemplan soluciones para diferentes intensidades de precipitaci√≥n en diversos tama√±os de techos. Efectivamente el SDK de PhysX facilit√≥ muchos de los procesos en cuanto a la simulaci√≥n del comportamiento f√≠sico del agua de lluvia, variando la cantidad de part√≠culas de fluido utilizadas para simular las diversas intensidades de precipitaci√≥n, as√≠ como realizando el c√°lculo de las colisiones generadas entre el fluido y los cuerpos r√≠gidos (sistema de techos y canaletas). Por otro lado, la creaci√≥n de part√≠culas de fluido a partir de emisores permiti√≥ simular de forma adecuada la precipitaci√≥n a partir de la condensaci√≥n del agua en forma de nubes, y su desaparici√≥n a partir de ‚ÄúDrains‚Äù emula el fen√≥meno de percolaci√≥n del agua a trav√©s de la tierra. Se logr√≥ desarrollar una interfaz gr√°fica utilizando el framework QT 4.7, que permite la interacci√≥n del usuario con la aplicaci√≥n para la creaci√≥n del sistema de techos y canaletas, generar una precipitaci√≥n ajustando los valores de intensidad, posicionar la c√°mara en vistas predeterminadas, editar los valores de los par√°metros de despliegue, cargar y guardar escenas predefinidas a partir de un archivo de texto y ejecutar pruebas de rendimiento. As√≠ mismo, es posible navegar por la escena para enfocar mejor alg√∫n √°rea de inter√©s. Se hicieron diversas pruebas de rendimiento que permitieron vislumbrar el alcance del SDK de PhysX en cuanto a la generaci√≥n de part√≠culas de fluido, as√≠ como el alcance de diversos equipos en el procesamiento de v√©rtices, c√°lculos de despliegue y soporte al desempe√±o de PhysX en el c√°lculo de la f√≠sica. De acuerdo a nuestras pruebas y los resultados obtenidos, los elementos cuyos valores tienen mayor impacto sobre el rendimiento de la aplicaci√≥n desarrollada son: la cantidad de part√≠culas del fluido que son generadas, la cantidad de v√©rtices de los modelos en la escena y la activaci√≥n del shader ‚ÄúDownSample‚Äù del buffer de profundidad. En el caso de las part√≠culas y los v√©rtices, a medida que aumenta su valor, disminuyen los FPS de la aplicaci√≥n. En el caso del shader ‚ÄúDownSample‚Äù, si se encuentra activo se incrementan los FPS de la aplicaci√≥n. 104 Por otro lado, el proceso de Adaptative Curvature Flow Filtering, realizado por el shader "Smooth" tiene un alto costo computacional, especialmente cuando el valor del kernel de suavizado y la cantidad de iteraciones aumenta, a pesar de que con ello se logran mejores resultados visuales. As√≠ mismo, las pruebas permitieron definir los valores de los par√°metros de despliegue que mejor se ajusten para garantizar un equilibrio entre la calidad de visual del fluido y la complejidad de c√°lculo. Los par√°metros m√°s relevantes son: ‚Ä¢ Grosor del Fluido: 0,7. ‚Ä¢ Tama√±o de las part√≠culas: 0,6. ‚Ä¢ Espesor de refracci√≥n: 0,4. ‚Ä¢ Escala de atenuaci√≥n: 0,03. ‚Ä¢ Brillo especular: 80. ‚Ä¢ Iteraciones de suavizado: 20. ‚Ä¢ Tama√±o de kernel de suavizado: 4,5. ‚Ä¢ Umbral de densidad: 200. A continuaci√≥n se presentan algunas posibles mejoras a la aplicaci√≥n desarrollada para dar m√°s alcance al trabajo en cuanto a la simulaci√≥n: ‚Ä¢ Incluir la simulaci√≥n de viento durante las precipitaciones, para lograr una simulaci√≥n m√°s fiel a la realidad. ‚Ä¢ A√±adir la posibilidad de construir estructuras con sistemas de techo m√°s complejos. ‚Ä¢ Agregar otros efectos visuales como c√°ustica para dar m√°s realismo al fluido. ‚Ä¢ Desarrollar una mejor distribuci√≥n de los emisores para que la generaci√≥n de part√≠culas de fluido cubra m√°s √°reas de extensi√≥n y al mismo tiempo permita que las part√≠culas no se dispersen demasiado. ‚Ä¢ Voxelizar el fluido para obtener una composici√≥n m√°s exacta en cuanto al c√°lculo del grosor del fluido para solucionar los artefactos producto de m√∫ltiples capas de fluido. ‚Ä¢ Estudiar la posibilidad de utilizar el stencil buffer para solucionar el artefacto del desbordamiento de part√≠culas. ‚Ä¢ Implementar el frustum culling tanto para los cuerpos r√≠gidos como para el fluido con la intenci√≥n de mejorar el rendimiento de la aplicaci√≥n. ‚Ä¢ Adaptar la aplicaci√≥n a la versi√≥n m√°s reciente de PhysX para comparar el rendimiento de la misma con una versi√≥n m√°s actualizada de este motor de f√≠sica. 105 ‚Ä¢ Implementar una versi√≥n de la aplicaci√≥n utilizando otro motor de f√≠sica y otro framework para el desarrollo de la interfaz gr√°fica, con el fin de comparar el rendimiento de dicha aplicaci√≥n con la de la aplicaci√≥n desarrollada en este trabajo. Esto nos proporcionar√≠a un indicativo de si nuestra elecci√≥n de utilizar PhysX y QT fue la m√°s adecuada. 106 Referencias [1] Corporation, NVIDIA, ¬´Physics SDK API Reference¬ª, [En l√≠nea]. Disponible en: www.nvidia.com/. [2] N. Corporation, 2008 - 2011. [En l√≠nea]. Disponible en: http://doc.qt.digia.com/qt/index.html. [3] R. Serway y J. Jewett, F√≠sica para ciencias e ingenier√≠a, vol. I, Thomson, 2005. [4] P. A. Sturrock, ¬´Plasma Physics: An Introduction to the Theory of Astrophysical¬ª, McGrawHill, 1994. [5] P. A. Tipler, F√≠sica, Barcelona: Ed. Revert√© S.A., 1983. [6] D. Nguyen, R. Fedkiw y H. Wann, ¬´Physically Based Modeling and Animation of Fire¬ª en Proceedings of SIGGRAPH, pp. 129‚Äì136, 1995. [7] R. Bridson y M. M√ºller, ¬´Fluid Simulation¬ª en SIGGRAPH 2007 Course Notes, 2007. [8] M. M√ºller, D. Charypar y M. Gross, ¬´Particle-Based Fluid Simulation for Interactive Applications¬ª en Proceedings of the 2003 ACM SIGGRAPH/Eurographics symposium on Computer animation. Eurographics Association, Aire-la-Ville, Suiza, 2003. [9] L. Cueto, ¬´Part√≠culas, vol√∫menes finitos y mallas no estructuradas: Simulaci√≥n num√©rica de problemas de din√°mica de fluidos¬ª La Coru√±a, Marzo, 2005. [10] E. Araujo, ¬´Teorema del valor de la densidad de contacto de fluidos en nanoporos¬ª, Merida, Venezuela, 2008. [11] P. Gourou y L. Papy, Compendio de Geograf√≠a General, RIALP, 1967. [12] Organizaci√≥n Meteorol√≥gica Mundial, ¬´Manual de observaci√≥n de nubes y otros meteoros¬ª, Atlas Internacional de Nubes, vol. I, n¬∫ 407, Ginebra 1993. [13] R. Pizarro, J. Pizarro, C. Sang√ºesa y E. Mart√≠nez, ¬´M√≥dulo 2: Curvas Itensidad Duraci√≥n Frecuencia¬ª en Sociendad Est√°ndares de Ingenier√≠a para Aguas y Suelos LTDA, 2003. 107 [14] M. Martelo, ¬´La Precipitaci√≥n en Venezuela y su relaci√≥n con el Sistema Clim√°tico¬ª, Caracas, Mayo, 2003. [15] D. da Silva,. G. de Sousa, M. Silva, V. Teichrieb, J. Kelner, T. Cordeiro, ¬´SBGAMES 2006 TUTORIAL AGEIA PHYSX¬ª, Pernambuco, Brasil, 2006. [16] L. A. L√≥pez R., AGUA - Instalaciones Sanitarias en los Edificios, Maracay: Betanzos, 1990. [17] F. Ching y C. Adams, Gu√≠a de Construcci√≥n Ilustrada, M√©xico: Limusa, 2006. [18] R. Manning, ¬´On the flow of water¬ª, 1891. [19] PAVCO de Venezuela, ¬´Manual: Canales y bajantes para aguas de lluvia¬ª, Septiembre 2009. [20] J. Hoberock y Y. Jia, ¬´High-Quality Ambient Occlusion¬ª en GPU Gems 3, H. Nguyen, Ed., Addison Wesley, 2008. [21] T. Akenine-M√∂ller, E. Haines y N. Hoffman, Real Time Rendering, Tercera ed., Massachusetts: A K Peters, Ltd., 2008. [22] F. Bagar, ¬´A Layered Particle-Based Fluid Model for Real-Time Rendering of Water¬ª en Eurographics Symposium on Rendering 2010. Junio 2010. [23] M. Zwicker, H. Pfister, J. van Baar y G. M., ¬´Surface Splatting¬ª en SIGGRAPH, 2001. [24] M. Botsch, A. Hornung, M. Zwicker y L. Kobbelt, ¬´High-Quality Surface Splatting on Today's GPUs¬ª en Eurographics Symposium on Point-Based Graphics, 2005. [25] W. van der Laan, S. Green y M. Sainz, ¬´Screen space fluid rendering with curvature flow¬ª en Proceedings of the 2009 symposium on Interactive 3D graphics and games, New York, EE.UU., 2009. [26] B. Peters y M. Sch√§f. [En l√≠nea]. Disponible en: http://www.mpi- inf.mpg.de/departments/irg3/ws0304/lcn/projects/Martin/index.htm. [27] A. Baldor, Geometr√≠a plana y del espacio y trigonometr√≠a, 2004. AGRADECIMIENTOS Tabla de Contenido √çndice de Figuras √çndice de Tablas Introducci√≥n CAP√çTULO I. Planteamiento del TEG 1. Planteamiento del Problema 2. Objetivo General 3. Objetivos Espec√≠ficos 4. Metodolog√≠a 5. Plataforma de hardware y software 6. Alcances y limitaciones de este trabajo CAP√çTULO II. Fluidos 1. Conceptos Fundamentales de Mec√°nica de Fluidos a) Compresibilidad b) Continuidad c) Fluido Newtoniano y no Newtoniano d) Viscosidad 2. Ecuaciones de Navier-Stokes a) Ecuaci√≥n del momentum b) Incompresibilidad 3. Smoothed Particle Hydrodynamics CAP√çTULO III. Simulaci√≥n de aguas de lluvia utilizando PhysX 1. Lluvias 2. Simulaci√≥n de lluvia con PhysX a) Creaci√≥n del fluido 3. Actores de PhysX a) Creaci√≥n del Actor CAP√çTULO IV. Fundamentos Arquitect√≥nicos para Sistemas de Techos y Canaletas 1. Terminolog√≠a de Techos 2. Detalles Arquitect√≥nicos de Implementaci√≥n 3. M√©todos de c√°lculo para aguas de lluvia 4. Sistema de Canaletas CAP√çTULO V. Render 1. Modelos 3D 2. Texturizado 3. Modelo de Iluminaci√≥n a) Oclusi√≥n ambiental (Ambiental Occlusion) 4. Render del Agua a) Splatting b) Adaptative Curvature Flow Filtering c) SkyBox d) Mapeo de Entorno Est√°tico e) Espesor y coeficiente de Fresnel CAP√çTULO VI. Dise√±o e Implementaci√≥n 1. Detalles de implementaci√≥n a) Transformaciones afines a los techos b) Transformaciones afines al sistema de canaletas c) Estructura del Edificio 2. Clases de la aplicaci√≥n a) Camara b) canaletas c) glwidget d) Librerias e) qtopengl f) roofSettings g) HelperActor h) DrawObjects i) Fluido j) Escena k) ObjMesh l) Shader m) Matrix n) UserAllocator o) DepthShader p) FluidShader q) ThicknessShader 3. Shaders a) Phong b) Depth c) Downsample d) Smooth e) Passing f) Thickness g) Composite h) Rain i) DebugTexture CAP√çTULO VII. Pruebas de rendimiento 1. Pruebas Cuantitativas 2. Pruebas Cualitativas a) Grosor del fluido y tama√±o de las part√≠culas b) Espesor de refracci√≥n c) Escala de atenuaci√≥n d) Brillo especular e) Iteraciones de suavizado y tama√±o de kernel de suavizado f) Umbral de densidad g) Artefactos visuales CAP√çTULO VIII. Conclusiones y trabajos futuros Referencias