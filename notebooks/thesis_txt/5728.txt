Microsoft Word - tesis_v5.doc Universidad Central de Venezuela Facultad de Ciencias Escuela de Computación Aplicaciones con Tecnología Internet DISEÑO Y DESARROLLO DE UN MÓDULO DE COMUNICACIÓN ENTRE EL FRAMEWORK RUBY ON RAILS Y LA CENTRAL TELEFÓNICA POR SOFTWARE ASTERISK, PARA EL MERCADEO DE PRODUCTOS Y SERVICIOS EMPRESARIALES Trabajo Especial de Grado presentado ante la Ilustre Universidad Central de Venezuela Por el Bachiller Carlos Augusto García Mujica CI: 17.400.329 para optar al título de Licenciado en Computación Tutor Prof. Edgar González Caracas, mayo / 2008 i ACTA Quienes suscriben miembros del Jurado, designado por el Consejo de Escuela de Computación, para examinar el Trabajo Especial de Grado presentado por el Bachiller Carlos Augusto García Mujica, C.I. 17.400.329, con el título: ”Diseño y Desarrollo de un Módulo de Comunicación entre el Framework Ruby on Rails y la Central Telefónica por Software Asterisk, para el Mercadeo de Productos y Servicios Empresariales”, a los fines de optar al título de Licenciado en Computación, dejan constancia lo siguiente: Leído como fue, dicho trabajo por cada uno de los miembros del Jurado, se fijó el 03 de Junio de 2008 a las 11:30 a.m, para que su autor lo defendiera en forma pública, se hizo en la sala del Centro de Computación, mediante una presentación oral de su contenido. Finalizada la defensa pública del Trabajo Especial de Grado, el Jurado decidió aprobarlo con una nota de _______ puntos, en fe de lo cual se levanta la presente Acta, en Caracas a los tres días del mes de Junio del año dos mil ocho, dejándose también constancia de que actúo como Coordinador del Jurado el profesor Edgar González. _____________________________ Prof. Edgar González (Tutor) _____________________________ _____________________________ Prof. Sergio Rivas Prof. Andrés Sanoja (Jurado Principal) (Jurado principal) ii DEDICATORIA Y AGRADECIMIENTOS A mi núcleo familiar por haber apostado a mi éxito desde el comienzo de mi carrera y seguirlo haciendo. En especial a mi madre por el soporte moral, mi hermana porque es un ser especial con el que se que cuento de principio a fin sin importar el asunto y mi padre que me apoyó durante todos mis estudios. A Mi Esperanza por el apoyo incondicional en todos los aspectos de mi vida y en especial por la ayuda brindada en el desarrollo de este proyecto. A mis tios, abuelos y primos que me han demostrado ser unas excelentes personas consecuentes, por lo que siempre contaré con ellos. A mi tutor y profesores de la carrera, por haber brindado sus conocimientos en un tiempo oportuno de mi formación. A mis compañeros de la universidad, con los que compartí momentos inolvidables, especialmente al legendario “circulo”, que espero continuemos en contacto a través de los años cultivando las amistades permanentemente. iii ÍNDICE DE CONTENIDOS ACTA ............................................................................................................................. i DEDICATORIA Y AGRADECIMIENTOS ................................................................ii ÍNDICE DE CONTENIDOS........................................................................................iii ÍNDICE DE GRÁFICOS .............................................................................................vi ÍNDICE DE TABLAS.................................................................................................vii RESUMEN................................................................................................................... ix INTRODUCCIÓN......................................................................................................... 2 CAPÍTULO I................................................................................................................. 4 Planteamiento del Problema y justificación del proyecto ............................................ 4 Objetivos ............................................................................................................... 6 Objetivo general .................................................................................................... 6 Objetivos específicos............................................................................................. 6 CAPÍTULO II................................................................................................................ 8 Marco Teórico ............................................................................................................... 8 Desarrollo Ágil ...................................................................................................... 8 Manifiesto Ágil...................................................................................................... 8 Características del Desarrollo Ágil...................................................................... 10 Programación Extrema ........................................................................................ 11 Características ..................................................................................................... 12 Prácticas de XP.................................................................................................... 14 Asterisk................................................................................................................ 19 ¿Qué es? .............................................................................................................. 21 Historia ................................................................................................................ 22 Características y Ventajas ................................................................................... 24 Asterisk como un PBX ........................................................................................ 27 Flexibilidad Vs. Configuración ........................................................................... 31 Configuración Gráfica vs Configuración de Texto ............................................. 32 Dialplans: Contextos, Extensiones, Prioridades y Aplicaciones ......................... 33 Contextos............................................................................................................. 33 Canales ................................................................................................................ 35 Extensiones.......................................................................................................... 35 Prioridades........................................................................................................... 37 Aplicaciones ........................................................................................................ 38 Dialplans.............................................................................................................. 38 Interfaces Asterisk Manager Interface y Asterisk Gateway Interface................. 39 iv Asterisk Gateway Interface ................................................................................. 40 Asterisk Manager Interface ................................................................................. 42 Ruby on Rails ...................................................................................................... 48 Filosofías ............................................................................................................. 50 Arquitectura......................................................................................................... 51 Componentes básicos .......................................................................................... 54 Active Record...................................................................................................... 54 Action Pack ......................................................................................................... 59 Gemas.................................................................................................................. 61 Características ..................................................................................................... 62 Comandos Básicos .............................................................................................. 62 Plugins ................................................................................................................. 64 Comandos Básicos .............................................................................................. 65 Pruebas ................................................................................................................ 67 Conectividad Rails - Asterisk.............................................................................. 74 Adhearsion........................................................................................................... 74 Instalación y Uso ................................................................................................. 77 Dialplans.............................................................................................................. 80 Telegraph............................................................................................................. 82 Instalación y Uso ................................................................................................. 83 Comparación Adhearsion - Telegraph ................................................................ 94 CAPÍTULO III ............................................................................................................ 97 Marco Aplicativo......................................................................................................... 97 Requerimientos Generales................................................................................... 97 Adaptación del Proceso de Desarrollo XP .......................................................... 99 Planificación........................................................................................................ 99 Diseño................................................................................................................ 100 Codificación ...................................................................................................... 100 Pruebas .............................................................................................................. 100 Feedback............................................................................................................ 101 Desarrollo de la Aplicación............................................................................... 101 Metáfora del Sistema......................................................................................... 101 Iteración 0.......................................................................................................... 104 Planificación...................................................................................................... 104 Iteración 1.......................................................................................................... 104 Planificación...................................................................................................... 105 Diseño................................................................................................................ 106 Codificación ...................................................................................................... 106 Pruebas .............................................................................................................. 109 Feedback............................................................................................................ 110 Iteración 2.......................................................................................................... 110 Planificación...................................................................................................... 111 v Diseño................................................................................................................ 111 Codificación ...................................................................................................... 112 Pruebas .............................................................................................................. 116 Feedback............................................................................................................ 119 Iteración 3.......................................................................................................... 120 Planificación...................................................................................................... 120 Diseño................................................................................................................ 121 Codificación ...................................................................................................... 122 Pruebas .............................................................................................................. 124 Feedback............................................................................................................ 128 Iteración 4.......................................................................................................... 129 Planificación...................................................................................................... 129 Diseño................................................................................................................ 129 Codificación ...................................................................................................... 130 Pruebas .............................................................................................................. 131 Feedback............................................................................................................ 134 CAPÍTULO IV .......................................................................................................... 135 Conclusiones y Recomendaciones ............................................................................ 135 REFERENCIAS ........................................................................................................ 139 CONTACTOS........................................................................................................... 146 ANEXOS................................................................................................................... 147 Glosario de términos ......................................................................................... 147 Anexo 1: Valores del Manifiesto Ágil .............................................................. 151 Anexo2: Principios del Manifiesto Ágil............................................................ 153 Anexo3: Proceso de la Programación Extrema................................................. 155 Anexo4: Prácticas de la Programación Extrema ............................................... 156 vi ÍNDICE DE GRÁFICOS Gráfico 1: Diagrama de la solución propuesta. ............................................................. 5 Gráfico 2: Esquema de interconexión de Asterisk con dispositivos internos y externos. ...................................................................................................................... 29 Gráfico 3: Esquema de interconexión entre varios PBX`s con dispositivos asociados. ..................................................................................................................................... 30 Gráfico 4: Modelo MVC ............................................................................................. 53 Gráfico 5: Modelo MVC en Rails ............................................................................... 54 Gráfico 6: Metáfora del Sistema. .............................................................................. 103 Gráfico 7: Especificación Clase AMIManager. ........................................................ 106 Gráfico 8: Diagrama de Clases, Iteración 2. ............................................................. 112 Gráfico 9: Prueba Aceptación, Pantalla Operador. ................................................... 118 Gráfico 10: Prueba Aceptación, Pantalla Supervisor (Estado Asterisk). .................. 118 Gráfico 11: Prueba Aceptación, Pantalla Supervisor (Detalle Llamada). ................. 119 Gráfico 12: Diagrama de Clases, Iteración 3. ........................................................... 121 Gráfico 13: Prueba Aceptación, Pantalla Administrador (Modo Mantenimiento). .. 128 Gráfico 14: Prueba Aceptación, Pantalla Validador (Cargar Archivo)..................... 128 Gráfico 15: Diagrama de Clases, Iteración 4. ........................................................... 129 Gráfico 16: Anexo 3, Proceso de la programación Extrema..................................... 155 Gráfico 17: Anexo 4, Prácticas de la programación Extrema. .................................. 156 vii ÍNDICE DE TABLAS Tabla 1:Extensión Asterisk. ........................................................................................ 36 Tabla 2: Componentes Extensiones Asterisk. ............................................................. 37 Tabla 3: Orden de Ejecución de Extensiones. ............................................................. 37 Tabla 4: Ejemplo de Dialplan de Asterisk................................................................... 38 Tabla 5: Paquete Ejemplo de Comunicación AMI...................................................... 42 Tabla 6: Ejemplo de Paquete de Autenticación AMI.................................................. 43 Tabla 7: Ejemplo Evento Dial. .................................................................................... 47 Tabla 8: Ejemplo Evento ExtensionStatus. ................................................................. 47 Tabla 9: Ejemplo ORM, búsqueda en base de datos por id. ....................................... 57 Tabla 10: Ejemplo ORM, guardar objeto en base de datos......................................... 57 Tabla 11: Ejemplo Listar Gemas................................................................................. 62 Tabla 12: Ejemplo Buscar Gema................................................................................. 63 Tabla 13: Ejemplo Instalar Gema................................................................................ 63 Tabla 14: Ejemplo Desinstalar Gema.......................................................................... 64 Tabla 15: Ejemplo para buscar un repositorio (Plugin). ............................................. 65 Tabla 16: Ejemplo para buscar un repositorio (Plugin/Windows). ............................. 65 Tabla 17: Ejemplo para agregar un repositorio (Plugins). .......................................... 65 Tabla 18: Ejemplo para quitar un repositorio (Plugins). ............................................. 66 Tabla 19 Ejemplo para Instalar un Plugin en el Proyecto. .......................................... 66 Tabla 20: Ejemplo de Código RSPEC. ....................................................................... 72 Tabla 21: Ejemplo 2 de Código RSPEC. .................................................................... 73 Tabla 22: Instalación Adhearsion................................................................................ 77 Tabla 23: Comunicación Adhearsion/Asterisk............................................................ 78 Tabla 24: Nuevo Proyecto Adhearsion. ...................................................................... 79 Tabla 25: Arrancar Adhearsion. .................................................................................. 80 Tabla 26: Ejemplo Dialplan de Adhearsion. ............................................................... 81 Tabla 27: Instalación Telegraph. ................................................................................. 83 Tabla 28: Comunicación Telegraph/Asterisk, AGI..................................................... 85 Tabla 29: Ejemplo Dialplan Telegraph AGI ............................................................... 85 Tabla 30: Empezando Telegraph/AMI........................................................................ 87 Tabla 31: Conexión Telegraph/Rails AMI. ................................................................. 87 Tabla 32: Iniciar Servidor AMI/Telegraph. ................................................................ 88 Tabla 33: Ejemplo Comandos Telegraph AMI. .......................................................... 88 Tabla 34: Ejemplo Funciones AMI Telegraph............................................................ 89 Tabla 35: Métodos Telegraph para consultas.............................................................. 90 Tabla 36: Métodos Telegraph para actualizaciones. ................................................... 90 Tabla 37: Métodos Telegraph para crear..................................................................... 90 Tabla 38: Métodos Telegraph para borrar. .................................................................. 91 viii Tabla 39: Empezando Telegraph Eventos AMI. ......................................................... 92 Tabla 40: Iniciar Servidor Eventos AMI Telegraph................................................... 92 Tabla 41: Funciones Eventos AMI.............................................................................. 93 Tabla 42: Cuadro comparativo Adhearsion - Telegraph. ............................................ 96 Tabla 43: Comunicación Adhearsion/Asterisk.......................................................... 107 Tabla 44: Script Adhearsion de Prueba. .................................................................... 107 Tabla 45: Comunicación Telegraph/Asterisk............................................................ 108 Tabla 46: Correcciones en Telegraph........................................................................ 109 Tabla 47: Pruebas Telegraph Iteración 1................................................................... 110 Tabla 48: Clase Central / Código Fuente Iteración 2. ............................................... 114 Tabla 49: Clase Extension / Código Fuente Iteración 2. ........................................... 115 Tabla 50: Clase Producto / Código Fuente Iteración 2. ............................................ 116 Tabla 51: Pruebas Clase Central Iteración 2. ............................................................ 117 Tabla 52: Pruebas Clase Producto Iteración 2........................................................... 117 Tabla 53: Clase Carga / Código Fuente Iteración 3. ................................................. 123 Tabla 54: Clase Mantenimiento / Código Fuente Iteración 3. .................................. 124 Tabla 55: Pruebas Clase Carga, Iteración 3. ............................................................. 125 Tabla 56: Pruebas Clase Mantenimiento, Iteración 3................................................ 126 Tabla 57: Clase AmiLogic Iteración 4. ..................................................................... 131 Tabla 58: Pruebas Clase Central y AmiLogic Iteración 4......................................... 133 ix RESUMEN En el presente Trabajo Especial de Grado se diseñó e implementó un módulo de conexión entre el framework Web Ruby on Rails y una central telefónica por software llamada Asterisk, como parte de una aplicación Web que integró elementos de la tecnología voz sobre IP (VoIP). Dicho módulo se implementó con el apoyo una herramienta que facilita el intercambio de información a bajo nivel entre dichas tecnologías, llamada Telegraph. La aplicación automatizó el proceso de oferta de productos y servicios empresariales, agilizando el proceso de contacto vía telefónica a los potenciales clientes. Durante el desarrollo se utilizó una interfaz de Asterisk llamada AMI, sobre la cual se envían y reciben comandos desde la aplicación para lograr los objetivos principales del proyecto, los cuales se listan a continuación: 1. Realización de llamadas desde la aplicación, es decir que el Software marque automáticamente un número recuperado de un repositorio de datos. 2. Monitoreo de llamadas, consiste en supervisar las llamadas realizadas. 3. Transferencia de llamadas, se transfiere una llamada en curso de una extensión a otra. 4. Estatus de Asterisk, es decir conocer el estatus de las extensiones y llamadas realizadas en Asterisk. Palabras Claves: Aplicaciones con tecnología Internet, Ruby on Rails (RoR), Programación Extrema (XP), Asterisk, Telegraph, Voz sobre IP (VoIP) 2 INTRODUCCIÓN En la actualidad, la utilización del mercadeo personalizado para ofrecer productos y servicios es la constante de las grandes corporaciones. Las Tecnologías de Información y Comunicación (TIC`s) aplicadas al mercadeo, facilitan el contacto directo, eficiente y rápido con los potenciales clientes, creando ventajas competitivas en el mundo de los negocios, reemplazando o complementando el uso de formas tradicionales de comunicación con el cliente. Productividad, eficiencia, eficacia y precisión, son los anhelos perseguidos por las organizaciones a la hora de realizar sus tareas, por lo que la automatización pasa a ser el pilar de los procesos cotidianos. La tecnología facilita las actividades corporativas, dotando a las organizaciones de mayores y mejores medios, que amplían su campo de aplicaciones e incrementan su rendimiento. Con estos planteamientos como premisas, y dada la creciente competitividad de los mercados, surge en las organizaciones la necesidad de contar con sistemas informáticos que mejoren la productividad o eficiencia en los procesos del negocio que se llevan a cabo diariamente. En el área de mercadeo ésto se traduce en el rápido y oportuno contacto con los potenciales clientes, elevando la cantidad de posibles ventas. Debido a la gran competencia en el área de mercadeo personalizado, las organizaciones requieren estar a la vanguardia tecnológica, automatizando la mayoría de los procesos que se puedan. Con el gran auge de la gran autopista cibernética como 3 se considera a Internet, y el crecimiento sostenido de las telecomunicaciones se considera la utilización de una aplicación que, valiéndose de herramientas Web y tecnologías telefónicas por software, facilite la oferta de productos y servicios mediante la realización de llamadas. En el presente proyecto se diseñó y desarrolló un módulo de una aplicación Web, utilizada para automatizar el proceso de mercadeo de productos y servicios empresariales a través de la central telefónica por software Asterisk. A nivel metodológico se seleccionó una técnica de desarrollo ágil, específicamente Programación Extrema que permite la elaboración de aplicaciones adaptables a las necesidades del cliente, lo cual favoreció para aplicar una técnica de programación orientada a pruebas. Precisamente, por su flexibilidad, sencillez y velocidad a la hora de diseñar y desarrollar aplicaciones, Ruby on Railes fue escogido como framework Web para la ejecución de este proyecto. Por su parte, Asterisk, una central telefónica por software de código abierto, fue utilizada por sus facilidades de interacción con sistemas externos. Este estudio se presenta en cuatro capítulos, siendo el primero el referido al planteamiento del problema, así como los objetivos y alcances del proyecto. En un segundo capítulo se introduce el marco teórico que sustenta a esta investigación, mientras que la metodología será abordada en un tercer capítulo. Por último se tendrán las conclusiones y recomendaciones de la investigación. 4 CAPÍTULO I PLANTEAMIENTO DEL PROBLEMA Y JUSTIFICACIÓN DEL PROYECTO Las Tecnologías de Información y Comunicación (TIC`s) al servicio del mercadeo personalizado optimizan los procesos de oferta de productos y servicios, garantizando una mejor atención a los posibles clientes. El uso de herramientas informáticas representa una solución práctica en mercados que son cada día más competitivos, pues ahorra costos de comercialización y supone mayor efectividad en la venta de los productos. Sustentándose en las ventajas que suponen las tecnologías informáticas para optimizar las tareas que componen el proceso de mercadeo telefónico, se plantea el desarrollo de una solución tecnológica que explote las potencialidades que proveen las herramientas orientadas a Web y las innovaciones de los sistemas de telefonía por software. Para dicha solución es conveniente el uso de un framework Web, ya que permite acelerar los tiempos de desarrollo a través de la reutilización de componentes, sin perder calidad en el producto. En este proyecto se utilizó Ruby on Rails por ser un framework Web de código abierto, para el desarrollo de aplicaciones Web, que combina simplicidad y precisión, codificando y configurando menos que con otros frameworks. A nivel de 5 telecomunicaciones se utilizó la central telefónica o PBX por software, Asterisk, que permite desarrollar una amplia variedad de aplicaciones telefónicas. La escogencia de estas tecnologías resultó estratégica ya que existen herramientas para implementar la comunicación e interacción entre ellas, como por ejemplo el plugin para Ruby on Rails (RoR), Telegraph, que provee una capa de abstracción para que los complejos comandos de Asterisk sean usados con facilidad en una aplicación que sea desarrollada con RoR. Entonces este proyecto comprende el desarrollo de una aplicación Web compuesta por un framework Web (RoR), un PBX (Asterisk) y una herramienta para la interconexión entre ambos (Telegraph), para automatizar los procesos que comprenden la realización de la llamadas telefónicas, supervisión de las llamadas, transferencia de llamadas y actualización constante del estado de la central telefónica. Tal como se muestra en el siguiente gráfico: Aplicación Web Modulo de Interconexión Central Telefónica (PBX) Gráfico 1: Diagrama de la solución propuesta. Fuente: Autor 6 La existencia de centrales telefónicas en sitios geográficos distantes que puedan conectarse con el mismo servidor, representó un punto a favor a la hora de escoger el modelo Web para la realización del módulo que se planteó este estudio. Además, la posibilidad de tener la aplicación en línea le brinda escalabilidad al Software, facilitando la labor de acceso a los usuarios ya que permite acceder a él de forma remota, consideración a tomar en cuenta a la hora de desarrollar la aplicación con tecnología Web. Objetivos Objetivo general 1. Diseñar y desarollar un módulo de comunicación entre el framework Web Ruby on Rails y la central telefónica por software, Asterisk, para el mercadeo de productos y servicios empresariales. Objetivos específicos 1.1. Diseñar e implementar un módulo que se comunique con la central telefónica Asterisk para el procesamiento de llamadas utilizando el plugin Telegraph como puente entre el framework Ruby on Rails y dicha central telefónica, que permita: 1.1.1. Realizar llamadas: se requiere automatizar la realización de 7 llamadas, es decir que el Software marque automáticamente un número recuperado de un repositorio de datos. 1.1.2. Monitorear llamadas: se necesita supervisar la llamada realizada por los operadores. 1.1.3. Transferir llamadas: se desea que un supervisor tenga la capacidad de transferir la llamada en curso a su extensión en un momento determinado. 1.1.4. Revisar el estatus de Asterisk: posibilidad de conocer el estatus de las extensiones y llamadas de Asterisk. 1.2. Automatizar el proceso de carga de números en el sistema. 8 CAPÍTULO II MARCO TEÓRICO Desarrollo Ágil Explicar el concepto de Desarrollo Ágil no es sencillo, ya que existe una definición clara, pero según [Agile Alliance (2001)] se plantea como un término que comprende distintas metodologías de desarrollo de software, cuyas premisas buscan satisfacer los requerimientos cambiantes de los clientes, haciendo énfasis en: • Amplia colaboración entre los programadores y los expertos en el dominio del problema. • Comunicación cara a cara por encima de la documentación escrita, es decir que promueve las reuniones personales. • Frecuentes entregas del producto, que generen un valor agregado desde el punto de vista de negocio. • Equipos de desarrollo pequeños y organizados. • Eficiente estructuración del código y del grupo de trabajo. Manifiesto Ágil Para comprender el contexto en que nacieron las conocidas metodologías de Desarrollo Ágil, es interesante remontarse al febrero de 2001 fecha en la que fueron convocados por Kent Beck (autor del libro Extreme Programming Explained), 9 numerosos críticos del modelaje de software en Snowbird, Utah para tratar sobre las crecientes vertientes de lo que hasta ese entonces le llamaban métodos “ligeros” de desarrollo de software. Tal como reseña [Folwer (2006)], sólo diecisiete de los expertos citados por Beck pudieron asistir, incluyendo al anfitrión, a la reunión donde empezó a utilizarse el término de “Métodos Ágiles” para describir estas nuevas castas. En la cita se resumieron los principios sobre los que se basan los métodos alternativos en cuatro postulados, conocidos como Manifiesto Ágil. El Manifiesto Ágil, firmado por Kent Beck, Mike Beedle, Arie van Bennekum, Alistair Cockburn, Ward Cunningham, Martin Fowler, James Grenning, Jim Highsmith, Andrew Hunt, Ron Jeffries, Jon Kern, Brian Marick, Robert C. Martin, Steve Mellor, Ken Schwaber, Jeff Sutherland y Dave Thomas, expone que: “Estamos poniendo al descubierto mejores métodos para desarrollar software, haciéndolo y ayudando a otros a que lo hagan. Con este trabajo hemos llegado a valorar: � A los individuos y su interacción, por encima de los procesos y las herramientas. � El software que funciona, por encima de la documentación exhaustiva. � La colaboración con el cliente, por encima de la negociación contractual. � La respuesta al cambio, por encima del seguimiento de un plan. Aunque hay valor en los elementos de la derecha, valoramos más los de la izquierda.” Entre los miembros más resaltados de este grupo se tienen: • Martin Fowler, investigador reconocido mundialmente en el campo del Análisis y Diseño Orientado a Objetos, UML y Patrones. • Alistair Cockburn, quien definió y documentó los Casos de Uso. 10 • Jim Highsmith, creador de la metodología ligera “Desarrollo de Software Adaptativo”. • Dave Thomas y Andrew Hunt, conocidos como “the pragmatic programmers” por su serie de libros “Pragmatic Programmer”. • Ken Beck, autor intelectual de la “Programación Extrema”, junto a Erich Gamma desarrollaron Junit (framework de prueba para Java), entre otros. • Ward Cunningham, creador del Wiki, y del clásico Repositorio de Patrones de Portland. Características del Desarrollo Ágil Según [Miller (2001)] las características del proceso ágil de desarrollo de software, tomado desde el punto de vista del tiempo de entrega, son: • Modularidad en el proceso de desarrollo. • Iterativo, con cortos ciclos, permitiendo rápidas correcciones y actualizaciones. • Ciclos en un período de tiempo de una (1) a seis (6) semanas. • Sencillez en el proceso de desarrollo, evitando tareas innecesarias. • Adaptativo, con la posibilidad de aparición de nuevos riesgos. • Proceso incremental que permite segmentar la construcción de las aplicaciones. • Orientado a las personas: se prefiere el proceso ágil enfocado a las personas que a los procesos y la tecnología. • Un ambiente de trabajo comunicativo y de colaboración. 11 Programación Extrema La Programación Extrema, mejor conocida por su nombre en inglés eXtreme Programming, de allí sus siglas (XP), es una de las llamadas Metodologías Ágiles de desarrollo. [Beck (1999-b)] explica que en este tipo programación el término “extrema” viene de tomar los principios y prácticas a niveles extremos. Señala que esta metodología ha evolucionado de los distintos problemas causados por los largos ciclos de desarrollo de los modelos tradicionales. El mismo autor explica que, en sus orígenes, la Programación Extrema comenzó como “una simple oportunidad de realizar el trabajo”, en combinación con otras prácticas de desarrollo de software que habían sido efectivas en décadas recientes. Sin embargo, [AAB (1998)] refieren que después de un número de pruebas exitosas, la metodología XP fue documentada en los principios y prácticas usadas. Según [Beck (1999-b)] XP es un proceso de desarrollo ligero, que propone el trabajo orientado directamente al objetivo, basado en las relaciones interpersonales y la velocidad de reacción. Por su parte, en el sitio Web Wikipedia se afirma que esta metodología es muy utilizada por sus fundamentos de adaptabilidad en vez de la previsibilidad. [Beck (1999-b)] propone que XP define Historias de Usuario como base del software a desarrollar. Dichas historias las escribe el cliente y describen escenarios 12 sobre el funcionamiento del software donde generalmente se describe el modelo, dominio, entre otros. [JRA (2001)] Jeffries R, Anderson A y Hendrickson C (2001) afirman que la Programación Extrema es una disciplina de desarrollo de software, basada en los valores de la simplicidad, comunicación y retroalimentación, que trabaja en un ambiente de integración del equipo de desarrollo, en presencia de prácticas sencillas, donde el cliente trabaja día a día con el grupo de desarrollo. Características En 1999, Beck refiere una serie de características de la llamada Programación Extrema, entre las cuales podemos destacar las siguientes: • Minimizar el riesgo de fallo del proceso por medio de la disposición permanente de un representante competente del cliente en el ambiente del equipo de desarrollo, que permite una retroalimentación veloz y eficaz, logrando una buena comunicación y coordinación entre los miembros del equipo y el cliente. • Trabaja bajo el esquema de entregas de funcionalidades o releases e iteraciones, por lo que se programará solo lo necesario para la entrega de ese release. En caso de que éste no se encuentre satisfecho, se adaptará el plan de releases e iteraciones hasta obtener su aprobación. Cabe destacar que, para cada entrega se discuten los objetivos con el cliente y se definen iteraciones, de corto tiempo, para cumplir con los objetivos de la entrega. Esta característica implica la integración continua del código, es decir que 13 cada funcionalidad que se desarrolla se integrará al sistema de inmediato. • Propone realizar contínuas pruebas unitarias por cada funcionalidad, de modo que se pueda corregir cualquier fallo antes de la entrega. Dichas pruebas deberían ser automatizadas y es recomendable que se escriban antes de la codificación del requerimiento. • La codificación del software en XP se produce siempre en parejas (dos programadores por ordenador), rotándolas a lo largo del proyecto, lo cual supone una mayor calidad del código. • Definir cortas iteraciones con rápidas y cortas entregas, que permiten escribir un código incremental al ir añadiendo pequeñas mejoras. • Implementar funcionalidades de la forma más sencilla posible, lo que lleva a una de sus premisas: simplicidad a la hora de escribir el código. • Refactorizar el código, lo que implica la reescritura de ciertos trozos con el fin de incrementar la legibilidad, mantenimiento y eficiencia del código. • El código es colectivo, ya que cualquier integrante del grupo puede realizar modificaciones sobre cualquier parte del código. • Documentación Limitada, es decir que no se basa en una documentación 14 exhaustiva sino sólo la necesaria para el proyecto, la cual generalmente se lleva a cabo en las últimas etapas del mismo. Prácticas de XP [Beck (1999-a)] explica que XP es una colección de ideas y prácticas tomadas de metodologías existentes. A continuación se explican las prácticas de XP según este autor: � El Juego de Planificación El programador debe estimar el esfuerzo que requiere la implementación de las historias de usuarios, luego el cliente decide el alcance y los tiempos del release en cuestión. Esta práctica se puede ilustrar como un juego, donde existen dos jugadores: Cliente y Programador, cada uno con su respectivo rol. Este juego se realiza durante la planificación de las entregas y las iteraciones. � Pequeños y Cortos Releases Se desea producir fragmentos sencillos del sistema, pero velozmente, sin importar que esto signifique que no cuenten con todas las funcionalidades pretendidas, pero que sí constituyan un valor adicional para el negocio. Nuevos releases son lanzados hasta diariamente, pero al menos una vez al mes. 15 � Metáfora [Fowler (2004)] dice que la arquitectura de XP es evolutiva y los posibles inconvenientes que se pueden generar por no contar con ella desde el comienzo del proyecto, se solventan con la existencia de la práctica conocida como la metáfora. El autor señala que “la metáfora es una práctica que consiste en formar un conjunto de nombres que actúen como vocabulario para hablar sobre el dominio del problema”. Según Fowler, el sistema es definido por una metáfora o un conjunto de metáforas compartidas entre el cliente y los programadores, lo cual guía el desarrollo describiendo el funcionamiento del sistema. � Diseño Simple XP hace énfasis en diseñar el sistema lo más simple como sea posible, tomando una solución sencilla que pueda ser implementada en el momento. Cualquier complejidad innecesaria y código extra deben ser eliminados. Al respecto, [Beck (1999-b)], explica que “en cualquier momento el diseño adecuado para el software es aquel que: supera con éxito todas las pruebas, no tiene lógica duplicada, refleja claramente la intención de implementación de los programadores y tiene el menor número posible de clases y métodos”. � Pruebas La escritura de código está dirigida por las pruebas unitarias. Las pruebas unitarias son implementadas antes de codificar el requerimiento y son ejecutadas 16 contínuamente ante cada modificación del sistema. El cliente es encargado de escribir las pruebas funcionales y vela por la validez de cada historia de usuario. En este contexto de desarrollo evolutivo y de pruebas, se hace indispensable la automatización de esta actividad. � Refactorización La refactorización es una práctica que comprende la reestructuración del código, eliminando la duplicación, simplificándolo y añadiéndole flexibilidad para permitir la escalabilidad. La refactorización refuerza la estructura interna del sistema sin cambiar su comportamiento externo. Sobre este aspecto, [Martin, R (2002)] señala que "el diseño del sistema de software es una cosa viviente. No se puede imponer todo en un inicio, pero en el transcurso del tiempo este diseño evoluciona conforme cambia las funcionalidades del sistema” � Programación en Parejas Dos personas deben codificar en un solo ordenador, este estilo de programación brinda numerosas ventajas, entre las que tenemos: • Una baja tasa de errores, ya que se detectan muchos errores tempranamente entre los compañeros. • Mayor calidad del código en menos líneas de código (se hacen mejoras inmediatas). • Los problemas se resuelven con mayor rapidez. 17 • Más de una persona conoce el código, lo que brinda velocidad a la hora del soporte. • Los programadores disfrutan más la labor de la codificación. � Código Colectivo Cualquier persona puede cambiar el código, aún si no lo haya hecho esa persona, ya que el código es de todos no pertenece a ningún integrante en particular. Esto incentiva a cada individuo del grupo a aportar con nuevas ideas y evita que algún programador sea imprescindible a la hora de cambios en el código. � Integración Contínua Cada pieza de código nuevo es integrada al sistema inmediatamente después de haberlo culminado. Las pruebas son ejecutadas antes y después del proceso de integración. La integración continua reduce el doble esfuerzo del grupo de trabajo, ya que existe más comunicación entre los integrantes que implica mayor reutilización de componentes. � 40 Horas a la Semana de Programación Se debe trabajar 40 horas a la semana como máximo. No se permite sobre tiempo en 2 semanas seguidas, si esto llegara a suceder se considera como un 18 problema. El trabajo extra trae una fuerte desventaja al desmotivar al grupo de trabajo. Proyectos que requieren sobre tiempo para intentar cumplir con los tiempos suelen ser entregados con retraso, debido a un fallo en la etapa de planificación. � Cliente en el Sitio El cliente debe estar presente y disponible para el equipo tiempo completo, si esto no es posible, se recomienda que tenga un representante siempre disponible que actué como su vocero. Una parte del éxito en un proyecto XP se debe a que el cliente conduce constantemente el trabajo para darle un mayor valor de negocio y los programadores pueden realizar cambios de manera rápida. Se considera que la comunicación oral es más efectiva que la escrita, ya que aminora el tiempo de comunicación y disminuye el riesgo de ser mal interpretada. � Estándares de Codificación Es indispensable que los programadores sigan ciertos estándares y/o reglas de codificación establecidos para el desarrollo del proyecto. Esto trae ventajas como mejoras en la comunicación de los programadores a través del código, producción de código más legible y mantenible, facilitando la realización de modificaciones. � Espacio de Trabajo Se prefiere tener una zona espaciosa con cubículos pequeños. 19 � Reglas El equipo tiene sus propias reglas a seguir, pero pueden cambiar en cualquier momento. Dichos cambios deben realizarse por acuerdos y son implementados según el impacto determinado del cambio. Asterisk El área de las telecomunicaciones es quizá una de las últimas grandes industrias que hasta el momento no había sido afectada por la revolución del “Software Libre”. La mayoría de las grandes empresas de telecomunicaciones siguen fabricando costosos, incompatibles, complicados y obsoletos sistemas de telefonía. [MJS (2005)] refiere como ejemplo de lo anterior que Nortel y su “Business Communications Manager” que corre bajo el servidor Windows NT 4.0, un switch o interruptor telefónico de aproximadamente 15 años y un PC de 700 Mhz, puede costar entre 5 y 15 mil dólares, sin incluir dispositivos extra de telefonía. Aparte se debe instalar el software de las funcionalidades “limitadas” para el funcionamiento de este dispositivo. La mayoría de los sistemas propietarios no brindan flexibilidad, no permiten incluir nuevas funcionalidades ni ofrecen escalabilidad, sino más bien pretenden implantar sistemas rígidos que obliguen al consumidor a cambiar todo el sistema en vez de re-potenciar el existente. 20 Asterisk cambia este paradigma, brindando flexibilidad y escalabilidad al cliente, tiene muy pocas limitaciones en este aspecto, siendo la mayor, la configuración del sistema. Asterisk permite implantar un sistema telefónico fabricado especialmente según las necesidades de cada consumidor. Una de las ventajas más notorias la comprende el ser distribuido bajo Software Libre. Según la [GNU (2007)], el Software Libre representa un software que respeta ciertas libertades a los usuarios, entonces una vez que se dispone, el mismo puede ser usado, estudiado, copiado, modificado y redistribuido libremente. El término puede ser confundido como software gratuito por su traducción del inglés, pero se refieren al término free, al garantizar libertades más no por ser gratis. Específicamente se refieren a 4 libertades necesarias para los usuarios del software: • Libertad de ejecutar el programa con cualquier propósito (privado, educativo, público, comercial, militar, entre otros). • Libertad de estudiar y modificar el programa. • Libertad de copiar o redistribuir el programa, de esta manera se puede ayudar al “vecino” o a cualquier otra persona. • Libertad de hacer mejoras en el programa y capacidad de publicar las mejoras, de modo que toda la comunidad se vea beneficiada de esta corrección. • Para cumplir el segundo y el cuarto punto, se tiene como precondición tener la posibilidad de acceder al código fuente, es decir que es necesario brindar al usuario acceso al código fuente para que se considere como Software Libre. 21 ¿Qué es? Según [MJS (2005)], Asterisk es una aplicación, multiplataforma, distribuida y desarrollada libremente, de una central telefónica PBX (Private Branch Exchange), liberada bajo la Licencia GPL de GNU (General Public License). Un PBX puede ser imaginado como una red privada de conmutación, conectada en un extremo a una cantidad de extensiones privadas y del otro lado, una red telefónica, usando el PBX como un conmutador de llamadas. El sistema incluye las funcionalidades asociadas a cualquier PBX propietarios, como conectar un número determinado de teléfonos para hacer llamadas entre sí o conectar con un proveedor de VoIP (Voice over Internet Protocol) o una ISDN (Integrated Services Digital Network). La central telefónica Asterisk también incluye características especiales que sólo poseen algunos PBX como: buzón de voz, distribución automática e interactiva de llamadas (Interactive Voice Response, IVR), conferencias, entre otras funcionalidades que se mencionarán más adelante. Por sus características, su flexibilidad y sus bondades para la construcción de soluciones en las telecomunicaciones, Asterisk comprende una de las herramientas telefónicas de código abierto más usada en la actualidad. También es considerado un marco de trabajo o framework que permite seleccionar y/o quitar ciertos módulos, lo que realza su flexibilidad y versatilidad, 22 facilitando diseñar un sistema telefónico hecho a la medida, lo que comprende una gran ventaja al compararlo contra los PBX propietarios, que como se comentó, son muy rígidos en este aspecto. Historia [MJS (2005)] refieren que en sus orígenes, Asterisk fue desarrollada por Mark Spencer en el año 1999, quién para ese entonces era estudiante de Ingeniería Informática en la Universidad de Auburn, Alabama. Entonces, Spencer decidió crear la empresa "Linux Support Services" con el objetivo de dar soporte a usuarios de Linux. Para lograr su misión, Spencer necesitaba una central telefónica, pero ante la imposibilidad de adquirirla dados sus elevados precios, decidió construir un software que le brindara los mismos beneficios, con sólo un PC bajo Linux y utilizando el lenguaje de programación “C”. De allí nace la idea del proyecto que dio origen a Asterisk, llamado de esta manera por el símbolo Asterisco (*), que en ambientes tales como Linux, Unix y DOS representa cualquier combinación de caracteres o un “comodín”, utilizado de igual manera en muchos otros sistemas y lenguajes de programación. El proyecto de Asterisk fue creciendo a través de los años bajo el paradigma del código abierto, por lo que programadores de diversas partes del mundo fueron 23 realizando contribuciones importantes al código de Asterisk, adicionando funcionalidades, realizando correcciones a ciertos errores y pruebas de la aplicación, entre muchas otras actividades. En el año 2002, "Linux Support Services", la empresa creada por Spencer, se convertiría en "Digium", redirigiendo sus objetivos al desarrollo y soporte de Asterisk. Spencer amplió el modelo de negocio tanto con la venta de hardware específico, fundamentalmente tarjetas de comunicación para la utilización de Asterisk, como con la venta de software propietario, entre el que destaca el "Asterisk Business Edition", aplicación basada en Asterisk a la que se le incorporan ciertas funcionalidades con derecho de autor (copyright). Uno de los grandes colaboradores para posicionar a Asterisk al sitio donde se encuentra en la actualidad, es Jim Dixon y su proyecto “Zapata Telephony”, nacido de la motivación de este ingeniero al que le interesaba mucho la interconexión entre los ordenadores y la telefonía. Y es que en primera instancia se creía que si existiera una tarjeta que pasara la información de la telefonía analógica al computador representaría un gran avance, ya que el procesamiento que se realizaba hasta el momento era a través de costosos sistemas con DSP (Digital Signal Processing) y ahora se podría llevar a cabo en el procesador del computador. Este fenómeno bajaría considerablemente los costos de los sistemas telefónicos, ya que se podría procesar la información en un computador en vez de en un costoso hardware. 24 Al pasar los años y observar que nadie había fabricado, ni planificaba la creación de dichas tarjetas, se propuso a fabricarlas él mismo y fue entonces cuando nació el proyecto conocido como “Zapata Telephony Project”. Al finalizar su construcción, compartió sus resultados con la comunidad de Software Libre, y gracias a su contribución nació la PSTN (Public Switched Telephone Network) de Asterisk, es decir la “La Red Telefónica Pública de Asterisk”. Características y Ventajas [MJS (2005)] mencionan las características telefónicas más importantes que tiene Asterisk: • Permite realizar llamadas entre extensiones conectadas a él y al exterior. • Transferencias de llamadas entre las extensiones. • Monitoreo de llamada. • Permite la conexión con un proveedor de telefonía de VoIP o RDSI. • Buzón de voz. • Grabación de la llamada. 25 • Identificador de números. • Bloqueo de números. • Distribución automática e interactiva de llamadas (“Interactive Voice Response”, IVR). • Llamadas en conferencia. Los mismos autores, en su obra Asterisk: The Future of Telephony, explican que las ventajas más notables que presenta este PBX son: • Posee soporte para voz sobre IP en numerosos protocolos tales como SIP, H.323, IAX, MGCP. • Puede establecer comunicación con casi todos los equipos estándares de telefonía. Por ejemplo, para conectar teléfonos analógicos se necesita instalar al menos una tarjeta telefónica FXS o FXO, fabricadas casi en su totalidad por la compañía de Mark Spencer, “Digium”. • Es una aplicación de código abierto con licencia GPL de GNU. Esto trae una gran ventaja porque permite que miles de desarrolladores a nivel mundial trabajen sobre este software, mejorándolo, agregándole nuevas funcionalidades, y colaborando al realizar correcciones sobre los errores. 26 • Una gran parte de la flexibilidad que brinda la aplicación se debe a la disponibilidad de modificar el código fuente, permitiendo que los desarrolladores puedan modificar el comportamiento de la aplicación y adaptarlo al problema. • Este software también presenta dentro de sus ventajas el ahorro de coste al consumidor, este aspecto es uno de los más trascendentales, y a su vez inspiró al desarrollo del sistema. Mientras que un PBX propietario puede generar gastos de varios miles de dólares, teniendo un ordenador disponible, este sistema se puede implantar con sólo cientos de dólares, lo que representa el costo de las tarjetas fabricadas por Digium. • Escalabilidad de aplicación: cualquier usuario puede agregar nuevas funcionalidades, llamadas dialplans, a través del lenguaje de script de Asterisk. Un dialplan, o plan de marcado en español, se considera el corazón de Asterisk y son los entes que definen como se va a procesar el tráfico del sistema, tanto de llamadas como de aplicaciones. Simplemente consisten de una lista de instrucciones o pasos que seguirá Asterisk durante la ejecución y comprenden la base de su configuración. Contrariamente a los sistemas PBX propietarios, los dialplans de Asterisk son hechos y modificados según la necesidad del consumidor. • Interfaces para la comunicación con otros lenguajes de programación, permitiendo añadir nuevos dialplans y/o nuevos módulos programados en el lenguaje C, escribiendo scripts en los lenguajes de programación Perl, Ruby, Phyton o cualquier otro lenguaje soportado por Linux a través del Asterisk Gateway Interface (AGI) y/o Asterisk Manager Interface (AMI). 27 • Asterisk es capaz de inter-operar con terminales IP actuando como un registrador y como puerta de enlace (gateway) entre ambos. • Multiplataforma, este software se puede ejecutar en diversos sistemas operativos, tales como Linux, Mac OS X, OpenBSD, FreeBSD, Solaris y Microsoft Windows, en referencia a este último es un caso especial ya que sólo hubo una versión de demostración, pero en realidad se dice que Asterisk no corre sobre la plataforma Microsoft. Originalmente Asterisk fue diseñado únicamente para trabajar sobre una plataforma Linux, siendo ésta la mejor soportada. Asterisk como un PBX En la historia de las telecomunicaciones, nunca se ha desarrollado un sistema que satisfaga las necesidades de cada negocio, a ningún precio. El consumidor siempre había tenido que adaptarse a las posibilidades del sistema, pero Asterisk es un sistema telefónico de PBX que revoluciona este aspecto, ya que ahora el cliente no tiene que adaptarse al sistema sino que éste se ajusta a las necesidades del cliente. Por esta razón, existen problemas en el área de la telefonía donde por los momentos sólo Asterisk puede ayudar. El éxito y la aceptación de este software ha sido muy buena y mucho más rápida que la que ocurrió con Linux. Esto se debe a varias razones: • Linux progresivamente encendió la primera llamarada hacia la aceptación 28 del Software Libre, así que para Asterisk es más sencillo seguir estos pasos. • La industria de telefonía carece de liderazgo. Es ahí donde aparece Asterisk, que tiene una visión realista, comprometida y futurista. • A lo largo del tiempo, los usuarios han sido víctimas de sistemas costosos, incompatibles, con muchas limitaciones y sin mucho soporte. Asterisk ha resuelto los primeros, por su compatibilidad, bajo costo y flexibilidad, y ha demostrado bastante pasión por resolver el último. • Asterisk es un PBX que puede ser orientado hacia la telefonía IP o la telefonía tradicional, pero generalmente es utilizado como un híbrido, conmutando llamadas, resolviendo las rutas y conectando los usuarios con el exterior a través del Internet, la telefonía analógica y con conexiones digitales (T1/E1). Entre sus características más notables tenemos las llamadas entre las estaciones, que como un PBX cualquiera ofrece. Esto significa que los usuarios pueden discar desde un teléfono a otro. Quizá parece una funcionalidad implicita, pero existen sistemas muy elementales (generalmente llamados Key) que tienen soporte para múltiples dispositivos y múltiples líneas telefónicas. Ellos permiten a los dispositivos usar cualquier línea, pero como éstos no poseen extensiones individuales, no existe manera de iniciar una llamada de una extensión a otra. Asterisk permite tanto comunicaciones directas entre extensiones internas como establecer contacto a dispositivos externos si se encuentra conectado a un proveedor de servicio, como se muestra en el siguiente gráfico: 29 Gráfico 2: Esquema de interconexión de Asterisk con dispositivos internos y externos. Fuente: Meggelen (et al. 2005) En este diagrama cada extensión que se encuentra a la izquierda del PBX puede conectarse a otra extensión discándola directamente. Esto significa que si el módem va a enviar un fax a la máquina local, los dispositivos se comunicarán directamente, a través del PBX. Para dar un ejemplo más ilustrativo, se puede imaginar dos oficinas separadas físicamente, que bien pudieran tener dos líneas telefónicas separadas, pero si ambas tienen Asterisk y una conexión a Internet, se puede realizar una configuración tal que se puedan comunicar las extensiones de cada uno de las oficinas a través de Internet, representando un ahorro de costos notable, especialmente si las oficinas están en países distintos. Inclusive se pudiera dar el caso que se reciba una llamada a la oficina A preguntando por cualquier protocolo. Si esa llamada la debe manejar el personal de la oficina B, se puede transferir la llamada a ésta oficina, pasándola a través de Internet, tal cual como se presenta en la siguiente imagen: 30 Gráfico 3: Esquema de interconexión entre varios PBX`s con dispositivos asociados. Fuente: Meggelen (et al. 2005) En el gráfico se aprecia el escenario con mayor claridad cuando entra una llamada a través de la PSTN (Public Switched Telephone Network) conectada al PBX de la oficina A, es atendida por una extensión de la oficina A y transferida a una extensión en la oficina B a través de Internet. También se puede dar el escenario donde la oficina B no tenga conexión a un proveedor de telefonía y realice sus llamadas a teléfonos externos a través de la oficina A. Estos son unos pocos ejemplos de la potencialidad que posee Asterisk con sólo una configuración adecuada usando telefonía con voz sobre IP. Tal como sostiene [GDD (2005)], con Asterisk también es posible implantar un sistema de comunicación común como el planteado en el primer escenario donde Asterisk sólo 31 se encuentre conectado a través de la telefonía tradicional, permitiendo con un poco de configuración nuevas funcionalidades utilizando VoIP. La mayoría de las compañías manejan dos redes, una para la telefonía y otra para los ordenadores. Si unimos estas dos redes en una sola comprendería un beneficio a nivel de costos, tanto en equipo como en personal. Además que a través del tiempo el hardware para los computadores y redes de ordenadores parece bajar progresivamente de precio, mientras que los sistemas propietarios de telefonía permanecen iguales. Voz sobre IP permite tener una extensión conectada siempre y cuando se disponga de una conexión veloz a Internet. Entonces una persona pudiera tener la misma extensión en su oficina y en su casa o hasta en su teléfono celular. Por éstas y otras características Asterisk está siendo implantado en muchos centros de llamadas a nivel mundial. Flexibilidad Vs. Configuración Naturalmente las ventajas y características vienen asociadas a un precio, ya que Asterisk no es un sistema simple a la hora de configuración, que quizá comprende su principal desventaja. A pesar que el software es claro y lógico, pudiendo implementar casi cualquier escenario a nivel de telefonía, cada una de las funcionalidades lleva un esfuerzo asociado, que para un principiante pudiera significar un tiempo considerable de dedicación. 32 Existe una curva de aprendizaje, pero puede ser sobrellevada con facilidad. Muchos desarrolladores se han convertido en expertos en telefonía. [GDD (2005)] explican que Asterisk no fue concebido para todos los perfiles de usuario, ya que para personas que no se quieren encargar en lo más mínimo de configuración ni instalación, esta no es la mejor opción. Es importante reflejar que aunque Asterisk tiene esta cantidad de ventajas, no es la solución adecuada para cada negocio, depende de las necesidades de cada uno, es por eso que se deben estudiar las posibilidades antes de escoger la tecnología a ser usada. Configuración Gráfica vs Configuración de Texto Actualmente la mayoría de las opciones de Asterisk se configuran a través de archivos de texto plano. Esta es una forma sencilla de crear, respaldar y modificar configuraciones para aquellos usuarios o desarrolladores que se sientan a gusto con este tipo de archivos. Existen algunos PBX que ofrecen interfaces gráficas, mejor conocidas como Graphical User Interface en inglés (GUI), para manipular su configuración. Otros PBX se configuran a través de los dispositivos conectadas a él como, por ejemplo, un teléfono, y algunos otros simplemente no pueden ser configuradas, excepto con personal certificado, que requieren de dispositivos especiales fabricados por la misma compañía de telecomunicaciones del sistema, para realizar dicha configuración. 33 Ya existen varias herramientas para instalar y configurar a Asterisk fácilmente a través de una interfaz gráfica, pero para tener la posibilidad de configurar todas las funcionalidades aún se requiere de una configuración de texto, aunque reducida. Pudiendo afirmar que la configuración de Asterisk se ha facilitado, reduciendo un poco el punto crítico que lo desvirtúa. Dialplans: Contextos, Extensiones, Prioridades y Aplicaciones Los dialplans (planes de marcado en español) están compuestos por cuatro partes principales, los contextos, las extensiones, las prioridades y las aplicaciones. Se explicarán sus componentes para luego dar una visión general de los dialplans. Contextos En Asterisk un contexto no es más que una colección de extensiones definidas por un nombre lógico. Por lo cual una misma extensión puede estar definida más de una vez, siempre y cuando se encuentre en dos contextos distintos, funcionando cada extensión de manera aislada. Estas extensiones no pueden establecer conexión a menos que se especifiqué lo contrario en Asterisk, es decir que dos contextos no se comunican al menos que se indique a nivel de configuración. Supongamos que 2 compañías comparten un mismo servidor de Asterisk, pero en las 2 compañías quieren definir sus extensiones del 1 al 10, en este momento se utilizan los contextos para separar cada lote de extensiones. Por ejemplo si en cada una de las compañías la extensión 1 es la de recepción, cuando una extensión de la compañía A marque 1, con la diferenciación de contextos, se asegura que se esté 34 comunicando con la recepcionista de la compañía A y no se confunda con las extensiones de la compañía B. Los contextos son denotados por un nombre de caracteres dentro de corchetes ([]). Nombre que puede estar compuesto por combinaciones de letras desde a “A” hasta la “Z”, mayúsculas o minúsculas, dígitos del 0 al 9 y ciertos caracteres especiales. En la página Web Asterisk Dialplan Introduction (2003), se explica que un contexto podría estar compuesto de cualquier cantidad de extensiones, un ejemplo sencillo podría ser (no como se configura en Asterisk): Context [prueba]: Extension Description 101 Edgar 102 Omar 103 Andrés 104 Chequear Contestadora 105 Salón de Conferencias 0 Recepción En el ejemplo se define un contexto llamado “prueba”, donde las primeras 3 extensiones, de la 101 a la 103, están asociadas a distintos empleados, la extensión 104 para solicitar consulta sobre el contestador automático, la quinta extensión con su número 105 pertenecería al salón de conferencias, finalmente la última definida con el número 0 asociada a la recepción. El sitio Web [Asterisk Dialplan Introduction (2003)], señala que los contextos pueden ser útiles al implementar ciertas configuraciones, tales como: • Seguridad: Con restricción sobre las llamadas salientes, dependiendo de la 35 extensión. • Enrutando: Según la extensión se pueden enrutar las llamdas. • Respuesta automática: Dar un mensaje automático, donde el usuario indique la extensión a comunicar. • Menús multinivel: Menús para ventas, soportes, entre otros, en una institución. • Autenticación: Preguntar por contraseñas para ciertas extensiones. Asterisk al recibir una llamada desde afuera o desde una extensión interna, las asocia a un contexto, el cual depende del canal en el que la llamada se recibió. Esto es posible ya que al configurar los canales en Asterisk, se define el contexto asociado a cada uno de ellos. Canales Según [Asterisk channels (2003)], un canal en Asterisk es una conexión que se asocia a una llamada cuando esta entra a Asterisk. Dicha conexión pudiera estar asociada a un teléfono, línea de teléfono, o a una llamada lógica (como una llamada a través de Internet). Se debe tomar en cuenta que cada llamada es colocada o recibida en un canal distinto, lo cual conforma un identificador único para esa llamada. Extensiones En cada contexto se definen una o más extensiones. A pesar que las extensiones generalmente son usadas para especificar cada de las extensiones 36 telefónicas, al igual que en los PBX tradicionales, en Asterisk pueden ser usadas para más que un simple identificador. Según [MJS (2005)], una extensión puede ser una instrucción que Asterisk va a seguir y es disparada por una llamada entrante o por una serie de dígitos marcados en un canal. Las extensiones especifican que sucede con una llamada cuando se manejan en el dialplan. La sintaxis para una extensión es la palabra “exten”, seguida de una flecha, de la siguiente manera: Instrucción de Asterisk: exten => Tabla 1:Extensión Asterisk. Colocándose luego el identificador de la extensión. A pesar que tradicionalmente se piensa en una extensión como un número, en Asterisk podemos definir identificadores como combinación de números y letras. Una extensión está compuesta por 3 componentes: • El identificador de la extensión • La prioridad • La aplicación o comando que es llamado Cada uno de los componentes separados por comas, por ejemplo: 37 Componentes de la extensión: exten => 123,1,Answer() Tabla 2: Componentes Extensiones Asterisk. En el ejemplo el identificador de la extensión es “123”, la prioridad es “1” y la aplicación es “Answer()”. Existe una extensión especial para Asterisk llamada “s”. Cuando una llamada entra a un contexto sin una extensión específica destino, son manejadas automáticamente por la extensión “s”. La “s” viene del término en inglés “start” (comienzo), ya que la mayoría de las llamadas empiezan su curso en la extensión “s”. Prioridades [MJS (2005)], comenta que cada extensión puede tener varios pasos, llamados prioridades. Cada prioridad es numerada secuencialmente, empezando desde el número uno (1). Cada prioridad se ejecuta en una aplicación específica. Por ejemplo: Prioridades de extensiones: exten => 123,1,Answer( ) exten => 123,2,Hangup( ) Tabla 3: Orden de Ejecución de Extensiones. En el ejemplo la extensión con la prioridad uno ejecuta su aplicación 38 (Contestar el teléfono) y luego se cuelga con la ejecución de la aplicación (Hangup()) que tiene asignada la prioridad dos. Aplicaciones [MJS (2005)], explica que una aplicación es el código que se ejecuta o la acción a tomar en el canal actual, tal como reproducir un sonido, leer una opción de usuario, responder o colgar la llamada, entre otras. Algunas aplicaciones como las expuestas en el punto anterior llamadas Answer() y Hangup(), que significan responder y colgar una llamada respectivamente, son algunas de las más usadas en el PBX. A estas aplicaciones no se les pasa ningún parámetro, más existen aplicaciones que llevan parámetros y tal cual como las funciones en la mayoría de los lenguajes de programación, son colocados dentro de paréntesis y separados por comas. Dialplans Finalmente la unión de las piezas (prioridades, aplicaciones, extensiones y contextos) se arman para formar lo que se llama en Asterisk, un dialplan. Un ejemplo sencillo puede ser: Dialplan ejemplo: [entrante] exten => s,1,Answer( ) exten => s,2,Playback(bienvenido) exten => s,3,Hangup( ) exten => 123,1,Answer() Tabla 4: Ejemplo de Dialplan de Asterisk. 39 En el ejemplo tenemos tres extensiones con el identificador “s”, cuyo funcionamiento fue comentado anteriormente y una extensión con el identificador “123”. Tomando como premisa que las llamadas se asocian al contexto “entrante”, cualquier llamada con un destino distinto a la extensión “123” pasará por la secuencia de aplicaciones Answer(), que contestará la llamada, Playback(hello-world), aplicación encargada de reproducir un archivo de sonido llamado hello-world y finalmente ejecutando Hangup(), aplicación que colgará la llamada. Pero si la llamada va dirigida hacia la extensión “123”, se ejecutará únicamente la aplicación Answer(). Interfaces Asterisk Manager Interface y Asterisk Gateway Interface Una de las facilidades de las que provee Asterisk son las interfaces de comunicación con ese framework, que permiten flexibilidad y escalabilidad. Esas interfaces son: Asterisk Gateway Interface (AGI) y Asterisk Manager Interface (AMI). AGI es una interfaz que permite establecer un intercambio de datos entre Asterisk y código escrito en un lenguaje de programación que tenga la capacidad de escribir al STDOUT (salida estándar) y leer del STDIN (entrada estándar), para tomar decisiones de enrutamiento y ejecución de aplicaciones y/o llamadas que se encuentren activas en Asterisk. AMI por su parte, da un control sobre el funcionamiento del sistema de 40 Asterisk; permitiendo conectarnos al framework por medio de un socket TCP desde cualquier lenguaje con soporte para sockets. Al recibir notificaciones sobre eventos que ocurren en Asterisk tales como información sobre las llamadas activas, sobre las extensiones, entre otros; así como emitiendo acciones que se ejecuten en Asterisk, como por ejemplo, realizar, colgar o transferir una llamada. Asterisk Gateway Interface Según [MJS (2005)], la interfaz Asterisk Gateway Interface (AGI), provee un estándar de conexión desde programas externos hacia el funcionamiento de Asterisk. Los scripts o conjunto de instrucciones son usados para agregarle una lógica avanzada al sistema de Asterisk, como lograr comunicación con bases de datos (tales como PostgreSQL o MySQL), o utilizar otros recursos externos. Dichos códigos pueden ser escritos en distintos lenguajes de programación tales como Perl, PHP, C, Pascal, Ruby, entre otros, dependiendo de la elección del desarrollador. También plantea que el sistema pasa el control desde el dialplan de Asterisk a un lenguaje externo a través de AGI, permitiendo la realización de tareas que serían muy difíciles o casi imposibles de implementar con Asterisk. Los scripts AGI se comunican con Asterisk a través de canales (apuntadores a archivos) conocidos como STDIN, STDOUT, y STDERR que pueden ser interpretados en Unix como la entrada estándar, la salida estándar y la salida de error estándar, respectivamente. Así, un código AGI lee del STDIN para tomar información de Asterisk, 41 escribe datos en el STDOUT para enviar información a Asterisk y puede escribir en el STDERR para enviar información de traza a la consola de Asterisk. Desde luego que se necesita una porción de configuración en Asterisk para lograr la comunicación efectiva a través de esta interfaz. Esta interfaz fue desarrollada para permitir que una aplicación externa a Asterisk tome el control sobre el flujo de la llamada, permitiendo desvíos, respuestas automáticas y otras modificaciones sobre la llamada. Esto pensando en los avances de los lenguajes de script y los beneficios que esto podría significar para el área de las centrales telefónicas, por ejemplo, la implementación sencilla de un centro de llamada o un IVR de manera programada. Valiéndose de la ventaja que significa la manipulación del flujo desde algún lenguaje externo, ya que proveen soportes para conexiones a bases de datos, rutinas externas, pase de información, entre otros aspectos que salen del alcance de Asterisk. En el sitio Web [Asterisk AGI (2003)], explican que la interfaz fue concebida para la distribución de llamadas recibidas a la central telefónica, mas no para la realización de llamadas asíncronas. Pero Asterisk brinda soporte para la realización de llamadas asíncronas por otros métodos que estudiaremos a continuación. Si se desea iniciar una llamada asíncrona con Asterisk, se tienen dos posibilidades: • Escribiendo un archivo de texto (.call) que iniciará una llamada automática a través de Asterisk, acción llamada auto-dial out. • Usando un comando llamado originate, que pudiera ser ejecutado a través el Asterisk Manager Interface, o AMI. 42 Asterisk Manager Interface La Web [AMAPI (2003)] explica que Asterisk Manager Interface (AMI), permite que una aplicación cliente, establezca comunicación con una instancia de Asterisk, y le envíe comandos o lea eventos del PBX a través de un flujo sobre TCP/IP. Esto resulta útil a la hora de realizar consultas sobre el estado de Asterisk o dar ciertas reglas que pudieran implicar la ejecución de un comando, aplicación, entre otras. Por su parte, en la página Web [UsingAMI (2007)], se afirma que ésta es una forma de conectarse a Asterisk desde una aplicación externa que permite consultar y manipular la información del PBX en un tiempo determinado. En el sitio Web [AMAPI (2003)] enfatizan que la interfaz utiliza un protocolo de comunicación para el intercambio de información entre la aplicación y el PBX, con previa autenticación. Para un conjunto de líneas se usará el término “paquete”, el cual es terminado con una línea en blanco, es decir con 2 saltos de línea seguidos. Dichos paquetes vienen dados de la siguiente forma: Paquete ejemplo de AMI: Action: <tipo de acción> <CRLF> <Key 1>: <valor 1> <CRLF> <Key 2>: <valor 2> <CRLF> ... <Variable>: <valor> <CRLF> <Variable>: <valor> <CRLF> ... <CRLF> Tabla 5: Paquete Ejemplo de Comunicación AMI. 43 Por ejemplo, para autenticarse con el sistema, se enviaría un paquete con este formato: Paquete ejemplo de autenticación AMI: Action: login <CRLF> Username: carlos <CRLF> Secret: good <CRLF> <CRLF> Tabla 6: Ejemplo de Paquete de Autenticación AMI. En este paquete el campo login es la acción a realizar, seguido del nombre de usuario y la contraseña de la cuenta a autenticar. En el sitio Web [AMAPI (2003)] mencionan algunas características del protocolo, entre las cuales encontramos: • Antes de empezar a enviar comandos a Asterisk, se debe establecer una sesión, es decir autenticarse contra el sistema. • Luego se pueden enviar paquetes en cualquier instante, sin importar la dirección, es decir si van a viajar del cliente al servidor Asterisk o viceversa. • La primera línea del paquete debe tener la acción cuando es enviado desde la aplicación, pero cuando lo envía Asterisk debe ser un evento o una respuesta a la aplicación cliente. • El orden de las líneas dentro del paquete es insignificante. • Los caracteres CR y LF son usados para delimitar cada línea. • Una línea en blanco indica el fin de un paquete. 44 En el mismo sitio de Internet, se señalan tres tipos de paquetes, entre los cuales se encuentran los paquetes de acción, de respuesta y de evento, a continuación se dará una breve descripción de cada uno: • Acción: un paquete enviado por un cliente de Asterisk conectado, pidiendo que una acción en particular sea ejecutada. Hay un conjunto finito pero extensible de acciones disponibles para los clientes, determinadas por los módulos cargados en Asterisk para ese momento. Solo se puede ejecutar una acción a la vez. Los paquetes de acción contienen tanto el nombre como los parámetros de la operación a ser ejecutada. • Respuesta: paquete de respuesta enviado por Asterisk, devolviendo el resultado al último paquete de acción entregado por el cliente. • Evento: paquete de data pertinente de un evento o cambio generado en Asterisk, como por ejemplo el cambio de estado de una extensión de Asterisk, cambio de estado de un canal, entre otros. [MJS (2005)] señala que para alcanzar la comunicación entre Asterisk y la aplicación externa a través de AMI, es necesario poseer una cuenta en Asterisk sobre la cual se autenticará la información. Dicha cuenta es una simple entrada en el archivo de configuración de Asterisk, manager.conf. También explica [MJS (2005)] que la aplicación cliente envía paquetes de acción al servidor de Asterisk, quien los recibe, procesa, realiza las operaciones adecuadas y le envía de vuelta a la aplicación cliente el resultado (error o éxito), en un 45 paquete de respuesta. Los paquetes incluyen un identificador para poder realizar la correspondencia sobre las acciones y respuestas. Por su parte, en la página de Internet [AMAPI (2003)] se explica que los paquetes de evento son usados bajo dos escenarios: • En primer lugar cuando Asterisk cambia de estado, es decir que hay un cambio en el sistema (una extensión es colgada o alguien es autenticado en el sistema, entre otras), Asterisk envía un paquete de evento informando el cambio. • El segundo escenario se da cuando la aplicación le envía un paquete a Asterisk solicitando información sobre el sistema y Asterisk le contesta con un paquete de respuesta que contiene: “Response: Follows” indicando éxito. Luego son enviados cero o más paquetes de evento con la información del sistema que solicitó el cliente seguido de una respuesta del cliente en una acción, indicando que toda la data fue enviada correctamente. A continuación se presentan las acciones más resaltantes tomadas del sitio de Internet [AMAPI (2003)]: • Command: Acción para ejecutar un comando específico de la consola de Asterisk. • ExtensionState: Devuelve el estado en que se encuentra una extensión específica. • Hangup: Cuelga un canal • Logoff: Termina la sesión iniciada con el sistema 46 • Monitor: Grabar la conversación de un canal. • Originate: Realiza una nueva llamada. • Redirect: Transfiere una llamada a otra extensión. • Status: Muestra el estado del sistema. Como se comentó anteriormente, existen dos escenarios para el envío de paquetes de eventos, desde Asterisk hacia la aplicación externa. Una posibilidad comprenden los paquetes asíncronos informativos sobre cambios, conocidos como eventos AMI. En este caso lo que sucede es simplemente un proceso de difusión de la información. En el sitio Web de [AME (2003)], se explica que dado un cambio dentro de Asterisk, se genera un evento que el PBX difundirá a través de su interfaz AMI en un formato específico. De esta manera las aplicaciones externas a Asterisk son capaces de conocer cualquier evento que sucede dentro del PBX casi al instante del mismo, ya que reciben un mensaje asíncrono desde Asterisk. Los paquetes de eventos llegan a distintos métodos de la aplicación. Según el método, la aplicación pudiera tomar una acción u otra dependiendo de lo que quiera lograr al momento del evento. A continuación se explican algunos eventos: • Dial --- Evento de marcado [derivado o disparado desde app_dial.c] 47 Ejemplo del mensaje: Ejemplo de evento cuando se marca un número en Asterisk: Event: Dial Evento Privilege: call,all Privilegio Source: Local/900@default,2 Fuente Destination: SIP/900-4c21 Destino CallerID: <unknown> Identificador de llamada CallerIDName: default Identificador de llamada SrcUniqueID: 1149161705.2 Identificador de la fuente DestUniqueID: 1149161705.4 Identificador del destino Tabla 7: Ejemplo Evento Dial. • ExtensionStatus --- Evento del estatus de la extensión [derivado o disparado desde manager.c] Ejemplo del mensaje: Ejemplo de evento de cambio de estatus de extensión en Asterisk: Event: ExtensionStatus Evento Exten: <ext> Extensión Context: <context> Contexto Status: <state> Estatus Tabla 8: Ejemplo Evento ExtensionStatus. En todos los mensajes viaja al principio del paquete el tipo del evento, luego viajan una serie de parámetros distintos dependiendo del evento que se genere. En este último caso tenemos que el tipo de evento es “ExtensionStatus”, que tiene tres parámetros, el primero “Exten” que tiene la información de la extensión que sufrió el cambio de estado, “Context” que tiene el contexto en el que se encuentra y “Status”, variable que contiene el estatus en el cual quedó la extensión que sufrió el cambio. 48 Ruby on Rails Ruby on Rails, conocido también como RoR o Rails, es un framework de aplicaciones Web escrito en el lenguaje de programación Ruby, que como se afirma en la página Web Wikipedia (2007), se apega al paradigma de la arquitectura Modelo Vista Controlador (MVC). Según [TDH (2006)] Ruby on Rails es un framework cuyo lema es facilitar el desarrollo, despliego y mantenimiento de aplicaciones Web. Persigue combinar simplicidad con la posibilidad de desarrollar escribiendo menos líneas de código que utilizando otros frameworks. Aproximadamente al año de ser lanzado al público (en 2004), Rails pasó de ser un framework desconocido a un fenómeno a nivel mundial, convirtiéndose en una de las mejores opciones a la hora de implementar aplicaciones Web. Para dar una perspectiva de esta evolución, se puede mencionar que pasó de ser usado por sólo hackers, a utilizarse como framework de desarrollo en compañías transnacionales a nivel mundial, según reseña [TDH (2006)]. Las aplicaciones implementadas con esta tecnología siguen una arquitectura MVC, igual que las desarrolladas usando frameworks como Tapestry y Struts basados en Java. [TDH (2006)] destaca como otro de los puntos claves de Rails el referido a las pruebas. Los programadores escriben pruebas para desarrollar una aplicación de calidad y Rails facilita la implementación de este tipo de pruebas, por lo que cualquier 49 aplicación Rails provee soporte para pruebas dentro del mismo framework. Por cada funcionalidad, RoR crea de manera automática con su herramienta de generación de código, un esqueleto de las pruebas del requerimiento, trozos que pudieran considerarse como una plantilla para desarrollar las pruebas. La facilidad de escribir y ejecutar las pruebas, trae como resultado que las aplicaciones desarrolladas tiendan a ser probadas. Los desarrollos en RoR son escritos en el lenguaje de programación Ruby. Tal como se señala en el sitio Web [Acerca de Ruby (2007)], Ruby es un lenguaje de scripting orientado a objetos, caracterizado por ser claro y conciso, donde el desarrollador puede expresar las ideas de forma limpia y natural. La sencillez a la hora de programar facilita retomar un código que fue escrito en tiempo pasado, dando legibilidad y claridad. El lenguaje fue creado en el año 1993 por Yukihiro Matsumoto, programador japonés conocido en el gremio informático como “Matz”. Su creador alega que tomó partes de sus lenguajes favoritos (Perl, Smalltalk, Eiffel, Ada y Lisp) que permitieran el diseño de un nuevo lenguaje que equilibra la programación funcional con la imperativa. El el sitio Web [Acerca de Ruby (2007)], señala que el lenguaje Ruby permite la metaprogramación, que consiste en generar o manipular programas a partir de otro programa, es decir que un código tenga la capacidad de modificar o generar un programa. Esto permite al programador ahorrar tiempo en la producción de código, de la cual Rails hace uso, lo que resulta en una sintaxis que muchos de sus usuarios 50 encuentran legible. El lenguaje combina una sintaxis inspirada en Perl, orientado a objetos similar a Smalltalk que comparte funcionalidades con algunos lenguajes de programación como Python, Lisp, Dylan y CLU. Ruby se vale de su característica orientada a objetos, teniendo hasta los números y los literales como objetos. Es un lenguaje de programación interpretado y su implementación es distribuida bajo la licencia de software libre GNU GPL. Filosofías Rails tiene vertientes claras de como una aplicación Web debería estar compuesta y organizada, además de la forma en que los subsistemas deberían configurarse e integrarse. Distinto a los frameworks Java que existen actualmente que basan su integración en archivos de configuración XML, una de las filosofías más acentuadas de Rails es la Convención sobre configuración. Ruby on Rails reemplaza la configuración masiva de archivos XML por una convención de nombres consistentes y rutas estándares para los distintos tipos de archivos usados en una aplicación Rails. Un ejemplo de esta práctica es la presente en la conexión con la base de datos, y es que según las convenciones de Rails, las tablas de las bases de datos deberían ser nombradas en plural y las clases en singular, entonces las clases User y Call tendrían por tablas a users y calls respectivamente, y su clave primaria en cada tabla conocido por el nombre id. Tal y como se presenta la convención en este caso, también sucede en muchos otros casos en las que se necesita la integración de los distintos elementos de la aplicación. 51 Cuando se diseña una aplicación partiendo de cero sin una base de datos preexistente, el seguir las convenciones de Rails significa usar menos código (aunque el comportamiento puede ser configurado si el sistema debe ser compatible con un sistema heredado). Otro de los principios fundamentales en Ruby on Rails es expresado comúnmente como DRY, por sus siglas en inglés Don't Repeat Yourself, en español significa no te repitas, cuya idea es minimizar la duplicación de código. Este principio plantea que las definiciones deberían hacerse una sola vez, ya que cuando se tiene código duplicado en la aplicación y es descubierto un error en él, habría que cambiar el defecto en numerosos lugares. Al reutilizar el código se minimiza el impacto de estos cambios a un sólo punto. [TDH (2006)] destaca que la combinación de las filosofías Rails en conjunto: la meta-programación, los plugins, las bondades y características del lenguaje Ruby, hacen de Rails un poderoso framework para el desarrollo de aplicaciones Web. Rails saca provecho de Ruby, facilitándole al programador el desarrollo de aplicaciones, permitiendo que la codificación sea considerablemente más corta y legible. Arquitectura En 1979 el Licenciado en Computación noruego, Trygve Mikkjel Heyerdahl Reenskaug, de 49 años de edad, propuso el Modelo Vista Controlador (MVC), un 52 nuevo diseño para el desarrollo de aplicaciones interactivas dividido en tres tipos de componentes: • Modelos. Comprenden los entes responsables del estado de la aplicación, en ocasiones estados transitorios durando sólo el tiempo de interactividad del usuario. En otros casos el estado es permanente, persistiendo generalmente en repositorios de datos. Un modelo es más que simplemente datos, comprende toda la lógica de negocio que es aplicada a esa data. Como se comentó, en Rails cada tabla es representada por un modelo asociado a ella, siendo el rol principal del modelo la implementación de métodos de consulta a la base de datos, comúnmente llamados querys, validaciones y actualizaciones a la base de datos. • Vistas. Son los componentes encargados de generar una interfaz de usuario, generalmente presentando los datos obtenidos de los modelos. Por ejemplo en una aplicación de una tienda se tiene una lista de productos disponibles. Dicha lista sería construida en un modelo de la aplicación, pero la vista estaría encargada de acceder la colección y definir un formato para su presentación al usuario final. • Controladores. Este componente es quien organiza y dirige la aplicación. Los controladores reciben eventos desde el exterior del sistema, interactúan con el modelo y le devuelve la vista apropiada al usuario. Tal como explica [TDH (2006)], estos tres componentes forman la arquitectura conocida como MVC, en el gráfico 3 se muestra el funcionamiento en términos abstractos. MVC es sólo un patrón que involucra separación del código de un modo específico para facilitarle ciertos aspectos al programador. 53 Gráfico 4: Modelo MVC Fuente: [TDH (2006)] En sus orígenes la plantilla MVC fue concebida únicamente para aplicaciones convencionales (Stand-alone) con interfaces de usuario, donde se descubrió que la separación de roles implicaba menor acoplamiento, un código más sencillo y mantenible con cada acción en el lugar correcto. Esta estructura provee una base o esqueleto de la aplicación, sobre la cual es más sencillo trabajar. Con el auge de las aplicaciones Web, los programadores retrocedieron, usando el obsoleto modelo monolítico donde se mezclaban la lógica de negocio, la presentación, el manejo de eventos y el acceso a repositorio de datos en un solo lugar. Luego, se empezó a experimentar y desarrollar aplicaciones Web con arquitecturas que intentaban separar el código, tal como lo propone el patrón MVC. El resultado fueron frameworks como WebObjects, Struts y Java Server Faces, todos basados en el modelo MVC. Rails provee una estructura para las aplicaciones donde se desarrollan modelos, vistas y controladores por separado, y los va integrando mientras se va Controlador Base de datos Modelo Vista 54 ejecutando el código. En la figura 4 se muestra el funcionamiento de Rails cuando recibe una petición. Según [Dave Astels (2007)], en una aplicación Rails los eventos de entrada son enviados primero a un enrutador (1), encargado de decidir quién será el componente que va a manejar dicha petición. Luego se identifica qué método se va a ejecutar en el controlador (2), la acción pudiera capturar la data de la petición e interactuar con el modelo (3). Eventualmente una acción preparará la data para la vista (4) que va a mostrarle al usuario. Gráfico 5: Modelo MVC en Rails Fuente: [TDH (2006)] Componentes básicos Active Record En la actualidad la mayoría de las aplicaciones desean persistir información en una base de datos relacional, hasta los sistemas poco estructurados como blogs y páginas de noticias usan este tipo de repositorios para guardar su información. Enrutador Controlador Modelo Vista Base de datos 1 2 3 4 5 55 Con el auge de los lenguajes de programación orientados a objeto, se ha presentado una dificultad al asociarlos con una base de datos relacional. Las base de datos a diferencia de los objetos se basa en conjuntos de valores agrupados, mientras que los objetos tienen sentido usando datos y operaciones. Existen dos tendencias al organizar la data en un sistema conciliando el paradigma orientado a objetos y el relacional, la primera consiste en organizar el programa alrededor de la base de datos (Programación centrada en la base de datos), el segundo al contrario organiza la base de datos alrededor del programa (ORM - Object/Relational Mapping). � Programación centrada en la base de datos En sus orígenes, la programación contra bases de datos relacionales se venía haciendo en lenguajes procedimentales tales como C y Cobol, y se realizaba escribiendo trozos de lenguaje SQL embebidos/empotrados dentro del código fuente, lo que producía una integración entre la lógica del código y la interacción con la base de datos. Este tipo de programación es común entre lenguajes de scripting como PHP, Perl y en Ruby también es usado. Es considerado la concepción ideal para pequeñas aplicaciones. Pero existe un problema: al mezclar la lógica de negocio junto con los accesos a la base de datos se pueden causar problemas de mantenimiento del código que pudieran traer graves repercusiones a la hora de agregar nuevos requerimientos o 56 modificar los ya existentes en el programa, teniendo duplicación de código no deseable en el mismo. El paradigma orientado a objetos nos ha enseñado que la encapsulación de los datos resuelve este problema. Al seguirlo, tendríamos un código más mantenible, que a la hora de un cambio se realizaría la modificación en un solo lugar del código. Luego se llevo el principio a la programación centrada en base de datos, encapsulando el acceso a la base de datos en clases. La aplicación se comunicaría a la base de datos a través de las clases. Práctica que fue bautizada con el acrónimo: ORM, del inglés Object/Relational Mapping o Asociación Objeto/Relacional. � Asociación Objeto/Relacional Las bibliotecas ORM se encuentran encargadas de asociar las tablas de las bases de datos a clases. Por ejemplo, si una base de datos tiene una tabla llamada productos, el programa va a tener una clase llamada Producto. Las filas en la tabla corresponderían a distintos objetos de la clase y los atributos serían usados para obtener e introducir los valores de las columnas. Las clases de Rails proveen métodos de operaciones sobre las tablas, por ejemplo, si se quiere buscar un producto específico en una tabla de productos. Simplemente se debe llamar a un método propio de la clase que devuelve el objeto según su identificador o algún atributo en especial. Si se busca por el atributo id, el código sería algo como: 57 Código ejemplo para buscar en la base de datos con id=1: producto = Producto.find(1) Objeto Clase función identificador Tabla 9: Ejemplo ORM, búsqueda en base de datos por id. También se tienen otras funciones que actualizan la base de datos (save, update). Probablemente la más usada es la función save, que guarda un objeto en la base de datos, en el caso que sea un objeto previamente recuperado y no sea nuevo, simplemente actualiza su estado en la base de datos. El código podría ser algo como: Código ejemplo para guardar en la base de datos un producto: producto.descuento = 0.5 producto.save Objeto Método Tabla 10: Ejemplo ORM, guardar objeto en base de datos. ORM relaciona tablas con clases, filas con objetos y columnas con atributos de esos objetos. Generalmente en la biblioteca de ORM se especifica la configuración para establecer la conexión entre la base de datos y las clases del programa. Active Record es la capa ORM (Object/Relational Mapping) que provee el framework Rails. Sigue al pie de la letra el estándar del modelo ORM: asociando 58 tablas con clases, filas con objetos y columnas con los atributos de los objetos como se reflejó anteriormente. La diferencia con respecto a las otras bibliotecas de ORM es en la forma que es configurado. Active Record se basa en el principio de convención sobre configuración para lograr esta conexión para minimizar la cantidad de configuración para los desarrolladores. En este caso la clase se asocia con la tabla teniendo el mismo nombre en plural como en el caso que se mencionó de la tabla users y la clase User. Entonces la labor de Active Record es de conectar los objetos del negocio y las tablas de la base de datos. Lograr la persistencia del dominio donde la lógica y la data sean envueltas en un solo sitio. Active Record es una implementación del patrón ORM y fue descrito por Fowler, tal como se reseña en el sitio Web [Active Record (2006)]: “Un objeto que envuelve una fila en una base de dato o una vista, encapsula el acceso a la base de datos y añade la lógica del dominio en esa data”. Este componente también brinda soporte de validaciones sofisticadas, inclusive, en una sola línea de código se puede extraer y aplicar el formato de errores o validar. En fin, tal como se plantea en [TDH (2006)], Active Record es la parte que describe el modelo en Rails de la arquitectura MVC. Active Record implementa lo que es llamado CRUD, siglas de (Create, Read/Retrieve, Update, Delete) en inglés, en español Crear, Obtener, Actualizar y Borrar. Acrónimo usado para referirse a las funciones básicas de bases de datos o de la capa de persistencia en un sistema. En algunos textos, se utilizan las siglas ABM para lo mismo (Alta Baja Modificación), obviando la operación de Obtener.. 59 Action Pack La vista y el controlador son partes del MVC que se encuentran estrechamente unidas. El controlador provee data a la vista, y el controlador recibe eventos desde la página generada por las vistas. Por esta causa el manejo de vistas y controladores en Rails dependen de un solo componente, Action Pack. A pesar que en Rails estas piezas (vista, controlador) se encuentran fusionados en un solo componente, se respeta la separación que propone el patrón Modelo Vista Controlador. � Vista En Rails la vista es responsable de generar la página que será mostrada en el navegador, es decir el código HTML que usualmente va a ser desplegado. Usualmente se quiere incluir contenido dinámico creado por alguna acción del controlador. En Rails el contenido dinámico es generado por plantillas que vienen dadas por tres grandes vertientes. La más usada es llamada RHTML que consiste de un código HTML con código Ruby embebido. De está vertiente se han desarrollado diversas mejoras como HAML que simplifica el largo y enredado código de la plantilla RHTML. Según la página en Internet de [HAML (2007)], HAML es un plugin -los 60 cuales serán discutidos más adelante- para la generación de vistas en las aplicaciones Rails y está basado en el principio “El Marcado debe ser bonito” del inglés Markup should be beautiful. Más no es simplemente por la belleza del código, sino para ser usado en ambientes altamente productivos (“La belleza lo hace más rápido”). HAML brinda una solución al problema del lento y repetitivo código de las plantillas. La segunda plantilla es llamada RXML, que permite la construcción de documentos XML usando código Ruby, siendo RJS la tercera plantilla permitiendo crear fragmentos JavaScript en el servidor para luego ser ejecutados en el navegador, está última es muy usada para crear vistas dinámicas con Ajax. Este soporte es muy flexible, pero en ocasiones puede violentar el patrón MVC. Embebiendo código en la vista se corre el riesgo de colocar código que debería estar en el modelo o el controlador, por lo que es labor del desarrollador prestar especial cuidado separando las labores de cada componente de la aplicación. � Controlador El controlador es quien orquesta la lógica de la aplicación, coordinando la interacción entre los usuarios, las vistas y el modelo. No obstante, Rails maneja internamente la mayoría de esta interacción facilitando el desarrollo y el mantenimiento de los controladores. Los controladores presentan un conjunto de servicios importantes, dentro de los cuales conseguimos: 61 • Enrutar peticiones externas hacia acciones internas, manejando URL`s sencillos. • Acelerar el proceso de respuesta manejando cache. • Manejar las sesiones. Gemas Según el sitio Web [RubyGems Manual (2007)], una gema es una aplicación Ruby empaquetada, o biblioteca de Ruby, que tiene un nombre y una versión definida. RubyGems es el nombre del proyecto que fue responsable del desarrollo de esta herramienta, su proceso de instalación es muy sencillo y se resume simplemente en descargar el paquete de un sitio Web en Internet y ejecutar el comando Ruby setup.rb cuando se está parado en el directorio de la descarga. Las gemas son manejadas en el ordenador usando el comando gem, permitiendo instalar, desinstalar y hacer búsquedas de paquetes o bibliotecas local o remotamente. Dicha herramienta funciona como un gestor de paquetes para Ruby, proporcionando un formato estándar y auto-contenido (gem) para distribuir programas o bibliotecas en Ruby, dando facilidades para manejar la instalación de los paquetes y su distribución. Es, por tanto, equivalente al papel que juegan CPAN y PEAR en los lenguajes Perl y PHP, respectivamente. 62 Características • Sencilla instalación y desinstalación de los paquetes y sus dependencias. • Manejo y control de paquetes locales. • Manejo de dependencias entre paquetes. • Buscar y listar paquetes locales y remotos. • Soporte para múltiples versiones de los paquetes instalados. • Interfaz Web para consultar la documentación de las gemas instaladas. • Interfaz sencilla para la construcción de paquetes. • Servidor sencillo para la distribución de paquetes. Comandos Básicos En esta sección se mencionarán los comandos más usados de la herramienta gem, dando una breve explicación de su funcionamiento. 1. Cuando se quiere buscar o listar simplemente basta con ejecutar: Ejemplo para listar Gemas: Gem query --remote #Atajo: gem q –R Tabla 11: Ejemplo Listar Gemas. Lo cual retornará una lista detallada de todas las gemas que se encuentran en el servidor remoto. Si se quiere depurar la lista y buscar una 63 gema específica basta simplemente con agregar la opción --name-matches y el nombre, ejemplo si queremos buscar un paquete llamado activerecord simplemente ejecutaríamos: Ejemplo para buscar Gema: gem query --remote --name-matches activerecord #Atajo: gem q -R -n activerecord Tabla 12: Ejemplo Buscar Gema. Esto retornará una lista de las gemas que coinciden con el nombre que fue especificado. 2. Si se desea instalar una nueva gema, simplemente se debe ejecutar el comando install seguido del nombre de la gema, por ejemplo si deseamos instalar un paquete llamado progressbar se debe ejecutar: Ejemplo para instalar una Gema: gem install --remote progressbar #Atajo: gem i -R progressbar Tabla 13: Ejemplo Instalar Gema. Finalmente para desinstalar una gema simplemente se ejecuta uninstall y el nombre de la gema, por ejemplo si se quisiera desinstalar la gema instalada en el comando anterior se ejecutaría: 64 Ejemplo para desinstalar una Gema: gem uninstall progressbar Tabla 14: Ejemplo Desinstalar Gema. Plugins Según [Wikipedia (2007)], un plugin (del inglés plug-in: “enchufar”, también conocido como addin o addon) es una aplicación informática que le aporta una función o utilidad específica a otra aplicación. Se utilizan como una forma de expandir programas de manera modular, permitiendo la inclusión de nuevas funcionalidades sin afectar a las ya existentes ni complicar el desarrollo del programa principal. Según [TDH (2006)], en Rails un plugin es una extensión o modificación del núcleo del framework y proveen: • Una forma de compartir ideas entre los desarrolladores, sin afectar el código base de cada proyecto. • Una arquitectura segmentada de manera que cada bloque de código pueda ser arreglado o modificado en el momento más conveniente. • Una ayuda para el núcleo de los desarrolladores, de modo que no estén obligados a incluir cada una de las nuevas características que día a día se van agregando en Rails, es decir, que al instalar Rails no se instalen todas las mejoras que existen sino que quede a potestad del programador si la necesita o no. 65 Comandos Básicos 1. Para buscar los repositorios (donde residen plugins) basta con ejecutar en la ruta de un proyecto: Buscar un repositorio de plugins: Rails script/plugin discover Tabla 15: Ejemplo para buscar un repositorio (Plugin). Mientras que para Windows (en todos los casos) se invierte la barra y se agrega el prefijo Ruby, es decir: Buscar un repositorio de plugins en Windows: Ruby script\plugin discover Tabla 16: Ejemplo para buscar un repositorio (Plugin/Windows). 2. Para agregar un repositorio de plugins, simplemente se ejecuta el comando source seguida de la URL donde se encuentra el repositorio, de esta forma: Agregar un repositorio de plugins: script/plugin source svn://Rubyforge.org/var/svn/expressica/plugins/ Tabla 17: Ejemplo para agregar un repositorio (Plugins). 66 3. Para quitar un repositorio: Quitar un repositorio de plugins: script/plugin unsource svn://Rubyforge.org/var/svn/expressica/plugins/ Tabla 18: Ejemplo para quitar un repositorio (Plugins). 4. Para instalar un plugin específico en un proyecto Rails, debemos navegar hasta la ruta del proyecto y ejecutar el comando install seguido del nombre del plugin (si se encuentra en un repositorio conocido) o del URL donde se aloja, ejemplo: Instalar un plugin en el proyecto: script/plugin install haml (si se tiene un repositorio con ese plugin incluido) ó script/plugin install svn://Rubyforge.org/var/svn/Telegraph/trunk (especificando el URL del plugin) Tabla 19 Ejemplo para Instalar un Plugin en el Proyecto. Se debe tener instalado subversion (SVN) y se debe cuidar el nombre del proyecto ya que si contiene espacios el proceso fallará. Se puede encontrar una diversidad de plugins para Rails disponibles para instalar en un proyecto, de los más utilizados en la actualidad tenemos: 67 � acts_as_rateable, plugin utilizado para asociarle un ranking a los modelos de ActiveRecord, indicador que puede usarse para realizar búsquedas, ordenamientos, entre otros. Este plugin se encuentra disponible en la siguiente URL: http://rateableplugin.Rubyforge.org � Acts as Authenticated, plugin utilizado para agregar restricciones de acceso a la aplicación de una manera sencilla. El plugin se encuentra disponible en la siguiente URL: http://technoweenie.stikipad.com/plugins/show/Acts+as+Authentic ated � RSpec on Rails, plugin que incluye las permite realizarle pruebas Spec al código de la aplicación. El plugin se encuentra disponible en la siguiente URL: http://rspec.Rubyforge.org Pruebas Según [Wikipedia (2007)], las pruebas de software son procesos que permiten verificar y revelar la calidad de una aplicación, de modo de identificar fallas o errores de implementación. Dichas Pruebas se integran dentro de las diferentes fases del ciclo de desarrollo del software. La calidad de un sistema es algo subjetivo que depende del contexto y del objeto que se pretenda conseguir. Para determinar dicho nivel de calidad se deben efectuar unas medidas o pruebas que permitan comprobar el grado de cumplimiento respecto a las especificaciones del sistema. 68 En el [RubyGems Manual (2007)] se plantea que las pruebas de software son colecciones de preguntas y escenarios que si devuelven un resultado consistente, se considera una aplicación que se responde según lo esperado. Informalmente hablando, las pruebas se escriben para interrogar y tantear una aplicación según un comportamiento esperado. Por ejemplo se podrían tener pruebas como: • Asegurar que un nombre tenga al menos 4 caracteres • Asegurar que el impuesto es del 9 % • Asegurar que al hacer una petición, el servidor despliegue la página correcta La idea de codificar las pruebas comprende agilizar y automatizar el proceso de desarrollo, ya que cada vez que crece una aplicación, probablemente se modifican clases existentes. Clases que funcionaban correctamente y quizá dejen de hacerlo. Anteriormente con las pruebas manuales se perdería mucho tiempo aplicándolas cada vez que haya una modificación, pero con las pruebas automatizadas, simplemente se vuelven a ejecutar después del cambio y verificar si se “rompió” algo en el camino. Existen diversos tipos de prueba, entre los cuales encontramos: • Pruebas unitarias • Pruebas funcionales • Pruebas de integración 69 • Pruebas de validación • Pruebas de sistema • Pruebas de caja blanca • Pruebas de caja negra • Pruebas de aceptación En el sitio Web [A Guide to Testing the Rails (2007)] se explica que al probar un código se tiene un porcentaje más elevado de certeza que se ha hecho un buen trabajo, brindándonos robustez, confiabilidad, minimizando los riesgos de fallos. Ésta última se considera una de las principales razones para aplicar pruebas al código. Además si se han codificado correctamente las pruebas, en cualquier iteración del desarrollo podemos saber: • Qué procesos funcionan correctamente. • Qué procesos presentan errores. • Qué efecto tiene la agregación de un nuevo módulo en la aplicación. Otra ventaja que nos brinda la codificación de pruebas es que a partir de allí se puede obtener la documentación del funcionamiento básico de la aplicación. Con estudiar los archivos de pruebas, se puede tener una idea del la labor que lleva un objeto en especial. Rails facilita la implementación de ciertos tipos de pruebas como las pruebas unitarias, pruebas funcionales y de integración. 70 La labor de las pruebas unitarias consiste en verificar el comportamiento de una clase a la vez, es decir que se encarga de probar cada método que se encuentra dentro de la clase que se está probando. En Rails Test::Unit es el módulo más conocido encargado de realizar las pruebas unitarias. Una prueba funcional es una prueba basada en la ejecución, revisión y retroalimentación de las funcionalidades, de allí su nombre, previamente diseñadas para el software. Las pruebas funcionales se hacen mediante el diseño de modelos de prueba que buscan evaluar cada una de las opciones con las que cuenta el paquete informático. En Rails las pruebas funcionales son utilizadas para realizar pruebas de controladores, verificar las interacciones de estos con las clases del Modelo. Test::Unit provee soporte para este tipo de pruebas. Finalmente, están las pruebas integrales o pruebas de integración, son aquellas que se realizan en el ámbito del desarrollo de software una vez que se han aprobado todas las pruebas unitarias de un módulo. Únicamente se refieren a la prueba o pruebas de todos los elementos unitarios que componen un proceso, hecha en conjunto, de una sola vez. En Rails las pruebas de integración fueron incluidas en la versión 1.1, pues su propósito recae en la verificación de las interacciones entre distintas acciones de la aplicación, a través de todos los controladores del sistema. Existe una técnica de programación orientada a pruebas llamada Test-Driven Development (TDD por sus siglas en inglés), que tiene su fundamento en la realización de los casos de pruebas que cubrirán las nuevas funcionalidades. Dichas 71 pruebas son codificadas al principio, escribiendo el código del requerimiento posterior a las pruebas. Esto garantiza que al finalizar la codificación el requerimiento, estos pasen las pruebas propuestas, tal como se señala en el sitio [Web Wikipedia (2007)]. En la actualidad se encuentra en auge una técnica que se considera una evolución sobre el TDD, llamada Behavior Driven Development (BDD por sus siglas en inglés). Según la página en Internet [Behaviour Driven Development (2007)], BDD consiste en el desarrollo de software realizando preguntas sobre el comportamiento de una aplicación antes y durante el proceso de desarrollo. El BDD direcciona los requerimientos y las especificaciones en un modo más textual, realizando preguntas como: “¿Qué debería llevar a cabo esta aplicación?” o “¿Qué labor debería realizar este modulo?” los desarrolladores son capaces de identificar fallos en su entendimiento del dominio del problema. Gracias a la técnica antes descrita, al enfocarnos en el comportamiento de las aplicaciones, se intenta crear un vocabulario común entre los integrantes de las distintas disciplinas en el proyecto. Entonces, busca minimizar los malos entendidos entre los expertos del dominio del problema y los expertos en tecnología tratando de resolver los requerimientos con una terminología clara y consistente. En el sitio Web [Behaviour Driven Development (2007)] se enfatiza que para verificar el comportamiento de una aplicación durante y después del proceso de desarrollo el código es sometido a pruebas de comportamiento. Dichas pruebas deberían responder e ilustrar el funcionamiento de la aplicación. 72 Por su parte, [Astels (2007)] destaca que la técnica contempla la codificación de especificaciones que describen el comportamiento en una forma clara, concisa, ejecutable y sin ambigüedades. Entonces en vez de escribir pruebas se plasman especificaciones sobre como el código debería comportarse. El sitio Web [RSpec Doc (2007)], refiere que en Ruby se puede implementar la técnica de la cual se viene hablando (BDD) de una forma sencilla, utilizando el framework Rspec, herramienta que le provee al programador un lenguaje específico de dominio para describir el comportamiento de un código Ruby a través de ejemplos ejecutables que sirven de guía en el proceso de desarrollo, documentación y pruebas de la aplicación. Esta herramienta también se puede incluir como un plugin en Rails para facilitar el uso a los programadores que quieren empezar a utilizarla. Un ejemplo de lo antes descrito es suponer que se está en conversación con un cliente sobre un desarrollo para un banco, donde un trozo de conversación podría ser: • Desarrollador: Describir una cuenta cuando es creada por primera vez. • Cliente: Debería tener saldo de 0 BsF. Traducido en Rspec podría ser algo como: Ejemplo de prueba RSPEC: describe Cuenta, " cuando es creada por primera vez" do it "debería tener saldo de 0 BsF" do ... end end Tabla 20: Ejemplo de Código RSPEC. Con este trozo de código se busca describir como se comporta una cuenta cuando se crea por primera vez en el sistema. El método devuelve un objeto de tipo 73 examplegroup, el cual no es más que un conjunto de ejemplos para simular un comportamiento particular de un sistema. En un ejemplo más completo se podría tener: Ejemplo completo de prueba RSPEC: describe Cuenta, " cuando es creada por primera vez" do before do @cuenta = Cuenta.new end it "debería tener saldo de 0 BsF" do @cuenta.saldo.should eql(0) end after do @cuenta = nil end end Tabla 21: Ejemplo 2 de Código RSPEC. En el ejemplo el método “it” devuelve un objeto de tipo ejemplo que representa un ejemplo del comportamiento que se desea describir. Mientras que los métodos “before” y “after” son utilizados para inicializar el estado de ciertos objetos antes que cada ejemplo sea ejecutado y liberar cualquier recurso después que cada ejemplo sea ejecutado, respectivamente. Cuando se ejecuta la especificación, se define el método should, el cual es encargado de la comparación de los objetos del sistema y le da sentido a la herramienta. Éste método junto a su opuesto (should_not), pueden tomar como parámetro una expresión a evaluar, llamada Expression Matcher. Durante la ejecución de esta función se realiza un llamado al método “matches?”, que es quién realiza la comparación a bajo nivel. Si este último devuelve verdadero, el ejemplo pasa y la ejecución continúa, pero si devuelve falso, el ejemplo falla, especificando un 74 mensaje de error retornado por matcher.failure_message. En el sitio Web [Rspec (2007)] se explica que Rspec también brinda soporte para la creación de Mocks y/o Stubs, objetos que son utilizados para simular el comportamiento de cualquier objeto real que pudiera interactuar en un momento dado con la aplicación. Estos objetos son muy utilizados por los desarrolladores cuando la aplicación interactúa con un sistema externo que no se tiene a disposición, pero su comportamiento es conocido. Los Mocks y los Stubs son similares, pero hay una diferencia semántica a la hora de su creación. Conectividad Rails - Asterisk Adhearsion Adhearsion es un framework que fue escrito en Ruby, de código abierto, cuyo propósito reside en facilitar la unión o conexión entre distintas tecnologías. Dicho framework integra uno de los principales PBXs de la actualidad como lo es Asterisk, con Ruby a través de las interfaces AMI y AGI como se explicó en el segundo capítulo, especialmente orientado a la escritura de aplicaciones con la interfaz AGI. Este framework fue diseñado para entender de manera sencilla los elementos de VoIP, mejorándolos e integrándolos en una solución coherente. Alguna de las tareas que son mejoradas con el uso del framework son: • Escribir instrucciones que procesan llamadas • Funcionalidades VoIP 75 • Colaboración con tecnologías más allá de VoIP • Integración de bases de datos para aplicaciones de VoIP • Integración con funcionalidades internas de Asterisk Adhearsion facilita a los programadores el diseño e implementación de aplicaciones aún sin haber tenido experiencia trabajando con tecnologías de VoIP, con un uso intuitivo y permitiendo descargar alguna solución pre-hecha e implantarla. Con la arquitectura extendida del framework, las funcionalidades de VoIP se pueden masificar con facilidad por su sencillez en la implementación. Adhearsion posee una cantidad de extensiones que pueden ser usadas de manera sencilla, brindando funcionalidades adicionales como integración con mensajería instantánea (Jabber/XMPP), en servidor para controlar el PBX de forma remota, entre otras. Todo esto en cualquier parte del framework, ya que Adhearsion “adhiere” estas tecnologías entre sí, que comprende una de las funcionalidades fundamentales de Adhearsion, inclusive es sencillo integrar extensiones propias del programador. Además el framework incluye un amplio conjunto de características, funcionalidades más implementadas por cada una de las aplicaciones de esta área. Una de las grandes ventajas de Adhearsion, es su integración y asociación con las bases de datos relacionales, ya que se basa en la relación de objetos y base de datos que fue desarrollado para Ruby on Rails. Valiéndose de esto, es muy sencillo integrar VoIP con una base de datos, donde una tabla en la base de datos llamada “usuarios”, se asocia con el objeto “Usuario” y cada columna de la tabla es una propiedad representativa del objeto, tal como se comentó en el capítulo anterior. 76 También se basa en el mismo principio que Rails al aplicar DRY (Don't Repeat Yourself), mencionado en el capítulo anterior. Adhearsion emplea un lenguaje de dominio específico orientado hacia VoIP, sin dejar de ser código Ruby completamente válido. Por ejemplo en un plan de llamado se tiene acceso a variables preestablecidas tales como “extension” o “callerid” (correspondientes a la extensión e identificador de llamada respectivamente) para cada llamada. Para acceder a las variables de bajo nivel propias de Asterisk, se tiene el objeto “PBX”, que envuelve la idea física del PBX. Entonces por ejemplo se puede hacer llamados a variables propias de Asterisk como lo es sip_users de esta forma: PBX.sip_users, que retorna información desde Asterisk. Esta comprende una de las grandes virtudes de este framework, ya que en el ejemplo ni siquiera se necesitaba información del uso apropiado de la interfaz con Asterisk (AMI), explicada en capítulos anteriores, sino que lo hace transparentemente para el programador, de forma de facilitarle la labor que se lleva a cabo a bajo nivel. Al igual que Ruby, Adhearsion buscan mejorar la productividad de los programadores permitiéndole realizar aplicaciones de manera rápida y sencilla. Actualmente Adhearsion es un software en versión beta, lo que en parte constituye una de sus desventajas, puesto que para llevar una aplicación a producción con Adhearsion, se deben hacer un conjunto adecuado de pruebas, pero el proyecto tiene su sistema de reporte de errores, lo que promueve que cada día sea más robusto y eficaz, incentivando al usuario a reportar y ayudar con errores que pudiera tener el framework. 77 Instalación y Uso Al igual que la mayoría de los otros proyectos de Ruby, Adhearsion usa el manejador de paquetes RubyGems, esto reduce el proceso de instalación del framework a la ejecución de un simple comando gem install, simplificando el tradicional des-empaquetamiento, posibilidad que se puede usar si no se instala RubyGems. Entonces se ejecutaría: Instalación Adhearsion: gem install Adhearsion --include-dependencies Tabla 22: Instalación Adhearsion. Con este comando además de la instalación del framework , RubyGems crea el comando ahn, comando de Adhearsion que permite crear nuevos proyectos para Adhearsion. También da la oportunidad de ejecutar el framework, instalar extensiones para Adhearsion, leer la documentación, entre otros. Para entender un poco más el funcionamiento de la integración Asterisk- Adhearsion, cuando llega a una llamada al servidor Asterisk, éste actúa como una especie de núcleo a bajo nivel para la llamada que transfiere el flujo a Adhearsion que se encarga de la lógica que se le va a aplicar a la llamada, entre las acciones que se pueden tomas tenemos: transferir la llamada, reproducir un mensaje, persistir información, entre otra gama de posibilidades. Esto lo logra estableciendo desde Asterisk una conexión TCP (por la cual se comunican) a un proceso de Adhearsion que ejecuta comandos y devuelve una respuesta con la acción. 78 Para establecer la comunicación entre Asterisk y Adhearsion solo hace falta un mínimo de configuración en Asterisk, una entrada en el archivo de configuración de las extensiones de usuarios, llamado extensions.conf. Por ejemplos si los usuarios se encuentran asociados con el contexto por defecto llamado “internal”, se modificaría de la siguiente forma: Para la comunicación Adhearsion y Asterisk: [internal] exten => _X.,1,AGI(agi://192.168.1.1) Tabla 23: Comunicación Adhearsion/Asterisk. • La primera línea indica el contexto, en este caso llamado “internal”. • En la línea siguiente encontramos la instrucción “exten=>”, comando requerido como prefijo a cada instrucción de llamada en enxtensions.conf. • Los caracteres “_X.” comprenden la expresión que denota la secuencia de números a ser capturados. Donde el carácter “_” indica que es un patrón en vez de ser un conjunto estático y la “X” representa cualquier número (0-9) mientras que el punto (“.”) indica que cualquier cantidad de repeticiones. Lo que en conjunto representa “el patrón de cualquier número con cualquier cantidad de repeticiones”. Entonces en este contexto cualquier número que sea procesado es redireccionado a Adhearsion. • Después de la coma aparece un número que indica la prioridad de la instrucción. • Finalmente, después de la segunda coma, tenemos la instrucción que se va a ejecutar que en este caso tenemos el comando AGI con un parámetro 79 “agi://192.168.1.1” indicando que otra aplicación va a procesar la llamada, y el parámetro es el URI que le indica a Asterisk que busque la IP especificada para ejecutar la aplicación, por lo que se debe colocar la IP donde se encuentra Adhearsion en ejecución (No es recomendado usar nombres de máquinas sino su IP). El siguiente paso es crear un nuevo proyecto de Adhearsion, por ejemplo: Nuevo Proyecto de Adhearsion: ahn create prueba Tabla 24: Nuevo Proyecto Adhearsion. Esto creará un nuevo proyecto que tendrá una estructura como: config/ extensions.rb helpers/ LICENSE logs/ Rakefile • La carpeta config es donde reside la configuración de la aplicación Adhearsion, incluyendo cualquier extensión del framework que se haya instalado. • El archivo extensions.rb es donde residen los planes de marcado (“dialplans”), más adelante se verá un ejemplo. • La carpeta helpers contiene todas las extensiones instaladas para la aplicación específica en la que se haya instalado. Dichas extensiones agregan funcionalidades útiles a la aplicación, pueden ser instaladas y/o desintaladas. El código fuente se encuentra en esta ruta en caso que se 80 necesiten modificar. • El archivo LICENSE contiene una copia de la licencia (GPL v2) por la cual se rige Adhearsion. • La carpeta logs contiene la bitácora de la aplicación. • Finalmente el Rakefile es el archivo del “rake”. Rake es un comando Ruby que automatiza ciertas tareas. Para arrancar la aplicación Adhearsion solo se debe ejecutar el comando ahn start con la ruta donde se encuenta el proyecto, por ejemplo: Nuevo Proyecto de Adhearsion: ahn start /prueba Tabla 25: Arrancar Adhearsion. Dialplans Finalmente se va a discutir sobre el código en si que se ejecuta cuando la aplicación es puesta en marcha y es pasado el procesamiento a Adhearsion. Como se comentó, el código va ubicado en el archivo extensions.rb que se encuentra en la ruta config en el proyecto de Adhearsion. Tradicionalmente los programadores podían enrutar llamadas en Asterisk de dos formas, la primera modificando directamente el archivo de configuración de Asterisk extensions.conf o escribiendo una aplicación aparte en un lenguaje de 81 scripting y usar el AGI para la comunicación. Un ejemplo sencillo de un plan de marcado o dialplan en Adhearsion podría verse algo como: Ejemplo de dialplan de Adhearsion: # File extensions.rb internal { case extension when 101...200 employee = User.find_by_extension extension dial employee voicemail when 888 play weather_report("Dallas Texas") end } Tabla 26: Ejemplo Dialplan de Adhearsion. El código esta escrito en lenguaje Ruby. Los fundamentos de Ruby permiten la modificación en el funcionamiento del lenguaje, convirtiéndose en un lenguaje particular según la necesidad, sin perder los beneficios del lenguaje Base (Ruby). En el ejemplo mostrado anteriormente Adhearsion relaciona directamente por convención el flujo del contexto llamado “internal” que como se explicó debe haber sido configurado en el archivo extensions.conf de Asterisk. Estudiando el código notamos la flexibilidad de Ruby con respecto a los rangos ya que se tiene un case con una condición de un rango entre 101 y 200 sin complicaciones. En la próxima línea se nota la convención con respecto a los objetos de la base de datos, ejecutando una consulta normal. Infiriendo que hay una colección de usuarios y extensiones. 82 También se observa la sencillez, que es uno de los factores de la creación de este framework. Finalmente tenemos una gama de funcionalidades de Adhearsion que nos simplifica el trabajo, como lo son la función dial para realizar una llamada a una extensión, voicemail para activar el contestador automático y play para reproducir sonidos. Existen otros métodos que se pueden usar a la hora de codificar un dialplan. Telegraph Telegraph es un plugin de Rails de código abierto, escrito en Ruby que permite la utilización de forma sencilla de las interfaces AGI y AMI de Asterisk. Funciona como un puente entre Rails y Asterisk, aprovechando la sencillez de Rails combinándolo con voz sobre IP (VoIP). Telegraph extiende el API de Asterisk, permitiendo el desarrollo de aplicaciones Web basadas VoIP de una forma rápida y sencilla al estilo de Rails usando el patrón MVC. Entre sus características más importantes tenemos: • La integración de funciones de la interfaz AGI en un controlador cualquiera de Rails. • Un modelo para el acceso a la interfaz AMI de Asterisk con funciones sencillas. • Soporte para recibir los eventos AMI. • Servidor proxy AMI que se comunica directamente con Asterisk. 83 Las aplicaciones hechas en Telegraph son sencillas de desarrollar, producir y mantener además de ser hechas en una forma robusta y escalable, ya que son realizadas bajo la filosofía de Rails. Telegraph maneja los comandos AMI de la aplicación a través de un proceso independiente (Drb), biblioteca Ruby utilizada para invocar objetos remotos, tal como se ejecutan en Java RMI y/o CORBA. Telegraph fue inspirado en centros de llamados distribuidos complejos, que existen realmente y su código es basado en un proyecto llamado RAGI y otros proyectos Ruby-AMI. Instalación y Uso La instalación es muy simple, ya que por ser un plugin lo único que se necesita es instalarlo en un proyecto Rails. Tal como se explicó en el capítulo anterior, basta con ejecutar un comando en la ruta del proyecto al que se quiere agregar, por ejemplo: Instalación de Telegraph: script/plugin install svn://Rubyforge.org/var/svn/Telegraph/trunk Tabla 27: Instalación Telegraph. Luego se debe definir que funcionalidad de Telegraph se va a implantar, como ya se comentó Telegraph soporta las dos grandes vertientes de comunicación de Asterisk con aplicaciones externas, que son las interfaces AGI y AMI, además brinda 84 soporte para los AMI Eventos o eventos AMI generados por Asterisk. � AGI Al igual que Adhearsion brinda soporte para la integración con Asterisk a través de la interfaz AGI de manera sencilla, de modo de crear una aplicación donde se quiere controlar el flujo de llamadas entrantes (IVR). Pero en vez de escribir largos dialplans, la meta es desarrollar aplicaciones similares a las aplicaciones Web basadas en MVC, de modo que al momento de redireccionar el flujo de una llamada, con Telegraph direccionamos de un controlador a una “voz”, que es la analogía de una “vista” en el MVC tal como lo hacemos en una aplicación Web. De esta forma se puede integrar en el mismo código la lógica de la aplicación Web y la lógica de la aplicación basada en voz. La petición AGI se comporta igual que las peticiones estándares de Rails, se diferencian cuando se va a mostrar la “vista”, ya que se debe capturar un objeto especial de voz (tipo MIME) que usa el API de Telegraph para mostrar la data aprovechando las ventajas de Rails durante el camino. Para lograr la comunicación entre Asterisk y la aplicación, se realiza un mínimo de configuración en Asterisk de modo que envíe la petición a través de la interfaz. De modo que se agrega una entrada en el archivo de configuración extensions.conf de Asterisk según el contexto, al igual que en el ejemplo con Adhearsion, supongamos que existe un contexto llamado “internal”, debemos colocar algo como: 85 Comunicación de Telegraph y Asterisk a través de AGI: [internal] exten => _X.,1,AGI(agi://192.168.1.1/controlador/index) Tabla 28: Comunicación Telegraph/Asterisk, AGI. El significado de las entradas son exactamente los mismos explicados en la sección anterior, por lo que se pasará directamente a un ejemplo práctico de la manipulación del flujo de una llamada, supongamos que queremos redireccionar una llamada a un archivo de sonido llamado “atender”, simplemente se debe tener un controlador parecido al siguiente código Rails: Ejemplo dialplan de Telegraph AGI: class ControladorController < ApplicationController def index respond_to do |ayuda| ayuda.html { render } ayuda.voice { render_voice do |voice| voice.play_sound "atender" end } end end end ) Tabla 29: Ejemplo Dialplan Telegraph AGI En principio se instancia el bloque respond_to para capturar el objeto de voz (tipo MIME), luego añadimos un “helper” para la voz (ayuda.voz). Seguidamente se llama al la función render_voice propia de Telegraph, junto a un bloque. Dentro de ese bloque insertamos el código de la “vista” o la “voz”, usando el lenguaje específico de dominio de Telegraph, en este caso el bloque simplemente llama a la 86 función “play”, para reproducir un archivo. � AMI Esta interfaz se debe usar cuando se quiere entablar una comunicación asíncrona con Asterisk, enviándole peticiones de acciones a realizar en Asterisk, por ejemplo iniciar una llamada saliente, conocer el estado de las llamadas en curso y otra gama de peticiones que se pueden realizar. AMI (Asterisk Manager Interface) como se mencionó en capítulos anteriores es una de las formas que tiene Asterisk de interacción con aplicaciones externas. Interfaz que permite realizar distinto tipo de consultas y comandos, tales como: • Consultar el estatus de algún dispositivo. • Modificación de parámetros en una llamada saliente. • Eventos de estatus hacia las aplicaciones, soportado en Telegraph por los eventos AMI. El API que provee el plugin es robusto, escondiendo la complejidad de bajo nivel de enviar, recibir y “parsear” métodos AMI tras un modelo de uso sencillo escrito en Ruby. Los métodos AMI realizan cuatro trabajos fundamentales: obtener información, crear objetos, actualizar objetos y borrar o destruir objetos. Como se mencionó en el capítulo anterior estas son las cuatro acciones básicas de los registros (CRUD). El modelo es accesible en cualquier parte de la aplicación Web. 87 Para empezar a usar la interfaz primero se debe crear el modelo del que se ha venido hablando, para eso se debería ejecutar en la ruta del proyecto el siguiente comando: Empezando con Telegraph AMI: script/generate ami_model MiModelo Tabla 30: Empezando Telegraph/AMI. En el ejemplo script/generate es un comando para la generación automática de código en Rails, con ami_model se especifica que se quiere generar el modelo AMI y finalmente “MiModelo” que es el nombre del modelo a generar. Luego se le debe indicar al proyecto de Rails que se debe conectar con Asterisk en el archivo de configuración del proyecto confit/enviroment.rb, se debe colocar una entrada como: Conexión de Telegraph y Rails AMI: Telegraph::AMIManager.establish_connection!(:host=> '192.168.1.1', :username=>'usuario', :secret=>'contraseña') Tabla 31: Conexión Telegraph/Rails AMI. Para llevar a cabo la acción explicada se debe tener configurado en Asterisk un nombre de usuario y una contraseña en el archivo manager.conf tal como se ilustró en el capítulo de Asterisk. En este ejemplo Telegraph::AMIManager.establish_connection! es la función de Telegraph encargada de realizar la conexión, seguida de una lista de parámetros. El primero es host, que indica el nombre o IP de la máquina a la que se quiere conectar, 88 luego se especifica el nombre de usuario y la contraseña (username y secret respectivamente) que corresponden a las entradas que se deben tener en el manager.conf de Asterisk. Finalmente se debe ejecutar el comando que inicia el servidor que funciona como puente entre la aplicación Rails y Asterisk: Iniciar servidor AMI en Telegraph: script/ami_server Tabla 32: Iniciar Servidor AMI/Telegraph. En este momento ya se tiene conectado Rails y Asterisk a través de la interfaz AMI. Como se comentó anteriormente, las funciones AMI de Telegraph se basan en el concepto CRUD al igual que Rails, entonces la invocación de métodos es similar a los de Rails, usando el modelo AMI. Luego se especifica una lista de parámetros, siendo el primero la operación que se quiere realizar en Asterisk, por ejemplo: Ejemplo comandos de Telegraph AMI: estatus = MiModelo.find(:sip_peer, :peer=>'SIP/usuario_prueba') Lista_estatus = MiModelo.find(:all_sip_peers) MiModelo.create(:call,:channel=>'SIP/usuario_prueba', :context=>'internal', :exten => 'xxxx', :priority=>1) Tabla 33: Ejemplo Comandos Telegraph AMI. En estos ejemplos se puede ver que comprende un modelo estático con el mismo nombre con el que fue generado, seguido de un método de la clase con su lista de parámetros. En el primero se llama a la función find (obtener), especificando como operación sip_show_peer de AMI y como último parámetro sobre quien se desea 89 hacer la consulta. El segundo ejemplo solo tiene 1 parámetro que indica que se va a llamar a una operación de AMI sin parámetros (all_sip_peers), esta operación devuelve una lista de todas las extensiones existentes en Asterisk. En el último ejemplo se llama a la función create (crear) y como primer parámetro call especificando un canal (channel), contexto (context), extensión (exten) y prioridad (priority), esta función de Asterisk inicia una llamada nueva por el canal dado usando el contexto y la prioridad especificados hacia un número que recibe en el parámetro exten. Las funciones AMI dependiendo del tipo retornan propiedades o eventos, las propiedades se pueden acceder directamente, mientas que los eventos vienen en un arreglo llamado events. En base a los ejemplos anteriores es válido: Ejemplo parámetros de funciones AMI en Telegraph: estatus.sip_user_agent Lista_estatus.events.each[:status] Tabla 34: Ejemplo Funciones AMI Telegraph. A continuación se va a presentar una lista de las funciones AMI más usadas en Telegraph junto con sus parámetros y la función que es activada en Asterisk Find: Operación Telegraph Parámetros Función AMI :extension_state :context, :exten extension_state 90 :variable :channel, :variable get_variable :all_iax_peers - iax_peers :queue - queue_status :sip_peer :peer sip_show_peer :all_sip_peers - sip_peers :status :channel status Tabla 35: Métodos Telegraph para consultas. Update: Operación Telegraph Parámetros Función AMI :redirect :channel, :context, :exten, :priority redirect :variable :channel, :variable, :value setvar Tabla 36: Métodos Telegraph para actualizaciones. Create: Operación Telegraph Parámetros Función AMI :monitor :channel, :file, :format, :mix monitor :call :channel, :context, :exten, :priority, :async (Entre otros opcionales) orginiate Tabla 37: Métodos Telegraph para crear. Destroy: 91 Operación Telegraph Parámetros Función AMI :monitor :channel stopmonitor :call :channel Hangup Tabla 38: Métodos Telegraph para borrar. � Eventos AMI Los eventos AMI son los distintos cambios de estado que se envían a través de la interfaz AMI. En Telegraph se puede configurar un proceso Rails específico que escucha dichos eventos para realizar distintas acciones. En el plugin, la interfaz para eventos AMI es usada cuando se quiere ejecutar una lógica específica cuando se produce un cambio por el PBX, eventos tales como el ingreso de un nuevo dispositivo al sistema, una nueva llamada exitosa, entre otros. Los eventos AMI no son recibidos directamente en la propia aplicación Web. Al ejecutar el comando de generación automática de código para los eventos AMI en Telegraph, se crea una carpeta dentro de la ruta del proyecto con un archivo llamado ami_logic.rb. Dicho comando se debe ejecutar en la ruta del proyecto Rails, tal como: 92 Empezando con Telegraph Eventos AMI: script/generate ami_logic Tabla 39: Empezando Telegraph Eventos AMI. Después de la ejecución se creará la carpeta “app/ami_logic”. Entonces al momento que Asterisk envíe un evento, Telegraph escuchará y ejecutará un método con el mismo nombre que se encuentre dentro del archivo app/ami_logic.rb junto con cualquier parámetro que acarree de Asterisk. Estos últimos son colocados en una lista de parámetros que pueden ser accedidos en dichos métodos. Para iniciar el proceso encargado de escuchar los eventos enviados por Asterisk y asociarlo con el método correspondiente en el ami_logic, se debe ejecutar: Iniciar servidor de Eventos AMI en Telegraph: script/ami_events Tabla 40: Iniciar Servidor Eventos AMI Telegraph. En el siguiente ejemplo del archivo ami_logic.rb podemos encontrar los eventos de mayor utilidad: Funciones que capturan Eventos AMI en Telegraph: class AmiLogic < Telegraph::AMIHandler def peer_status # Método llamado cuando el estatus de un dispositivo # registrado en el sistema cambia # Los parámetros son :peer, :peer_status # El parámetro peer_status puede tener uno de los # siguientes valores: # (Registered, Unregistered, Reachable, Unreachable) estado = params[:peer_status] quien = params[:peer] p “Status de #{quien} : #{estado}” 93 end def link # Función llamada cuando 2 canales son conectados con # éxito. # Los parámetros son :channel1, :channel2 canal1 = params[:channel1] canal2 = params[:channel2] p “Llamada activa!” end def extension_status # Funcion que se dispara cuando existe un cambio de estado # en alguna extension de Asterisk # Tiene un parámetro que indica la extensión que cambia de # estado :exten y otro que indica el estatus :status #STATUS POSIBLES # 0: Disponible / inactiva # 1: Disponible / activa o llamando # 4: No Disponible # 8: Disponible / sonando extension = params[:exten] estado = params[:status] p “La extensión: #{extension} tiene el estado : #{estado}” end end Tabla 41: Funciones Eventos AMI. Dentro de cada método se puede tener una lógica tan simple como la mostrada o tan compleja que llame a otro método AMI, cambio en la base de datos, entre otras acciones que se pudieran realizarse a nivel de programación. 94 Comparación Adhearsion - Telegraph En las secciones anteriores se ha venido hablando sobre dos herramientas cuyo objetivo es facilitar la comunicación entre el PBX por software Asterisk y aplicaciones externas utilizando las interfaces AGI y AMI. En esta sección se va a realizar una breve comparación entre las herramientas. En primer lugar se observa que el núcleo de las herramientas es similar, ya que ambas se encuentran desarrolladas en el lenguaje de programación Ruby y distribuidas bajo el paradigma de código abierto de la GNU, pero una de las grandes diferencias es que por concepción son distintos, siendo Adhearsión un framework y Telegraph un plugin. Esto no hace a Adhearsion mejor que Telegraph ni viceversa, pero influye a la hora de decidir cual de las herramientas se va a usar en el proyecto, ya que dependiendo de la orientación de la aplicación VoIP que se desea desarrollar, conviene más una herramienta sobre la otra. A pesar de que la madurez de Adhearsion es escasa, inclusive los creadores recomiendan probarlo exhaustivamente antes de llevar un sistema a producción con el framework; Telegraph no tiene más tiempo en distribución que Adhearsion, por lo que no es un indicador de mucho peso. Aunque sobre este aspecto se puede afirmar que Adhearsion ya es un framework con un poco de uso mientras que Telegraph es un plugin que está empezando a crecer por lo que hay mas probabilidades de fallo con este último. 95 Un plugin es fácil de manejar en un proyecto que un framework que te crea un proyecto propio. Una de las razones de ésta afirmación comprenden los cambios que se deseen hacer sobre el código fuente bien sea por adaptación o corrección de errores, ya que es más sencillo realizarlo a un plugin que a un framework. Esto es considerado importante, más aún tomando en cuenta lo comentado anteriormente sobre la madurez de las herramientas, ya que las primeras versiones de cualquier software tiene a presentar más fallos que las que tienen tiempo distribuyéndose. Por otro lado con los plugins no se puede empezar una aplicación desde cero, sino que tiene que estar asociados a un proyecto, esto dependiendo de la aplicación a desarrollar puede ser beneficioso o no. Las tecnologías difieren en la forma como se integran. Con Adhearsion se debe realizar un proyecto nuevo propio de la herramienta, mientras que Telegraph se adapta a un proyecto Rails, lo cual requiere pensar si el objetivo es integrar VoIP con Web o si solo se quiere una aplicación VoIP. Uno de los aspectos más importantes es el uso para el cual se encuentra orientada la herramienta depende mucho de la interfaz por la cual se comunica con Asterisk (AGI/AMI). A pesar que ambas herramientas brindan soporte para ambas interfaces, Telegraph brindando un valor agregado con el soporte para los eventos AMI, en base a lo expuesto en este capítulo de Adhearsion, podemos afirmar que es una herramienta orientada hacia el uso de la interfaz AGI. Diseñado para la facilitación de la implementación de IVR's, que manipulan el flujo de llamadas que se reciben, procesando información de una llamada recibida. De Telegraph no se puede afirmar lo mismo, ya que no tiene una tendencia tan marcada como Adhearsion, lo que si se puede afirmar es el amplio soporte para la interfaz AMI, manejándose de 96 manera sencilla, incluyendo los eventos que se disparan en Asterisk. En la siguiente tabla se aprecian algunas diferencias y semejanzas entre las dos herramientas en aspectos que se deben tomar en cuenta a la hora de elegir cuál usar para un proyecto específico: Propiedad Adhearsion Telegraph Lenguaje Código Fuente Ruby Ruby Licencia Código abierto (GPL) Código abierto (GPL) Distribuido como Framework Plugin Instalación RubyGems Svn – Plugin Install Interfaz Soporte AGI – AMI AGI - AMI - AMI Events Orientado a Interfaz AGI AMI Soporte para desarrolladores Reporte de errores / Foros Lista de correo / Foros Conectividad Ruby - Asterisk Rails – Asterisk Tabla 42: Cuadro comparativo Adhearsion - Telegraph. 97 CAPÍTULO III MARCO APLICATIVO En este capítulo se describirá el ámbito aplicativo de la presente investigación, plasmando los requerimientos generales del cliente y el proceso de desarrollo de los componentes de la aplicación y su adaptación a la metodología aplicada, en este caso Programación Extrema (XP, por sus siglas en inglés). Luego se mostrará la visión general de los componentes de software que fueron desarrollados para el proyecto, explicando detalladamente la utilización de las herramientas, lenguajes y frameworks que se utilizaron. Finalmente se explica la adaptación del proceso de desarrollo (XP) y sus prácticas, llevadas al desarrollo del proyecto, en cada una de sus iteraciones o fases. Requerimientos Generales A gran escala, el proyecto busca automatizar el proceso de mercadeo de productos y servicios empresariales vía telefónica. El proceso de llamado, consistió primordialmente en la recuperación de un 98 número telefónico de un repositorio de datos, junto con cierta información personal del posible cliente, donde dicho número sea discado desde el PBX y pasado a la extensión desde donde se realiza la petición. Además de ese proceso, se requiere realizar manipulaciones adicionales a dicha llamada, que serían: • Supervisión: proceso en el que una extensión del PBX tiene la posibilidad de escuchar el diálogo de una llamada en curso, realizada desde otra extensión de la central telefónica. • Transferencia: proceso en el que el se transfiere una llamada en curso desde una extensión a otra de la central telefónica. Cabe destacar que se desea conocer en todo momento el estatus de las llamadas y extensiones de la central telefónica, desde la aplicación. Se requieren distintos perfiles en la aplicación, entre los cuales tenemos: • Operador: usuario encargado únicamente de la realización de llamadas a los potenciales clientes. • Supervisor: usuario encargado de monitorear el estatus de las llamadas hechas por operadores, capaz de supervisar llamadas en curso, con la posibilidad de transferirlas a su extensión. • Validador: usuario capaz de introducir y validar un nuevo número telefónico y los datos de un potencial cliente. • Administrador: usuario encargado de la gestión y supervisión de todo el sistema. Pudiendo ver las estadísticas de ventas, ingresar nuevos usuarios al sistema y capaz de realizar labores de los perfiles del validador y supervisor, entre otras funciones. 99 Se requiere automatizar el proceso de carga de posibles clientes en el sistema. Adaptación del Proceso de Desarrollo XP Como se mencionó en el segundo capítulo de la investigación, el proceso de desarrollo XP es ligero y capaz de manejar los requerimientos cambiantes del cliente, teniéndolo bastante involucrado con el desarrollo. En esta sección se ilustrará la adaptación del proceso de desarrollo de la programación extrema en la presente investigación. El proceso de desarrollo de software XP está basado en entregas e iteraciones. Se dividió el proyecto en 4 iteraciones, con un tiempo aproximado de 4 a 5 semanas por iteración. En cada iteración se aplicarán las siguientes prácticas: Planificación Dado que en esta investigación el producto se desarrolló a través de un tercero y no del usuario final de la aplicación, no se realizaron historias de usuario como define la metodología XP en sus prácticas. Sin embargo, se definieron requerimientos a ser desarrollados en cada iteración. 100 Diseño En el diseño se realizará la definición de clases involucradas en la implementación de los requerimientos de la iteración. Valiéndose de la modelación ágil, se anexarán diagramas, utilizando la notación de UML, que permitan visualizar con mayor claridad la interacción entre dichas clases. Codificación En cada iteración se realizó el código fuente que dió solución a los requerimientos establecidos por el cliente en cada etapa del proceso de desarrollo. Dado que este proyecto fue realizado por una sola persona, no fue posible la aplicación de la práctica de programación en pareja. Pruebas El desarrollo del proyecto se basó en la técnica BDD (Behavior Driven Development), que propone la escritura de pruebas de comportamiento para el desarrollo de una aplicación, inclusive hace hincapié que dichas pruebas deberían ser definidas antes de implementar los requerimientos. Además explica que el uso de la técnica, implica la automatización de las pruebas. Al final de cada iteración se realizaron pruebas de aceptación de parte del cliente. En cada iteración se anexará el código fuente de las pruebas codificadas. Para la adaptación de las pruebas de comportamientos en Rails se utilizó un plugin llamado rspec que facilita la escritura de las mismas, según señala RSpec Doc (2007). 101 Para las pruebas que involucraban interacción con entes externos se utilizaron herramientas como Mocks y Stubs, destacadas en la Web RSpec Doc (2007), ya que simulan o imitan el comportamiento de esos entes, permitiendo la realización de las pruebas sin la necesidad de interactuar con los sistemas externos. Feedback Esta fase no pertenece a la metodología XP, más se cree conveniente presentar los resultados obtenidos de cada iteración, reflejando los aspectos que requieran de una refactorización en iteraciones posteriores. Desarrollo de la Aplicación Metáfora del Sistema El sistema está compuesto por dos piezas principales y dos entes externos que interactúan con él, brindandole servicios para lograr el objetivo final que implica el desarrollo de una aplicación Web/VoIP. Las piezas de la aplicación comprenden en principio un módulo que maneja la conexión hacia la central telefónica usando el plugin de Rails: Telegraph y el resto de la lógica de la aplicación comprende la segunda pieza, esta última desarrollada con el framework Web Ruby on Rails. 102 Con respecto a los entes externos, tenemos al manejador de base de datos MySQL, que fue utilizado para la persistencia de los datos en la aplicación y Asterisk es la otra herramienta en cuestión que desempeñó un papel fundamental en la investigación, ya que suministró la capa de servicios en el ámbito telefónico (VoIP), siendo el PBX que estuvo en constante comunicación con la aplicación Web. Siendo el fin último del proyecto la automatización del proceso de mercadeo de productos y servicios empresariales vía telefónica, resultó de gran utilidad la interconexión entre Rails y Asterisk, ya que la idea era automatizar el proceso de llamado, realizandose directamente desde un browser al accionar un botón. Un softphone es un software que hace una simulación de teléfono convencional a través de la computadora, es decir, que permite utilizarla para hacer llamadas a otros dispositivos telefónicos. De tal modo, que la aplicación se encargue de solicitarle la realización de una nueva llamada al PBX Asterisk hacia el destinatario correspondiente. Llamada que luego es transferida al softphone que tiene asignada la extensión del usuario que ejecutó la orden, más no es necesario que conteste la llamada ni conozca la existencia del softphone, ya que el software está configurado para que la llamada se contesta automáticamente. Por su parte, para lograr la comunicación entre la aplicación Web y Asterisk, utilizando la herramienta Telegraph, fue necesaria la ejecución de procesos Ruby (drb) responsables de recibir y/o enviar los datos al PBX. Específicamente, a través de Telegraph se inician dos procesos, el primero de ellos para comunicar la aplicación 103 Web con la interfaz AMI de Asterisk; mientras que el segundo se encarga de recibir los eventos AMI asíncronos que difunde el PBX y ejecutar el método específico para el evento generado. A continuación se mostrará gráficamente el funcionamiento general de la aplicación: Aplicac ión Web - VoIP Módulo de Inte rcone xión Central Telefónica (PBX) Repos itorio de Datos Consultas Utiliza Comandos Aplica ción We b Operador AMI AMI Events AMI drb`s Eventos asíncronos Validador Administrador Supervisor Browser S oftphone S oftphone Browser Browser Browser Red pública Llamada Clie nte Gráfico 6: Metáfora del Sistema. Fuente: Autor 104 Iteración 0 En la iteración 0 se definió la planificación general de todo el proceso de desarrollo de los componentes de software que se realizaron en la investigación. Planificación A continuación se muestran la lista de requerimientos generales que guiaron el desarrollo de los componentes de software: 1. Establecer comunicación efectiva entre el PBX Asterisk y el framework Rails. 2. Implementación de un módulo encargado de manejar el proceso de llamadas e intercambio de información con el PBX. 3. Implementación de funcionalidades en la aplicación Web. Iteración 1 Fecha de inicio: 19-06-2007 Al comienzo de esta iteración se instaló en el sistema un softphone (X-Lite) para lograr la comunicación básica entre el computador y Asterisk, dicho intercambio lo cual fue realizado sobre el protocolo SIP. Durante la primera iteración se realizó la comunicación entre el framework Ruby on Rails y el PBX Asterisk, a través de una herramienta que sirvió de puente entre ambas tecnologías. 105 En primera instancia se instaló el framework Adhearsion, y se logró la comunicación entre Asterisk y un script de Adhearsion escrito en lenguaje Ruby. Luego de lograr la conexión, se detectó que dicho framework no era el más adecuado para resolver el problema, ya que se encuentra orientado para la realización de IVR's valiéndose de la interfaz AGI de Asterisk. Seguidamente se procedió a buscar una herramienta más adaptada para satisfacer las necesidades del cliente, y se llegó a una herramienta más adecuada que comprendía un plugin de Rails llamado Telegraph, lo que lo hacía más atractivo para la adaptación a la aplicación. Finalmente, en esta iteración se realizó la instalación/inclusión del plugin en el proyecto logrando la conexión efectiva entre Rails y Asterisk con la herramienta adecuada, ya que soportaba el envío de comandos AMI e inclusive la captura de eventos AMI. Planificación Lista de requerimientos que fueron desarrollados en la primera iteración: 1. Instalación y prueba del framework Adhearsion para la comunicación Rails- Asterisk. 2. Instalación del plugin Telegraph para la comunicación Rails-Asterisk. 106 Diseño Se incluyeron nuevas clases en el proyecto con la instalación de Telegraph, más no se crearon nuevas clases propias. En el siguiente diagrama se refleja la clase principal de Telegraph sobre la cual se realizaron algunas correcciones de errores que presentaba el plugin, las cuales serán presentadas más adelante. Gráfico 7: Especificación Clase AMIManager. Codificación � Adhearsion Después de instalar el framework Adhearsion, se procedió a establecer la comunicación entre el mismo y Asterisk para lo que se necesitaba una entrada en Asterisk que transfiriera las llamadas desde Asterisk a Adhearsion. En el archivo 107 extention.conf de Asterisk, se agregaron las siguientes instrucciones: Comunicación entre Adhearsion y Asterisk: [internal] exten => _X.,1,AGI(agi://200.200.200.10) Tabla 43: Comunicación Adhearsion/Asterisk. Código que enviaba las llamadas que llegaron al contexto “internal” de la aplicación que se ejecuta en la dirección IP 200.200.200.10. En este caso se hizo sólo una prueba de comunicación exitosa antes de cambiar de herramienta. El script Adhearsion que se corrió fue muy sencillo imprimiendo la extensión destino de la llamada, como se ilustra a continuación: Script Adhearsion de prueba: internal { puts extension } Tabla 44: Script Adhearsion de Prueba. � Telegraph Se instaló el plugin Telegraph en el proyecto y se logró la conexión con Asterisk a través de la interfaz AMI. Para ello se generó el modelo que usa dicha interfaz y se le indicó al proyecto que se conectara a Asterisk, colocándole el host, usuario y contraseña de Asterisk en un archivo de configuración de Rails, de forma de cargar esa configuración y establecer la conexión al momento de iniciar el servidor AMI. Para eso se colocó en el script que inicia el servidor AMI (ami_server) la siguiente instrucción: 108 Comunicación entre Telegraph y Asterisk: ami_server = Telegraph::AMIServer.new(:host => @config['host'], :username => @config['username'], :secret => @config['secret']) Tabla 45: Comunicación Telegraph/Asterisk. Donde en la variable @config se cargó el archivo de configuración de Rails “ami.yml”, quien tiene la información de Asterisk. Finalmente en Asterisk se tiene que ingresar el usuario y contraseña en el archivo managers.conf para que realice la autenticación y permita establecer la conexión TCP. Luego de la instalación y conexión se corrigieron algunos errores que presentaba el plugin en su clase AMIManager, específicamente en la definición de los arreglos que se usan para llamar a las funciones de Telegraph, a continuación se muestra el código fuente de los arreglos que fueron modificados, las modificaciones se encuentrán marcadas en el color rojo: Correcciones del código fuente en Telegraph: FIND = { :agents => [:agents, []], :db => [:db_get,[:family, :key]], :extension_state => [:extension_state, [:context, :exten]], :variable => [:getvar, [:channel, :variable]], :all_iax_peers => [:iax_peers, []], :mailbox => [:mailbox_status, [:mailbox]], :parked_calls => [:parked_calls, []], :queue => [:queue_status, []], 109 :mailbox_count=> [:mailbox_count, []], :sip_peer=> [:sip_show_peer, [:peer]], :all_sip_peers=> [:sip_peers, []], :status=> [:status, [:channel]] } UPDATE = {:absolute_timeout => [:absolute_timeout, [:channel, :timeout]], :monitor => [:change_monitor, [:channel, :file]], :db => [:db_put, [:family, :key, :value]], :redirect => [:redirect, [:channel, :context, :exten, :priority]], :variable => [:setvar, [:channel, :variable, :value]] } CREATE = {:monitor => [:monitor, [:channel, :file, :format, :mix]], :call => [:originate, []] #Call/Originate has many optional parameters } DESTROY = { :call => [:hangup, [:channel]], :monitor => [:stopmonitor, [:channel]] } Tabla 46: Correcciones en Telegraph. Pruebas Se realizaron un pool de pruebas de conexión, usando el modelo AMI. Dichas pruebas involucraban acciones básicas de llamadas, tales como realización y transferencia de llamadas. A continuación se muestran los comandos ejecutados, probados desde la cónsola Ruby del proyecto Rails: 110 Pruebas de Telegraph en la primera iteración: AMIModel.create(:call, :channel=>'SIP/12', :context=>'from internal', exten=>'12', priority=>1); AMIModel.update(:redirect, :channel=>'SIP/11-09ec47c8', :context=>'from-internal', :extension=>'13', :priority=>1); AMIModel.find(:status, :channel=>'SIP/12'); Tabla 47: Pruebas Telegraph Iteración 1. En cada caso se invoca al modelo generado dinámicamente por Telegraph y se llaman a las distintas funciones estilo CRUD, indicando la función específica a activar de AMI y los parámetros que recibe la misma. Feedback El prof. Edgar González revisó la instalación del plugin, colaboró en la realización de las pruebas de conexión con el servidor de Telegraph y brindó apoyo permanente para la corrección de errores en el plugin. Cada uno de los requerimientos fue desarrollado y probado con éxito, presentando el funcionamiento esperado. Iteración 2 Fecha de inicio: 11-07-2007 En la segunda iteración se procedió a implementar lo que era el módulo de conexión como tal, entre la aplicación y Asterisk utilizando los beneficios que aporta el plugin Telegraph. 111 Planificación Requerimientos que fueron desarrolladas en la segunda iteración: 1. Implementar una función que permita a un operador iniciar una llamada telefónica a través del PBX Asterisk, hacia un número de un potencial cliente recuperado del repositorio de datos elegidos según ciertos parámetros de prioridad, registrando la llamada en el sistema. 2. Implementar una función que permita colgar una llamada. 3. Implementar una función que permita a un supervisor transferir una llamada telefónica en curso a su extensión. 4. Implementar una función que permita a un supervisor monitorear una llamada en curso, es decir que permita escuchar la conversación de la llamada y persista esta información en el sistema. 5. Implementar una función que consulte el estado de una extensión de Asterisk en un momento dado, y actualicé la información del sistema. Diseño En el siguiente diagrama se visualizan las clases involucradas para la solución 112 de las tareas concebidas en esta iteración. Gráfico 8: Diagrama de Clases, Iteración 2. Fuente: Autor Codificación Se muestra a continuación el código fuente de las funciones más importantes dentro de la clase Central, la función de actualización de estatus de la clase Extension y el algoritmo de búsqueda de números en el repositorio de datos de la clase Producto: Parte del código desarrollado en la segunda iteración, específicamente la clase Central, 113 donde se definen las funciones que presentan la lógica con todo lo pertinente a la llamada: class Central < Telegraph::AMIManager def self.llamar(producto, operador, ip) extension = self.extension_from_ip(ip) return nil, :extension_no_ociosa unless Extension.find_by_numero(extension).state == Extension::OCIOSA llamada = nil Numero.transaction do numero = producto.siguiente_numero_a_llamar(operador) return nil, :no_hay_numeros_disponibles unless numero extension = self.extension_from_ip(ip) self.establecer_llamada(numero.numero, extension) llamada = Llamada.create!(:producto => producto, :operador => operador, :numero => numero, :extension => extension, :centro => operador.centro) end return llamada, nil end def self.colgar(llamada) finalizar_llamada(llamada.extension) end def self.establecer_llamada(number, extension) # Hace una llamada al numero suministrado, pero primero # espera por que la extension sea levantada number_to_call = add_dial_prefix(strip_local_area_code(number)) create(:call, :context => ::ApplConfig[:context], :priority => ::ApplConfig[:priority], :async => ::ApplConfig[:async], :channel => "SIP/#{extension}", :exten => number_to_call) end def self.espiar_llamada(extension_a_espiar, extension_que_espia) create(:call, :channel => "local/#{extension_que_espia}", :context => ::ApplConfig[:context], :application => 'ChanSpy', :priority => ::ApplConfig[:priority], 114 :data => "sip/#{extension_a_espiar} |q", :async => true, :variable => "espiando= #{extension_a_espiar") end def self.extension_espiada(extension) res = find(:variable, :channel => channel_from_extension(extension), :variable => 'espiando') return res.value unless res.value.blank? nil end def self.transferir_llamada(extension_origen, extension_destino) channel = channel_linked_to_extension(extension_origen) return unless channel Central.update(:redirect, :channel => channel, :context => ::ApplConfig[:context], :exten => extension_destino, :priority => ::ApplConfig[:priority]) end def self.finalizar_llamada(extension) channel = channel_from_extension(extension) return unless channel destroy(:call, :channel => channel) end def self.extension_from_ip(ip) dot_index = ip.rindex('.') ip[dot_index-1,1]+ip[dot_index+1, ip.length] end end Tabla 48: Clase Central / Código Fuente Iteración 2. Parte del código desarrollado en la segunda iteración, Clase Extensión, donde se presenta el estatus de la extensión: class Extension < ActiveRecord::Base def state(reload = false) if @state.nil? or reload 115 res = Central.find(:extension_state, :exten => numero, :context => ::ApplConfig[:context]) @state = res.status if res end @state end end Tabla 49: Clase Extension / Código Fuente Iteración 2. Parte del código desarrollado en la segunda iteración, Clase Producto, donde se presenta el algoritmo encargado de búscar el siguiente número a ser llamado: class Producto < ActiveRecord::Base def siguiente_numero_a_llamar(operador, options = {}) raise ArgumentError.new("Operador esperado") unless operador.is_a?(Operador) num = numeros_llamar.find(:first, :conditions => ["volver_llamar_at < ? and operador = ?",Time.now, operador.login], :order => "volver_llamar_at") return num if num num = numeros_llamar.find(:first, :conditions => ["volver_llamar_at < ? and (operador is null or operador = '')",Time.now], :order => "volver_llamar_at") return num if num num = numeros_llamar.find(:first, :conditions => ["volver_llamar_at is null and operador = ?", operador.login], :order => "prioritario desc, ultima_llamada_at, created_at") return num if num num = numeros_llamar.find(:first, :conditions => "volver_llamar_at is null and (operador is null or operador = '')", :order => "prioritario desc, ultima_llamada_at, created_at") 116 return num if num return nil end end Tabla 50: Clase Producto / Código Fuente Iteración 2. Pruebas Se codificaron una serie de pruebas de comportamiento con el plugin rspec, que fueron aplicadas a las clases del modelo, al igual que se realizaron pruebas de aceptación del producto. A continuación se muestran ciertas pruebas realizadas sobre la clase Central: Pruebas SPEC de la clase Central en la segunda iteración: describe Central do fixtures :productos, :centros, :usuarios, :extensiones, :mantenimientos, :numeros before(:each) do end it "deberia llamar si el sistema no esta en mantenimiento y los parametros son correctos" do Central.llamar(productos(:aba_1024_venta), usuarios(:operador_caracas), "200.200.201.112") end it "no deberia llamar si la extension no esta ociosa" do Central.llamar(productos(:aba_1024_venta), usuarios(:operador_maracay), "200.200.202.112").should be_eql([nil, :extension_no_ociosa]) end it "deberia recuperar la extension desde una ip valida" do Central.extension_from_ip("200.200.200.34").should == 117 "034" end it "deberia arrojar una exception al intentar recuperar la extension desde una ip que es nil" do lambda{ Central.extension_from_ip(nil) }.should raise_error end end Tabla 51: Pruebas Clase Central Iteración 2. Seguidamente se anexa una de las varias pruebas que se le aplicaron al algoritmo de búsqueda de llamadas: Pruebas SPEC de la clase Producto en la segunda iteración: describe Producto, "Primera Prueba, numero a llamar con 5 entradas una fecha de volver_a_llamar. La primera 30 minutos antes de la hora actual (fuera del rango), la segunda a 10 minutos de la hora actual (dentro del rango) y la tercera 5 minutos despues de la hora actual (dentro del rango) y otras 2 con volver a llamar en nil" do fixtures :numeros, :usuarios, :productos before(:each) do @producto = productos(:aba_1024_instalacion) end it "deberia devolver el numero de Anibal" do num=@producto.siguiente_numero_a_llamar(usuarios(:operado r_caracas)) num.should be_eql(numeros(:anibal_rojas)) end end Tabla 52: Pruebas Clase Producto Iteración 2. Se realizaron pruebas de aceptación sobre el producto, donde el cliente se familiarizó las funcionalidades básicas tales como iniciar una nueva llamada, transferir o espiar una llamada, como se muestra en las siguientes pantallas: 118 • Pantalla de la aplicación con perfil de operador, donde es posible realizar una llamada. Gráfico 9: Prueba Aceptación, Pantalla Operador. Fuente: Autor • Pantalla de la aplicación con perfil de supervisor, donde se muestra toda la información de llamadas y extensiones del centro al que pertenece Gráfico 10: Prueba Aceptación, Pantalla Supervisor (Estado Asterisk). Fuente: Autor 119 • Pantalla que muestra el detalle de una llamada a un supervisor, donde puede monitorearla o transferirla a su extensión. Gráfico 11: Prueba Aceptación, Pantalla Supervisor (Detalle Llamada). Fuente: Autor Feedback El cliente estuvo satisfecho con las funcionalidades agregadas. Los algoritmos codificados fueron revisados y aprobados. El cliente pidió una refactorización del algoritmo de actualización de estatus, ya que las constantes llamadas a Asterisk congestionaron el canal produciendo un cierto colapso de la aplicación. Dicha refactorización se realizará en iteraciones posteriores. Se determinó que se requería un softphone con la capacidad de contestar automáticamente una llamada entrante de modo que el usuario no se vea en la necesidad de interactuar con dicho software, sino solo con la aplicación en cuestión, por lo que se instaló un softphone llamado “Twinkle”. 120 Iteración 3 Fecha de inicio: 21-08-2007 En la tercera iteración se procedió a desarrollar requerimientos adicionales del cliente. Funcionalidades, tales como la carga de un archivo excel a la base de datos con la información de los clientes, entre otras. Planificación Lista de requerimientos a desarrollar de la tercera iteración: • Implementar una funcionalidad en el sistema que permita al usuario (perfil Validador), tomar un archivo excel e ingresar la data del archivo (contiene datos del cliente) en el repositorio de datos de la aplicación. Permitiendole validar el número telefónico posteriormente. • Implementar una funcionalidad que permita al Administrador del sistema colocarlo a la aplicación en un modo “Mantenimiento”, en el cual ningún operador pueda iniciar una llamada nueva. 121 Diseño En el siguiente diagrama se visualizan las clases involucradas para la solución realizada en esta iteración. Gráfico 12: Diagrama de Clases, Iteración 3. Fuente: Autor. 122 Codificación Se muestra a continuación el código fuente de las funciones más importantes dentro de la clase Carga y Mantenimiento que comprenden el modelo en la implementación de las tareas. Código fuente de la tercera iteración, la clase Carga, encargada de tomar el archivo Excel, parsearlo e ingresar la información en la base de datos: class Carga < ActiveRecord::Base def self.parsear inicializa_logger carga = Carga.find ARGV[2] # Se recupera el número de la # corrida a procesar de la # linea de comando carga.iniciada_at = Time.new carga.save! logger.info "Iniciando proceso de la carga del archivo de excel llamado #{carga.filename} de la Corrida ID: #{ARGV[2]}" begin workbook = Spreadsheet::ParseExcel.parse(carga.full_filename) worksheet = workbook.worksheet(0) carga.recuperar_filas_excel(worksheet) carga.finalizada_at = Time.new carga.save! rescue Exception => e CargaLog.create(:carga_id => carga.id,:descripcion => "Error cargando el archivo: (#{carga.filename}) Detalle: #{e.to_s}") logger.debug "Se presento un error cargando el archivo (#{carga.filename}), en la carga: (#{carga.id})" end end def recuperar_filas_excel (worksheet) contadorError = 0 contadorExito = 0 skip = 1 worksheet.each(skip) do |row| sleep(Carga.sleep_time) if Carga.sleep? begin n = Numero.new 123 n.central = row.at(0).to_texto.to_s rescue nil n.numero = row.at(1).to_texto.to_s rescue nil n.numero = "0#{n.numero}" unless n.numero[0,1] == '0' n.nombre = row.at(2).to_texto rescue nil n.producto_id = producto_id n.carga_id = id n.created_by = created_by n.updated_by = updated_by unless row.at(3).blank? prioritario = row.at(3).to_entero rescue nil n.prioritario = (prioritario == 1) else n.prioritario = false end unless row.at(4).blank? n.operador = row.at(4).to_texto.strip rescue nil n.operador = nil if n.operador.blank? end unless n.save! contadorError = contadorError+1 else contadorExito = contadorExito+1 logger.info "Se agrego el numero: (#{n.numero}) al sistema con exito." end rescue Exception => e CargaLog.create( :carga_id => id, :descripcion => "Detalle: #{e.to_s}, Error cargando el numero: (#{n.numero})" ) logger.info "Error al agregar el numero: (#{n.numero}). Detalle: #{e.to_s}" end logger.info "Se procesaron #{contadorExito+contadorError} registros, #{contadorExito} se agregaron con Exito a la Base de Datos y #{contadorError} presentaron Errores." end end def en_proceso?(reload=false) if @en_proceso.nil? or reload @en_proceso = if finalizada_at false else res = `ps -ef | grep ruby` res["Carga.parsear #{id}"] end end Tabla 53: Clase Carga / Código Fuente Iteración 3. 124 Código fuente de la tercera iteración, clase Mantenimiento, donde se restringe la salida de llamadas de un operador: class Mantenimiento < ActiveRecord::Base def self.empezar_mantenimiento mant = Mantenimiento.find(1) mant.en_mantenimiento = true mant.save end def self.terminar_mantenimiento mant = Mantenimiento.find(1) mant.en_mantenimiento = false mant.save end def self.en_mantenimiento? mant = Mantenimiento.find(1) return mant.en_mantenimiento if mant nil end End Tabla 54: Clase Mantenimiento / Código Fuente Iteración 3. Pruebas Se codificaron una serie de pruebas de comportamiento con el plugin rspec, que fueron aplicadas a las clases Carga y Mantenimiento, al igual que se realizaron pruebas de aceptación del producto. A continuación se muestran ciertas pruebas realizadas sobre la clase Carga: 125 Pruebas SPEC clase Carga en la tercera iteración: describe Carga, "with enough text" do before(:each) do producto = Producto.new @carga = Carga.new(:descripcion => 'x' * 255, :content_type => 'x', :filename => 'amiMODEL', :size => 100.kilobytes, :producto_id => producto) end it "should be saved" do lambda { @carga.save }.should change(Carga, :count) end it "should't have errors in the attribute descripcion, content_type and filename" do @carga.should have(:no).error_on(:descripcion) @carga.should have(:no).error_on(:content_type) @carga.should have(:no).error_on(:filename) @carga.should have(:no).error_on(:size) end end describe Carga, "with too much text" do before(:each) do producto = Producto.new @carga = Carga.new(:descripcion => 'x' * 256, :producto_id => producto) end it "should not be saved" do lambda { @carga.save }.should_not change(Carga, :count) end it "should have a length error in the attribute descripcion" do @carga.should have(1).error_on(:descripcion) @carga.errors.on(:descripcion).should == "es demasiado largo (el máximo es de 255 caracteres)" end end Tabla 55: Pruebas Clase Carga, Iteración 3. 126 A continuación se incluyen pruebas realizadas sobre la clase Central que involucra la opción de Mantenimiento: Pruebas SPEC clase Mantenimiento en la tercera iteración: describe Central do fixtures :productos, :centros, :usuarios, :extensiones, :mantenimientos, :numeros before(:each) do end it "no deberia llamar si el sistema entra mantenimiento" do Mantenimiento.empezar_mantenimiento Central.llamar(productos(:aba_1024_venta), usuarios(:operador_caracas), "200.200.201.112").should be_eql([nil, :sistema_en_mantenimineto]) end it "deberia llamar si el sistema termina el mantenimiento" do Mantenimiento.terminar_mantenimiento Central.llamar(productos(:aba_1024_venta), usuarios(:operador_caracas), "200.200.201.112").nil?.should be_false end end Tabla 56: Pruebas Clase Mantenimiento, Iteración 3. El cliente probó las nuevas funcionalidades agregadas. En el caso de la funcionalidad de mantenimiento, se cambió de estado, mientras habían varias llamadas en curso, las cuales continuaron y a la hora de volver a llamar les lanzó un mensaje de error, lo que califica como aprobada la prueba del cliente. Para la carga de data en el sistema, se realizaron varias pruebas con distintos archivos, probando archivos con datos desde 15 a 4500 filas, comportandose bien 127 ante los casos borde, tales como números repetidos, error en la data, entre otros. Dichos datos vienen en un archivo de la siguiente manera: Tabla 6: Ejemplo de Archivo de datos. A continuación se muestran las pantallas que fueron útilizadas durante las distintas pruebas del usuario de esta iteración. • A continuación se muestra la pantalla de la aplicación donde al usuario Administrador se le permite activar el modo “Mantenimiento” en la aplicación: 128 Gráfico 13: Prueba Aceptación, Pantalla Administrador (Modo Mantenimiento). Fuente: Autor • El siguiente gráfico muestra la pantalla que utiliza el usuario Validador, que le permite cargar un archivo de nueva data para la base de datos de clientes: Gráfico 14: Prueba Aceptación, Pantalla Validador (Cargar Archivo). Fuente: Autor Feedback Luego de la aplicación de pruebas el cliente certificó las funcionalidades agregadas y pidió que el algoritmo de carga en el sistema se realizará en segundo plano previendo que los archivos de datos fueran muy grandes. 129 Iteración 4 Fecha de inicio: 01-10-2007 • En la cuarta iteración se refactorizó la funcionalidad incluida en la segunda iteración de consulta de estado de una extensión de Asterisk. Planificación Requerimientos que fueron desarrollados en la cuarta iteración: • Refactorizar el código de la actualización de estatus de la aplicación. Reemplazando las peticiones AMI a la recepción y manipulación de los eventos AMI generados por Asterisk. Diseño En el siguiente diagrama se muestra la clase que fue desarrollada para la solución de la tarea en cuestión. Gráfico 15: Diagrama de Clases, Iteración 4. Fuente: Autor 130 Codificación Se muestra a continuación el código fuente de la función extension_status de la clase AmiLogic, encargada de toda la lógica de la actualización del estatus de una extensión, tanto del estado de uso (inactiva, activa, sonando, no disponible), como del estado de monitoreo (espiada, espiando, no espiada). Código fuente de la clase AmiLogic, es la clase donde llegan los eventos generados por Asterisk: class AmiLogic < Telegraph::AMIHandler # Funcion que se dispara cuando existe un cambio de estado en # alguna extension de asterisk def extension_status #STATUS POSIBLES # 0: Arriba / inactiva | Idle # 1: Arriba / activa o llamando | In Use # 4: Abajo | Unavailable # 8: Arriba / sonando | Ringing unless ((exten = Extension.find_by_numero(params[:exten])).nil?) begin exten.state = Extension.find_human_state(params[:status]) if (exten.state == 'Ociosa') if exten.espiada? exten1 = Extension.find_by_numero(exten.espiada_por) exten1.espiando_a = nil exten1.save! Central.finalizar_llamada(exten1.numero) exten.espiada_por = nil elsif exten.espiando? exten1 = Extension.find_by_numero(exten.espiando_a) exten1.espiada_por = nil exten1.save! exten.espiando_a = nil end end 131 exten.save! rescue Exception => e logger.error("Cambio de Status de Extension: Error al cambiar de status a la extensión (#{params[:exten]}).") logger.error("Detalle del error: (#{e.to_s}).") end else logger.warn("Cambio de Status de Extension: No se encontró la extensión (#{params[:exten]}) registrada en el sistema.") end end end Tabla 57: Clase AmiLogic Iteración 4. Pruebas Se codificaron una serie de pruebas de comportamiento con el plugin rspec, que fueron aplicadas a las clase AmiLogic, al igual que se realizaron pruebas de aceptación del requerimiento. Se simuló el sistema PBX Asterisk a través de un stub para las pruebas de cambio de estado de monitoreo. Pruebas SPEC sobre la clase AmiLogic y Central, donde se simuló el comportamiento de Asterisk a través de objetos STUB: describe Central do it "deberia quedar igual el status de las extensiones (0- espiada y 0-espiando) (dado que la respuesta es de unos canales vacios, ninguna extension deberia ser espiada ni espiando)" do exten1 = extensiones(:exten_operador_caracas_2) exten2 = extensiones(:exten_supervisor_caracas_1) exten1.espiada?.should be(false) exten2.espiando?.should be(false) 132 a = Telegraph::AsteriskResponse.new a.results = "Channel Location State Application(Data) \n0 active channels\n0 active calls\n" Central.stub!(:cli_command).and_return(a) Central.actualizar_espio_extension_channels(exten1.numero) exten1.reload exten1.espiada?.should be(false) Central.actualizar_espio_extension_channels(exten2.numero) exten2.reload exten2.espiando?.should be(false) end it "deberia actualizar el status de las extensiones (dado que la respuesta es de una extension espiada, una extension debera ser espiada y la otra espiando)" do exten1 = extensiones(:exten_operador_caracas_2) exten2 = extensiones(:exten_supervisor_caracas_1) exten1.espiada?.should be(false) exten2.espiando?.should be(false) a = Telegraph::AsteriskResponse.new a.results = "Channel Location State Application(Data) \nSIP/0112-08b54440 (None) Up Bridged Call(Local/0112@defaul\nLocal/0112@default-5 s@macro-dial:10 Up Dial(SIP/0112||tr) \nLocal/1121@default-5 s@default:1 Up ChanSpy(sip/1115|q) \nZap/1-1 s@from-zaptel:1 Up Bridged Call(SIP/0133-08b7aae0\nSIP/0133-08b7aae0 s@macro-dialout-trun Up Dial(ZAP/1/2424379|300|) \n5 active channels\n2 active calls\n" Central.stub!(:cli_command).and_return(a) Central.actualizar_espio_extension_channels(exten1.numero) exten1.reload exten1.espiada?.should be(true) Central.actualizar_espio_extension_channels(exten2.numero) exten2.reload exten2.espiando?.should be(true) end end describe AmiLogic, "Events that change extensions states" do fixtures :extensiones it "should change the extension 1112 state from Ociosa to En uso" do @ami_event_handler = AmiLogic.new({:exten => '1112', :status => '1'}) @extension = extensiones(:exten_operador_caracas) @extension.state.should be_eql("Ociosa") @ami_event_handler.extension_status @extension.reload 133 @extension.state.should be_eql("En uso") end it "should change the extension 2112 state from No disponible to Ociosa" do @ami_event_handler = AmiLogic.new({:exten => '2112', :status => '0'}) @extension = extensiones(:exten_operador_maracay) @extension.state.should be_eql("No disponible") @ami_event_handler.extension_status @extension.reload @extension.state.should be_eql("Ociosa") end it "should change the extension 2112 state from No disponible to En uso" do @ami_event_handler = AmiLogic.new({:exten => '2112', :status => '1'}) @extension = extensiones(:exten_operador_maracay) @extension.state.should be_eql("No disponible") @ami_event_handler.extension_status @extension.reload @extension.state.should be_eql("En uso") end it "should change the extension 2112 state from No disponible to Repicando" do @ami_event_handler = AmiLogic.new({:exten => '2112', :status => '8'}) @extension = extensiones(:exten_operador_maracay) @extension.state.should be_eql("No disponible") @ami_event_handler.extension_status @extension.reload @extension.state.should be_eql("Repicando") end end Tabla 58: Pruebas Clase Central y AmiLogic Iteración 4. El cliente probó el requerimiento cambiando de estatus una extensión y verificando en la aplicación el estatus de la misma. Se realizaron varias pruebas con la aplicación funcionando establemente con el cambio. 134 Feedback Al llevar el cambio a producción, el cliente informó que tanto el performance como la estabilidad de la aplicación mejoraron notablemente, reduciendo sustancialmente el número de peticiones desde la aplicación hacia Asterisk. 135 CAPÍTULO IV CONCLUSIONES Y RECOMENDACIONES El proyecto culminó con la puesta en producción de una aplicación que combina el ámbito Web y la tecnología de voz sobre IP (VoIP), conectandolos a través de un módulo desarrollado según los principios de las metodologías ágiles. Con esto se cumplió el objetivo principal del estudio dando como fruto una herramienta que automatizó el proceso de mercadeo de productos y servicios empresariales. Actualmente, la aplicación desarrollada se está utilizando para implementar centros de llamadas telefónicas automatizados, donde se tienen operadores que contactan a los potenciales clientes vía telefónica. Supervisores que monitorean el tráfico de las llamadas y usuarios validadores que ingresan nuevos datos al sistema, ampliando así la base de datos de posibles clientes. En el proyecto se utilizó la central telefónica Asterisk, que es un PBX orientado hacia el desarrollo de sistemas automatizados de voz. Éste a pesar de manejar su lenguaje de scripting interno, brinda la posibilidad de intercambio de datos con entes externos que pudieran intervenir en el flujo de los procesos del PBX, bien sea modificando el curso de una llamada, activando funciones propias o recolectando información que manda el PBX para procesarla y/o almacenarla. En este estudio la aplicación desarrollada es un ente externo de Asterisk que se comunica por una interfaz llamada Asterisk Manager Interface (AMI), bien sea 136 activando funciones de Asterisk o interpretando mensajes enviados por dicha central telefónica. Cabe destacar que el papel de la herramienta conectora entre la tecnología VoIP del PBX Asterisk y framework Ruby on Rails, llamada Telegraph, fue fundamental en el desarrollo de la aplicación ya que facilitó el uso de las interfaces que provee Asterisk para la comunicación. Esto redujo los tiempos de desarrollo considerablemente ya que gran parte de la comunicación a bajo nivel se encontraba implementado en la herramienta conectora. Por su parte, el uso de Ruby on Rails permitió el desarrollo de una aplicación de calidad de manera ágil, valiéndose de su sencilla organización de las piezas y componentes, tales como Action Pack, Active Record y Plugins, estos últimos muy útiles ya que existe una gran gama de ellos en la Web brindando solución a problemas cuyo desarrollo pudiera llevar gran cantidad de horas de diseño e implementación. En el ámbito tecnológico de la investigación realizada se puede concluir que al pasar el tiempo las técnicas de desarrollo son cada vez más refinadas permitiendo así el desarrollo ágil de aplicaciones manteniendo la calidad, enfocándose cada vez más en los requerimientos del cliente, por lo cual se pudiera inferir que en el futuro las aplicaciones serán orientadas a satisfacer las demandas del cliente de la mejor manera posible. Al aplicar programación extrema como proceso de desarrollo, se observó el ahorro de tiempo de las etapas de la implementación con respecto a experiencias pasadas. Este proceso de desarrollo se debe usar cuando el cliente necesita obtener 137 resultados rápidamente, mas para lograr esta acometida es necesario aplicar y adaptar correctamente las prácticas que propone la especificación del proceso de desarrollo. Otro aspecto fundamental en la aplicación de la metodología XP es tener al cliente lo más involucrado posible con el desarrollo y validar cada una de las soluciones implementadas a las tareas descritas a través de pruebas de aceptación, lo cual es muy importante ya que es una medida confiable del avance del proyecto. La utilización del proceso de desarrollo XP en este estudio brindo muchos beneficios, entre los cuales tenemos la entrega oportuna al cliente de requerimientos establecidos, la prueba de cada algoritmo implementado, el enfoque en el desarrollo de los requerimientos, entre otros. Es prudente mencionar que el desarrollo del proyecto fue basado en la filosofía de desarrollo orientado a pruebas. Un porcentaje importante de las soluciones fueron implementadas luego de haber codificado las pruebas, tal como lo describe la técnica BDD, lo que garantiza robustez en el producto realizado. Los algoritmos codificados fueron sometidos a pruebas antes, durante y después de finalizada la realización y/o modificación en la implementación de los mismos. Con respecto al área de las telecomunicaciones e informática, se puede afirmar que pareciera estrecharse la línea de separación entre éstas. En la actualidad es complicado hablar de un desarrollo completamente telefónico, porque las telecomunicaciones se encuentran ligadas con la informática a tal punto que en la mayoría de los casos se utilizan algoritmos para llevar a cabo ciertas tareas. Los desarrolladores están empezando a incursionar en el área de telecomunicaciones y 138 viceversa, lo que pudiera resultar en un extenso desarrollo de las aplicaciones VoIP a nivel mundial. Para futuros desarrollos donde se aplicará la metodología XP, es recomendable definir claramente el alcance del proyecto y de cada requerimiento, sustentándolos contra los requerimientos, tareas o historias de usuarios según sea hecha la adaptación de XP. Esto sin perder la flexibilidad y adaptabilidad que brinda el proceso de desarrollo ante posibles cambios. Se recomienda estudiar a fondo el funcionamiento de las herramientas que se vean involucradas en el proyecto, ya que ese tiempo de análisis puede resultar en ahorro de tiempo y costos. Este punto se ve reflejado en este estudio cuando se tomó la decisión de cambiar de herramienta conectora de Adhearsion a Telegraph debido a la adaptación de la herramienta en la solución realizada. En este caso Telegraph prevaleció ya que es un plugin para Ruby on Rails, framework en el que se desarrolló la aplicación. También se debe tomar en cuenta, sobre el tiempo de entrega del producto, la curva de aprendizaje que pudiera tener cada programador en caso de que los mismos no posean total dominio de las tecnologías a ser usadas durante el proceso de desarrollo. 139 REFERENCIAS • [About "A Guide to Testing the Rails" (2007)].[Página Web en línea]. Disponible: http://manuals.rubyonrails.com/read/book/5 [Consulta: 2007, diciembre 20] • [Acerca de Ruby (2007)]. [Página Web en línea]. Disponible: http://www.ruby-lang.org/es/about [Consulta: 2008, enero 10] • [Active Record (2006)]. [Documento en línea]. Disponible: http://www.martinfowler.com/eaaCatalog/activeRecord.html [Consulta: 2007, noviembre 2] • [Active Record (2007)]. [Página Web en línea]. Disponible: http://wiki.rubyonrails.org/rails/pages/ActiveRecord [Consulta: 2007, noviembre 5] • [Adhearsion (2007)]. [Página Web en línea]. Disponible: http://adhearsion.com/ [Consulta: 2007, diciembre 29] • [Agile Alliance (2001)]. [Página Web en línea]. Disponible : http://www.agilealliance.org/ [Consulta: 2007, septiembre 17] • [AAB (1998)]. Anderson A, Beattie R, Beck K, Bryant D, DeArment M, Fowler M, Fronczak M, Garzaniti R, Gore D, Hacker B, Handrickson C, Jeffries R, Joppie D, Kim D, Kowalsky P, Mueller D, Murasky T, Nutter R, Pantea A y Thomas D (1998).Chrysler Goes to "Extremes". Case Study. En Agile software development methods [Libro en línea] Disponible: http://www.inf.vtt.fi/pdf/publications/2002/P478.pdf. [Consulta: 2007, septiembre 17] 140 • [Asterisk AGI (2003)]. [Página Web en línea]. Disponible: http://www.voip-info.org/wiki-Asterisk+AGI [Consulta: 2007, noviembre 20] • [Asterisk channels (2003)]. [Página Web en línea]. Disponible: http://www.voip-info.org/wiki/view/Asterisk+channels [Consulta: 2008, enero 10] • [Asterisk Dialplan Introduction (2003)]. [Página Web en línea]. Disponible: http://www.voip-info.org/wiki-Asterisk+Dialplan+Introduction [Consulta: 2008, enero 10] • [AMAPI (2003)] Asterisk manager API (2003). [Página Web en línea]. Disponible: http://www.voip-info.org/wiki/view/Asterisk+manager+API [Consulta: 2007, noviembre 22] • [AME (2003)] Asterisk manager events (2003). [Página Web en línea]. Disponible: http://www.voip-info.org/wiki/view/asterisk+manager+events [Consulta: 2008, enero 05] • [Barrios M. (2005)]. Manual de Trabajos de Grado de Especialización y Maestría y Tesis Doctorales. Universidad Pedagógica Experimental Libertador, Caracas, Venezuela. • [Beck, K. (1999-a)]. Embracing Change With Extreme Programming. IEEE Computer 32, Estados Unidos. • [Beck, K. (1999-b)]. Extreme programming explained: Embrace change. Addisson-Wesley, Estados Unidos. 141 • [Behaviour Driven Development (2007, diciembre 23)]. [Página Web en línea]. Disponible: http://behaviour-driven.org/ [Consulta: 2007, diciembre 28] • [Dave Astels (2007)]. A New Look at Test Driven Development [Documento en línea]. Disponible: http://blog.daveastels.com/2005/07/05/a-new-look-at-test-driven- development [Consulta: 2007, diciembre 28] • [Fowler, Martin. (2004, mayo)]. Is Design Dead? [Artículo en línea]. Disponible: http://martinfowler.com/articles/designDead.html [Consulta: 2007, diciembre 01] • [Fowler, Martin. (2006, julio)]. Writing The Agile Manifesto. [Artículo en línea]. Disponible: http://martinfowler.com/articles/agileStory.html [Consulta: 2007, septiembre 01] • [GNU (2007, noviembre 01)]. The Free Software Definition. [Página Web en línea]. Disponible: http://www.gnu.org/philosophy/free-sw.html [Consulta: 2007, noviembre 05] • [GDD (2005)] Gomillion D y Dempster B (2005). Building Telephony Systems with Asterisk. Packt Publishing Ltd. 32 Lincoln Road Olton Birmingham, B27 6PA, UK. • [HAML (2007)]. [Página Web en línea]. Disponible: http://haml.hamptoncatlin.com/ [Consulta: 2007, diciembre 20] • [Introducing Test/Unit (2007)]. [Página Web en línea]. Disponible: http://manuals.rubyonrails.com/read/chapter/21 [Consulta: 2007, diciembre 27] 142 • [JRA (2001)]. Jeffries R, Anderson A y Hendrickson C (2001). Extreme Programming Installed. En Agile software development methods [Libro en línea] Disponible: http://www.inf.vtt.fi/pdf/publications/2002/P478.pdf. [Consulta: 2007, septiembre 17] • [MAS (2001)]. Manifesto for Agile Software Development (2001) [Documento en línea]. Disponible: http://www.agilemanifesto.org/ [Consulta: 2007, septiembre 17] • [Martin, R (2002)]. Continuos Care vs. Initial Design [Artículo en línea]. Disponible: http://www.agilealliance.org/system/article/file/833/file.pdf. [Consulta: 2007, septiembre 01] • [MJS (2005)]. Meggelen J, Smith J y Madsen L (2005). Asterisk: The Future of Telephony O’Reilly Media, Inc., Estados Unidos. • [Miller, M. (2001)]. Writing The Agile Manifesto. [Libro en línea]. Disponible: http://martinfowler.com/articles/agileStory.html [Consulta: 2007, noviembre 01] • [Models (2006)]. [Página Web en línea]. Disponible: http://wiki.rubyonrails.org/Rails/pages/Models [Consulta: 2007, noviembre 10] • [Plugins (2006)]. [Página Web en línea]. Disponible: http://wiki.rubyonrails.org/rails/pages/Plugins [Consulta: 2007, diciembre 20] • [Rspec (2008)]. [Página Web en línea]. Disponible: http://rspec.info/rdoc/index.html [Consulta: 2007, diciembre 27] 143 • [RSpec Doc (2007)]. [Página Web en línea]. Disponible: http://rspec.info/documentation/ [Consulta: 2007, diciembre 28] • [RubyGems Manual (2007)]. [Página Web en línea]. Disponible: http://rubygems.org/read/book/1 [Consulta: 2007, diciembre 20] • [Telegraph (2007)]. [Página Web en línea]. Disponible: http://telegraph.rubyforge.org/Home.html [Consulta: 2007, enero 6] • [Telegraph Documentation (2007)]. [Página Web en línea]. Disponible: http://telegraph.rubyforge.org/wiki/wiki.pl [Consulta: 2008, enero 2] • [TDH (2006)]. Thomas D., Heinemeier D, Breedt L., Clark M., Duncan J., Gehtland J., y Andreas Schwarz (2006). Agile Web Development with Rails: Second Edition, 2nd Edition. The Pragmatic Bookshelf, Estados Unidos. • [UsingAMI (2007)]. [Página Web en línea]. Disponible: http://telegraph.rubyforge.org/wiki/wiki.pl?UsingAMI [Consulta: 2007, noviembre 12] • [Wikipedia (2007, diciembre 17)]. Behavior Driven Development [Página Web en línea]. Disponible: http://en.wikipedia.org/wiki/Behavior_driven_development [Consulta: 2007, noviembre 15] • [Wikipedia (2007, julio 8)]. Manifiesto Ágil [Página Web en línea]. Disponible: http://es.wikipedia.org/wiki/Manifiesto_%C3%A1gil. [Consulta: 2007, octubre 05] • [Wikipedia (2007, octubre 6)]. Modelo Vista Controlador [Página Web en 144 línea]. Disponible: http://es.wikipedia.org/wiki/Modelo_Vista_Controlador [Consulta: 2007, noviembre 10] • [Wikipedia (2007, diciembre 31)]. Plugin [Página Web en línea]. Disponible: http://es.wikipedia.org/wiki/Plugin [Consulta: 2007, diciembre 20] • [Wikipedia (2007, julio 7)]. Programación Extrema [Página Web en línea]. Disponible: http://es.wikipedia.org/wiki/Programaci%C3%B3n_Extrema. [Consulta: 2007, agosto 21] • [Wikipedia (2007, diciembre 20)]. Pruebas de Software [Página Web en línea]. Disponible: http://es.wikipedia.org/wiki/Pruebas_de_software [Consulta: 2007, diciembre 15] • [Wikipedia (2008, enero 2)]. Ruby [Página Web en línea]. Disponible: http://es.wikipedia.org/wiki/Ruby [Consulta: 2008, enero 10] • [Wikipedia (2007, diciembre 7)]. Ruby on Rails [Página Web en línea]. Disponible: http://es.wikipedia.org/wiki/Ruby_on_Rails [Consulta: 2007, diciembre 18] • [Wikipedia (2007, marzo 30)]. RubyGems [Página Web en línea]. Disponible: http://es.wikipedia.org/wiki/RubyGems [Consulta: 2007, diciembre 20] • [Wikipedia (2008, mayo 7)]. Softphone [Página Web en línea]. Disponible: http://es.wikipedia.org/wiki/Softphone. [Consulta: 2008, mayo 7] • [Wikipedia (2008, enero 5)]. Software Libre [Página Web en línea]. 145 Disponible: http://es.wikipedia.org/wiki/Software_libre. [Consulta: 2008, enero 10] • [Wikipedia (2008, enero 17)]. Test-driven development [Página Web en línea]. Disponible: http://en.wikipedia.org/wiki/Test-driven_development. [Consulta: 2008, enero 10] 146 CONTACTOS A continuación se plasman los datos de contacto del presente Trabajo Especial de Grado: Nombres: Carlos Augusto Apellidos: García Mujica Dirección de Correo: carlosve.ucv@gmail.com Nombre: Edgar Apellido: González Cargo: Profesor de la Escuela de Computación de la Facultad de Ciencias UCV. Dirección de Correo: edgargonzalez@gmail.com. 147 ANEXOS Glosario de términos • AJAX: acrónimo de Asynchronous JavaScript And XML, es una técnica de desarrollo Web para crear aplicaciones interactivas o RIA (Rich Internet Applications). Éstas se ejecutan en el cliente, es decir, en el navegador de los usuarios y mantiene comunicación asíncrona con el servidor en segundo plano. De esta forma es posible realizar cambios sobre la misma página sin necesidad de recargarla. • API: del inglés Application Programming Interface - Interfaz de Programación de Aplicaciones, es el conjunto de funciones y procedimientos (o métodos si se refiere a programación orientada a objetos) que ofrece cierta librería para ser utilizado por otro software como una capa de abstracción. • Blog: en español también una bitácora, es un sitio Web periódicamente actualizado que recopila cronológicamente textos o artículos de uno o varios autores, apareciendo primero el más reciente, donde el autor conserva siempre la libertad de dejar publicado lo que crea pertinente. • Digital Signal Processing (DSP): Es un dispositivo capaz de interpretar, procesar y modificar señales provenientes de distintas fuentes. • Framework: En el desarrollo de software, un framework es una estructura de soporte definida en la cual otro proyecto de software puede ser organizado y desarrollado. Típicamente, un framework puede incluir soporte de programas, bibliotecas y un lenguaje interpretado entre otros 148 softwares para ayudar a desarrollar y unir los diferentes componentes de un proyecto. • Gateway: en informática corresponde a un dispositivo capáz de conectar redes de distinto protocolo o protocolos incompatibles, funcionando como intermediario permitiendo la comunicación. • GNU: proyecto iniciado por Richard Stallman con el objetivo de crear un sistema operativo completamente libre: el sistema GNU . • GPL: (Licencia Pública General) es una licencia creada por la Free Software Foundation, y está orientada principalmente a proteger la libre distribución, modificación y uso de software. • Hacker: es el neologismo utilizado para referirse a un experto en varias o alguna rama técnica relacionada con la informática: programación, redes de computadoras, sistemas operativos, hardware de red/voz, entre otros. • IAX: AX (Inter-Asterisk eXchange protocol) es uno de los protocolos utilizado por Asterisk. Es utilizado para manejar conexiones VoIP entre servidores Asterisk, y entre servidores y clientes que también utilizan protocolo IAX. • Java: es un lenguaje de programación orientado a objetos desarrollado por Sun Microsystems a principios de los años 1990. El lenguaje en sí mismo toma mucha de su sintaxis de C y C++, pero tiene un modelo de objetos más simple y elimina herramientas de bajo nivel como punteros. • JavaScript: es un lenguaje de programación interpretado, es decir, que no requiere compilación, utilizado principalmente en páginas Web, con una sintaxis semejante a la del lenguaje Java y el lenguaje C. 149 • Lenguajes de Script: es un lenguaje de programación que fue diseñado para ser ejecutado por medio de un intérprete, en contraste con los lenguajes compilados. • Productividad: También conocido como eficiencia es genéricamente entendida como la relación entre la producción obtenida por un sistema de producción o servicios y los recursos utilizados para obtenerla. También puede ser definida como la relación entre los resultados y el tiempo utilizado para obtenerlos: cuanto menor sea el tiempo que lleve obtener el resultado deseado, más productivo es el sistema. • PSTN: La Red Telefónica Conmutada (PSTN en inglés) es una red de comunicación diseñada primordialmente para la transmisión de voz, aunque pueda también transportar datos, por ejemplo en el caso del fax o de la conexión a Internet a través de un módem acústico. • RSDI: Según la UIT-T podemos definir Red Digital de Servicios Integrados (RDSI o ISDN en inglés) como: una red que procede por evolución de la Red Digital Integrada (RDI) y que facilita conexiones digitales extremo a extremo para proporcionar una amplia gama de servicios, tanto de voz como de otros tipos, y a la que los usuarios acceden a través de un conjunto de interfaces normalizados. • SIP: Session Initiation Protocol (SIP o Protocolo de Inicio de Sesiones) es un protocolo desarrollado por el IETF MMUSIC Working Group con la intención de ser el estándar para la iniciación, modificación y finalización de sesiones interactivas de usuario donde intervienen elementos multimedia como el video, voz, mensajería instantánea, juegos online y realidad virtual. 150 • Softphone: es un software que hace una simulación de teléfono convencional por computadora. Es decir, permite usar la computadora para hacer llamadas a otros softphones o a otros teléfonos convencionales. • TCP/IP: La familia de protocolos de Internet es un conjunto de protocolos de red en la que se basa Internet y que permiten la transmisión de datos entre redes de computadoras. En ocasiones se la denomina conjunto de protocolos TCP/IP, en referencia a los dos protocolos más importantes que la componen: Protocolo de Control de Transmisión (TCP) y Protocolo de Internet (IP), que fueron los dos primeros en definirse, y que son los más utilizados de la familia. • URI: es una cadena corta de caracteres que identifica inequívocamente un recurso (servicio, página, documento, dirección de correo electrónico, enciclopedia, etc). Normalmente estos recursos son accesibles en una red o sistema. • URL: significa Uniform Resource Locator, es decir, localizador uniforme de recurso. Es una secuencia de caracteres, de acuerdo a un formato estándar, que se usa para nombrar recursos, como documentos e imágenes en Internet, por su localización. • VoIP: Voz sobre Protocolo de Internet, también llamado Voz sobre IP, VozIP, VoIP (por sus siglas en inglés), o Telefonía IP, es un grupo de recursos que hacen posible que la señal de voz viaje a través de Internet empleando un protocolo IP (Internet Protocol). Esto significa que se envía la señal de voz en forma digital en paquetes en lugar de enviarla (en forma digital o analógica) a través de circuitos utilizables solo para telefonía como una compañía telefónica convencional o PSTN. 151 • XMPP: siglas inglesas de eXtensible Messaging and Presence Protocol (Protocolo ampliable de mensajería y [comunicación de] presencia), es un protocolo abierto y ampliable basado en XML, originalmente ideado para mensajería instantánea. Anexo 1: Valores del Manifiesto Ágil • Valorar más a los individuos y su interacción que a los procesos y las herramientas • Este principio es muy importante y no se puede malinterpretar su planteamiento. No plantea que los procesos no son importantes, es más generalmente comprenden una guía de operación, pero sin personas con el conocimiento técnico e incentivo adecuado, no producen resultados por más que los procesos se encuentren eficientes. • Se plantea que los procesos deberían adaptarse a la organización, a las personas y a los grupos de trabajo; no al revés. • Valorar más el software que funciona que la documentación exhaustiva • Se debería tener en cuenta el valor del trabajo por prototipos o por partes, ya que las entregas de funcionalidades ya elaboradas ofrece una retroalimentación enriquecedora y estimulante, generando nuevas ideas y posibilidades que serían muy complicadas concebir en un documento de requisitos hecho antes de comenzar a elaborar el proyecto. • Los documentos son soporte del análisis y diseño y permiten la transferencia del conocimiento, registrando información histórica. El manifiesto no afirma que no hagan falta, sino plantea que son menos importantes que los productos que funcionan. • Entonces se afirma que los documentos no pueden sustituir, ni pueden 152 ofrecer la riqueza y generación de valor que se logra con la comunicación directa entre las personas y a través de la interacción con los prototipos. • Valorar más la colaboración con el cliente que la negociación contractual • Como se observo en valores expuestos anteriormente, el manifiesto ágil plantea que el valor del resultado no es consecuencia de haber controlado una ejecución conforme a procesos, sino de haber sido implementado directamente sobre el producto. Un contrato tampoco aporta mucho valor al producto, simplemente comprende una formalidad que establece líneas divisorias entre responsabilidades, que fija los referentes para posibles disputas contractuales entre cliente y proveedor. • En el desarrollo ágil se intenta incluir al cliente como un miembro más del equipo, integrándolo y aportando colaboración en el grupo de trabajo, es por eso que los modelos por contrato no encajan es este tipo de métodos. • Valorar más la respuesta al cambio que el seguimiento de un plan • Las prácticas ágiles están especialmente indicadas para productos difíciles de definir con detalle en el principio, en entornos inestables, que tienen como factor inherente al cambio, que presentan una evolución rápida y continua, es por eso que la capacidad de respuesta a los cambios resulta un aporte de mayor valor que la elaboración y cumplimiento una rigurosa planificación. • Uno de los principales valores de la gestión ágil es la adaptación y facilidad de respuesta al cambio; diferentes a los de la antigua gestión de proyectos que comprenden control y planificación para evitar desviaciones sobre el plan. 153 Anexo2: Principios del Manifiesto Ágil Tras los cuatro valores descritos anteriormente, los firmantes redactaron los siguientes lineamientos como principios del Manifiesto Ágil: • Nuestra principal prioridad es satisfacer al cliente a través de la entrega temprana y continua de software de valor. • Los requisitos cambiantes son bienvenidos, aunque lleguen tarde al desarrollo. Los procesos ágiles explotan el cambio como ventaja competitiva para el cliente. • Entregar con frecuencia software que funcione, los periodos pueden variar de un par de semanas hasta un par de meses, prefiriendo los periodos breves. • Los clientes o expertos del negocio y los desarrolladores deben trabajar juntos de forma cotidiana a lo largo del proyecto. • Construir los proyectos en torno a individuos motivados, brindándoles la oportunidad y el respaldo que necesitan y dándoles confianza para que lleven a cabo la tarea. • La forma más eficiente y efectiva de hacer fluir la información de ida y vuelta dentro de un grupo de desarrollo es mediante la conversación personalizada. • Software en funcionamiento es la principal medida del progreso. • Los procesos ágiles promueven el desarrollo sostenible. Los patrocinadores, desarrolladores y usuarios deben mantener un ritmo constante en forma indefinida. • La atención continua a la excelencia técnica y buen diseño enaltece la agilidad. 154 • Simplicidad, arte de maximizar la cantidad de trabajo que no se hace, es esencial. • Las mejores arquitecturas, requisitos y diseños emergen de equipos auto- organizados. • En intervalos regulares, el equipo reflexiona la forma de ser más efectivo para ajustar acordemente su conducta. 155 Anexo3: Proceso de la Programación Extrema El ciclo de XP comprende cinco fases: Exploración, Planeamiento, Iteraciones de Entregas, Producción, Mantenimiento y Muerte, como se muestran en la siguiente figura: Gráfico 16: Anexo 3, Proceso de la programación Extrema. Fuente: Beck, K. (1999-b) 156 Anexo4: Prácticas de la Programación Extrema Las prácticas de la programación extrema se pueden apreciar gráficamente en el siguiente gráfico: Gráfico 17: Anexo 4, Prácticas de la programación Extrema. Fuente: Beck, K. (1999-b)Microsoft Word - tesis_v5.doc Universidad Central de Venezuela Facultad de Ciencias Escuela de Computación Aplicaciones con Tecnología Internet DISEÑO Y DESARROLLO DE UN MÓDULO DE COMUNICACIÓN ENTRE EL FRAMEWORK RUBY ON RAILS Y LA CENTRAL TELEFÓNICA POR SOFTWARE ASTERISK, PARA EL MERCADEO DE PRODUCTOS Y SERVICIOS EMPRESARIALES Trabajo Especial de Grado presentado ante la Ilustre Universidad Central de Venezuela Por el Bachiller Carlos Augusto García Mujica CI: 17.400.329 para optar al título de Licenciado en Computación Tutor Prof. Edgar González Caracas, mayo / 2008 i ACTA Quienes suscriben miembros del Jurado, designado por el Consejo de Escuela de Computación, para examinar el Trabajo Especial de Grado presentado por el Bachiller Carlos Augusto García Mujica, C.I. 17.400.329, con el título: ”Diseño y Desarrollo de un Módulo de Comunicación entre el Framework Ruby on Rails y la Central Telefónica por Software Asterisk, para el Mercadeo de Productos y Servicios Empresariales”, a los fines de optar al título de Licenciado en Computación, dejan constancia lo siguiente: Leído como fue, dicho trabajo por cada uno de los miembros del Jurado, se fijó el 03 de Junio de 2008 a las 11:30 a.m, para que su autor lo defendiera en forma pública, se hizo en la sala del Centro de Computación, mediante una presentación oral de su contenido. Finalizada la defensa pública del Trabajo Especial de Grado, el Jurado decidió aprobarlo con una nota de _______ puntos, en fe de lo cual se levanta la presente Acta, en Caracas a los tres días del mes de Junio del año dos mil ocho, dejándose también constancia de que actúo como Coordinador del Jurado el profesor Edgar González. _____________________________ Prof. Edgar González (Tutor) _____________________________ _____________________________ Prof. Sergio Rivas Prof. Andrés Sanoja (Jurado Principal) (Jurado principal) ii DEDICATORIA Y AGRADECIMIENTOS A mi núcleo familiar por haber apostado a mi éxito desde el comienzo de mi carrera y seguirlo haciendo. En especial a mi madre por el soporte moral, mi hermana porque es un ser especial con el que se que cuento de principio a fin sin importar el asunto y mi padre que me apoyó durante todos mis estudios. A Mi Esperanza por el apoyo incondicional en todos los aspectos de mi vida y en especial por la ayuda brindada en el desarrollo de este proyecto. A mis tios, abuelos y primos que me han demostrado ser unas excelentes personas consecuentes, por lo que siempre contaré con ellos. A mi tutor y profesores de la carrera, por haber brindado sus conocimientos en un tiempo oportuno de mi formación. A mis compañeros de la universidad, con los que compartí momentos inolvidables, especialmente al legendario “circulo”, que espero continuemos en contacto a través de los años cultivando las amistades permanentemente. iii ÍNDICE DE CONTENIDOS ACTA ............................................................................................................................. i DEDICATORIA Y AGRADECIMIENTOS ................................................................ii ÍNDICE DE CONTENIDOS........................................................................................iii ÍNDICE DE GRÁFICOS .............................................................................................vi ÍNDICE DE TABLAS.................................................................................................vii RESUMEN................................................................................................................... ix INTRODUCCIÓN......................................................................................................... 2 CAPÍTULO I................................................................................................................. 4 Planteamiento del Problema y justificación del proyecto ............................................ 4 Objetivos ............................................................................................................... 6 Objetivo general .................................................................................................... 6 Objetivos específicos............................................................................................. 6 CAPÍTULO II................................................................................................................ 8 Marco Teórico ............................................................................................................... 8 Desarrollo Ágil ...................................................................................................... 8 Manifiesto Ágil...................................................................................................... 8 Características del Desarrollo Ágil...................................................................... 10 Programación Extrema ........................................................................................ 11 Características ..................................................................................................... 12 Prácticas de XP.................................................................................................... 14 Asterisk................................................................................................................ 19 ¿Qué es? .............................................................................................................. 21 Historia ................................................................................................................ 22 Características y Ventajas ................................................................................... 24 Asterisk como un PBX ........................................................................................ 27 Flexibilidad Vs. Configuración ........................................................................... 31 Configuración Gráfica vs Configuración de Texto ............................................. 32 Dialplans: Contextos, Extensiones, Prioridades y Aplicaciones ......................... 33 Contextos............................................................................................................. 33 Canales ................................................................................................................ 35 Extensiones.......................................................................................................... 35 Prioridades........................................................................................................... 37 Aplicaciones ........................................................................................................ 38 Dialplans.............................................................................................................. 38 Interfaces Asterisk Manager Interface y Asterisk Gateway Interface................. 39 iv Asterisk Gateway Interface ................................................................................. 40 Asterisk Manager Interface ................................................................................. 42 Ruby on Rails ...................................................................................................... 48 Filosofías ............................................................................................................. 50 Arquitectura......................................................................................................... 51 Componentes básicos .......................................................................................... 54 Active Record...................................................................................................... 54 Action Pack ......................................................................................................... 59 Gemas.................................................................................................................. 61 Características ..................................................................................................... 62 Comandos Básicos .............................................................................................. 62 Plugins ................................................................................................................. 64 Comandos Básicos .............................................................................................. 65 Pruebas ................................................................................................................ 67 Conectividad Rails - Asterisk.............................................................................. 74 Adhearsion........................................................................................................... 74 Instalación y Uso ................................................................................................. 77 Dialplans.............................................................................................................. 80 Telegraph............................................................................................................. 82 Instalación y Uso ................................................................................................. 83 Comparación Adhearsion - Telegraph ................................................................ 94 CAPÍTULO III ............................................................................................................ 97 Marco Aplicativo......................................................................................................... 97 Requerimientos Generales................................................................................... 97 Adaptación del Proceso de Desarrollo XP .......................................................... 99 Planificación........................................................................................................ 99 Diseño................................................................................................................ 100 Codificación ...................................................................................................... 100 Pruebas .............................................................................................................. 100 Feedback............................................................................................................ 101 Desarrollo de la Aplicación............................................................................... 101 Metáfora del Sistema......................................................................................... 101 Iteración 0.......................................................................................................... 104 Planificación...................................................................................................... 104 Iteración 1.......................................................................................................... 104 Planificación...................................................................................................... 105 Diseño................................................................................................................ 106 Codificación ...................................................................................................... 106 Pruebas .............................................................................................................. 109 Feedback............................................................................................................ 110 Iteración 2.......................................................................................................... 110 Planificación...................................................................................................... 111 v Diseño................................................................................................................ 111 Codificación ...................................................................................................... 112 Pruebas .............................................................................................................. 116 Feedback............................................................................................................ 119 Iteración 3.......................................................................................................... 120 Planificación...................................................................................................... 120 Diseño................................................................................................................ 121 Codificación ...................................................................................................... 122 Pruebas .............................................................................................................. 124 Feedback............................................................................................................ 128 Iteración 4.......................................................................................................... 129 Planificación...................................................................................................... 129 Diseño................................................................................................................ 129 Codificación ...................................................................................................... 130 Pruebas .............................................................................................................. 131 Feedback............................................................................................................ 134 CAPÍTULO IV .......................................................................................................... 135 Conclusiones y Recomendaciones ............................................................................ 135 REFERENCIAS ........................................................................................................ 139 CONTACTOS........................................................................................................... 146 ANEXOS................................................................................................................... 147 Glosario de términos ......................................................................................... 147 Anexo 1: Valores del Manifiesto Ágil .............................................................. 151 Anexo2: Principios del Manifiesto Ágil............................................................ 153 Anexo3: Proceso de la Programación Extrema................................................. 155 Anexo4: Prácticas de la Programación Extrema ............................................... 156 vi ÍNDICE DE GRÁFICOS Gráfico 1: Diagrama de la solución propuesta. ............................................................. 5 Gráfico 2: Esquema de interconexión de Asterisk con dispositivos internos y externos. ...................................................................................................................... 29 Gráfico 3: Esquema de interconexión entre varios PBX`s con dispositivos asociados. ..................................................................................................................................... 30 Gráfico 4: Modelo MVC ............................................................................................. 53 Gráfico 5: Modelo MVC en Rails ............................................................................... 54 Gráfico 6: Metáfora del Sistema. .............................................................................. 103 Gráfico 7: Especificación Clase AMIManager. ........................................................ 106 Gráfico 8: Diagrama de Clases, Iteración 2. ............................................................. 112 Gráfico 9: Prueba Aceptación, Pantalla Operador. ................................................... 118 Gráfico 10: Prueba Aceptación, Pantalla Supervisor (Estado Asterisk). .................. 118 Gráfico 11: Prueba Aceptación, Pantalla Supervisor (Detalle Llamada). ................. 119 Gráfico 12: Diagrama de Clases, Iteración 3. ........................................................... 121 Gráfico 13: Prueba Aceptación, Pantalla Administrador (Modo Mantenimiento). .. 128 Gráfico 14: Prueba Aceptación, Pantalla Validador (Cargar Archivo)..................... 128 Gráfico 15: Diagrama de Clases, Iteración 4. ........................................................... 129 Gráfico 16: Anexo 3, Proceso de la programación Extrema..................................... 155 Gráfico 17: Anexo 4, Prácticas de la programación Extrema. .................................. 156 vii ÍNDICE DE TABLAS Tabla 1:Extensión Asterisk. ........................................................................................ 36 Tabla 2: Componentes Extensiones Asterisk. ............................................................. 37 Tabla 3: Orden de Ejecución de Extensiones. ............................................................. 37 Tabla 4: Ejemplo de Dialplan de Asterisk................................................................... 38 Tabla 5: Paquete Ejemplo de Comunicación AMI...................................................... 42 Tabla 6: Ejemplo de Paquete de Autenticación AMI.................................................. 43 Tabla 7: Ejemplo Evento Dial. .................................................................................... 47 Tabla 8: Ejemplo Evento ExtensionStatus. ................................................................. 47 Tabla 9: Ejemplo ORM, búsqueda en base de datos por id. ....................................... 57 Tabla 10: Ejemplo ORM, guardar objeto en base de datos......................................... 57 Tabla 11: Ejemplo Listar Gemas................................................................................. 62 Tabla 12: Ejemplo Buscar Gema................................................................................. 63 Tabla 13: Ejemplo Instalar Gema................................................................................ 63 Tabla 14: Ejemplo Desinstalar Gema.......................................................................... 64 Tabla 15: Ejemplo para buscar un repositorio (Plugin). ............................................. 65 Tabla 16: Ejemplo para buscar un repositorio (Plugin/Windows). ............................. 65 Tabla 17: Ejemplo para agregar un repositorio (Plugins). .......................................... 65 Tabla 18: Ejemplo para quitar un repositorio (Plugins). ............................................. 66 Tabla 19 Ejemplo para Instalar un Plugin en el Proyecto. .......................................... 66 Tabla 20: Ejemplo de Código RSPEC. ....................................................................... 72 Tabla 21: Ejemplo 2 de Código RSPEC. .................................................................... 73 Tabla 22: Instalación Adhearsion................................................................................ 77 Tabla 23: Comunicación Adhearsion/Asterisk............................................................ 78 Tabla 24: Nuevo Proyecto Adhearsion. ...................................................................... 79 Tabla 25: Arrancar Adhearsion. .................................................................................. 80 Tabla 26: Ejemplo Dialplan de Adhearsion. ............................................................... 81 Tabla 27: Instalación Telegraph. ................................................................................. 83 Tabla 28: Comunicación Telegraph/Asterisk, AGI..................................................... 85 Tabla 29: Ejemplo Dialplan Telegraph AGI ............................................................... 85 Tabla 30: Empezando Telegraph/AMI........................................................................ 87 Tabla 31: Conexión Telegraph/Rails AMI. ................................................................. 87 Tabla 32: Iniciar Servidor AMI/Telegraph. ................................................................ 88 Tabla 33: Ejemplo Comandos Telegraph AMI. .......................................................... 88 Tabla 34: Ejemplo Funciones AMI Telegraph............................................................ 89 Tabla 35: Métodos Telegraph para consultas.............................................................. 90 Tabla 36: Métodos Telegraph para actualizaciones. ................................................... 90 Tabla 37: Métodos Telegraph para crear..................................................................... 90 Tabla 38: Métodos Telegraph para borrar. .................................................................. 91 viii Tabla 39: Empezando Telegraph Eventos AMI. ......................................................... 92 Tabla 40: Iniciar Servidor Eventos AMI Telegraph................................................... 92 Tabla 41: Funciones Eventos AMI.............................................................................. 93 Tabla 42: Cuadro comparativo Adhearsion - Telegraph. ............................................ 96 Tabla 43: Comunicación Adhearsion/Asterisk.......................................................... 107 Tabla 44: Script Adhearsion de Prueba. .................................................................... 107 Tabla 45: Comunicación Telegraph/Asterisk............................................................ 108 Tabla 46: Correcciones en Telegraph........................................................................ 109 Tabla 47: Pruebas Telegraph Iteración 1................................................................... 110 Tabla 48: Clase Central / Código Fuente Iteración 2. ............................................... 114 Tabla 49: Clase Extension / Código Fuente Iteración 2. ........................................... 115 Tabla 50: Clase Producto / Código Fuente Iteración 2. ............................................ 116 Tabla 51: Pruebas Clase Central Iteración 2. ............................................................ 117 Tabla 52: Pruebas Clase Producto Iteración 2........................................................... 117 Tabla 53: Clase Carga / Código Fuente Iteración 3. ................................................. 123 Tabla 54: Clase Mantenimiento / Código Fuente Iteración 3. .................................. 124 Tabla 55: Pruebas Clase Carga, Iteración 3. ............................................................. 125 Tabla 56: Pruebas Clase Mantenimiento, Iteración 3................................................ 126 Tabla 57: Clase AmiLogic Iteración 4. ..................................................................... 131 Tabla 58: Pruebas Clase Central y AmiLogic Iteración 4......................................... 133 ix RESUMEN En el presente Trabajo Especial de Grado se diseñó e implementó un módulo de conexión entre el framework Web Ruby on Rails y una central telefónica por software llamada Asterisk, como parte de una aplicación Web que integró elementos de la tecnología voz sobre IP (VoIP). Dicho módulo se implementó con el apoyo una herramienta que facilita el intercambio de información a bajo nivel entre dichas tecnologías, llamada Telegraph. La aplicación automatizó el proceso de oferta de productos y servicios empresariales, agilizando el proceso de contacto vía telefónica a los potenciales clientes. Durante el desarrollo se utilizó una interfaz de Asterisk llamada AMI, sobre la cual se envían y reciben comandos desde la aplicación para lograr los objetivos principales del proyecto, los cuales se listan a continuación: 1. Realización de llamadas desde la aplicación, es decir que el Software marque automáticamente un número recuperado de un repositorio de datos. 2. Monitoreo de llamadas, consiste en supervisar las llamadas realizadas. 3. Transferencia de llamadas, se transfiere una llamada en curso de una extensión a otra. 4. Estatus de Asterisk, es decir conocer el estatus de las extensiones y llamadas realizadas en Asterisk. Palabras Claves: Aplicaciones con tecnología Internet, Ruby on Rails (RoR), Programación Extrema (XP), Asterisk, Telegraph, Voz sobre IP (VoIP) 2 INTRODUCCIÓN En la actualidad, la utilización del mercadeo personalizado para ofrecer productos y servicios es la constante de las grandes corporaciones. Las Tecnologías de Información y Comunicación (TIC`s) aplicadas al mercadeo, facilitan el contacto directo, eficiente y rápido con los potenciales clientes, creando ventajas competitivas en el mundo de los negocios, reemplazando o complementando el uso de formas tradicionales de comunicación con el cliente. Productividad, eficiencia, eficacia y precisión, son los anhelos perseguidos por las organizaciones a la hora de realizar sus tareas, por lo que la automatización pasa a ser el pilar de los procesos cotidianos. La tecnología facilita las actividades corporativas, dotando a las organizaciones de mayores y mejores medios, que amplían su campo de aplicaciones e incrementan su rendimiento. Con estos planteamientos como premisas, y dada la creciente competitividad de los mercados, surge en las organizaciones la necesidad de contar con sistemas informáticos que mejoren la productividad o eficiencia en los procesos del negocio que se llevan a cabo diariamente. En el área de mercadeo ésto se traduce en el rápido y oportuno contacto con los potenciales clientes, elevando la cantidad de posibles ventas. Debido a la gran competencia en el área de mercadeo personalizado, las organizaciones requieren estar a la vanguardia tecnológica, automatizando la mayoría de los procesos que se puedan. Con el gran auge de la gran autopista cibernética como 3 se considera a Internet, y el crecimiento sostenido de las telecomunicaciones se considera la utilización de una aplicación que, valiéndose de herramientas Web y tecnologías telefónicas por software, facilite la oferta de productos y servicios mediante la realización de llamadas. En el presente proyecto se diseñó y desarrolló un módulo de una aplicación Web, utilizada para automatizar el proceso de mercadeo de productos y servicios empresariales a través de la central telefónica por software Asterisk. A nivel metodológico se seleccionó una técnica de desarrollo ágil, específicamente Programación Extrema que permite la elaboración de aplicaciones adaptables a las necesidades del cliente, lo cual favoreció para aplicar una técnica de programación orientada a pruebas. Precisamente, por su flexibilidad, sencillez y velocidad a la hora de diseñar y desarrollar aplicaciones, Ruby on Railes fue escogido como framework Web para la ejecución de este proyecto. Por su parte, Asterisk, una central telefónica por software de código abierto, fue utilizada por sus facilidades de interacción con sistemas externos. Este estudio se presenta en cuatro capítulos, siendo el primero el referido al planteamiento del problema, así como los objetivos y alcances del proyecto. En un segundo capítulo se introduce el marco teórico que sustenta a esta investigación, mientras que la metodología será abordada en un tercer capítulo. Por último se tendrán las conclusiones y recomendaciones de la investigación. 4 CAPÍTULO I PLANTEAMIENTO DEL PROBLEMA Y JUSTIFICACIÓN DEL PROYECTO Las Tecnologías de Información y Comunicación (TIC`s) al servicio del mercadeo personalizado optimizan los procesos de oferta de productos y servicios, garantizando una mejor atención a los posibles clientes. El uso de herramientas informáticas representa una solución práctica en mercados que son cada día más competitivos, pues ahorra costos de comercialización y supone mayor efectividad en la venta de los productos. Sustentándose en las ventajas que suponen las tecnologías informáticas para optimizar las tareas que componen el proceso de mercadeo telefónico, se plantea el desarrollo de una solución tecnológica que explote las potencialidades que proveen las herramientas orientadas a Web y las innovaciones de los sistemas de telefonía por software. Para dicha solución es conveniente el uso de un framework Web, ya que permite acelerar los tiempos de desarrollo a través de la reutilización de componentes, sin perder calidad en el producto. En este proyecto se utilizó Ruby on Rails por ser un framework Web de código abierto, para el desarrollo de aplicaciones Web, que combina simplicidad y precisión, codificando y configurando menos que con otros frameworks. A nivel de 5 telecomunicaciones se utilizó la central telefónica o PBX por software, Asterisk, que permite desarrollar una amplia variedad de aplicaciones telefónicas. La escogencia de estas tecnologías resultó estratégica ya que existen herramientas para implementar la comunicación e interacción entre ellas, como por ejemplo el plugin para Ruby on Rails (RoR), Telegraph, que provee una capa de abstracción para que los complejos comandos de Asterisk sean usados con facilidad en una aplicación que sea desarrollada con RoR. Entonces este proyecto comprende el desarrollo de una aplicación Web compuesta por un framework Web (RoR), un PBX (Asterisk) y una herramienta para la interconexión entre ambos (Telegraph), para automatizar los procesos que comprenden la realización de la llamadas telefónicas, supervisión de las llamadas, transferencia de llamadas y actualización constante del estado de la central telefónica. Tal como se muestra en el siguiente gráfico: Aplicación Web Modulo de Interconexión Central Telefónica (PBX) Gráfico 1: Diagrama de la solución propuesta. Fuente: Autor 6 La existencia de centrales telefónicas en sitios geográficos distantes que puedan conectarse con el mismo servidor, representó un punto a favor a la hora de escoger el modelo Web para la realización del módulo que se planteó este estudio. Además, la posibilidad de tener la aplicación en línea le brinda escalabilidad al Software, facilitando la labor de acceso a los usuarios ya que permite acceder a él de forma remota, consideración a tomar en cuenta a la hora de desarrollar la aplicación con tecnología Web. Objetivos Objetivo general 1. Diseñar y desarollar un módulo de comunicación entre el framework Web Ruby on Rails y la central telefónica por software, Asterisk, para el mercadeo de productos y servicios empresariales. Objetivos específicos 1.1. Diseñar e implementar un módulo que se comunique con la central telefónica Asterisk para el procesamiento de llamadas utilizando el plugin Telegraph como puente entre el framework Ruby on Rails y dicha central telefónica, que permita: 1.1.1. Realizar llamadas: se requiere automatizar la realización de 7 llamadas, es decir que el Software marque automáticamente un número recuperado de un repositorio de datos. 1.1.2. Monitorear llamadas: se necesita supervisar la llamada realizada por los operadores. 1.1.3. Transferir llamadas: se desea que un supervisor tenga la capacidad de transferir la llamada en curso a su extensión en un momento determinado. 1.1.4. Revisar el estatus de Asterisk: posibilidad de conocer el estatus de las extensiones y llamadas de Asterisk. 1.2. Automatizar el proceso de carga de números en el sistema. 8 CAPÍTULO II MARCO TEÓRICO Desarrollo Ágil Explicar el concepto de Desarrollo Ágil no es sencillo, ya que existe una definición clara, pero según [Agile Alliance (2001)] se plantea como un término que comprende distintas metodologías de desarrollo de software, cuyas premisas buscan satisfacer los requerimientos cambiantes de los clientes, haciendo énfasis en: • Amplia colaboración entre los programadores y los expertos en el dominio del problema. • Comunicación cara a cara por encima de la documentación escrita, es decir que promueve las reuniones personales. • Frecuentes entregas del producto, que generen un valor agregado desde el punto de vista de negocio. • Equipos de desarrollo pequeños y organizados. • Eficiente estructuración del código y del grupo de trabajo. Manifiesto Ágil Para comprender el contexto en que nacieron las conocidas metodologías de Desarrollo Ágil, es interesante remontarse al febrero de 2001 fecha en la que fueron convocados por Kent Beck (autor del libro Extreme Programming Explained), 9 numerosos críticos del modelaje de software en Snowbird, Utah para tratar sobre las crecientes vertientes de lo que hasta ese entonces le llamaban métodos “ligeros” de desarrollo de software. Tal como reseña [Folwer (2006)], sólo diecisiete de los expertos citados por Beck pudieron asistir, incluyendo al anfitrión, a la reunión donde empezó a utilizarse el término de “Métodos Ágiles” para describir estas nuevas castas. En la cita se resumieron los principios sobre los que se basan los métodos alternativos en cuatro postulados, conocidos como Manifiesto Ágil. El Manifiesto Ágil, firmado por Kent Beck, Mike Beedle, Arie van Bennekum, Alistair Cockburn, Ward Cunningham, Martin Fowler, James Grenning, Jim Highsmith, Andrew Hunt, Ron Jeffries, Jon Kern, Brian Marick, Robert C. Martin, Steve Mellor, Ken Schwaber, Jeff Sutherland y Dave Thomas, expone que: “Estamos poniendo al descubierto mejores métodos para desarrollar software, haciéndolo y ayudando a otros a que lo hagan. Con este trabajo hemos llegado a valorar: � A los individuos y su interacción, por encima de los procesos y las herramientas. � El software que funciona, por encima de la documentación exhaustiva. � La colaboración con el cliente, por encima de la negociación contractual. � La respuesta al cambio, por encima del seguimiento de un plan. Aunque hay valor en los elementos de la derecha, valoramos más los de la izquierda.” Entre los miembros más resaltados de este grupo se tienen: • Martin Fowler, investigador reconocido mundialmente en el campo del Análisis y Diseño Orientado a Objetos, UML y Patrones. • Alistair Cockburn, quien definió y documentó los Casos de Uso. 10 • Jim Highsmith, creador de la metodología ligera “Desarrollo de Software Adaptativo”. • Dave Thomas y Andrew Hunt, conocidos como “the pragmatic programmers” por su serie de libros “Pragmatic Programmer”. • Ken Beck, autor intelectual de la “Programación Extrema”, junto a Erich Gamma desarrollaron Junit (framework de prueba para Java), entre otros. • Ward Cunningham, creador del Wiki, y del clásico Repositorio de Patrones de Portland. Características del Desarrollo Ágil Según [Miller (2001)] las características del proceso ágil de desarrollo de software, tomado desde el punto de vista del tiempo de entrega, son: • Modularidad en el proceso de desarrollo. • Iterativo, con cortos ciclos, permitiendo rápidas correcciones y actualizaciones. • Ciclos en un período de tiempo de una (1) a seis (6) semanas. • Sencillez en el proceso de desarrollo, evitando tareas innecesarias. • Adaptativo, con la posibilidad de aparición de nuevos riesgos. • Proceso incremental que permite segmentar la construcción de las aplicaciones. • Orientado a las personas: se prefiere el proceso ágil enfocado a las personas que a los procesos y la tecnología. • Un ambiente de trabajo comunicativo y de colaboración. 11 Programación Extrema La Programación Extrema, mejor conocida por su nombre en inglés eXtreme Programming, de allí sus siglas (XP), es una de las llamadas Metodologías Ágiles de desarrollo. [Beck (1999-b)] explica que en este tipo programación el término “extrema” viene de tomar los principios y prácticas a niveles extremos. Señala que esta metodología ha evolucionado de los distintos problemas causados por los largos ciclos de desarrollo de los modelos tradicionales. El mismo autor explica que, en sus orígenes, la Programación Extrema comenzó como “una simple oportunidad de realizar el trabajo”, en combinación con otras prácticas de desarrollo de software que habían sido efectivas en décadas recientes. Sin embargo, [AAB (1998)] refieren que después de un número de pruebas exitosas, la metodología XP fue documentada en los principios y prácticas usadas. Según [Beck (1999-b)] XP es un proceso de desarrollo ligero, que propone el trabajo orientado directamente al objetivo, basado en las relaciones interpersonales y la velocidad de reacción. Por su parte, en el sitio Web Wikipedia se afirma que esta metodología es muy utilizada por sus fundamentos de adaptabilidad en vez de la previsibilidad. [Beck (1999-b)] propone que XP define Historias de Usuario como base del software a desarrollar. Dichas historias las escribe el cliente y describen escenarios 12 sobre el funcionamiento del software donde generalmente se describe el modelo, dominio, entre otros. [JRA (2001)] Jeffries R, Anderson A y Hendrickson C (2001) afirman que la Programación Extrema es una disciplina de desarrollo de software, basada en los valores de la simplicidad, comunicación y retroalimentación, que trabaja en un ambiente de integración del equipo de desarrollo, en presencia de prácticas sencillas, donde el cliente trabaja día a día con el grupo de desarrollo. Características En 1999, Beck refiere una serie de características de la llamada Programación Extrema, entre las cuales podemos destacar las siguientes: • Minimizar el riesgo de fallo del proceso por medio de la disposición permanente de un representante competente del cliente en el ambiente del equipo de desarrollo, que permite una retroalimentación veloz y eficaz, logrando una buena comunicación y coordinación entre los miembros del equipo y el cliente. • Trabaja bajo el esquema de entregas de funcionalidades o releases e iteraciones, por lo que se programará solo lo necesario para la entrega de ese release. En caso de que éste no se encuentre satisfecho, se adaptará el plan de releases e iteraciones hasta obtener su aprobación. Cabe destacar que, para cada entrega se discuten los objetivos con el cliente y se definen iteraciones, de corto tiempo, para cumplir con los objetivos de la entrega. Esta característica implica la integración continua del código, es decir que 13 cada funcionalidad que se desarrolla se integrará al sistema de inmediato. • Propone realizar contínuas pruebas unitarias por cada funcionalidad, de modo que se pueda corregir cualquier fallo antes de la entrega. Dichas pruebas deberían ser automatizadas y es recomendable que se escriban antes de la codificación del requerimiento. • La codificación del software en XP se produce siempre en parejas (dos programadores por ordenador), rotándolas a lo largo del proyecto, lo cual supone una mayor calidad del código. • Definir cortas iteraciones con rápidas y cortas entregas, que permiten escribir un código incremental al ir añadiendo pequeñas mejoras. • Implementar funcionalidades de la forma más sencilla posible, lo que lleva a una de sus premisas: simplicidad a la hora de escribir el código. • Refactorizar el código, lo que implica la reescritura de ciertos trozos con el fin de incrementar la legibilidad, mantenimiento y eficiencia del código. • El código es colectivo, ya que cualquier integrante del grupo puede realizar modificaciones sobre cualquier parte del código. • Documentación Limitada, es decir que no se basa en una documentación 14 exhaustiva sino sólo la necesaria para el proyecto, la cual generalmente se lleva a cabo en las últimas etapas del mismo. Prácticas de XP [Beck (1999-a)] explica que XP es una colección de ideas y prácticas tomadas de metodologías existentes. A continuación se explican las prácticas de XP según este autor: � El Juego de Planificación El programador debe estimar el esfuerzo que requiere la implementación de las historias de usuarios, luego el cliente decide el alcance y los tiempos del release en cuestión. Esta práctica se puede ilustrar como un juego, donde existen dos jugadores: Cliente y Programador, cada uno con su respectivo rol. Este juego se realiza durante la planificación de las entregas y las iteraciones. � Pequeños y Cortos Releases Se desea producir fragmentos sencillos del sistema, pero velozmente, sin importar que esto signifique que no cuenten con todas las funcionalidades pretendidas, pero que sí constituyan un valor adicional para el negocio. Nuevos releases son lanzados hasta diariamente, pero al menos una vez al mes. 15 � Metáfora [Fowler (2004)] dice que la arquitectura de XP es evolutiva y los posibles inconvenientes que se pueden generar por no contar con ella desde el comienzo del proyecto, se solventan con la existencia de la práctica conocida como la metáfora. El autor señala que “la metáfora es una práctica que consiste en formar un conjunto de nombres que actúen como vocabulario para hablar sobre el dominio del problema”. Según Fowler, el sistema es definido por una metáfora o un conjunto de metáforas compartidas entre el cliente y los programadores, lo cual guía el desarrollo describiendo el funcionamiento del sistema. � Diseño Simple XP hace énfasis en diseñar el sistema lo más simple como sea posible, tomando una solución sencilla que pueda ser implementada en el momento. Cualquier complejidad innecesaria y código extra deben ser eliminados. Al respecto, [Beck (1999-b)], explica que “en cualquier momento el diseño adecuado para el software es aquel que: supera con éxito todas las pruebas, no tiene lógica duplicada, refleja claramente la intención de implementación de los programadores y tiene el menor número posible de clases y métodos”. � Pruebas La escritura de código está dirigida por las pruebas unitarias. Las pruebas unitarias son implementadas antes de codificar el requerimiento y son ejecutadas 16 contínuamente ante cada modificación del sistema. El cliente es encargado de escribir las pruebas funcionales y vela por la validez de cada historia de usuario. En este contexto de desarrollo evolutivo y de pruebas, se hace indispensable la automatización de esta actividad. � Refactorización La refactorización es una práctica que comprende la reestructuración del código, eliminando la duplicación, simplificándolo y añadiéndole flexibilidad para permitir la escalabilidad. La refactorización refuerza la estructura interna del sistema sin cambiar su comportamiento externo. Sobre este aspecto, [Martin, R (2002)] señala que "el diseño del sistema de software es una cosa viviente. No se puede imponer todo en un inicio, pero en el transcurso del tiempo este diseño evoluciona conforme cambia las funcionalidades del sistema” � Programación en Parejas Dos personas deben codificar en un solo ordenador, este estilo de programación brinda numerosas ventajas, entre las que tenemos: • Una baja tasa de errores, ya que se detectan muchos errores tempranamente entre los compañeros. • Mayor calidad del código en menos líneas de código (se hacen mejoras inmediatas). • Los problemas se resuelven con mayor rapidez. 17 • Más de una persona conoce el código, lo que brinda velocidad a la hora del soporte. • Los programadores disfrutan más la labor de la codificación. � Código Colectivo Cualquier persona puede cambiar el código, aún si no lo haya hecho esa persona, ya que el código es de todos no pertenece a ningún integrante en particular. Esto incentiva a cada individuo del grupo a aportar con nuevas ideas y evita que algún programador sea imprescindible a la hora de cambios en el código. � Integración Contínua Cada pieza de código nuevo es integrada al sistema inmediatamente después de haberlo culminado. Las pruebas son ejecutadas antes y después del proceso de integración. La integración continua reduce el doble esfuerzo del grupo de trabajo, ya que existe más comunicación entre los integrantes que implica mayor reutilización de componentes. � 40 Horas a la Semana de Programación Se debe trabajar 40 horas a la semana como máximo. No se permite sobre tiempo en 2 semanas seguidas, si esto llegara a suceder se considera como un 18 problema. El trabajo extra trae una fuerte desventaja al desmotivar al grupo de trabajo. Proyectos que requieren sobre tiempo para intentar cumplir con los tiempos suelen ser entregados con retraso, debido a un fallo en la etapa de planificación. � Cliente en el Sitio El cliente debe estar presente y disponible para el equipo tiempo completo, si esto no es posible, se recomienda que tenga un representante siempre disponible que actué como su vocero. Una parte del éxito en un proyecto XP se debe a que el cliente conduce constantemente el trabajo para darle un mayor valor de negocio y los programadores pueden realizar cambios de manera rápida. Se considera que la comunicación oral es más efectiva que la escrita, ya que aminora el tiempo de comunicación y disminuye el riesgo de ser mal interpretada. � Estándares de Codificación Es indispensable que los programadores sigan ciertos estándares y/o reglas de codificación establecidos para el desarrollo del proyecto. Esto trae ventajas como mejoras en la comunicación de los programadores a través del código, producción de código más legible y mantenible, facilitando la realización de modificaciones. � Espacio de Trabajo Se prefiere tener una zona espaciosa con cubículos pequeños. 19 � Reglas El equipo tiene sus propias reglas a seguir, pero pueden cambiar en cualquier momento. Dichos cambios deben realizarse por acuerdos y son implementados según el impacto determinado del cambio. Asterisk El área de las telecomunicaciones es quizá una de las últimas grandes industrias que hasta el momento no había sido afectada por la revolución del “Software Libre”. La mayoría de las grandes empresas de telecomunicaciones siguen fabricando costosos, incompatibles, complicados y obsoletos sistemas de telefonía. [MJS (2005)] refiere como ejemplo de lo anterior que Nortel y su “Business Communications Manager” que corre bajo el servidor Windows NT 4.0, un switch o interruptor telefónico de aproximadamente 15 años y un PC de 700 Mhz, puede costar entre 5 y 15 mil dólares, sin incluir dispositivos extra de telefonía. Aparte se debe instalar el software de las funcionalidades “limitadas” para el funcionamiento de este dispositivo. La mayoría de los sistemas propietarios no brindan flexibilidad, no permiten incluir nuevas funcionalidades ni ofrecen escalabilidad, sino más bien pretenden implantar sistemas rígidos que obliguen al consumidor a cambiar todo el sistema en vez de re-potenciar el existente. 20 Asterisk cambia este paradigma, brindando flexibilidad y escalabilidad al cliente, tiene muy pocas limitaciones en este aspecto, siendo la mayor, la configuración del sistema. Asterisk permite implantar un sistema telefónico fabricado especialmente según las necesidades de cada consumidor. Una de las ventajas más notorias la comprende el ser distribuido bajo Software Libre. Según la [GNU (2007)], el Software Libre representa un software que respeta ciertas libertades a los usuarios, entonces una vez que se dispone, el mismo puede ser usado, estudiado, copiado, modificado y redistribuido libremente. El término puede ser confundido como software gratuito por su traducción del inglés, pero se refieren al término free, al garantizar libertades más no por ser gratis. Específicamente se refieren a 4 libertades necesarias para los usuarios del software: • Libertad de ejecutar el programa con cualquier propósito (privado, educativo, público, comercial, militar, entre otros). • Libertad de estudiar y modificar el programa. • Libertad de copiar o redistribuir el programa, de esta manera se puede ayudar al “vecino” o a cualquier otra persona. • Libertad de hacer mejoras en el programa y capacidad de publicar las mejoras, de modo que toda la comunidad se vea beneficiada de esta corrección. • Para cumplir el segundo y el cuarto punto, se tiene como precondición tener la posibilidad de acceder al código fuente, es decir que es necesario brindar al usuario acceso al código fuente para que se considere como Software Libre. 21 ¿Qué es? Según [MJS (2005)], Asterisk es una aplicación, multiplataforma, distribuida y desarrollada libremente, de una central telefónica PBX (Private Branch Exchange), liberada bajo la Licencia GPL de GNU (General Public License). Un PBX puede ser imaginado como una red privada de conmutación, conectada en un extremo a una cantidad de extensiones privadas y del otro lado, una red telefónica, usando el PBX como un conmutador de llamadas. El sistema incluye las funcionalidades asociadas a cualquier PBX propietarios, como conectar un número determinado de teléfonos para hacer llamadas entre sí o conectar con un proveedor de VoIP (Voice over Internet Protocol) o una ISDN (Integrated Services Digital Network). La central telefónica Asterisk también incluye características especiales que sólo poseen algunos PBX como: buzón de voz, distribución automática e interactiva de llamadas (Interactive Voice Response, IVR), conferencias, entre otras funcionalidades que se mencionarán más adelante. Por sus características, su flexibilidad y sus bondades para la construcción de soluciones en las telecomunicaciones, Asterisk comprende una de las herramientas telefónicas de código abierto más usada en la actualidad. También es considerado un marco de trabajo o framework que permite seleccionar y/o quitar ciertos módulos, lo que realza su flexibilidad y versatilidad, 22 facilitando diseñar un sistema telefónico hecho a la medida, lo que comprende una gran ventaja al compararlo contra los PBX propietarios, que como se comentó, son muy rígidos en este aspecto. Historia [MJS (2005)] refieren que en sus orígenes, Asterisk fue desarrollada por Mark Spencer en el año 1999, quién para ese entonces era estudiante de Ingeniería Informática en la Universidad de Auburn, Alabama. Entonces, Spencer decidió crear la empresa "Linux Support Services" con el objetivo de dar soporte a usuarios de Linux. Para lograr su misión, Spencer necesitaba una central telefónica, pero ante la imposibilidad de adquirirla dados sus elevados precios, decidió construir un software que le brindara los mismos beneficios, con sólo un PC bajo Linux y utilizando el lenguaje de programación “C”. De allí nace la idea del proyecto que dio origen a Asterisk, llamado de esta manera por el símbolo Asterisco (*), que en ambientes tales como Linux, Unix y DOS representa cualquier combinación de caracteres o un “comodín”, utilizado de igual manera en muchos otros sistemas y lenguajes de programación. El proyecto de Asterisk fue creciendo a través de los años bajo el paradigma del código abierto, por lo que programadores de diversas partes del mundo fueron 23 realizando contribuciones importantes al código de Asterisk, adicionando funcionalidades, realizando correcciones a ciertos errores y pruebas de la aplicación, entre muchas otras actividades. En el año 2002, "Linux Support Services", la empresa creada por Spencer, se convertiría en "Digium", redirigiendo sus objetivos al desarrollo y soporte de Asterisk. Spencer amplió el modelo de negocio tanto con la venta de hardware específico, fundamentalmente tarjetas de comunicación para la utilización de Asterisk, como con la venta de software propietario, entre el que destaca el "Asterisk Business Edition", aplicación basada en Asterisk a la que se le incorporan ciertas funcionalidades con derecho de autor (copyright). Uno de los grandes colaboradores para posicionar a Asterisk al sitio donde se encuentra en la actualidad, es Jim Dixon y su proyecto “Zapata Telephony”, nacido de la motivación de este ingeniero al que le interesaba mucho la interconexión entre los ordenadores y la telefonía. Y es que en primera instancia se creía que si existiera una tarjeta que pasara la información de la telefonía analógica al computador representaría un gran avance, ya que el procesamiento que se realizaba hasta el momento era a través de costosos sistemas con DSP (Digital Signal Processing) y ahora se podría llevar a cabo en el procesador del computador. Este fenómeno bajaría considerablemente los costos de los sistemas telefónicos, ya que se podría procesar la información en un computador en vez de en un costoso hardware. 24 Al pasar los años y observar que nadie había fabricado, ni planificaba la creación de dichas tarjetas, se propuso a fabricarlas él mismo y fue entonces cuando nació el proyecto conocido como “Zapata Telephony Project”. Al finalizar su construcción, compartió sus resultados con la comunidad de Software Libre, y gracias a su contribución nació la PSTN (Public Switched Telephone Network) de Asterisk, es decir la “La Red Telefónica Pública de Asterisk”. Características y Ventajas [MJS (2005)] mencionan las características telefónicas más importantes que tiene Asterisk: • Permite realizar llamadas entre extensiones conectadas a él y al exterior. • Transferencias de llamadas entre las extensiones. • Monitoreo de llamada. • Permite la conexión con un proveedor de telefonía de VoIP o RDSI. • Buzón de voz. • Grabación de la llamada. 25 • Identificador de números. • Bloqueo de números. • Distribución automática e interactiva de llamadas (“Interactive Voice Response”, IVR). • Llamadas en conferencia. Los mismos autores, en su obra Asterisk: The Future of Telephony, explican que las ventajas más notables que presenta este PBX son: • Posee soporte para voz sobre IP en numerosos protocolos tales como SIP, H.323, IAX, MGCP. • Puede establecer comunicación con casi todos los equipos estándares de telefonía. Por ejemplo, para conectar teléfonos analógicos se necesita instalar al menos una tarjeta telefónica FXS o FXO, fabricadas casi en su totalidad por la compañía de Mark Spencer, “Digium”. • Es una aplicación de código abierto con licencia GPL de GNU. Esto trae una gran ventaja porque permite que miles de desarrolladores a nivel mundial trabajen sobre este software, mejorándolo, agregándole nuevas funcionalidades, y colaborando al realizar correcciones sobre los errores. 26 • Una gran parte de la flexibilidad que brinda la aplicación se debe a la disponibilidad de modificar el código fuente, permitiendo que los desarrolladores puedan modificar el comportamiento de la aplicación y adaptarlo al problema. • Este software también presenta dentro de sus ventajas el ahorro de coste al consumidor, este aspecto es uno de los más trascendentales, y a su vez inspiró al desarrollo del sistema. Mientras que un PBX propietario puede generar gastos de varios miles de dólares, teniendo un ordenador disponible, este sistema se puede implantar con sólo cientos de dólares, lo que representa el costo de las tarjetas fabricadas por Digium. • Escalabilidad de aplicación: cualquier usuario puede agregar nuevas funcionalidades, llamadas dialplans, a través del lenguaje de script de Asterisk. Un dialplan, o plan de marcado en español, se considera el corazón de Asterisk y son los entes que definen como se va a procesar el tráfico del sistema, tanto de llamadas como de aplicaciones. Simplemente consisten de una lista de instrucciones o pasos que seguirá Asterisk durante la ejecución y comprenden la base de su configuración. Contrariamente a los sistemas PBX propietarios, los dialplans de Asterisk son hechos y modificados según la necesidad del consumidor. • Interfaces para la comunicación con otros lenguajes de programación, permitiendo añadir nuevos dialplans y/o nuevos módulos programados en el lenguaje C, escribiendo scripts en los lenguajes de programación Perl, Ruby, Phyton o cualquier otro lenguaje soportado por Linux a través del Asterisk Gateway Interface (AGI) y/o Asterisk Manager Interface (AMI). 27 • Asterisk es capaz de inter-operar con terminales IP actuando como un registrador y como puerta de enlace (gateway) entre ambos. • Multiplataforma, este software se puede ejecutar en diversos sistemas operativos, tales como Linux, Mac OS X, OpenBSD, FreeBSD, Solaris y Microsoft Windows, en referencia a este último es un caso especial ya que sólo hubo una versión de demostración, pero en realidad se dice que Asterisk no corre sobre la plataforma Microsoft. Originalmente Asterisk fue diseñado únicamente para trabajar sobre una plataforma Linux, siendo ésta la mejor soportada. Asterisk como un PBX En la historia de las telecomunicaciones, nunca se ha desarrollado un sistema que satisfaga las necesidades de cada negocio, a ningún precio. El consumidor siempre había tenido que adaptarse a las posibilidades del sistema, pero Asterisk es un sistema telefónico de PBX que revoluciona este aspecto, ya que ahora el cliente no tiene que adaptarse al sistema sino que éste se ajusta a las necesidades del cliente. Por esta razón, existen problemas en el área de la telefonía donde por los momentos sólo Asterisk puede ayudar. El éxito y la aceptación de este software ha sido muy buena y mucho más rápida que la que ocurrió con Linux. Esto se debe a varias razones: • Linux progresivamente encendió la primera llamarada hacia la aceptación 28 del Software Libre, así que para Asterisk es más sencillo seguir estos pasos. • La industria de telefonía carece de liderazgo. Es ahí donde aparece Asterisk, que tiene una visión realista, comprometida y futurista. • A lo largo del tiempo, los usuarios han sido víctimas de sistemas costosos, incompatibles, con muchas limitaciones y sin mucho soporte. Asterisk ha resuelto los primeros, por su compatibilidad, bajo costo y flexibilidad, y ha demostrado bastante pasión por resolver el último. • Asterisk es un PBX que puede ser orientado hacia la telefonía IP o la telefonía tradicional, pero generalmente es utilizado como un híbrido, conmutando llamadas, resolviendo las rutas y conectando los usuarios con el exterior a través del Internet, la telefonía analógica y con conexiones digitales (T1/E1). Entre sus características más notables tenemos las llamadas entre las estaciones, que como un PBX cualquiera ofrece. Esto significa que los usuarios pueden discar desde un teléfono a otro. Quizá parece una funcionalidad implicita, pero existen sistemas muy elementales (generalmente llamados Key) que tienen soporte para múltiples dispositivos y múltiples líneas telefónicas. Ellos permiten a los dispositivos usar cualquier línea, pero como éstos no poseen extensiones individuales, no existe manera de iniciar una llamada de una extensión a otra. Asterisk permite tanto comunicaciones directas entre extensiones internas como establecer contacto a dispositivos externos si se encuentra conectado a un proveedor de servicio, como se muestra en el siguiente gráfico: 29 Gráfico 2: Esquema de interconexión de Asterisk con dispositivos internos y externos. Fuente: Meggelen (et al. 2005) En este diagrama cada extensión que se encuentra a la izquierda del PBX puede conectarse a otra extensión discándola directamente. Esto significa que si el módem va a enviar un fax a la máquina local, los dispositivos se comunicarán directamente, a través del PBX. Para dar un ejemplo más ilustrativo, se puede imaginar dos oficinas separadas físicamente, que bien pudieran tener dos líneas telefónicas separadas, pero si ambas tienen Asterisk y una conexión a Internet, se puede realizar una configuración tal que se puedan comunicar las extensiones de cada uno de las oficinas a través de Internet, representando un ahorro de costos notable, especialmente si las oficinas están en países distintos. Inclusive se pudiera dar el caso que se reciba una llamada a la oficina A preguntando por cualquier protocolo. Si esa llamada la debe manejar el personal de la oficina B, se puede transferir la llamada a ésta oficina, pasándola a través de Internet, tal cual como se presenta en la siguiente imagen: 30 Gráfico 3: Esquema de interconexión entre varios PBX`s con dispositivos asociados. Fuente: Meggelen (et al. 2005) En el gráfico se aprecia el escenario con mayor claridad cuando entra una llamada a través de la PSTN (Public Switched Telephone Network) conectada al PBX de la oficina A, es atendida por una extensión de la oficina A y transferida a una extensión en la oficina B a través de Internet. También se puede dar el escenario donde la oficina B no tenga conexión a un proveedor de telefonía y realice sus llamadas a teléfonos externos a través de la oficina A. Estos son unos pocos ejemplos de la potencialidad que posee Asterisk con sólo una configuración adecuada usando telefonía con voz sobre IP. Tal como sostiene [GDD (2005)], con Asterisk también es posible implantar un sistema de comunicación común como el planteado en el primer escenario donde Asterisk sólo 31 se encuentre conectado a través de la telefonía tradicional, permitiendo con un poco de configuración nuevas funcionalidades utilizando VoIP. La mayoría de las compañías manejan dos redes, una para la telefonía y otra para los ordenadores. Si unimos estas dos redes en una sola comprendería un beneficio a nivel de costos, tanto en equipo como en personal. Además que a través del tiempo el hardware para los computadores y redes de ordenadores parece bajar progresivamente de precio, mientras que los sistemas propietarios de telefonía permanecen iguales. Voz sobre IP permite tener una extensión conectada siempre y cuando se disponga de una conexión veloz a Internet. Entonces una persona pudiera tener la misma extensión en su oficina y en su casa o hasta en su teléfono celular. Por éstas y otras características Asterisk está siendo implantado en muchos centros de llamadas a nivel mundial. Flexibilidad Vs. Configuración Naturalmente las ventajas y características vienen asociadas a un precio, ya que Asterisk no es un sistema simple a la hora de configuración, que quizá comprende su principal desventaja. A pesar que el software es claro y lógico, pudiendo implementar casi cualquier escenario a nivel de telefonía, cada una de las funcionalidades lleva un esfuerzo asociado, que para un principiante pudiera significar un tiempo considerable de dedicación. 32 Existe una curva de aprendizaje, pero puede ser sobrellevada con facilidad. Muchos desarrolladores se han convertido en expertos en telefonía. [GDD (2005)] explican que Asterisk no fue concebido para todos los perfiles de usuario, ya que para personas que no se quieren encargar en lo más mínimo de configuración ni instalación, esta no es la mejor opción. Es importante reflejar que aunque Asterisk tiene esta cantidad de ventajas, no es la solución adecuada para cada negocio, depende de las necesidades de cada uno, es por eso que se deben estudiar las posibilidades antes de escoger la tecnología a ser usada. Configuración Gráfica vs Configuración de Texto Actualmente la mayoría de las opciones de Asterisk se configuran a través de archivos de texto plano. Esta es una forma sencilla de crear, respaldar y modificar configuraciones para aquellos usuarios o desarrolladores que se sientan a gusto con este tipo de archivos. Existen algunos PBX que ofrecen interfaces gráficas, mejor conocidas como Graphical User Interface en inglés (GUI), para manipular su configuración. Otros PBX se configuran a través de los dispositivos conectadas a él como, por ejemplo, un teléfono, y algunos otros simplemente no pueden ser configuradas, excepto con personal certificado, que requieren de dispositivos especiales fabricados por la misma compañía de telecomunicaciones del sistema, para realizar dicha configuración. 33 Ya existen varias herramientas para instalar y configurar a Asterisk fácilmente a través de una interfaz gráfica, pero para tener la posibilidad de configurar todas las funcionalidades aún se requiere de una configuración de texto, aunque reducida. Pudiendo afirmar que la configuración de Asterisk se ha facilitado, reduciendo un poco el punto crítico que lo desvirtúa. Dialplans: Contextos, Extensiones, Prioridades y Aplicaciones Los dialplans (planes de marcado en español) están compuestos por cuatro partes principales, los contextos, las extensiones, las prioridades y las aplicaciones. Se explicarán sus componentes para luego dar una visión general de los dialplans. Contextos En Asterisk un contexto no es más que una colección de extensiones definidas por un nombre lógico. Por lo cual una misma extensión puede estar definida más de una vez, siempre y cuando se encuentre en dos contextos distintos, funcionando cada extensión de manera aislada. Estas extensiones no pueden establecer conexión a menos que se especifiqué lo contrario en Asterisk, es decir que dos contextos no se comunican al menos que se indique a nivel de configuración. Supongamos que 2 compañías comparten un mismo servidor de Asterisk, pero en las 2 compañías quieren definir sus extensiones del 1 al 10, en este momento se utilizan los contextos para separar cada lote de extensiones. Por ejemplo si en cada una de las compañías la extensión 1 es la de recepción, cuando una extensión de la compañía A marque 1, con la diferenciación de contextos, se asegura que se esté 34 comunicando con la recepcionista de la compañía A y no se confunda con las extensiones de la compañía B. Los contextos son denotados por un nombre de caracteres dentro de corchetes ([]). Nombre que puede estar compuesto por combinaciones de letras desde a “A” hasta la “Z”, mayúsculas o minúsculas, dígitos del 0 al 9 y ciertos caracteres especiales. En la página Web Asterisk Dialplan Introduction (2003), se explica que un contexto podría estar compuesto de cualquier cantidad de extensiones, un ejemplo sencillo podría ser (no como se configura en Asterisk): Context [prueba]: Extension Description 101 Edgar 102 Omar 103 Andrés 104 Chequear Contestadora 105 Salón de Conferencias 0 Recepción En el ejemplo se define un contexto llamado “prueba”, donde las primeras 3 extensiones, de la 101 a la 103, están asociadas a distintos empleados, la extensión 104 para solicitar consulta sobre el contestador automático, la quinta extensión con su número 105 pertenecería al salón de conferencias, finalmente la última definida con el número 0 asociada a la recepción. El sitio Web [Asterisk Dialplan Introduction (2003)], señala que los contextos pueden ser útiles al implementar ciertas configuraciones, tales como: • Seguridad: Con restricción sobre las llamadas salientes, dependiendo de la 35 extensión. • Enrutando: Según la extensión se pueden enrutar las llamdas. • Respuesta automática: Dar un mensaje automático, donde el usuario indique la extensión a comunicar. • Menús multinivel: Menús para ventas, soportes, entre otros, en una institución. • Autenticación: Preguntar por contraseñas para ciertas extensiones. Asterisk al recibir una llamada desde afuera o desde una extensión interna, las asocia a un contexto, el cual depende del canal en el que la llamada se recibió. Esto es posible ya que al configurar los canales en Asterisk, se define el contexto asociado a cada uno de ellos. Canales Según [Asterisk channels (2003)], un canal en Asterisk es una conexión que se asocia a una llamada cuando esta entra a Asterisk. Dicha conexión pudiera estar asociada a un teléfono, línea de teléfono, o a una llamada lógica (como una llamada a través de Internet). Se debe tomar en cuenta que cada llamada es colocada o recibida en un canal distinto, lo cual conforma un identificador único para esa llamada. Extensiones En cada contexto se definen una o más extensiones. A pesar que las extensiones generalmente son usadas para especificar cada de las extensiones 36 telefónicas, al igual que en los PBX tradicionales, en Asterisk pueden ser usadas para más que un simple identificador. Según [MJS (2005)], una extensión puede ser una instrucción que Asterisk va a seguir y es disparada por una llamada entrante o por una serie de dígitos marcados en un canal. Las extensiones especifican que sucede con una llamada cuando se manejan en el dialplan. La sintaxis para una extensión es la palabra “exten”, seguida de una flecha, de la siguiente manera: Instrucción de Asterisk: exten => Tabla 1:Extensión Asterisk. Colocándose luego el identificador de la extensión. A pesar que tradicionalmente se piensa en una extensión como un número, en Asterisk podemos definir identificadores como combinación de números y letras. Una extensión está compuesta por 3 componentes: • El identificador de la extensión • La prioridad • La aplicación o comando que es llamado Cada uno de los componentes separados por comas, por ejemplo: 37 Componentes de la extensión: exten => 123,1,Answer() Tabla 2: Componentes Extensiones Asterisk. En el ejemplo el identificador de la extensión es “123”, la prioridad es “1” y la aplicación es “Answer()”. Existe una extensión especial para Asterisk llamada “s”. Cuando una llamada entra a un contexto sin una extensión específica destino, son manejadas automáticamente por la extensión “s”. La “s” viene del término en inglés “start” (comienzo), ya que la mayoría de las llamadas empiezan su curso en la extensión “s”. Prioridades [MJS (2005)], comenta que cada extensión puede tener varios pasos, llamados prioridades. Cada prioridad es numerada secuencialmente, empezando desde el número uno (1). Cada prioridad se ejecuta en una aplicación específica. Por ejemplo: Prioridades de extensiones: exten => 123,1,Answer( ) exten => 123,2,Hangup( ) Tabla 3: Orden de Ejecución de Extensiones. En el ejemplo la extensión con la prioridad uno ejecuta su aplicación 38 (Contestar el teléfono) y luego se cuelga con la ejecución de la aplicación (Hangup()) que tiene asignada la prioridad dos. Aplicaciones [MJS (2005)], explica que una aplicación es el código que se ejecuta o la acción a tomar en el canal actual, tal como reproducir un sonido, leer una opción de usuario, responder o colgar la llamada, entre otras. Algunas aplicaciones como las expuestas en el punto anterior llamadas Answer() y Hangup(), que significan responder y colgar una llamada respectivamente, son algunas de las más usadas en el PBX. A estas aplicaciones no se les pasa ningún parámetro, más existen aplicaciones que llevan parámetros y tal cual como las funciones en la mayoría de los lenguajes de programación, son colocados dentro de paréntesis y separados por comas. Dialplans Finalmente la unión de las piezas (prioridades, aplicaciones, extensiones y contextos) se arman para formar lo que se llama en Asterisk, un dialplan. Un ejemplo sencillo puede ser: Dialplan ejemplo: [entrante] exten => s,1,Answer( ) exten => s,2,Playback(bienvenido) exten => s,3,Hangup( ) exten => 123,1,Answer() Tabla 4: Ejemplo de Dialplan de Asterisk. 39 En el ejemplo tenemos tres extensiones con el identificador “s”, cuyo funcionamiento fue comentado anteriormente y una extensión con el identificador “123”. Tomando como premisa que las llamadas se asocian al contexto “entrante”, cualquier llamada con un destino distinto a la extensión “123” pasará por la secuencia de aplicaciones Answer(), que contestará la llamada, Playback(hello-world), aplicación encargada de reproducir un archivo de sonido llamado hello-world y finalmente ejecutando Hangup(), aplicación que colgará la llamada. Pero si la llamada va dirigida hacia la extensión “123”, se ejecutará únicamente la aplicación Answer(). Interfaces Asterisk Manager Interface y Asterisk Gateway Interface Una de las facilidades de las que provee Asterisk son las interfaces de comunicación con ese framework, que permiten flexibilidad y escalabilidad. Esas interfaces son: Asterisk Gateway Interface (AGI) y Asterisk Manager Interface (AMI). AGI es una interfaz que permite establecer un intercambio de datos entre Asterisk y código escrito en un lenguaje de programación que tenga la capacidad de escribir al STDOUT (salida estándar) y leer del STDIN (entrada estándar), para tomar decisiones de enrutamiento y ejecución de aplicaciones y/o llamadas que se encuentren activas en Asterisk. AMI por su parte, da un control sobre el funcionamiento del sistema de 40 Asterisk; permitiendo conectarnos al framework por medio de un socket TCP desde cualquier lenguaje con soporte para sockets. Al recibir notificaciones sobre eventos que ocurren en Asterisk tales como información sobre las llamadas activas, sobre las extensiones, entre otros; así como emitiendo acciones que se ejecuten en Asterisk, como por ejemplo, realizar, colgar o transferir una llamada. Asterisk Gateway Interface Según [MJS (2005)], la interfaz Asterisk Gateway Interface (AGI), provee un estándar de conexión desde programas externos hacia el funcionamiento de Asterisk. Los scripts o conjunto de instrucciones son usados para agregarle una lógica avanzada al sistema de Asterisk, como lograr comunicación con bases de datos (tales como PostgreSQL o MySQL), o utilizar otros recursos externos. Dichos códigos pueden ser escritos en distintos lenguajes de programación tales como Perl, PHP, C, Pascal, Ruby, entre otros, dependiendo de la elección del desarrollador. También plantea que el sistema pasa el control desde el dialplan de Asterisk a un lenguaje externo a través de AGI, permitiendo la realización de tareas que serían muy difíciles o casi imposibles de implementar con Asterisk. Los scripts AGI se comunican con Asterisk a través de canales (apuntadores a archivos) conocidos como STDIN, STDOUT, y STDERR que pueden ser interpretados en Unix como la entrada estándar, la salida estándar y la salida de error estándar, respectivamente. Así, un código AGI lee del STDIN para tomar información de Asterisk, 41 escribe datos en el STDOUT para enviar información a Asterisk y puede escribir en el STDERR para enviar información de traza a la consola de Asterisk. Desde luego que se necesita una porción de configuración en Asterisk para lograr la comunicación efectiva a través de esta interfaz. Esta interfaz fue desarrollada para permitir que una aplicación externa a Asterisk tome el control sobre el flujo de la llamada, permitiendo desvíos, respuestas automáticas y otras modificaciones sobre la llamada. Esto pensando en los avances de los lenguajes de script y los beneficios que esto podría significar para el área de las centrales telefónicas, por ejemplo, la implementación sencilla de un centro de llamada o un IVR de manera programada. Valiéndose de la ventaja que significa la manipulación del flujo desde algún lenguaje externo, ya que proveen soportes para conexiones a bases de datos, rutinas externas, pase de información, entre otros aspectos que salen del alcance de Asterisk. En el sitio Web [Asterisk AGI (2003)], explican que la interfaz fue concebida para la distribución de llamadas recibidas a la central telefónica, mas no para la realización de llamadas asíncronas. Pero Asterisk brinda soporte para la realización de llamadas asíncronas por otros métodos que estudiaremos a continuación. Si se desea iniciar una llamada asíncrona con Asterisk, se tienen dos posibilidades: • Escribiendo un archivo de texto (.call) que iniciará una llamada automática a través de Asterisk, acción llamada auto-dial out. • Usando un comando llamado originate, que pudiera ser ejecutado a través el Asterisk Manager Interface, o AMI. 42 Asterisk Manager Interface La Web [AMAPI (2003)] explica que Asterisk Manager Interface (AMI), permite que una aplicación cliente, establezca comunicación con una instancia de Asterisk, y le envíe comandos o lea eventos del PBX a través de un flujo sobre TCP/IP. Esto resulta útil a la hora de realizar consultas sobre el estado de Asterisk o dar ciertas reglas que pudieran implicar la ejecución de un comando, aplicación, entre otras. Por su parte, en la página Web [UsingAMI (2007)], se afirma que ésta es una forma de conectarse a Asterisk desde una aplicación externa que permite consultar y manipular la información del PBX en un tiempo determinado. En el sitio Web [AMAPI (2003)] enfatizan que la interfaz utiliza un protocolo de comunicación para el intercambio de información entre la aplicación y el PBX, con previa autenticación. Para un conjunto de líneas se usará el término “paquete”, el cual es terminado con una línea en blanco, es decir con 2 saltos de línea seguidos. Dichos paquetes vienen dados de la siguiente forma: Paquete ejemplo de AMI: Action: <tipo de acción> <CRLF> <Key 1>: <valor 1> <CRLF> <Key 2>: <valor 2> <CRLF> ... <Variable>: <valor> <CRLF> <Variable>: <valor> <CRLF> ... <CRLF> Tabla 5: Paquete Ejemplo de Comunicación AMI. 43 Por ejemplo, para autenticarse con el sistema, se enviaría un paquete con este formato: Paquete ejemplo de autenticación AMI: Action: login <CRLF> Username: carlos <CRLF> Secret: good <CRLF> <CRLF> Tabla 6: Ejemplo de Paquete de Autenticación AMI. En este paquete el campo login es la acción a realizar, seguido del nombre de usuario y la contraseña de la cuenta a autenticar. En el sitio Web [AMAPI (2003)] mencionan algunas características del protocolo, entre las cuales encontramos: • Antes de empezar a enviar comandos a Asterisk, se debe establecer una sesión, es decir autenticarse contra el sistema. • Luego se pueden enviar paquetes en cualquier instante, sin importar la dirección, es decir si van a viajar del cliente al servidor Asterisk o viceversa. • La primera línea del paquete debe tener la acción cuando es enviado desde la aplicación, pero cuando lo envía Asterisk debe ser un evento o una respuesta a la aplicación cliente. • El orden de las líneas dentro del paquete es insignificante. • Los caracteres CR y LF son usados para delimitar cada línea. • Una línea en blanco indica el fin de un paquete. 44 En el mismo sitio de Internet, se señalan tres tipos de paquetes, entre los cuales se encuentran los paquetes de acción, de respuesta y de evento, a continuación se dará una breve descripción de cada uno: • Acción: un paquete enviado por un cliente de Asterisk conectado, pidiendo que una acción en particular sea ejecutada. Hay un conjunto finito pero extensible de acciones disponibles para los clientes, determinadas por los módulos cargados en Asterisk para ese momento. Solo se puede ejecutar una acción a la vez. Los paquetes de acción contienen tanto el nombre como los parámetros de la operación a ser ejecutada. • Respuesta: paquete de respuesta enviado por Asterisk, devolviendo el resultado al último paquete de acción entregado por el cliente. • Evento: paquete de data pertinente de un evento o cambio generado en Asterisk, como por ejemplo el cambio de estado de una extensión de Asterisk, cambio de estado de un canal, entre otros. [MJS (2005)] señala que para alcanzar la comunicación entre Asterisk y la aplicación externa a través de AMI, es necesario poseer una cuenta en Asterisk sobre la cual se autenticará la información. Dicha cuenta es una simple entrada en el archivo de configuración de Asterisk, manager.conf. También explica [MJS (2005)] que la aplicación cliente envía paquetes de acción al servidor de Asterisk, quien los recibe, procesa, realiza las operaciones adecuadas y le envía de vuelta a la aplicación cliente el resultado (error o éxito), en un 45 paquete de respuesta. Los paquetes incluyen un identificador para poder realizar la correspondencia sobre las acciones y respuestas. Por su parte, en la página de Internet [AMAPI (2003)] se explica que los paquetes de evento son usados bajo dos escenarios: • En primer lugar cuando Asterisk cambia de estado, es decir que hay un cambio en el sistema (una extensión es colgada o alguien es autenticado en el sistema, entre otras), Asterisk envía un paquete de evento informando el cambio. • El segundo escenario se da cuando la aplicación le envía un paquete a Asterisk solicitando información sobre el sistema y Asterisk le contesta con un paquete de respuesta que contiene: “Response: Follows” indicando éxito. Luego son enviados cero o más paquetes de evento con la información del sistema que solicitó el cliente seguido de una respuesta del cliente en una acción, indicando que toda la data fue enviada correctamente. A continuación se presentan las acciones más resaltantes tomadas del sitio de Internet [AMAPI (2003)]: • Command: Acción para ejecutar un comando específico de la consola de Asterisk. • ExtensionState: Devuelve el estado en que se encuentra una extensión específica. • Hangup: Cuelga un canal • Logoff: Termina la sesión iniciada con el sistema 46 • Monitor: Grabar la conversación de un canal. • Originate: Realiza una nueva llamada. • Redirect: Transfiere una llamada a otra extensión. • Status: Muestra el estado del sistema. Como se comentó anteriormente, existen dos escenarios para el envío de paquetes de eventos, desde Asterisk hacia la aplicación externa. Una posibilidad comprenden los paquetes asíncronos informativos sobre cambios, conocidos como eventos AMI. En este caso lo que sucede es simplemente un proceso de difusión de la información. En el sitio Web de [AME (2003)], se explica que dado un cambio dentro de Asterisk, se genera un evento que el PBX difundirá a través de su interfaz AMI en un formato específico. De esta manera las aplicaciones externas a Asterisk son capaces de conocer cualquier evento que sucede dentro del PBX casi al instante del mismo, ya que reciben un mensaje asíncrono desde Asterisk. Los paquetes de eventos llegan a distintos métodos de la aplicación. Según el método, la aplicación pudiera tomar una acción u otra dependiendo de lo que quiera lograr al momento del evento. A continuación se explican algunos eventos: • Dial --- Evento de marcado [derivado o disparado desde app_dial.c] 47 Ejemplo del mensaje: Ejemplo de evento cuando se marca un número en Asterisk: Event: Dial Evento Privilege: call,all Privilegio Source: Local/900@default,2 Fuente Destination: SIP/900-4c21 Destino CallerID: <unknown> Identificador de llamada CallerIDName: default Identificador de llamada SrcUniqueID: 1149161705.2 Identificador de la fuente DestUniqueID: 1149161705.4 Identificador del destino Tabla 7: Ejemplo Evento Dial. • ExtensionStatus --- Evento del estatus de la extensión [derivado o disparado desde manager.c] Ejemplo del mensaje: Ejemplo de evento de cambio de estatus de extensión en Asterisk: Event: ExtensionStatus Evento Exten: <ext> Extensión Context: <context> Contexto Status: <state> Estatus Tabla 8: Ejemplo Evento ExtensionStatus. En todos los mensajes viaja al principio del paquete el tipo del evento, luego viajan una serie de parámetros distintos dependiendo del evento que se genere. En este último caso tenemos que el tipo de evento es “ExtensionStatus”, que tiene tres parámetros, el primero “Exten” que tiene la información de la extensión que sufrió el cambio de estado, “Context” que tiene el contexto en el que se encuentra y “Status”, variable que contiene el estatus en el cual quedó la extensión que sufrió el cambio. 48 Ruby on Rails Ruby on Rails, conocido también como RoR o Rails, es un framework de aplicaciones Web escrito en el lenguaje de programación Ruby, que como se afirma en la página Web Wikipedia (2007), se apega al paradigma de la arquitectura Modelo Vista Controlador (MVC). Según [TDH (2006)] Ruby on Rails es un framework cuyo lema es facilitar el desarrollo, despliego y mantenimiento de aplicaciones Web. Persigue combinar simplicidad con la posibilidad de desarrollar escribiendo menos líneas de código que utilizando otros frameworks. Aproximadamente al año de ser lanzado al público (en 2004), Rails pasó de ser un framework desconocido a un fenómeno a nivel mundial, convirtiéndose en una de las mejores opciones a la hora de implementar aplicaciones Web. Para dar una perspectiva de esta evolución, se puede mencionar que pasó de ser usado por sólo hackers, a utilizarse como framework de desarrollo en compañías transnacionales a nivel mundial, según reseña [TDH (2006)]. Las aplicaciones implementadas con esta tecnología siguen una arquitectura MVC, igual que las desarrolladas usando frameworks como Tapestry y Struts basados en Java. [TDH (2006)] destaca como otro de los puntos claves de Rails el referido a las pruebas. Los programadores escriben pruebas para desarrollar una aplicación de calidad y Rails facilita la implementación de este tipo de pruebas, por lo que cualquier 49 aplicación Rails provee soporte para pruebas dentro del mismo framework. Por cada funcionalidad, RoR crea de manera automática con su herramienta de generación de código, un esqueleto de las pruebas del requerimiento, trozos que pudieran considerarse como una plantilla para desarrollar las pruebas. La facilidad de escribir y ejecutar las pruebas, trae como resultado que las aplicaciones desarrolladas tiendan a ser probadas. Los desarrollos en RoR son escritos en el lenguaje de programación Ruby. Tal como se señala en el sitio Web [Acerca de Ruby (2007)], Ruby es un lenguaje de scripting orientado a objetos, caracterizado por ser claro y conciso, donde el desarrollador puede expresar las ideas de forma limpia y natural. La sencillez a la hora de programar facilita retomar un código que fue escrito en tiempo pasado, dando legibilidad y claridad. El lenguaje fue creado en el año 1993 por Yukihiro Matsumoto, programador japonés conocido en el gremio informático como “Matz”. Su creador alega que tomó partes de sus lenguajes favoritos (Perl, Smalltalk, Eiffel, Ada y Lisp) que permitieran el diseño de un nuevo lenguaje que equilibra la programación funcional con la imperativa. El el sitio Web [Acerca de Ruby (2007)], señala que el lenguaje Ruby permite la metaprogramación, que consiste en generar o manipular programas a partir de otro programa, es decir que un código tenga la capacidad de modificar o generar un programa. Esto permite al programador ahorrar tiempo en la producción de código, de la cual Rails hace uso, lo que resulta en una sintaxis que muchos de sus usuarios 50 encuentran legible. El lenguaje combina una sintaxis inspirada en Perl, orientado a objetos similar a Smalltalk que comparte funcionalidades con algunos lenguajes de programación como Python, Lisp, Dylan y CLU. Ruby se vale de su característica orientada a objetos, teniendo hasta los números y los literales como objetos. Es un lenguaje de programación interpretado y su implementación es distribuida bajo la licencia de software libre GNU GPL. Filosofías Rails tiene vertientes claras de como una aplicación Web debería estar compuesta y organizada, además de la forma en que los subsistemas deberían configurarse e integrarse. Distinto a los frameworks Java que existen actualmente que basan su integración en archivos de configuración XML, una de las filosofías más acentuadas de Rails es la Convención sobre configuración. Ruby on Rails reemplaza la configuración masiva de archivos XML por una convención de nombres consistentes y rutas estándares para los distintos tipos de archivos usados en una aplicación Rails. Un ejemplo de esta práctica es la presente en la conexión con la base de datos, y es que según las convenciones de Rails, las tablas de las bases de datos deberían ser nombradas en plural y las clases en singular, entonces las clases User y Call tendrían por tablas a users y calls respectivamente, y su clave primaria en cada tabla conocido por el nombre id. Tal y como se presenta la convención en este caso, también sucede en muchos otros casos en las que se necesita la integración de los distintos elementos de la aplicación. 51 Cuando se diseña una aplicación partiendo de cero sin una base de datos preexistente, el seguir las convenciones de Rails significa usar menos código (aunque el comportamiento puede ser configurado si el sistema debe ser compatible con un sistema heredado). Otro de los principios fundamentales en Ruby on Rails es expresado comúnmente como DRY, por sus siglas en inglés Don't Repeat Yourself, en español significa no te repitas, cuya idea es minimizar la duplicación de código. Este principio plantea que las definiciones deberían hacerse una sola vez, ya que cuando se tiene código duplicado en la aplicación y es descubierto un error en él, habría que cambiar el defecto en numerosos lugares. Al reutilizar el código se minimiza el impacto de estos cambios a un sólo punto. [TDH (2006)] destaca que la combinación de las filosofías Rails en conjunto: la meta-programación, los plugins, las bondades y características del lenguaje Ruby, hacen de Rails un poderoso framework para el desarrollo de aplicaciones Web. Rails saca provecho de Ruby, facilitándole al programador el desarrollo de aplicaciones, permitiendo que la codificación sea considerablemente más corta y legible. Arquitectura En 1979 el Licenciado en Computación noruego, Trygve Mikkjel Heyerdahl Reenskaug, de 49 años de edad, propuso el Modelo Vista Controlador (MVC), un 52 nuevo diseño para el desarrollo de aplicaciones interactivas dividido en tres tipos de componentes: • Modelos. Comprenden los entes responsables del estado de la aplicación, en ocasiones estados transitorios durando sólo el tiempo de interactividad del usuario. En otros casos el estado es permanente, persistiendo generalmente en repositorios de datos. Un modelo es más que simplemente datos, comprende toda la lógica de negocio que es aplicada a esa data. Como se comentó, en Rails cada tabla es representada por un modelo asociado a ella, siendo el rol principal del modelo la implementación de métodos de consulta a la base de datos, comúnmente llamados querys, validaciones y actualizaciones a la base de datos. • Vistas. Son los componentes encargados de generar una interfaz de usuario, generalmente presentando los datos obtenidos de los modelos. Por ejemplo en una aplicación de una tienda se tiene una lista de productos disponibles. Dicha lista sería construida en un modelo de la aplicación, pero la vista estaría encargada de acceder la colección y definir un formato para su presentación al usuario final. • Controladores. Este componente es quien organiza y dirige la aplicación. Los controladores reciben eventos desde el exterior del sistema, interactúan con el modelo y le devuelve la vista apropiada al usuario. Tal como explica [TDH (2006)], estos tres componentes forman la arquitectura conocida como MVC, en el gráfico 3 se muestra el funcionamiento en términos abstractos. MVC es sólo un patrón que involucra separación del código de un modo específico para facilitarle ciertos aspectos al programador. 53 Gráfico 4: Modelo MVC Fuente: [TDH (2006)] En sus orígenes la plantilla MVC fue concebida únicamente para aplicaciones convencionales (Stand-alone) con interfaces de usuario, donde se descubrió que la separación de roles implicaba menor acoplamiento, un código más sencillo y mantenible con cada acción en el lugar correcto. Esta estructura provee una base o esqueleto de la aplicación, sobre la cual es más sencillo trabajar. Con el auge de las aplicaciones Web, los programadores retrocedieron, usando el obsoleto modelo monolítico donde se mezclaban la lógica de negocio, la presentación, el manejo de eventos y el acceso a repositorio de datos en un solo lugar. Luego, se empezó a experimentar y desarrollar aplicaciones Web con arquitecturas que intentaban separar el código, tal como lo propone el patrón MVC. El resultado fueron frameworks como WebObjects, Struts y Java Server Faces, todos basados en el modelo MVC. Rails provee una estructura para las aplicaciones donde se desarrollan modelos, vistas y controladores por separado, y los va integrando mientras se va Controlador Base de datos Modelo Vista 54 ejecutando el código. En la figura 4 se muestra el funcionamiento de Rails cuando recibe una petición. Según [Dave Astels (2007)], en una aplicación Rails los eventos de entrada son enviados primero a un enrutador (1), encargado de decidir quién será el componente que va a manejar dicha petición. Luego se identifica qué método se va a ejecutar en el controlador (2), la acción pudiera capturar la data de la petición e interactuar con el modelo (3). Eventualmente una acción preparará la data para la vista (4) que va a mostrarle al usuario. Gráfico 5: Modelo MVC en Rails Fuente: [TDH (2006)] Componentes básicos Active Record En la actualidad la mayoría de las aplicaciones desean persistir información en una base de datos relacional, hasta los sistemas poco estructurados como blogs y páginas de noticias usan este tipo de repositorios para guardar su información. Enrutador Controlador Modelo Vista Base de datos 1 2 3 4 5 55 Con el auge de los lenguajes de programación orientados a objeto, se ha presentado una dificultad al asociarlos con una base de datos relacional. Las base de datos a diferencia de los objetos se basa en conjuntos de valores agrupados, mientras que los objetos tienen sentido usando datos y operaciones. Existen dos tendencias al organizar la data en un sistema conciliando el paradigma orientado a objetos y el relacional, la primera consiste en organizar el programa alrededor de la base de datos (Programación centrada en la base de datos), el segundo al contrario organiza la base de datos alrededor del programa (ORM - Object/Relational Mapping). � Programación centrada en la base de datos En sus orígenes, la programación contra bases de datos relacionales se venía haciendo en lenguajes procedimentales tales como C y Cobol, y se realizaba escribiendo trozos de lenguaje SQL embebidos/empotrados dentro del código fuente, lo que producía una integración entre la lógica del código y la interacción con la base de datos. Este tipo de programación es común entre lenguajes de scripting como PHP, Perl y en Ruby también es usado. Es considerado la concepción ideal para pequeñas aplicaciones. Pero existe un problema: al mezclar la lógica de negocio junto con los accesos a la base de datos se pueden causar problemas de mantenimiento del código que pudieran traer graves repercusiones a la hora de agregar nuevos requerimientos o 56 modificar los ya existentes en el programa, teniendo duplicación de código no deseable en el mismo. El paradigma orientado a objetos nos ha enseñado que la encapsulación de los datos resuelve este problema. Al seguirlo, tendríamos un código más mantenible, que a la hora de un cambio se realizaría la modificación en un solo lugar del código. Luego se llevo el principio a la programación centrada en base de datos, encapsulando el acceso a la base de datos en clases. La aplicación se comunicaría a la base de datos a través de las clases. Práctica que fue bautizada con el acrónimo: ORM, del inglés Object/Relational Mapping o Asociación Objeto/Relacional. � Asociación Objeto/Relacional Las bibliotecas ORM se encuentran encargadas de asociar las tablas de las bases de datos a clases. Por ejemplo, si una base de datos tiene una tabla llamada productos, el programa va a tener una clase llamada Producto. Las filas en la tabla corresponderían a distintos objetos de la clase y los atributos serían usados para obtener e introducir los valores de las columnas. Las clases de Rails proveen métodos de operaciones sobre las tablas, por ejemplo, si se quiere buscar un producto específico en una tabla de productos. Simplemente se debe llamar a un método propio de la clase que devuelve el objeto según su identificador o algún atributo en especial. Si se busca por el atributo id, el código sería algo como: 57 Código ejemplo para buscar en la base de datos con id=1: producto = Producto.find(1) Objeto Clase función identificador Tabla 9: Ejemplo ORM, búsqueda en base de datos por id. También se tienen otras funciones que actualizan la base de datos (save, update). Probablemente la más usada es la función save, que guarda un objeto en la base de datos, en el caso que sea un objeto previamente recuperado y no sea nuevo, simplemente actualiza su estado en la base de datos. El código podría ser algo como: Código ejemplo para guardar en la base de datos un producto: producto.descuento = 0.5 producto.save Objeto Método Tabla 10: Ejemplo ORM, guardar objeto en base de datos. ORM relaciona tablas con clases, filas con objetos y columnas con atributos de esos objetos. Generalmente en la biblioteca de ORM se especifica la configuración para establecer la conexión entre la base de datos y las clases del programa. Active Record es la capa ORM (Object/Relational Mapping) que provee el framework Rails. Sigue al pie de la letra el estándar del modelo ORM: asociando 58 tablas con clases, filas con objetos y columnas con los atributos de los objetos como se reflejó anteriormente. La diferencia con respecto a las otras bibliotecas de ORM es en la forma que es configurado. Active Record se basa en el principio de convención sobre configuración para lograr esta conexión para minimizar la cantidad de configuración para los desarrolladores. En este caso la clase se asocia con la tabla teniendo el mismo nombre en plural como en el caso que se mencionó de la tabla users y la clase User. Entonces la labor de Active Record es de conectar los objetos del negocio y las tablas de la base de datos. Lograr la persistencia del dominio donde la lógica y la data sean envueltas en un solo sitio. Active Record es una implementación del patrón ORM y fue descrito por Fowler, tal como se reseña en el sitio Web [Active Record (2006)]: “Un objeto que envuelve una fila en una base de dato o una vista, encapsula el acceso a la base de datos y añade la lógica del dominio en esa data”. Este componente también brinda soporte de validaciones sofisticadas, inclusive, en una sola línea de código se puede extraer y aplicar el formato de errores o validar. En fin, tal como se plantea en [TDH (2006)], Active Record es la parte que describe el modelo en Rails de la arquitectura MVC. Active Record implementa lo que es llamado CRUD, siglas de (Create, Read/Retrieve, Update, Delete) en inglés, en español Crear, Obtener, Actualizar y Borrar. Acrónimo usado para referirse a las funciones básicas de bases de datos o de la capa de persistencia en un sistema. En algunos textos, se utilizan las siglas ABM para lo mismo (Alta Baja Modificación), obviando la operación de Obtener.. 59 Action Pack La vista y el controlador son partes del MVC que se encuentran estrechamente unidas. El controlador provee data a la vista, y el controlador recibe eventos desde la página generada por las vistas. Por esta causa el manejo de vistas y controladores en Rails dependen de un solo componente, Action Pack. A pesar que en Rails estas piezas (vista, controlador) se encuentran fusionados en un solo componente, se respeta la separación que propone el patrón Modelo Vista Controlador. � Vista En Rails la vista es responsable de generar la página que será mostrada en el navegador, es decir el código HTML que usualmente va a ser desplegado. Usualmente se quiere incluir contenido dinámico creado por alguna acción del controlador. En Rails el contenido dinámico es generado por plantillas que vienen dadas por tres grandes vertientes. La más usada es llamada RHTML que consiste de un código HTML con código Ruby embebido. De está vertiente se han desarrollado diversas mejoras como HAML que simplifica el largo y enredado código de la plantilla RHTML. Según la página en Internet de [HAML (2007)], HAML es un plugin -los 60 cuales serán discutidos más adelante- para la generación de vistas en las aplicaciones Rails y está basado en el principio “El Marcado debe ser bonito” del inglés Markup should be beautiful. Más no es simplemente por la belleza del código, sino para ser usado en ambientes altamente productivos (“La belleza lo hace más rápido”). HAML brinda una solución al problema del lento y repetitivo código de las plantillas. La segunda plantilla es llamada RXML, que permite la construcción de documentos XML usando código Ruby, siendo RJS la tercera plantilla permitiendo crear fragmentos JavaScript en el servidor para luego ser ejecutados en el navegador, está última es muy usada para crear vistas dinámicas con Ajax. Este soporte es muy flexible, pero en ocasiones puede violentar el patrón MVC. Embebiendo código en la vista se corre el riesgo de colocar código que debería estar en el modelo o el controlador, por lo que es labor del desarrollador prestar especial cuidado separando las labores de cada componente de la aplicación. � Controlador El controlador es quien orquesta la lógica de la aplicación, coordinando la interacción entre los usuarios, las vistas y el modelo. No obstante, Rails maneja internamente la mayoría de esta interacción facilitando el desarrollo y el mantenimiento de los controladores. Los controladores presentan un conjunto de servicios importantes, dentro de los cuales conseguimos: 61 • Enrutar peticiones externas hacia acciones internas, manejando URL`s sencillos. • Acelerar el proceso de respuesta manejando cache. • Manejar las sesiones. Gemas Según el sitio Web [RubyGems Manual (2007)], una gema es una aplicación Ruby empaquetada, o biblioteca de Ruby, que tiene un nombre y una versión definida. RubyGems es el nombre del proyecto que fue responsable del desarrollo de esta herramienta, su proceso de instalación es muy sencillo y se resume simplemente en descargar el paquete de un sitio Web en Internet y ejecutar el comando Ruby setup.rb cuando se está parado en el directorio de la descarga. Las gemas son manejadas en el ordenador usando el comando gem, permitiendo instalar, desinstalar y hacer búsquedas de paquetes o bibliotecas local o remotamente. Dicha herramienta funciona como un gestor de paquetes para Ruby, proporcionando un formato estándar y auto-contenido (gem) para distribuir programas o bibliotecas en Ruby, dando facilidades para manejar la instalación de los paquetes y su distribución. Es, por tanto, equivalente al papel que juegan CPAN y PEAR en los lenguajes Perl y PHP, respectivamente. 62 Características • Sencilla instalación y desinstalación de los paquetes y sus dependencias. • Manejo y control de paquetes locales. • Manejo de dependencias entre paquetes. • Buscar y listar paquetes locales y remotos. • Soporte para múltiples versiones de los paquetes instalados. • Interfaz Web para consultar la documentación de las gemas instaladas. • Interfaz sencilla para la construcción de paquetes. • Servidor sencillo para la distribución de paquetes. Comandos Básicos En esta sección se mencionarán los comandos más usados de la herramienta gem, dando una breve explicación de su funcionamiento. 1. Cuando se quiere buscar o listar simplemente basta con ejecutar: Ejemplo para listar Gemas: Gem query --remote #Atajo: gem q –R Tabla 11: Ejemplo Listar Gemas. Lo cual retornará una lista detallada de todas las gemas que se encuentran en el servidor remoto. Si se quiere depurar la lista y buscar una 63 gema específica basta simplemente con agregar la opción --name-matches y el nombre, ejemplo si queremos buscar un paquete llamado activerecord simplemente ejecutaríamos: Ejemplo para buscar Gema: gem query --remote --name-matches activerecord #Atajo: gem q -R -n activerecord Tabla 12: Ejemplo Buscar Gema. Esto retornará una lista de las gemas que coinciden con el nombre que fue especificado. 2. Si se desea instalar una nueva gema, simplemente se debe ejecutar el comando install seguido del nombre de la gema, por ejemplo si deseamos instalar un paquete llamado progressbar se debe ejecutar: Ejemplo para instalar una Gema: gem install --remote progressbar #Atajo: gem i -R progressbar Tabla 13: Ejemplo Instalar Gema. Finalmente para desinstalar una gema simplemente se ejecuta uninstall y el nombre de la gema, por ejemplo si se quisiera desinstalar la gema instalada en el comando anterior se ejecutaría: 64 Ejemplo para desinstalar una Gema: gem uninstall progressbar Tabla 14: Ejemplo Desinstalar Gema. Plugins Según [Wikipedia (2007)], un plugin (del inglés plug-in: “enchufar”, también conocido como addin o addon) es una aplicación informática que le aporta una función o utilidad específica a otra aplicación. Se utilizan como una forma de expandir programas de manera modular, permitiendo la inclusión de nuevas funcionalidades sin afectar a las ya existentes ni complicar el desarrollo del programa principal. Según [TDH (2006)], en Rails un plugin es una extensión o modificación del núcleo del framework y proveen: • Una forma de compartir ideas entre los desarrolladores, sin afectar el código base de cada proyecto. • Una arquitectura segmentada de manera que cada bloque de código pueda ser arreglado o modificado en el momento más conveniente. • Una ayuda para el núcleo de los desarrolladores, de modo que no estén obligados a incluir cada una de las nuevas características que día a día se van agregando en Rails, es decir, que al instalar Rails no se instalen todas las mejoras que existen sino que quede a potestad del programador si la necesita o no. 65 Comandos Básicos 1. Para buscar los repositorios (donde residen plugins) basta con ejecutar en la ruta de un proyecto: Buscar un repositorio de plugins: Rails script/plugin discover Tabla 15: Ejemplo para buscar un repositorio (Plugin). Mientras que para Windows (en todos los casos) se invierte la barra y se agrega el prefijo Ruby, es decir: Buscar un repositorio de plugins en Windows: Ruby script\plugin discover Tabla 16: Ejemplo para buscar un repositorio (Plugin/Windows). 2. Para agregar un repositorio de plugins, simplemente se ejecuta el comando source seguida de la URL donde se encuentra el repositorio, de esta forma: Agregar un repositorio de plugins: script/plugin source svn://Rubyforge.org/var/svn/expressica/plugins/ Tabla 17: Ejemplo para agregar un repositorio (Plugins). 66 3. Para quitar un repositorio: Quitar un repositorio de plugins: script/plugin unsource svn://Rubyforge.org/var/svn/expressica/plugins/ Tabla 18: Ejemplo para quitar un repositorio (Plugins). 4. Para instalar un plugin específico en un proyecto Rails, debemos navegar hasta la ruta del proyecto y ejecutar el comando install seguido del nombre del plugin (si se encuentra en un repositorio conocido) o del URL donde se aloja, ejemplo: Instalar un plugin en el proyecto: script/plugin install haml (si se tiene un repositorio con ese plugin incluido) ó script/plugin install svn://Rubyforge.org/var/svn/Telegraph/trunk (especificando el URL del plugin) Tabla 19 Ejemplo para Instalar un Plugin en el Proyecto. Se debe tener instalado subversion (SVN) y se debe cuidar el nombre del proyecto ya que si contiene espacios el proceso fallará. Se puede encontrar una diversidad de plugins para Rails disponibles para instalar en un proyecto, de los más utilizados en la actualidad tenemos: 67 � acts_as_rateable, plugin utilizado para asociarle un ranking a los modelos de ActiveRecord, indicador que puede usarse para realizar búsquedas, ordenamientos, entre otros. Este plugin se encuentra disponible en la siguiente URL: http://rateableplugin.Rubyforge.org � Acts as Authenticated, plugin utilizado para agregar restricciones de acceso a la aplicación de una manera sencilla. El plugin se encuentra disponible en la siguiente URL: http://technoweenie.stikipad.com/plugins/show/Acts+as+Authentic ated � RSpec on Rails, plugin que incluye las permite realizarle pruebas Spec al código de la aplicación. El plugin se encuentra disponible en la siguiente URL: http://rspec.Rubyforge.org Pruebas Según [Wikipedia (2007)], las pruebas de software son procesos que permiten verificar y revelar la calidad de una aplicación, de modo de identificar fallas o errores de implementación. Dichas Pruebas se integran dentro de las diferentes fases del ciclo de desarrollo del software. La calidad de un sistema es algo subjetivo que depende del contexto y del objeto que se pretenda conseguir. Para determinar dicho nivel de calidad se deben efectuar unas medidas o pruebas que permitan comprobar el grado de cumplimiento respecto a las especificaciones del sistema. 68 En el [RubyGems Manual (2007)] se plantea que las pruebas de software son colecciones de preguntas y escenarios que si devuelven un resultado consistente, se considera una aplicación que se responde según lo esperado. Informalmente hablando, las pruebas se escriben para interrogar y tantear una aplicación según un comportamiento esperado. Por ejemplo se podrían tener pruebas como: • Asegurar que un nombre tenga al menos 4 caracteres • Asegurar que el impuesto es del 9 % • Asegurar que al hacer una petición, el servidor despliegue la página correcta La idea de codificar las pruebas comprende agilizar y automatizar el proceso de desarrollo, ya que cada vez que crece una aplicación, probablemente se modifican clases existentes. Clases que funcionaban correctamente y quizá dejen de hacerlo. Anteriormente con las pruebas manuales se perdería mucho tiempo aplicándolas cada vez que haya una modificación, pero con las pruebas automatizadas, simplemente se vuelven a ejecutar después del cambio y verificar si se “rompió” algo en el camino. Existen diversos tipos de prueba, entre los cuales encontramos: • Pruebas unitarias • Pruebas funcionales • Pruebas de integración 69 • Pruebas de validación • Pruebas de sistema • Pruebas de caja blanca • Pruebas de caja negra • Pruebas de aceptación En el sitio Web [A Guide to Testing the Rails (2007)] se explica que al probar un código se tiene un porcentaje más elevado de certeza que se ha hecho un buen trabajo, brindándonos robustez, confiabilidad, minimizando los riesgos de fallos. Ésta última se considera una de las principales razones para aplicar pruebas al código. Además si se han codificado correctamente las pruebas, en cualquier iteración del desarrollo podemos saber: • Qué procesos funcionan correctamente. • Qué procesos presentan errores. • Qué efecto tiene la agregación de un nuevo módulo en la aplicación. Otra ventaja que nos brinda la codificación de pruebas es que a partir de allí se puede obtener la documentación del funcionamiento básico de la aplicación. Con estudiar los archivos de pruebas, se puede tener una idea del la labor que lleva un objeto en especial. Rails facilita la implementación de ciertos tipos de pruebas como las pruebas unitarias, pruebas funcionales y de integración. 70 La labor de las pruebas unitarias consiste en verificar el comportamiento de una clase a la vez, es decir que se encarga de probar cada método que se encuentra dentro de la clase que se está probando. En Rails Test::Unit es el módulo más conocido encargado de realizar las pruebas unitarias. Una prueba funcional es una prueba basada en la ejecución, revisión y retroalimentación de las funcionalidades, de allí su nombre, previamente diseñadas para el software. Las pruebas funcionales se hacen mediante el diseño de modelos de prueba que buscan evaluar cada una de las opciones con las que cuenta el paquete informático. En Rails las pruebas funcionales son utilizadas para realizar pruebas de controladores, verificar las interacciones de estos con las clases del Modelo. Test::Unit provee soporte para este tipo de pruebas. Finalmente, están las pruebas integrales o pruebas de integración, son aquellas que se realizan en el ámbito del desarrollo de software una vez que se han aprobado todas las pruebas unitarias de un módulo. Únicamente se refieren a la prueba o pruebas de todos los elementos unitarios que componen un proceso, hecha en conjunto, de una sola vez. En Rails las pruebas de integración fueron incluidas en la versión 1.1, pues su propósito recae en la verificación de las interacciones entre distintas acciones de la aplicación, a través de todos los controladores del sistema. Existe una técnica de programación orientada a pruebas llamada Test-Driven Development (TDD por sus siglas en inglés), que tiene su fundamento en la realización de los casos de pruebas que cubrirán las nuevas funcionalidades. Dichas 71 pruebas son codificadas al principio, escribiendo el código del requerimiento posterior a las pruebas. Esto garantiza que al finalizar la codificación el requerimiento, estos pasen las pruebas propuestas, tal como se señala en el sitio [Web Wikipedia (2007)]. En la actualidad se encuentra en auge una técnica que se considera una evolución sobre el TDD, llamada Behavior Driven Development (BDD por sus siglas en inglés). Según la página en Internet [Behaviour Driven Development (2007)], BDD consiste en el desarrollo de software realizando preguntas sobre el comportamiento de una aplicación antes y durante el proceso de desarrollo. El BDD direcciona los requerimientos y las especificaciones en un modo más textual, realizando preguntas como: “¿Qué debería llevar a cabo esta aplicación?” o “¿Qué labor debería realizar este modulo?” los desarrolladores son capaces de identificar fallos en su entendimiento del dominio del problema. Gracias a la técnica antes descrita, al enfocarnos en el comportamiento de las aplicaciones, se intenta crear un vocabulario común entre los integrantes de las distintas disciplinas en el proyecto. Entonces, busca minimizar los malos entendidos entre los expertos del dominio del problema y los expertos en tecnología tratando de resolver los requerimientos con una terminología clara y consistente. En el sitio Web [Behaviour Driven Development (2007)] se enfatiza que para verificar el comportamiento de una aplicación durante y después del proceso de desarrollo el código es sometido a pruebas de comportamiento. Dichas pruebas deberían responder e ilustrar el funcionamiento de la aplicación. 72 Por su parte, [Astels (2007)] destaca que la técnica contempla la codificación de especificaciones que describen el comportamiento en una forma clara, concisa, ejecutable y sin ambigüedades. Entonces en vez de escribir pruebas se plasman especificaciones sobre como el código debería comportarse. El sitio Web [RSpec Doc (2007)], refiere que en Ruby se puede implementar la técnica de la cual se viene hablando (BDD) de una forma sencilla, utilizando el framework Rspec, herramienta que le provee al programador un lenguaje específico de dominio para describir el comportamiento de un código Ruby a través de ejemplos ejecutables que sirven de guía en el proceso de desarrollo, documentación y pruebas de la aplicación. Esta herramienta también se puede incluir como un plugin en Rails para facilitar el uso a los programadores que quieren empezar a utilizarla. Un ejemplo de lo antes descrito es suponer que se está en conversación con un cliente sobre un desarrollo para un banco, donde un trozo de conversación podría ser: • Desarrollador: Describir una cuenta cuando es creada por primera vez. • Cliente: Debería tener saldo de 0 BsF. Traducido en Rspec podría ser algo como: Ejemplo de prueba RSPEC: describe Cuenta, " cuando es creada por primera vez" do it "debería tener saldo de 0 BsF" do ... end end Tabla 20: Ejemplo de Código RSPEC. Con este trozo de código se busca describir como se comporta una cuenta cuando se crea por primera vez en el sistema. El método devuelve un objeto de tipo 73 examplegroup, el cual no es más que un conjunto de ejemplos para simular un comportamiento particular de un sistema. En un ejemplo más completo se podría tener: Ejemplo completo de prueba RSPEC: describe Cuenta, " cuando es creada por primera vez" do before do @cuenta = Cuenta.new end it "debería tener saldo de 0 BsF" do @cuenta.saldo.should eql(0) end after do @cuenta = nil end end Tabla 21: Ejemplo 2 de Código RSPEC. En el ejemplo el método “it” devuelve un objeto de tipo ejemplo que representa un ejemplo del comportamiento que se desea describir. Mientras que los métodos “before” y “after” son utilizados para inicializar el estado de ciertos objetos antes que cada ejemplo sea ejecutado y liberar cualquier recurso después que cada ejemplo sea ejecutado, respectivamente. Cuando se ejecuta la especificación, se define el método should, el cual es encargado de la comparación de los objetos del sistema y le da sentido a la herramienta. Éste método junto a su opuesto (should_not), pueden tomar como parámetro una expresión a evaluar, llamada Expression Matcher. Durante la ejecución de esta función se realiza un llamado al método “matches?”, que es quién realiza la comparación a bajo nivel. Si este último devuelve verdadero, el ejemplo pasa y la ejecución continúa, pero si devuelve falso, el ejemplo falla, especificando un 74 mensaje de error retornado por matcher.failure_message. En el sitio Web [Rspec (2007)] se explica que Rspec también brinda soporte para la creación de Mocks y/o Stubs, objetos que son utilizados para simular el comportamiento de cualquier objeto real que pudiera interactuar en un momento dado con la aplicación. Estos objetos son muy utilizados por los desarrolladores cuando la aplicación interactúa con un sistema externo que no se tiene a disposición, pero su comportamiento es conocido. Los Mocks y los Stubs son similares, pero hay una diferencia semántica a la hora de su creación. Conectividad Rails - Asterisk Adhearsion Adhearsion es un framework que fue escrito en Ruby, de código abierto, cuyo propósito reside en facilitar la unión o conexión entre distintas tecnologías. Dicho framework integra uno de los principales PBXs de la actualidad como lo es Asterisk, con Ruby a través de las interfaces AMI y AGI como se explicó en el segundo capítulo, especialmente orientado a la escritura de aplicaciones con la interfaz AGI. Este framework fue diseñado para entender de manera sencilla los elementos de VoIP, mejorándolos e integrándolos en una solución coherente. Alguna de las tareas que son mejoradas con el uso del framework son: • Escribir instrucciones que procesan llamadas • Funcionalidades VoIP 75 • Colaboración con tecnologías más allá de VoIP • Integración de bases de datos para aplicaciones de VoIP • Integración con funcionalidades internas de Asterisk Adhearsion facilita a los programadores el diseño e implementación de aplicaciones aún sin haber tenido experiencia trabajando con tecnologías de VoIP, con un uso intuitivo y permitiendo descargar alguna solución pre-hecha e implantarla. Con la arquitectura extendida del framework, las funcionalidades de VoIP se pueden masificar con facilidad por su sencillez en la implementación. Adhearsion posee una cantidad de extensiones que pueden ser usadas de manera sencilla, brindando funcionalidades adicionales como integración con mensajería instantánea (Jabber/XMPP), en servidor para controlar el PBX de forma remota, entre otras. Todo esto en cualquier parte del framework, ya que Adhearsion “adhiere” estas tecnologías entre sí, que comprende una de las funcionalidades fundamentales de Adhearsion, inclusive es sencillo integrar extensiones propias del programador. Además el framework incluye un amplio conjunto de características, funcionalidades más implementadas por cada una de las aplicaciones de esta área. Una de las grandes ventajas de Adhearsion, es su integración y asociación con las bases de datos relacionales, ya que se basa en la relación de objetos y base de datos que fue desarrollado para Ruby on Rails. Valiéndose de esto, es muy sencillo integrar VoIP con una base de datos, donde una tabla en la base de datos llamada “usuarios”, se asocia con el objeto “Usuario” y cada columna de la tabla es una propiedad representativa del objeto, tal como se comentó en el capítulo anterior. 76 También se basa en el mismo principio que Rails al aplicar DRY (Don't Repeat Yourself), mencionado en el capítulo anterior. Adhearsion emplea un lenguaje de dominio específico orientado hacia VoIP, sin dejar de ser código Ruby completamente válido. Por ejemplo en un plan de llamado se tiene acceso a variables preestablecidas tales como “extension” o “callerid” (correspondientes a la extensión e identificador de llamada respectivamente) para cada llamada. Para acceder a las variables de bajo nivel propias de Asterisk, se tiene el objeto “PBX”, que envuelve la idea física del PBX. Entonces por ejemplo se puede hacer llamados a variables propias de Asterisk como lo es sip_users de esta forma: PBX.sip_users, que retorna información desde Asterisk. Esta comprende una de las grandes virtudes de este framework, ya que en el ejemplo ni siquiera se necesitaba información del uso apropiado de la interfaz con Asterisk (AMI), explicada en capítulos anteriores, sino que lo hace transparentemente para el programador, de forma de facilitarle la labor que se lleva a cabo a bajo nivel. Al igual que Ruby, Adhearsion buscan mejorar la productividad de los programadores permitiéndole realizar aplicaciones de manera rápida y sencilla. Actualmente Adhearsion es un software en versión beta, lo que en parte constituye una de sus desventajas, puesto que para llevar una aplicación a producción con Adhearsion, se deben hacer un conjunto adecuado de pruebas, pero el proyecto tiene su sistema de reporte de errores, lo que promueve que cada día sea más robusto y eficaz, incentivando al usuario a reportar y ayudar con errores que pudiera tener el framework. 77 Instalación y Uso Al igual que la mayoría de los otros proyectos de Ruby, Adhearsion usa el manejador de paquetes RubyGems, esto reduce el proceso de instalación del framework a la ejecución de un simple comando gem install, simplificando el tradicional des-empaquetamiento, posibilidad que se puede usar si no se instala RubyGems. Entonces se ejecutaría: Instalación Adhearsion: gem install Adhearsion --include-dependencies Tabla 22: Instalación Adhearsion. Con este comando además de la instalación del framework , RubyGems crea el comando ahn, comando de Adhearsion que permite crear nuevos proyectos para Adhearsion. También da la oportunidad de ejecutar el framework, instalar extensiones para Adhearsion, leer la documentación, entre otros. Para entender un poco más el funcionamiento de la integración Asterisk- Adhearsion, cuando llega a una llamada al servidor Asterisk, éste actúa como una especie de núcleo a bajo nivel para la llamada que transfiere el flujo a Adhearsion que se encarga de la lógica que se le va a aplicar a la llamada, entre las acciones que se pueden tomas tenemos: transferir la llamada, reproducir un mensaje, persistir información, entre otra gama de posibilidades. Esto lo logra estableciendo desde Asterisk una conexión TCP (por la cual se comunican) a un proceso de Adhearsion que ejecuta comandos y devuelve una respuesta con la acción. 78 Para establecer la comunicación entre Asterisk y Adhearsion solo hace falta un mínimo de configuración en Asterisk, una entrada en el archivo de configuración de las extensiones de usuarios, llamado extensions.conf. Por ejemplos si los usuarios se encuentran asociados con el contexto por defecto llamado “internal”, se modificaría de la siguiente forma: Para la comunicación Adhearsion y Asterisk: [internal] exten => _X.,1,AGI(agi://192.168.1.1) Tabla 23: Comunicación Adhearsion/Asterisk. • La primera línea indica el contexto, en este caso llamado “internal”. • En la línea siguiente encontramos la instrucción “exten=>”, comando requerido como prefijo a cada instrucción de llamada en enxtensions.conf. • Los caracteres “_X.” comprenden la expresión que denota la secuencia de números a ser capturados. Donde el carácter “_” indica que es un patrón en vez de ser un conjunto estático y la “X” representa cualquier número (0-9) mientras que el punto (“.”) indica que cualquier cantidad de repeticiones. Lo que en conjunto representa “el patrón de cualquier número con cualquier cantidad de repeticiones”. Entonces en este contexto cualquier número que sea procesado es redireccionado a Adhearsion. • Después de la coma aparece un número que indica la prioridad de la instrucción. • Finalmente, después de la segunda coma, tenemos la instrucción que se va a ejecutar que en este caso tenemos el comando AGI con un parámetro 79 “agi://192.168.1.1” indicando que otra aplicación va a procesar la llamada, y el parámetro es el URI que le indica a Asterisk que busque la IP especificada para ejecutar la aplicación, por lo que se debe colocar la IP donde se encuentra Adhearsion en ejecución (No es recomendado usar nombres de máquinas sino su IP). El siguiente paso es crear un nuevo proyecto de Adhearsion, por ejemplo: Nuevo Proyecto de Adhearsion: ahn create prueba Tabla 24: Nuevo Proyecto Adhearsion. Esto creará un nuevo proyecto que tendrá una estructura como: config/ extensions.rb helpers/ LICENSE logs/ Rakefile • La carpeta config es donde reside la configuración de la aplicación Adhearsion, incluyendo cualquier extensión del framework que se haya instalado. • El archivo extensions.rb es donde residen los planes de marcado (“dialplans”), más adelante se verá un ejemplo. • La carpeta helpers contiene todas las extensiones instaladas para la aplicación específica en la que se haya instalado. Dichas extensiones agregan funcionalidades útiles a la aplicación, pueden ser instaladas y/o desintaladas. El código fuente se encuentra en esta ruta en caso que se 80 necesiten modificar. • El archivo LICENSE contiene una copia de la licencia (GPL v2) por la cual se rige Adhearsion. • La carpeta logs contiene la bitácora de la aplicación. • Finalmente el Rakefile es el archivo del “rake”. Rake es un comando Ruby que automatiza ciertas tareas. Para arrancar la aplicación Adhearsion solo se debe ejecutar el comando ahn start con la ruta donde se encuenta el proyecto, por ejemplo: Nuevo Proyecto de Adhearsion: ahn start /prueba Tabla 25: Arrancar Adhearsion. Dialplans Finalmente se va a discutir sobre el código en si que se ejecuta cuando la aplicación es puesta en marcha y es pasado el procesamiento a Adhearsion. Como se comentó, el código va ubicado en el archivo extensions.rb que se encuentra en la ruta config en el proyecto de Adhearsion. Tradicionalmente los programadores podían enrutar llamadas en Asterisk de dos formas, la primera modificando directamente el archivo de configuración de Asterisk extensions.conf o escribiendo una aplicación aparte en un lenguaje de 81 scripting y usar el AGI para la comunicación. Un ejemplo sencillo de un plan de marcado o dialplan en Adhearsion podría verse algo como: Ejemplo de dialplan de Adhearsion: # File extensions.rb internal { case extension when 101...200 employee = User.find_by_extension extension dial employee voicemail when 888 play weather_report("Dallas Texas") end } Tabla 26: Ejemplo Dialplan de Adhearsion. El código esta escrito en lenguaje Ruby. Los fundamentos de Ruby permiten la modificación en el funcionamiento del lenguaje, convirtiéndose en un lenguaje particular según la necesidad, sin perder los beneficios del lenguaje Base (Ruby). En el ejemplo mostrado anteriormente Adhearsion relaciona directamente por convención el flujo del contexto llamado “internal” que como se explicó debe haber sido configurado en el archivo extensions.conf de Asterisk. Estudiando el código notamos la flexibilidad de Ruby con respecto a los rangos ya que se tiene un case con una condición de un rango entre 101 y 200 sin complicaciones. En la próxima línea se nota la convención con respecto a los objetos de la base de datos, ejecutando una consulta normal. Infiriendo que hay una colección de usuarios y extensiones. 82 También se observa la sencillez, que es uno de los factores de la creación de este framework. Finalmente tenemos una gama de funcionalidades de Adhearsion que nos simplifica el trabajo, como lo son la función dial para realizar una llamada a una extensión, voicemail para activar el contestador automático y play para reproducir sonidos. Existen otros métodos que se pueden usar a la hora de codificar un dialplan. Telegraph Telegraph es un plugin de Rails de código abierto, escrito en Ruby que permite la utilización de forma sencilla de las interfaces AGI y AMI de Asterisk. Funciona como un puente entre Rails y Asterisk, aprovechando la sencillez de Rails combinándolo con voz sobre IP (VoIP). Telegraph extiende el API de Asterisk, permitiendo el desarrollo de aplicaciones Web basadas VoIP de una forma rápida y sencilla al estilo de Rails usando el patrón MVC. Entre sus características más importantes tenemos: • La integración de funciones de la interfaz AGI en un controlador cualquiera de Rails. • Un modelo para el acceso a la interfaz AMI de Asterisk con funciones sencillas. • Soporte para recibir los eventos AMI. • Servidor proxy AMI que se comunica directamente con Asterisk. 83 Las aplicaciones hechas en Telegraph son sencillas de desarrollar, producir y mantener además de ser hechas en una forma robusta y escalable, ya que son realizadas bajo la filosofía de Rails. Telegraph maneja los comandos AMI de la aplicación a través de un proceso independiente (Drb), biblioteca Ruby utilizada para invocar objetos remotos, tal como se ejecutan en Java RMI y/o CORBA. Telegraph fue inspirado en centros de llamados distribuidos complejos, que existen realmente y su código es basado en un proyecto llamado RAGI y otros proyectos Ruby-AMI. Instalación y Uso La instalación es muy simple, ya que por ser un plugin lo único que se necesita es instalarlo en un proyecto Rails. Tal como se explicó en el capítulo anterior, basta con ejecutar un comando en la ruta del proyecto al que se quiere agregar, por ejemplo: Instalación de Telegraph: script/plugin install svn://Rubyforge.org/var/svn/Telegraph/trunk Tabla 27: Instalación Telegraph. Luego se debe definir que funcionalidad de Telegraph se va a implantar, como ya se comentó Telegraph soporta las dos grandes vertientes de comunicación de Asterisk con aplicaciones externas, que son las interfaces AGI y AMI, además brinda 84 soporte para los AMI Eventos o eventos AMI generados por Asterisk. � AGI Al igual que Adhearsion brinda soporte para la integración con Asterisk a través de la interfaz AGI de manera sencilla, de modo de crear una aplicación donde se quiere controlar el flujo de llamadas entrantes (IVR). Pero en vez de escribir largos dialplans, la meta es desarrollar aplicaciones similares a las aplicaciones Web basadas en MVC, de modo que al momento de redireccionar el flujo de una llamada, con Telegraph direccionamos de un controlador a una “voz”, que es la analogía de una “vista” en el MVC tal como lo hacemos en una aplicación Web. De esta forma se puede integrar en el mismo código la lógica de la aplicación Web y la lógica de la aplicación basada en voz. La petición AGI se comporta igual que las peticiones estándares de Rails, se diferencian cuando se va a mostrar la “vista”, ya que se debe capturar un objeto especial de voz (tipo MIME) que usa el API de Telegraph para mostrar la data aprovechando las ventajas de Rails durante el camino. Para lograr la comunicación entre Asterisk y la aplicación, se realiza un mínimo de configuración en Asterisk de modo que envíe la petición a través de la interfaz. De modo que se agrega una entrada en el archivo de configuración extensions.conf de Asterisk según el contexto, al igual que en el ejemplo con Adhearsion, supongamos que existe un contexto llamado “internal”, debemos colocar algo como: 85 Comunicación de Telegraph y Asterisk a través de AGI: [internal] exten => _X.,1,AGI(agi://192.168.1.1/controlador/index) Tabla 28: Comunicación Telegraph/Asterisk, AGI. El significado de las entradas son exactamente los mismos explicados en la sección anterior, por lo que se pasará directamente a un ejemplo práctico de la manipulación del flujo de una llamada, supongamos que queremos redireccionar una llamada a un archivo de sonido llamado “atender”, simplemente se debe tener un controlador parecido al siguiente código Rails: Ejemplo dialplan de Telegraph AGI: class ControladorController < ApplicationController def index respond_to do |ayuda| ayuda.html { render } ayuda.voice { render_voice do |voice| voice.play_sound "atender" end } end end end ) Tabla 29: Ejemplo Dialplan Telegraph AGI En principio se instancia el bloque respond_to para capturar el objeto de voz (tipo MIME), luego añadimos un “helper” para la voz (ayuda.voz). Seguidamente se llama al la función render_voice propia de Telegraph, junto a un bloque. Dentro de ese bloque insertamos el código de la “vista” o la “voz”, usando el lenguaje específico de dominio de Telegraph, en este caso el bloque simplemente llama a la 86 función “play”, para reproducir un archivo. � AMI Esta interfaz se debe usar cuando se quiere entablar una comunicación asíncrona con Asterisk, enviándole peticiones de acciones a realizar en Asterisk, por ejemplo iniciar una llamada saliente, conocer el estado de las llamadas en curso y otra gama de peticiones que se pueden realizar. AMI (Asterisk Manager Interface) como se mencionó en capítulos anteriores es una de las formas que tiene Asterisk de interacción con aplicaciones externas. Interfaz que permite realizar distinto tipo de consultas y comandos, tales como: • Consultar el estatus de algún dispositivo. • Modificación de parámetros en una llamada saliente. • Eventos de estatus hacia las aplicaciones, soportado en Telegraph por los eventos AMI. El API que provee el plugin es robusto, escondiendo la complejidad de bajo nivel de enviar, recibir y “parsear” métodos AMI tras un modelo de uso sencillo escrito en Ruby. Los métodos AMI realizan cuatro trabajos fundamentales: obtener información, crear objetos, actualizar objetos y borrar o destruir objetos. Como se mencionó en el capítulo anterior estas son las cuatro acciones básicas de los registros (CRUD). El modelo es accesible en cualquier parte de la aplicación Web. 87 Para empezar a usar la interfaz primero se debe crear el modelo del que se ha venido hablando, para eso se debería ejecutar en la ruta del proyecto el siguiente comando: Empezando con Telegraph AMI: script/generate ami_model MiModelo Tabla 30: Empezando Telegraph/AMI. En el ejemplo script/generate es un comando para la generación automática de código en Rails, con ami_model se especifica que se quiere generar el modelo AMI y finalmente “MiModelo” que es el nombre del modelo a generar. Luego se le debe indicar al proyecto de Rails que se debe conectar con Asterisk en el archivo de configuración del proyecto confit/enviroment.rb, se debe colocar una entrada como: Conexión de Telegraph y Rails AMI: Telegraph::AMIManager.establish_connection!(:host=> '192.168.1.1', :username=>'usuario', :secret=>'contraseña') Tabla 31: Conexión Telegraph/Rails AMI. Para llevar a cabo la acción explicada se debe tener configurado en Asterisk un nombre de usuario y una contraseña en el archivo manager.conf tal como se ilustró en el capítulo de Asterisk. En este ejemplo Telegraph::AMIManager.establish_connection! es la función de Telegraph encargada de realizar la conexión, seguida de una lista de parámetros. El primero es host, que indica el nombre o IP de la máquina a la que se quiere conectar, 88 luego se especifica el nombre de usuario y la contraseña (username y secret respectivamente) que corresponden a las entradas que se deben tener en el manager.conf de Asterisk. Finalmente se debe ejecutar el comando que inicia el servidor que funciona como puente entre la aplicación Rails y Asterisk: Iniciar servidor AMI en Telegraph: script/ami_server Tabla 32: Iniciar Servidor AMI/Telegraph. En este momento ya se tiene conectado Rails y Asterisk a través de la interfaz AMI. Como se comentó anteriormente, las funciones AMI de Telegraph se basan en el concepto CRUD al igual que Rails, entonces la invocación de métodos es similar a los de Rails, usando el modelo AMI. Luego se especifica una lista de parámetros, siendo el primero la operación que se quiere realizar en Asterisk, por ejemplo: Ejemplo comandos de Telegraph AMI: estatus = MiModelo.find(:sip_peer, :peer=>'SIP/usuario_prueba') Lista_estatus = MiModelo.find(:all_sip_peers) MiModelo.create(:call,:channel=>'SIP/usuario_prueba', :context=>'internal', :exten => 'xxxx', :priority=>1) Tabla 33: Ejemplo Comandos Telegraph AMI. En estos ejemplos se puede ver que comprende un modelo estático con el mismo nombre con el que fue generado, seguido de un método de la clase con su lista de parámetros. En el primero se llama a la función find (obtener), especificando como operación sip_show_peer de AMI y como último parámetro sobre quien se desea 89 hacer la consulta. El segundo ejemplo solo tiene 1 parámetro que indica que se va a llamar a una operación de AMI sin parámetros (all_sip_peers), esta operación devuelve una lista de todas las extensiones existentes en Asterisk. En el último ejemplo se llama a la función create (crear) y como primer parámetro call especificando un canal (channel), contexto (context), extensión (exten) y prioridad (priority), esta función de Asterisk inicia una llamada nueva por el canal dado usando el contexto y la prioridad especificados hacia un número que recibe en el parámetro exten. Las funciones AMI dependiendo del tipo retornan propiedades o eventos, las propiedades se pueden acceder directamente, mientas que los eventos vienen en un arreglo llamado events. En base a los ejemplos anteriores es válido: Ejemplo parámetros de funciones AMI en Telegraph: estatus.sip_user_agent Lista_estatus.events.each[:status] Tabla 34: Ejemplo Funciones AMI Telegraph. A continuación se va a presentar una lista de las funciones AMI más usadas en Telegraph junto con sus parámetros y la función que es activada en Asterisk Find: Operación Telegraph Parámetros Función AMI :extension_state :context, :exten extension_state 90 :variable :channel, :variable get_variable :all_iax_peers - iax_peers :queue - queue_status :sip_peer :peer sip_show_peer :all_sip_peers - sip_peers :status :channel status Tabla 35: Métodos Telegraph para consultas. Update: Operación Telegraph Parámetros Función AMI :redirect :channel, :context, :exten, :priority redirect :variable :channel, :variable, :value setvar Tabla 36: Métodos Telegraph para actualizaciones. Create: Operación Telegraph Parámetros Función AMI :monitor :channel, :file, :format, :mix monitor :call :channel, :context, :exten, :priority, :async (Entre otros opcionales) orginiate Tabla 37: Métodos Telegraph para crear. Destroy: 91 Operación Telegraph Parámetros Función AMI :monitor :channel stopmonitor :call :channel Hangup Tabla 38: Métodos Telegraph para borrar. � Eventos AMI Los eventos AMI son los distintos cambios de estado que se envían a través de la interfaz AMI. En Telegraph se puede configurar un proceso Rails específico que escucha dichos eventos para realizar distintas acciones. En el plugin, la interfaz para eventos AMI es usada cuando se quiere ejecutar una lógica específica cuando se produce un cambio por el PBX, eventos tales como el ingreso de un nuevo dispositivo al sistema, una nueva llamada exitosa, entre otros. Los eventos AMI no son recibidos directamente en la propia aplicación Web. Al ejecutar el comando de generación automática de código para los eventos AMI en Telegraph, se crea una carpeta dentro de la ruta del proyecto con un archivo llamado ami_logic.rb. Dicho comando se debe ejecutar en la ruta del proyecto Rails, tal como: 92 Empezando con Telegraph Eventos AMI: script/generate ami_logic Tabla 39: Empezando Telegraph Eventos AMI. Después de la ejecución se creará la carpeta “app/ami_logic”. Entonces al momento que Asterisk envíe un evento, Telegraph escuchará y ejecutará un método con el mismo nombre que se encuentre dentro del archivo app/ami_logic.rb junto con cualquier parámetro que acarree de Asterisk. Estos últimos son colocados en una lista de parámetros que pueden ser accedidos en dichos métodos. Para iniciar el proceso encargado de escuchar los eventos enviados por Asterisk y asociarlo con el método correspondiente en el ami_logic, se debe ejecutar: Iniciar servidor de Eventos AMI en Telegraph: script/ami_events Tabla 40: Iniciar Servidor Eventos AMI Telegraph. En el siguiente ejemplo del archivo ami_logic.rb podemos encontrar los eventos de mayor utilidad: Funciones que capturan Eventos AMI en Telegraph: class AmiLogic < Telegraph::AMIHandler def peer_status # Método llamado cuando el estatus de un dispositivo # registrado en el sistema cambia # Los parámetros son :peer, :peer_status # El parámetro peer_status puede tener uno de los # siguientes valores: # (Registered, Unregistered, Reachable, Unreachable) estado = params[:peer_status] quien = params[:peer] p “Status de #{quien} : #{estado}” 93 end def link # Función llamada cuando 2 canales son conectados con # éxito. # Los parámetros son :channel1, :channel2 canal1 = params[:channel1] canal2 = params[:channel2] p “Llamada activa!” end def extension_status # Funcion que se dispara cuando existe un cambio de estado # en alguna extension de Asterisk # Tiene un parámetro que indica la extensión que cambia de # estado :exten y otro que indica el estatus :status #STATUS POSIBLES # 0: Disponible / inactiva # 1: Disponible / activa o llamando # 4: No Disponible # 8: Disponible / sonando extension = params[:exten] estado = params[:status] p “La extensión: #{extension} tiene el estado : #{estado}” end end Tabla 41: Funciones Eventos AMI. Dentro de cada método se puede tener una lógica tan simple como la mostrada o tan compleja que llame a otro método AMI, cambio en la base de datos, entre otras acciones que se pudieran realizarse a nivel de programación. 94 Comparación Adhearsion - Telegraph En las secciones anteriores se ha venido hablando sobre dos herramientas cuyo objetivo es facilitar la comunicación entre el PBX por software Asterisk y aplicaciones externas utilizando las interfaces AGI y AMI. En esta sección se va a realizar una breve comparación entre las herramientas. En primer lugar se observa que el núcleo de las herramientas es similar, ya que ambas se encuentran desarrolladas en el lenguaje de programación Ruby y distribuidas bajo el paradigma de código abierto de la GNU, pero una de las grandes diferencias es que por concepción son distintos, siendo Adhearsión un framework y Telegraph un plugin. Esto no hace a Adhearsion mejor que Telegraph ni viceversa, pero influye a la hora de decidir cual de las herramientas se va a usar en el proyecto, ya que dependiendo de la orientación de la aplicación VoIP que se desea desarrollar, conviene más una herramienta sobre la otra. A pesar de que la madurez de Adhearsion es escasa, inclusive los creadores recomiendan probarlo exhaustivamente antes de llevar un sistema a producción con el framework; Telegraph no tiene más tiempo en distribución que Adhearsion, por lo que no es un indicador de mucho peso. Aunque sobre este aspecto se puede afirmar que Adhearsion ya es un framework con un poco de uso mientras que Telegraph es un plugin que está empezando a crecer por lo que hay mas probabilidades de fallo con este último. 95 Un plugin es fácil de manejar en un proyecto que un framework que te crea un proyecto propio. Una de las razones de ésta afirmación comprenden los cambios que se deseen hacer sobre el código fuente bien sea por adaptación o corrección de errores, ya que es más sencillo realizarlo a un plugin que a un framework. Esto es considerado importante, más aún tomando en cuenta lo comentado anteriormente sobre la madurez de las herramientas, ya que las primeras versiones de cualquier software tiene a presentar más fallos que las que tienen tiempo distribuyéndose. Por otro lado con los plugins no se puede empezar una aplicación desde cero, sino que tiene que estar asociados a un proyecto, esto dependiendo de la aplicación a desarrollar puede ser beneficioso o no. Las tecnologías difieren en la forma como se integran. Con Adhearsion se debe realizar un proyecto nuevo propio de la herramienta, mientras que Telegraph se adapta a un proyecto Rails, lo cual requiere pensar si el objetivo es integrar VoIP con Web o si solo se quiere una aplicación VoIP. Uno de los aspectos más importantes es el uso para el cual se encuentra orientada la herramienta depende mucho de la interfaz por la cual se comunica con Asterisk (AGI/AMI). A pesar que ambas herramientas brindan soporte para ambas interfaces, Telegraph brindando un valor agregado con el soporte para los eventos AMI, en base a lo expuesto en este capítulo de Adhearsion, podemos afirmar que es una herramienta orientada hacia el uso de la interfaz AGI. Diseñado para la facilitación de la implementación de IVR's, que manipulan el flujo de llamadas que se reciben, procesando información de una llamada recibida. De Telegraph no se puede afirmar lo mismo, ya que no tiene una tendencia tan marcada como Adhearsion, lo que si se puede afirmar es el amplio soporte para la interfaz AMI, manejándose de 96 manera sencilla, incluyendo los eventos que se disparan en Asterisk. En la siguiente tabla se aprecian algunas diferencias y semejanzas entre las dos herramientas en aspectos que se deben tomar en cuenta a la hora de elegir cuál usar para un proyecto específico: Propiedad Adhearsion Telegraph Lenguaje Código Fuente Ruby Ruby Licencia Código abierto (GPL) Código abierto (GPL) Distribuido como Framework Plugin Instalación RubyGems Svn – Plugin Install Interfaz Soporte AGI – AMI AGI - AMI - AMI Events Orientado a Interfaz AGI AMI Soporte para desarrolladores Reporte de errores / Foros Lista de correo / Foros Conectividad Ruby - Asterisk Rails – Asterisk Tabla 42: Cuadro comparativo Adhearsion - Telegraph. 97 CAPÍTULO III MARCO APLICATIVO En este capítulo se describirá el ámbito aplicativo de la presente investigación, plasmando los requerimientos generales del cliente y el proceso de desarrollo de los componentes de la aplicación y su adaptación a la metodología aplicada, en este caso Programación Extrema (XP, por sus siglas en inglés). Luego se mostrará la visión general de los componentes de software que fueron desarrollados para el proyecto, explicando detalladamente la utilización de las herramientas, lenguajes y frameworks que se utilizaron. Finalmente se explica la adaptación del proceso de desarrollo (XP) y sus prácticas, llevadas al desarrollo del proyecto, en cada una de sus iteraciones o fases. Requerimientos Generales A gran escala, el proyecto busca automatizar el proceso de mercadeo de productos y servicios empresariales vía telefónica. El proceso de llamado, consistió primordialmente en la recuperación de un 98 número telefónico de un repositorio de datos, junto con cierta información personal del posible cliente, donde dicho número sea discado desde el PBX y pasado a la extensión desde donde se realiza la petición. Además de ese proceso, se requiere realizar manipulaciones adicionales a dicha llamada, que serían: • Supervisión: proceso en el que una extensión del PBX tiene la posibilidad de escuchar el diálogo de una llamada en curso, realizada desde otra extensión de la central telefónica. • Transferencia: proceso en el que el se transfiere una llamada en curso desde una extensión a otra de la central telefónica. Cabe destacar que se desea conocer en todo momento el estatus de las llamadas y extensiones de la central telefónica, desde la aplicación. Se requieren distintos perfiles en la aplicación, entre los cuales tenemos: • Operador: usuario encargado únicamente de la realización de llamadas a los potenciales clientes. • Supervisor: usuario encargado de monitorear el estatus de las llamadas hechas por operadores, capaz de supervisar llamadas en curso, con la posibilidad de transferirlas a su extensión. • Validador: usuario capaz de introducir y validar un nuevo número telefónico y los datos de un potencial cliente. • Administrador: usuario encargado de la gestión y supervisión de todo el sistema. Pudiendo ver las estadísticas de ventas, ingresar nuevos usuarios al sistema y capaz de realizar labores de los perfiles del validador y supervisor, entre otras funciones. 99 Se requiere automatizar el proceso de carga de posibles clientes en el sistema. Adaptación del Proceso de Desarrollo XP Como se mencionó en el segundo capítulo de la investigación, el proceso de desarrollo XP es ligero y capaz de manejar los requerimientos cambiantes del cliente, teniéndolo bastante involucrado con el desarrollo. En esta sección se ilustrará la adaptación del proceso de desarrollo de la programación extrema en la presente investigación. El proceso de desarrollo de software XP está basado en entregas e iteraciones. Se dividió el proyecto en 4 iteraciones, con un tiempo aproximado de 4 a 5 semanas por iteración. En cada iteración se aplicarán las siguientes prácticas: Planificación Dado que en esta investigación el producto se desarrolló a través de un tercero y no del usuario final de la aplicación, no se realizaron historias de usuario como define la metodología XP en sus prácticas. Sin embargo, se definieron requerimientos a ser desarrollados en cada iteración. 100 Diseño En el diseño se realizará la definición de clases involucradas en la implementación de los requerimientos de la iteración. Valiéndose de la modelación ágil, se anexarán diagramas, utilizando la notación de UML, que permitan visualizar con mayor claridad la interacción entre dichas clases. Codificación En cada iteración se realizó el código fuente que dió solución a los requerimientos establecidos por el cliente en cada etapa del proceso de desarrollo. Dado que este proyecto fue realizado por una sola persona, no fue posible la aplicación de la práctica de programación en pareja. Pruebas El desarrollo del proyecto se basó en la técnica BDD (Behavior Driven Development), que propone la escritura de pruebas de comportamiento para el desarrollo de una aplicación, inclusive hace hincapié que dichas pruebas deberían ser definidas antes de implementar los requerimientos. Además explica que el uso de la técnica, implica la automatización de las pruebas. Al final de cada iteración se realizaron pruebas de aceptación de parte del cliente. En cada iteración se anexará el código fuente de las pruebas codificadas. Para la adaptación de las pruebas de comportamientos en Rails se utilizó un plugin llamado rspec que facilita la escritura de las mismas, según señala RSpec Doc (2007). 101 Para las pruebas que involucraban interacción con entes externos se utilizaron herramientas como Mocks y Stubs, destacadas en la Web RSpec Doc (2007), ya que simulan o imitan el comportamiento de esos entes, permitiendo la realización de las pruebas sin la necesidad de interactuar con los sistemas externos. Feedback Esta fase no pertenece a la metodología XP, más se cree conveniente presentar los resultados obtenidos de cada iteración, reflejando los aspectos que requieran de una refactorización en iteraciones posteriores. Desarrollo de la Aplicación Metáfora del Sistema El sistema está compuesto por dos piezas principales y dos entes externos que interactúan con él, brindandole servicios para lograr el objetivo final que implica el desarrollo de una aplicación Web/VoIP. Las piezas de la aplicación comprenden en principio un módulo que maneja la conexión hacia la central telefónica usando el plugin de Rails: Telegraph y el resto de la lógica de la aplicación comprende la segunda pieza, esta última desarrollada con el framework Web Ruby on Rails. 102 Con respecto a los entes externos, tenemos al manejador de base de datos MySQL, que fue utilizado para la persistencia de los datos en la aplicación y Asterisk es la otra herramienta en cuestión que desempeñó un papel fundamental en la investigación, ya que suministró la capa de servicios en el ámbito telefónico (VoIP), siendo el PBX que estuvo en constante comunicación con la aplicación Web. Siendo el fin último del proyecto la automatización del proceso de mercadeo de productos y servicios empresariales vía telefónica, resultó de gran utilidad la interconexión entre Rails y Asterisk, ya que la idea era automatizar el proceso de llamado, realizandose directamente desde un browser al accionar un botón. Un softphone es un software que hace una simulación de teléfono convencional a través de la computadora, es decir, que permite utilizarla para hacer llamadas a otros dispositivos telefónicos. De tal modo, que la aplicación se encargue de solicitarle la realización de una nueva llamada al PBX Asterisk hacia el destinatario correspondiente. Llamada que luego es transferida al softphone que tiene asignada la extensión del usuario que ejecutó la orden, más no es necesario que conteste la llamada ni conozca la existencia del softphone, ya que el software está configurado para que la llamada se contesta automáticamente. Por su parte, para lograr la comunicación entre la aplicación Web y Asterisk, utilizando la herramienta Telegraph, fue necesaria la ejecución de procesos Ruby (drb) responsables de recibir y/o enviar los datos al PBX. Específicamente, a través de Telegraph se inician dos procesos, el primero de ellos para comunicar la aplicación 103 Web con la interfaz AMI de Asterisk; mientras que el segundo se encarga de recibir los eventos AMI asíncronos que difunde el PBX y ejecutar el método específico para el evento generado. A continuación se mostrará gráficamente el funcionamiento general de la aplicación: Aplicac ión Web - VoIP Módulo de Inte rcone xión Central Telefónica (PBX) Repos itorio de Datos Consultas Utiliza Comandos Aplica ción We b Operador AMI AMI Events AMI drb`s Eventos asíncronos Validador Administrador Supervisor Browser S oftphone S oftphone Browser Browser Browser Red pública Llamada Clie nte Gráfico 6: Metáfora del Sistema. Fuente: Autor 104 Iteración 0 En la iteración 0 se definió la planificación general de todo el proceso de desarrollo de los componentes de software que se realizaron en la investigación. Planificación A continuación se muestran la lista de requerimientos generales que guiaron el desarrollo de los componentes de software: 1. Establecer comunicación efectiva entre el PBX Asterisk y el framework Rails. 2. Implementación de un módulo encargado de manejar el proceso de llamadas e intercambio de información con el PBX. 3. Implementación de funcionalidades en la aplicación Web. Iteración 1 Fecha de inicio: 19-06-2007 Al comienzo de esta iteración se instaló en el sistema un softphone (X-Lite) para lograr la comunicación básica entre el computador y Asterisk, dicho intercambio lo cual fue realizado sobre el protocolo SIP. Durante la primera iteración se realizó la comunicación entre el framework Ruby on Rails y el PBX Asterisk, a través de una herramienta que sirvió de puente entre ambas tecnologías. 105 En primera instancia se instaló el framework Adhearsion, y se logró la comunicación entre Asterisk y un script de Adhearsion escrito en lenguaje Ruby. Luego de lograr la conexión, se detectó que dicho framework no era el más adecuado para resolver el problema, ya que se encuentra orientado para la realización de IVR's valiéndose de la interfaz AGI de Asterisk. Seguidamente se procedió a buscar una herramienta más adaptada para satisfacer las necesidades del cliente, y se llegó a una herramienta más adecuada que comprendía un plugin de Rails llamado Telegraph, lo que lo hacía más atractivo para la adaptación a la aplicación. Finalmente, en esta iteración se realizó la instalación/inclusión del plugin en el proyecto logrando la conexión efectiva entre Rails y Asterisk con la herramienta adecuada, ya que soportaba el envío de comandos AMI e inclusive la captura de eventos AMI. Planificación Lista de requerimientos que fueron desarrollados en la primera iteración: 1. Instalación y prueba del framework Adhearsion para la comunicación Rails- Asterisk. 2. Instalación del plugin Telegraph para la comunicación Rails-Asterisk. 106 Diseño Se incluyeron nuevas clases en el proyecto con la instalación de Telegraph, más no se crearon nuevas clases propias. En el siguiente diagrama se refleja la clase principal de Telegraph sobre la cual se realizaron algunas correcciones de errores que presentaba el plugin, las cuales serán presentadas más adelante. Gráfico 7: Especificación Clase AMIManager. Codificación � Adhearsion Después de instalar el framework Adhearsion, se procedió a establecer la comunicación entre el mismo y Asterisk para lo que se necesitaba una entrada en Asterisk que transfiriera las llamadas desde Asterisk a Adhearsion. En el archivo 107 extention.conf de Asterisk, se agregaron las siguientes instrucciones: Comunicación entre Adhearsion y Asterisk: [internal] exten => _X.,1,AGI(agi://200.200.200.10) Tabla 43: Comunicación Adhearsion/Asterisk. Código que enviaba las llamadas que llegaron al contexto “internal” de la aplicación que se ejecuta en la dirección IP 200.200.200.10. En este caso se hizo sólo una prueba de comunicación exitosa antes de cambiar de herramienta. El script Adhearsion que se corrió fue muy sencillo imprimiendo la extensión destino de la llamada, como se ilustra a continuación: Script Adhearsion de prueba: internal { puts extension } Tabla 44: Script Adhearsion de Prueba. � Telegraph Se instaló el plugin Telegraph en el proyecto y se logró la conexión con Asterisk a través de la interfaz AMI. Para ello se generó el modelo que usa dicha interfaz y se le indicó al proyecto que se conectara a Asterisk, colocándole el host, usuario y contraseña de Asterisk en un archivo de configuración de Rails, de forma de cargar esa configuración y establecer la conexión al momento de iniciar el servidor AMI. Para eso se colocó en el script que inicia el servidor AMI (ami_server) la siguiente instrucción: 108 Comunicación entre Telegraph y Asterisk: ami_server = Telegraph::AMIServer.new(:host => @config['host'], :username => @config['username'], :secret => @config['secret']) Tabla 45: Comunicación Telegraph/Asterisk. Donde en la variable @config se cargó el archivo de configuración de Rails “ami.yml”, quien tiene la información de Asterisk. Finalmente en Asterisk se tiene que ingresar el usuario y contraseña en el archivo managers.conf para que realice la autenticación y permita establecer la conexión TCP. Luego de la instalación y conexión se corrigieron algunos errores que presentaba el plugin en su clase AMIManager, específicamente en la definición de los arreglos que se usan para llamar a las funciones de Telegraph, a continuación se muestra el código fuente de los arreglos que fueron modificados, las modificaciones se encuentrán marcadas en el color rojo: Correcciones del código fuente en Telegraph: FIND = { :agents => [:agents, []], :db => [:db_get,[:family, :key]], :extension_state => [:extension_state, [:context, :exten]], :variable => [:getvar, [:channel, :variable]], :all_iax_peers => [:iax_peers, []], :mailbox => [:mailbox_status, [:mailbox]], :parked_calls => [:parked_calls, []], :queue => [:queue_status, []], 109 :mailbox_count=> [:mailbox_count, []], :sip_peer=> [:sip_show_peer, [:peer]], :all_sip_peers=> [:sip_peers, []], :status=> [:status, [:channel]] } UPDATE = {:absolute_timeout => [:absolute_timeout, [:channel, :timeout]], :monitor => [:change_monitor, [:channel, :file]], :db => [:db_put, [:family, :key, :value]], :redirect => [:redirect, [:channel, :context, :exten, :priority]], :variable => [:setvar, [:channel, :variable, :value]] } CREATE = {:monitor => [:monitor, [:channel, :file, :format, :mix]], :call => [:originate, []] #Call/Originate has many optional parameters } DESTROY = { :call => [:hangup, [:channel]], :monitor => [:stopmonitor, [:channel]] } Tabla 46: Correcciones en Telegraph. Pruebas Se realizaron un pool de pruebas de conexión, usando el modelo AMI. Dichas pruebas involucraban acciones básicas de llamadas, tales como realización y transferencia de llamadas. A continuación se muestran los comandos ejecutados, probados desde la cónsola Ruby del proyecto Rails: 110 Pruebas de Telegraph en la primera iteración: AMIModel.create(:call, :channel=>'SIP/12', :context=>'from internal', exten=>'12', priority=>1); AMIModel.update(:redirect, :channel=>'SIP/11-09ec47c8', :context=>'from-internal', :extension=>'13', :priority=>1); AMIModel.find(:status, :channel=>'SIP/12'); Tabla 47: Pruebas Telegraph Iteración 1. En cada caso se invoca al modelo generado dinámicamente por Telegraph y se llaman a las distintas funciones estilo CRUD, indicando la función específica a activar de AMI y los parámetros que recibe la misma. Feedback El prof. Edgar González revisó la instalación del plugin, colaboró en la realización de las pruebas de conexión con el servidor de Telegraph y brindó apoyo permanente para la corrección de errores en el plugin. Cada uno de los requerimientos fue desarrollado y probado con éxito, presentando el funcionamiento esperado. Iteración 2 Fecha de inicio: 11-07-2007 En la segunda iteración se procedió a implementar lo que era el módulo de conexión como tal, entre la aplicación y Asterisk utilizando los beneficios que aporta el plugin Telegraph. 111 Planificación Requerimientos que fueron desarrolladas en la segunda iteración: 1. Implementar una función que permita a un operador iniciar una llamada telefónica a través del PBX Asterisk, hacia un número de un potencial cliente recuperado del repositorio de datos elegidos según ciertos parámetros de prioridad, registrando la llamada en el sistema. 2. Implementar una función que permita colgar una llamada. 3. Implementar una función que permita a un supervisor transferir una llamada telefónica en curso a su extensión. 4. Implementar una función que permita a un supervisor monitorear una llamada en curso, es decir que permita escuchar la conversación de la llamada y persista esta información en el sistema. 5. Implementar una función que consulte el estado de una extensión de Asterisk en un momento dado, y actualicé la información del sistema. Diseño En el siguiente diagrama se visualizan las clases involucradas para la solución 112 de las tareas concebidas en esta iteración. Gráfico 8: Diagrama de Clases, Iteración 2. Fuente: Autor Codificación Se muestra a continuación el código fuente de las funciones más importantes dentro de la clase Central, la función de actualización de estatus de la clase Extension y el algoritmo de búsqueda de números en el repositorio de datos de la clase Producto: Parte del código desarrollado en la segunda iteración, específicamente la clase Central, 113 donde se definen las funciones que presentan la lógica con todo lo pertinente a la llamada: class Central < Telegraph::AMIManager def self.llamar(producto, operador, ip) extension = self.extension_from_ip(ip) return nil, :extension_no_ociosa unless Extension.find_by_numero(extension).state == Extension::OCIOSA llamada = nil Numero.transaction do numero = producto.siguiente_numero_a_llamar(operador) return nil, :no_hay_numeros_disponibles unless numero extension = self.extension_from_ip(ip) self.establecer_llamada(numero.numero, extension) llamada = Llamada.create!(:producto => producto, :operador => operador, :numero => numero, :extension => extension, :centro => operador.centro) end return llamada, nil end def self.colgar(llamada) finalizar_llamada(llamada.extension) end def self.establecer_llamada(number, extension) # Hace una llamada al numero suministrado, pero primero # espera por que la extension sea levantada number_to_call = add_dial_prefix(strip_local_area_code(number)) create(:call, :context => ::ApplConfig[:context], :priority => ::ApplConfig[:priority], :async => ::ApplConfig[:async], :channel => "SIP/#{extension}", :exten => number_to_call) end def self.espiar_llamada(extension_a_espiar, extension_que_espia) create(:call, :channel => "local/#{extension_que_espia}", :context => ::ApplConfig[:context], :application => 'ChanSpy', :priority => ::ApplConfig[:priority], 114 :data => "sip/#{extension_a_espiar} |q", :async => true, :variable => "espiando= #{extension_a_espiar") end def self.extension_espiada(extension) res = find(:variable, :channel => channel_from_extension(extension), :variable => 'espiando') return res.value unless res.value.blank? nil end def self.transferir_llamada(extension_origen, extension_destino) channel = channel_linked_to_extension(extension_origen) return unless channel Central.update(:redirect, :channel => channel, :context => ::ApplConfig[:context], :exten => extension_destino, :priority => ::ApplConfig[:priority]) end def self.finalizar_llamada(extension) channel = channel_from_extension(extension) return unless channel destroy(:call, :channel => channel) end def self.extension_from_ip(ip) dot_index = ip.rindex('.') ip[dot_index-1,1]+ip[dot_index+1, ip.length] end end Tabla 48: Clase Central / Código Fuente Iteración 2. Parte del código desarrollado en la segunda iteración, Clase Extensión, donde se presenta el estatus de la extensión: class Extension < ActiveRecord::Base def state(reload = false) if @state.nil? or reload 115 res = Central.find(:extension_state, :exten => numero, :context => ::ApplConfig[:context]) @state = res.status if res end @state end end Tabla 49: Clase Extension / Código Fuente Iteración 2. Parte del código desarrollado en la segunda iteración, Clase Producto, donde se presenta el algoritmo encargado de búscar el siguiente número a ser llamado: class Producto < ActiveRecord::Base def siguiente_numero_a_llamar(operador, options = {}) raise ArgumentError.new("Operador esperado") unless operador.is_a?(Operador) num = numeros_llamar.find(:first, :conditions => ["volver_llamar_at < ? and operador = ?",Time.now, operador.login], :order => "volver_llamar_at") return num if num num = numeros_llamar.find(:first, :conditions => ["volver_llamar_at < ? and (operador is null or operador = '')",Time.now], :order => "volver_llamar_at") return num if num num = numeros_llamar.find(:first, :conditions => ["volver_llamar_at is null and operador = ?", operador.login], :order => "prioritario desc, ultima_llamada_at, created_at") return num if num num = numeros_llamar.find(:first, :conditions => "volver_llamar_at is null and (operador is null or operador = '')", :order => "prioritario desc, ultima_llamada_at, created_at") 116 return num if num return nil end end Tabla 50: Clase Producto / Código Fuente Iteración 2. Pruebas Se codificaron una serie de pruebas de comportamiento con el plugin rspec, que fueron aplicadas a las clases del modelo, al igual que se realizaron pruebas de aceptación del producto. A continuación se muestran ciertas pruebas realizadas sobre la clase Central: Pruebas SPEC de la clase Central en la segunda iteración: describe Central do fixtures :productos, :centros, :usuarios, :extensiones, :mantenimientos, :numeros before(:each) do end it "deberia llamar si el sistema no esta en mantenimiento y los parametros son correctos" do Central.llamar(productos(:aba_1024_venta), usuarios(:operador_caracas), "200.200.201.112") end it "no deberia llamar si la extension no esta ociosa" do Central.llamar(productos(:aba_1024_venta), usuarios(:operador_maracay), "200.200.202.112").should be_eql([nil, :extension_no_ociosa]) end it "deberia recuperar la extension desde una ip valida" do Central.extension_from_ip("200.200.200.34").should == 117 "034" end it "deberia arrojar una exception al intentar recuperar la extension desde una ip que es nil" do lambda{ Central.extension_from_ip(nil) }.should raise_error end end Tabla 51: Pruebas Clase Central Iteración 2. Seguidamente se anexa una de las varias pruebas que se le aplicaron al algoritmo de búsqueda de llamadas: Pruebas SPEC de la clase Producto en la segunda iteración: describe Producto, "Primera Prueba, numero a llamar con 5 entradas una fecha de volver_a_llamar. La primera 30 minutos antes de la hora actual (fuera del rango), la segunda a 10 minutos de la hora actual (dentro del rango) y la tercera 5 minutos despues de la hora actual (dentro del rango) y otras 2 con volver a llamar en nil" do fixtures :numeros, :usuarios, :productos before(:each) do @producto = productos(:aba_1024_instalacion) end it "deberia devolver el numero de Anibal" do num=@producto.siguiente_numero_a_llamar(usuarios(:operado r_caracas)) num.should be_eql(numeros(:anibal_rojas)) end end Tabla 52: Pruebas Clase Producto Iteración 2. Se realizaron pruebas de aceptación sobre el producto, donde el cliente se familiarizó las funcionalidades básicas tales como iniciar una nueva llamada, transferir o espiar una llamada, como se muestra en las siguientes pantallas: 118 • Pantalla de la aplicación con perfil de operador, donde es posible realizar una llamada. Gráfico 9: Prueba Aceptación, Pantalla Operador. Fuente: Autor • Pantalla de la aplicación con perfil de supervisor, donde se muestra toda la información de llamadas y extensiones del centro al que pertenece Gráfico 10: Prueba Aceptación, Pantalla Supervisor (Estado Asterisk). Fuente: Autor 119 • Pantalla que muestra el detalle de una llamada a un supervisor, donde puede monitorearla o transferirla a su extensión. Gráfico 11: Prueba Aceptación, Pantalla Supervisor (Detalle Llamada). Fuente: Autor Feedback El cliente estuvo satisfecho con las funcionalidades agregadas. Los algoritmos codificados fueron revisados y aprobados. El cliente pidió una refactorización del algoritmo de actualización de estatus, ya que las constantes llamadas a Asterisk congestionaron el canal produciendo un cierto colapso de la aplicación. Dicha refactorización se realizará en iteraciones posteriores. Se determinó que se requería un softphone con la capacidad de contestar automáticamente una llamada entrante de modo que el usuario no se vea en la necesidad de interactuar con dicho software, sino solo con la aplicación en cuestión, por lo que se instaló un softphone llamado “Twinkle”. 120 Iteración 3 Fecha de inicio: 21-08-2007 En la tercera iteración se procedió a desarrollar requerimientos adicionales del cliente. Funcionalidades, tales como la carga de un archivo excel a la base de datos con la información de los clientes, entre otras. Planificación Lista de requerimientos a desarrollar de la tercera iteración: • Implementar una funcionalidad en el sistema que permita al usuario (perfil Validador), tomar un archivo excel e ingresar la data del archivo (contiene datos del cliente) en el repositorio de datos de la aplicación. Permitiendole validar el número telefónico posteriormente. • Implementar una funcionalidad que permita al Administrador del sistema colocarlo a la aplicación en un modo “Mantenimiento”, en el cual ningún operador pueda iniciar una llamada nueva. 121 Diseño En el siguiente diagrama se visualizan las clases involucradas para la solución realizada en esta iteración. Gráfico 12: Diagrama de Clases, Iteración 3. Fuente: Autor. 122 Codificación Se muestra a continuación el código fuente de las funciones más importantes dentro de la clase Carga y Mantenimiento que comprenden el modelo en la implementación de las tareas. Código fuente de la tercera iteración, la clase Carga, encargada de tomar el archivo Excel, parsearlo e ingresar la información en la base de datos: class Carga < ActiveRecord::Base def self.parsear inicializa_logger carga = Carga.find ARGV[2] # Se recupera el número de la # corrida a procesar de la # linea de comando carga.iniciada_at = Time.new carga.save! logger.info "Iniciando proceso de la carga del archivo de excel llamado #{carga.filename} de la Corrida ID: #{ARGV[2]}" begin workbook = Spreadsheet::ParseExcel.parse(carga.full_filename) worksheet = workbook.worksheet(0) carga.recuperar_filas_excel(worksheet) carga.finalizada_at = Time.new carga.save! rescue Exception => e CargaLog.create(:carga_id => carga.id,:descripcion => "Error cargando el archivo: (#{carga.filename}) Detalle: #{e.to_s}") logger.debug "Se presento un error cargando el archivo (#{carga.filename}), en la carga: (#{carga.id})" end end def recuperar_filas_excel (worksheet) contadorError = 0 contadorExito = 0 skip = 1 worksheet.each(skip) do |row| sleep(Carga.sleep_time) if Carga.sleep? begin n = Numero.new 123 n.central = row.at(0).to_texto.to_s rescue nil n.numero = row.at(1).to_texto.to_s rescue nil n.numero = "0#{n.numero}" unless n.numero[0,1] == '0' n.nombre = row.at(2).to_texto rescue nil n.producto_id = producto_id n.carga_id = id n.created_by = created_by n.updated_by = updated_by unless row.at(3).blank? prioritario = row.at(3).to_entero rescue nil n.prioritario = (prioritario == 1) else n.prioritario = false end unless row.at(4).blank? n.operador = row.at(4).to_texto.strip rescue nil n.operador = nil if n.operador.blank? end unless n.save! contadorError = contadorError+1 else contadorExito = contadorExito+1 logger.info "Se agrego el numero: (#{n.numero}) al sistema con exito." end rescue Exception => e CargaLog.create( :carga_id => id, :descripcion => "Detalle: #{e.to_s}, Error cargando el numero: (#{n.numero})" ) logger.info "Error al agregar el numero: (#{n.numero}). Detalle: #{e.to_s}" end logger.info "Se procesaron #{contadorExito+contadorError} registros, #{contadorExito} se agregaron con Exito a la Base de Datos y #{contadorError} presentaron Errores." end end def en_proceso?(reload=false) if @en_proceso.nil? or reload @en_proceso = if finalizada_at false else res = `ps -ef | grep ruby` res["Carga.parsear #{id}"] end end Tabla 53: Clase Carga / Código Fuente Iteración 3. 124 Código fuente de la tercera iteración, clase Mantenimiento, donde se restringe la salida de llamadas de un operador: class Mantenimiento < ActiveRecord::Base def self.empezar_mantenimiento mant = Mantenimiento.find(1) mant.en_mantenimiento = true mant.save end def self.terminar_mantenimiento mant = Mantenimiento.find(1) mant.en_mantenimiento = false mant.save end def self.en_mantenimiento? mant = Mantenimiento.find(1) return mant.en_mantenimiento if mant nil end End Tabla 54: Clase Mantenimiento / Código Fuente Iteración 3. Pruebas Se codificaron una serie de pruebas de comportamiento con el plugin rspec, que fueron aplicadas a las clases Carga y Mantenimiento, al igual que se realizaron pruebas de aceptación del producto. A continuación se muestran ciertas pruebas realizadas sobre la clase Carga: 125 Pruebas SPEC clase Carga en la tercera iteración: describe Carga, "with enough text" do before(:each) do producto = Producto.new @carga = Carga.new(:descripcion => 'x' * 255, :content_type => 'x', :filename => 'amiMODEL', :size => 100.kilobytes, :producto_id => producto) end it "should be saved" do lambda { @carga.save }.should change(Carga, :count) end it "should't have errors in the attribute descripcion, content_type and filename" do @carga.should have(:no).error_on(:descripcion) @carga.should have(:no).error_on(:content_type) @carga.should have(:no).error_on(:filename) @carga.should have(:no).error_on(:size) end end describe Carga, "with too much text" do before(:each) do producto = Producto.new @carga = Carga.new(:descripcion => 'x' * 256, :producto_id => producto) end it "should not be saved" do lambda { @carga.save }.should_not change(Carga, :count) end it "should have a length error in the attribute descripcion" do @carga.should have(1).error_on(:descripcion) @carga.errors.on(:descripcion).should == "es demasiado largo (el máximo es de 255 caracteres)" end end Tabla 55: Pruebas Clase Carga, Iteración 3. 126 A continuación se incluyen pruebas realizadas sobre la clase Central que involucra la opción de Mantenimiento: Pruebas SPEC clase Mantenimiento en la tercera iteración: describe Central do fixtures :productos, :centros, :usuarios, :extensiones, :mantenimientos, :numeros before(:each) do end it "no deberia llamar si el sistema entra mantenimiento" do Mantenimiento.empezar_mantenimiento Central.llamar(productos(:aba_1024_venta), usuarios(:operador_caracas), "200.200.201.112").should be_eql([nil, :sistema_en_mantenimineto]) end it "deberia llamar si el sistema termina el mantenimiento" do Mantenimiento.terminar_mantenimiento Central.llamar(productos(:aba_1024_venta), usuarios(:operador_caracas), "200.200.201.112").nil?.should be_false end end Tabla 56: Pruebas Clase Mantenimiento, Iteración 3. El cliente probó las nuevas funcionalidades agregadas. En el caso de la funcionalidad de mantenimiento, se cambió de estado, mientras habían varias llamadas en curso, las cuales continuaron y a la hora de volver a llamar les lanzó un mensaje de error, lo que califica como aprobada la prueba del cliente. Para la carga de data en el sistema, se realizaron varias pruebas con distintos archivos, probando archivos con datos desde 15 a 4500 filas, comportandose bien 127 ante los casos borde, tales como números repetidos, error en la data, entre otros. Dichos datos vienen en un archivo de la siguiente manera: Tabla 6: Ejemplo de Archivo de datos. A continuación se muestran las pantallas que fueron útilizadas durante las distintas pruebas del usuario de esta iteración. • A continuación se muestra la pantalla de la aplicación donde al usuario Administrador se le permite activar el modo “Mantenimiento” en la aplicación: 128 Gráfico 13: Prueba Aceptación, Pantalla Administrador (Modo Mantenimiento). Fuente: Autor • El siguiente gráfico muestra la pantalla que utiliza el usuario Validador, que le permite cargar un archivo de nueva data para la base de datos de clientes: Gráfico 14: Prueba Aceptación, Pantalla Validador (Cargar Archivo). Fuente: Autor Feedback Luego de la aplicación de pruebas el cliente certificó las funcionalidades agregadas y pidió que el algoritmo de carga en el sistema se realizará en segundo plano previendo que los archivos de datos fueran muy grandes. 129 Iteración 4 Fecha de inicio: 01-10-2007 • En la cuarta iteración se refactorizó la funcionalidad incluida en la segunda iteración de consulta de estado de una extensión de Asterisk. Planificación Requerimientos que fueron desarrollados en la cuarta iteración: • Refactorizar el código de la actualización de estatus de la aplicación. Reemplazando las peticiones AMI a la recepción y manipulación de los eventos AMI generados por Asterisk. Diseño En el siguiente diagrama se muestra la clase que fue desarrollada para la solución de la tarea en cuestión. Gráfico 15: Diagrama de Clases, Iteración 4. Fuente: Autor 130 Codificación Se muestra a continuación el código fuente de la función extension_status de la clase AmiLogic, encargada de toda la lógica de la actualización del estatus de una extensión, tanto del estado de uso (inactiva, activa, sonando, no disponible), como del estado de monitoreo (espiada, espiando, no espiada). Código fuente de la clase AmiLogic, es la clase donde llegan los eventos generados por Asterisk: class AmiLogic < Telegraph::AMIHandler # Funcion que se dispara cuando existe un cambio de estado en # alguna extension de asterisk def extension_status #STATUS POSIBLES # 0: Arriba / inactiva | Idle # 1: Arriba / activa o llamando | In Use # 4: Abajo | Unavailable # 8: Arriba / sonando | Ringing unless ((exten = Extension.find_by_numero(params[:exten])).nil?) begin exten.state = Extension.find_human_state(params[:status]) if (exten.state == 'Ociosa') if exten.espiada? exten1 = Extension.find_by_numero(exten.espiada_por) exten1.espiando_a = nil exten1.save! Central.finalizar_llamada(exten1.numero) exten.espiada_por = nil elsif exten.espiando? exten1 = Extension.find_by_numero(exten.espiando_a) exten1.espiada_por = nil exten1.save! exten.espiando_a = nil end end 131 exten.save! rescue Exception => e logger.error("Cambio de Status de Extension: Error al cambiar de status a la extensión (#{params[:exten]}).") logger.error("Detalle del error: (#{e.to_s}).") end else logger.warn("Cambio de Status de Extension: No se encontró la extensión (#{params[:exten]}) registrada en el sistema.") end end end Tabla 57: Clase AmiLogic Iteración 4. Pruebas Se codificaron una serie de pruebas de comportamiento con el plugin rspec, que fueron aplicadas a las clase AmiLogic, al igual que se realizaron pruebas de aceptación del requerimiento. Se simuló el sistema PBX Asterisk a través de un stub para las pruebas de cambio de estado de monitoreo. Pruebas SPEC sobre la clase AmiLogic y Central, donde se simuló el comportamiento de Asterisk a través de objetos STUB: describe Central do it "deberia quedar igual el status de las extensiones (0- espiada y 0-espiando) (dado que la respuesta es de unos canales vacios, ninguna extension deberia ser espiada ni espiando)" do exten1 = extensiones(:exten_operador_caracas_2) exten2 = extensiones(:exten_supervisor_caracas_1) exten1.espiada?.should be(false) exten2.espiando?.should be(false) 132 a = Telegraph::AsteriskResponse.new a.results = "Channel Location State Application(Data) \n0 active channels\n0 active calls\n" Central.stub!(:cli_command).and_return(a) Central.actualizar_espio_extension_channels(exten1.numero) exten1.reload exten1.espiada?.should be(false) Central.actualizar_espio_extension_channels(exten2.numero) exten2.reload exten2.espiando?.should be(false) end it "deberia actualizar el status de las extensiones (dado que la respuesta es de una extension espiada, una extension debera ser espiada y la otra espiando)" do exten1 = extensiones(:exten_operador_caracas_2) exten2 = extensiones(:exten_supervisor_caracas_1) exten1.espiada?.should be(false) exten2.espiando?.should be(false) a = Telegraph::AsteriskResponse.new a.results = "Channel Location State Application(Data) \nSIP/0112-08b54440 (None) Up Bridged Call(Local/0112@defaul\nLocal/0112@default-5 s@macro-dial:10 Up Dial(SIP/0112||tr) \nLocal/1121@default-5 s@default:1 Up ChanSpy(sip/1115|q) \nZap/1-1 s@from-zaptel:1 Up Bridged Call(SIP/0133-08b7aae0\nSIP/0133-08b7aae0 s@macro-dialout-trun Up Dial(ZAP/1/2424379|300|) \n5 active channels\n2 active calls\n" Central.stub!(:cli_command).and_return(a) Central.actualizar_espio_extension_channels(exten1.numero) exten1.reload exten1.espiada?.should be(true) Central.actualizar_espio_extension_channels(exten2.numero) exten2.reload exten2.espiando?.should be(true) end end describe AmiLogic, "Events that change extensions states" do fixtures :extensiones it "should change the extension 1112 state from Ociosa to En uso" do @ami_event_handler = AmiLogic.new({:exten => '1112', :status => '1'}) @extension = extensiones(:exten_operador_caracas) @extension.state.should be_eql("Ociosa") @ami_event_handler.extension_status @extension.reload 133 @extension.state.should be_eql("En uso") end it "should change the extension 2112 state from No disponible to Ociosa" do @ami_event_handler = AmiLogic.new({:exten => '2112', :status => '0'}) @extension = extensiones(:exten_operador_maracay) @extension.state.should be_eql("No disponible") @ami_event_handler.extension_status @extension.reload @extension.state.should be_eql("Ociosa") end it "should change the extension 2112 state from No disponible to En uso" do @ami_event_handler = AmiLogic.new({:exten => '2112', :status => '1'}) @extension = extensiones(:exten_operador_maracay) @extension.state.should be_eql("No disponible") @ami_event_handler.extension_status @extension.reload @extension.state.should be_eql("En uso") end it "should change the extension 2112 state from No disponible to Repicando" do @ami_event_handler = AmiLogic.new({:exten => '2112', :status => '8'}) @extension = extensiones(:exten_operador_maracay) @extension.state.should be_eql("No disponible") @ami_event_handler.extension_status @extension.reload @extension.state.should be_eql("Repicando") end end Tabla 58: Pruebas Clase Central y AmiLogic Iteración 4. El cliente probó el requerimiento cambiando de estatus una extensión y verificando en la aplicación el estatus de la misma. Se realizaron varias pruebas con la aplicación funcionando establemente con el cambio. 134 Feedback Al llevar el cambio a producción, el cliente informó que tanto el performance como la estabilidad de la aplicación mejoraron notablemente, reduciendo sustancialmente el número de peticiones desde la aplicación hacia Asterisk. 135 CAPÍTULO IV CONCLUSIONES Y RECOMENDACIONES El proyecto culminó con la puesta en producción de una aplicación que combina el ámbito Web y la tecnología de voz sobre IP (VoIP), conectandolos a través de un módulo desarrollado según los principios de las metodologías ágiles. Con esto se cumplió el objetivo principal del estudio dando como fruto una herramienta que automatizó el proceso de mercadeo de productos y servicios empresariales. Actualmente, la aplicación desarrollada se está utilizando para implementar centros de llamadas telefónicas automatizados, donde se tienen operadores que contactan a los potenciales clientes vía telefónica. Supervisores que monitorean el tráfico de las llamadas y usuarios validadores que ingresan nuevos datos al sistema, ampliando así la base de datos de posibles clientes. En el proyecto se utilizó la central telefónica Asterisk, que es un PBX orientado hacia el desarrollo de sistemas automatizados de voz. Éste a pesar de manejar su lenguaje de scripting interno, brinda la posibilidad de intercambio de datos con entes externos que pudieran intervenir en el flujo de los procesos del PBX, bien sea modificando el curso de una llamada, activando funciones propias o recolectando información que manda el PBX para procesarla y/o almacenarla. En este estudio la aplicación desarrollada es un ente externo de Asterisk que se comunica por una interfaz llamada Asterisk Manager Interface (AMI), bien sea 136 activando funciones de Asterisk o interpretando mensajes enviados por dicha central telefónica. Cabe destacar que el papel de la herramienta conectora entre la tecnología VoIP del PBX Asterisk y framework Ruby on Rails, llamada Telegraph, fue fundamental en el desarrollo de la aplicación ya que facilitó el uso de las interfaces que provee Asterisk para la comunicación. Esto redujo los tiempos de desarrollo considerablemente ya que gran parte de la comunicación a bajo nivel se encontraba implementado en la herramienta conectora. Por su parte, el uso de Ruby on Rails permitió el desarrollo de una aplicación de calidad de manera ágil, valiéndose de su sencilla organización de las piezas y componentes, tales como Action Pack, Active Record y Plugins, estos últimos muy útiles ya que existe una gran gama de ellos en la Web brindando solución a problemas cuyo desarrollo pudiera llevar gran cantidad de horas de diseño e implementación. En el ámbito tecnológico de la investigación realizada se puede concluir que al pasar el tiempo las técnicas de desarrollo son cada vez más refinadas permitiendo así el desarrollo ágil de aplicaciones manteniendo la calidad, enfocándose cada vez más en los requerimientos del cliente, por lo cual se pudiera inferir que en el futuro las aplicaciones serán orientadas a satisfacer las demandas del cliente de la mejor manera posible. Al aplicar programación extrema como proceso de desarrollo, se observó el ahorro de tiempo de las etapas de la implementación con respecto a experiencias pasadas. Este proceso de desarrollo se debe usar cuando el cliente necesita obtener 137 resultados rápidamente, mas para lograr esta acometida es necesario aplicar y adaptar correctamente las prácticas que propone la especificación del proceso de desarrollo. Otro aspecto fundamental en la aplicación de la metodología XP es tener al cliente lo más involucrado posible con el desarrollo y validar cada una de las soluciones implementadas a las tareas descritas a través de pruebas de aceptación, lo cual es muy importante ya que es una medida confiable del avance del proyecto. La utilización del proceso de desarrollo XP en este estudio brindo muchos beneficios, entre los cuales tenemos la entrega oportuna al cliente de requerimientos establecidos, la prueba de cada algoritmo implementado, el enfoque en el desarrollo de los requerimientos, entre otros. Es prudente mencionar que el desarrollo del proyecto fue basado en la filosofía de desarrollo orientado a pruebas. Un porcentaje importante de las soluciones fueron implementadas luego de haber codificado las pruebas, tal como lo describe la técnica BDD, lo que garantiza robustez en el producto realizado. Los algoritmos codificados fueron sometidos a pruebas antes, durante y después de finalizada la realización y/o modificación en la implementación de los mismos. Con respecto al área de las telecomunicaciones e informática, se puede afirmar que pareciera estrecharse la línea de separación entre éstas. En la actualidad es complicado hablar de un desarrollo completamente telefónico, porque las telecomunicaciones se encuentran ligadas con la informática a tal punto que en la mayoría de los casos se utilizan algoritmos para llevar a cabo ciertas tareas. Los desarrolladores están empezando a incursionar en el área de telecomunicaciones y 138 viceversa, lo que pudiera resultar en un extenso desarrollo de las aplicaciones VoIP a nivel mundial. Para futuros desarrollos donde se aplicará la metodología XP, es recomendable definir claramente el alcance del proyecto y de cada requerimiento, sustentándolos contra los requerimientos, tareas o historias de usuarios según sea hecha la adaptación de XP. Esto sin perder la flexibilidad y adaptabilidad que brinda el proceso de desarrollo ante posibles cambios. Se recomienda estudiar a fondo el funcionamiento de las herramientas que se vean involucradas en el proyecto, ya que ese tiempo de análisis puede resultar en ahorro de tiempo y costos. Este punto se ve reflejado en este estudio cuando se tomó la decisión de cambiar de herramienta conectora de Adhearsion a Telegraph debido a la adaptación de la herramienta en la solución realizada. En este caso Telegraph prevaleció ya que es un plugin para Ruby on Rails, framework en el que se desarrolló la aplicación. También se debe tomar en cuenta, sobre el tiempo de entrega del producto, la curva de aprendizaje que pudiera tener cada programador en caso de que los mismos no posean total dominio de las tecnologías a ser usadas durante el proceso de desarrollo. 139 REFERENCIAS • [About "A Guide to Testing the Rails" (2007)].[Página Web en línea]. Disponible: http://manuals.rubyonrails.com/read/book/5 [Consulta: 2007, diciembre 20] • [Acerca de Ruby (2007)]. [Página Web en línea]. Disponible: http://www.ruby-lang.org/es/about [Consulta: 2008, enero 10] • [Active Record (2006)]. [Documento en línea]. Disponible: http://www.martinfowler.com/eaaCatalog/activeRecord.html [Consulta: 2007, noviembre 2] • [Active Record (2007)]. [Página Web en línea]. Disponible: http://wiki.rubyonrails.org/rails/pages/ActiveRecord [Consulta: 2007, noviembre 5] • [Adhearsion (2007)]. [Página Web en línea]. Disponible: http://adhearsion.com/ [Consulta: 2007, diciembre 29] • [Agile Alliance (2001)]. [Página Web en línea]. Disponible : http://www.agilealliance.org/ [Consulta: 2007, septiembre 17] • [AAB (1998)]. Anderson A, Beattie R, Beck K, Bryant D, DeArment M, Fowler M, Fronczak M, Garzaniti R, Gore D, Hacker B, Handrickson C, Jeffries R, Joppie D, Kim D, Kowalsky P, Mueller D, Murasky T, Nutter R, Pantea A y Thomas D (1998).Chrysler Goes to "Extremes". Case Study. En Agile software development methods [Libro en línea] Disponible: http://www.inf.vtt.fi/pdf/publications/2002/P478.pdf. [Consulta: 2007, septiembre 17] 140 • [Asterisk AGI (2003)]. [Página Web en línea]. Disponible: http://www.voip-info.org/wiki-Asterisk+AGI [Consulta: 2007, noviembre 20] • [Asterisk channels (2003)]. [Página Web en línea]. Disponible: http://www.voip-info.org/wiki/view/Asterisk+channels [Consulta: 2008, enero 10] • [Asterisk Dialplan Introduction (2003)]. [Página Web en línea]. Disponible: http://www.voip-info.org/wiki-Asterisk+Dialplan+Introduction [Consulta: 2008, enero 10] • [AMAPI (2003)] Asterisk manager API (2003). [Página Web en línea]. Disponible: http://www.voip-info.org/wiki/view/Asterisk+manager+API [Consulta: 2007, noviembre 22] • [AME (2003)] Asterisk manager events (2003). [Página Web en línea]. Disponible: http://www.voip-info.org/wiki/view/asterisk+manager+events [Consulta: 2008, enero 05] • [Barrios M. (2005)]. Manual de Trabajos de Grado de Especialización y Maestría y Tesis Doctorales. Universidad Pedagógica Experimental Libertador, Caracas, Venezuela. • [Beck, K. (1999-a)]. Embracing Change With Extreme Programming. IEEE Computer 32, Estados Unidos. • [Beck, K. (1999-b)]. Extreme programming explained: Embrace change. Addisson-Wesley, Estados Unidos. 141 • [Behaviour Driven Development (2007, diciembre 23)]. [Página Web en línea]. Disponible: http://behaviour-driven.org/ [Consulta: 2007, diciembre 28] • [Dave Astels (2007)]. A New Look at Test Driven Development [Documento en línea]. Disponible: http://blog.daveastels.com/2005/07/05/a-new-look-at-test-driven- development [Consulta: 2007, diciembre 28] • [Fowler, Martin. (2004, mayo)]. Is Design Dead? [Artículo en línea]. Disponible: http://martinfowler.com/articles/designDead.html [Consulta: 2007, diciembre 01] • [Fowler, Martin. (2006, julio)]. Writing The Agile Manifesto. [Artículo en línea]. Disponible: http://martinfowler.com/articles/agileStory.html [Consulta: 2007, septiembre 01] • [GNU (2007, noviembre 01)]. The Free Software Definition. [Página Web en línea]. Disponible: http://www.gnu.org/philosophy/free-sw.html [Consulta: 2007, noviembre 05] • [GDD (2005)] Gomillion D y Dempster B (2005). Building Telephony Systems with Asterisk. Packt Publishing Ltd. 32 Lincoln Road Olton Birmingham, B27 6PA, UK. • [HAML (2007)]. [Página Web en línea]. Disponible: http://haml.hamptoncatlin.com/ [Consulta: 2007, diciembre 20] • [Introducing Test/Unit (2007)]. [Página Web en línea]. Disponible: http://manuals.rubyonrails.com/read/chapter/21 [Consulta: 2007, diciembre 27] 142 • [JRA (2001)]. Jeffries R, Anderson A y Hendrickson C (2001). Extreme Programming Installed. En Agile software development methods [Libro en línea] Disponible: http://www.inf.vtt.fi/pdf/publications/2002/P478.pdf. [Consulta: 2007, septiembre 17] • [MAS (2001)]. Manifesto for Agile Software Development (2001) [Documento en línea]. Disponible: http://www.agilemanifesto.org/ [Consulta: 2007, septiembre 17] • [Martin, R (2002)]. Continuos Care vs. Initial Design [Artículo en línea]. Disponible: http://www.agilealliance.org/system/article/file/833/file.pdf. [Consulta: 2007, septiembre 01] • [MJS (2005)]. Meggelen J, Smith J y Madsen L (2005). Asterisk: The Future of Telephony O’Reilly Media, Inc., Estados Unidos. • [Miller, M. (2001)]. Writing The Agile Manifesto. [Libro en línea]. Disponible: http://martinfowler.com/articles/agileStory.html [Consulta: 2007, noviembre 01] • [Models (2006)]. [Página Web en línea]. Disponible: http://wiki.rubyonrails.org/Rails/pages/Models [Consulta: 2007, noviembre 10] • [Plugins (2006)]. [Página Web en línea]. Disponible: http://wiki.rubyonrails.org/rails/pages/Plugins [Consulta: 2007, diciembre 20] • [Rspec (2008)]. [Página Web en línea]. Disponible: http://rspec.info/rdoc/index.html [Consulta: 2007, diciembre 27] 143 • [RSpec Doc (2007)]. [Página Web en línea]. Disponible: http://rspec.info/documentation/ [Consulta: 2007, diciembre 28] • [RubyGems Manual (2007)]. [Página Web en línea]. Disponible: http://rubygems.org/read/book/1 [Consulta: 2007, diciembre 20] • [Telegraph (2007)]. [Página Web en línea]. Disponible: http://telegraph.rubyforge.org/Home.html [Consulta: 2007, enero 6] • [Telegraph Documentation (2007)]. [Página Web en línea]. Disponible: http://telegraph.rubyforge.org/wiki/wiki.pl [Consulta: 2008, enero 2] • [TDH (2006)]. Thomas D., Heinemeier D, Breedt L., Clark M., Duncan J., Gehtland J., y Andreas Schwarz (2006). Agile Web Development with Rails: Second Edition, 2nd Edition. The Pragmatic Bookshelf, Estados Unidos. • [UsingAMI (2007)]. [Página Web en línea]. Disponible: http://telegraph.rubyforge.org/wiki/wiki.pl?UsingAMI [Consulta: 2007, noviembre 12] • [Wikipedia (2007, diciembre 17)]. Behavior Driven Development [Página Web en línea]. Disponible: http://en.wikipedia.org/wiki/Behavior_driven_development [Consulta: 2007, noviembre 15] • [Wikipedia (2007, julio 8)]. Manifiesto Ágil [Página Web en línea]. Disponible: http://es.wikipedia.org/wiki/Manifiesto_%C3%A1gil. [Consulta: 2007, octubre 05] • [Wikipedia (2007, octubre 6)]. Modelo Vista Controlador [Página Web en 144 línea]. Disponible: http://es.wikipedia.org/wiki/Modelo_Vista_Controlador [Consulta: 2007, noviembre 10] • [Wikipedia (2007, diciembre 31)]. Plugin [Página Web en línea]. Disponible: http://es.wikipedia.org/wiki/Plugin [Consulta: 2007, diciembre 20] • [Wikipedia (2007, julio 7)]. Programación Extrema [Página Web en línea]. Disponible: http://es.wikipedia.org/wiki/Programaci%C3%B3n_Extrema. [Consulta: 2007, agosto 21] • [Wikipedia (2007, diciembre 20)]. Pruebas de Software [Página Web en línea]. Disponible: http://es.wikipedia.org/wiki/Pruebas_de_software [Consulta: 2007, diciembre 15] • [Wikipedia (2008, enero 2)]. Ruby [Página Web en línea]. Disponible: http://es.wikipedia.org/wiki/Ruby [Consulta: 2008, enero 10] • [Wikipedia (2007, diciembre 7)]. Ruby on Rails [Página Web en línea]. Disponible: http://es.wikipedia.org/wiki/Ruby_on_Rails [Consulta: 2007, diciembre 18] • [Wikipedia (2007, marzo 30)]. RubyGems [Página Web en línea]. Disponible: http://es.wikipedia.org/wiki/RubyGems [Consulta: 2007, diciembre 20] • [Wikipedia (2008, mayo 7)]. Softphone [Página Web en línea]. Disponible: http://es.wikipedia.org/wiki/Softphone. [Consulta: 2008, mayo 7] • [Wikipedia (2008, enero 5)]. Software Libre [Página Web en línea]. 145 Disponible: http://es.wikipedia.org/wiki/Software_libre. [Consulta: 2008, enero 10] • [Wikipedia (2008, enero 17)]. Test-driven development [Página Web en línea]. Disponible: http://en.wikipedia.org/wiki/Test-driven_development. [Consulta: 2008, enero 10] 146 CONTACTOS A continuación se plasman los datos de contacto del presente Trabajo Especial de Grado: Nombres: Carlos Augusto Apellidos: García Mujica Dirección de Correo: carlosve.ucv@gmail.com Nombre: Edgar Apellido: González Cargo: Profesor de la Escuela de Computación de la Facultad de Ciencias UCV. Dirección de Correo: edgargonzalez@gmail.com. 147 ANEXOS Glosario de términos • AJAX: acrónimo de Asynchronous JavaScript And XML, es una técnica de desarrollo Web para crear aplicaciones interactivas o RIA (Rich Internet Applications). Éstas se ejecutan en el cliente, es decir, en el navegador de los usuarios y mantiene comunicación asíncrona con el servidor en segundo plano. De esta forma es posible realizar cambios sobre la misma página sin necesidad de recargarla. • API: del inglés Application Programming Interface - Interfaz de Programación de Aplicaciones, es el conjunto de funciones y procedimientos (o métodos si se refiere a programación orientada a objetos) que ofrece cierta librería para ser utilizado por otro software como una capa de abstracción. • Blog: en español también una bitácora, es un sitio Web periódicamente actualizado que recopila cronológicamente textos o artículos de uno o varios autores, apareciendo primero el más reciente, donde el autor conserva siempre la libertad de dejar publicado lo que crea pertinente. • Digital Signal Processing (DSP): Es un dispositivo capaz de interpretar, procesar y modificar señales provenientes de distintas fuentes. • Framework: En el desarrollo de software, un framework es una estructura de soporte definida en la cual otro proyecto de software puede ser organizado y desarrollado. Típicamente, un framework puede incluir soporte de programas, bibliotecas y un lenguaje interpretado entre otros 148 softwares para ayudar a desarrollar y unir los diferentes componentes de un proyecto. • Gateway: en informática corresponde a un dispositivo capáz de conectar redes de distinto protocolo o protocolos incompatibles, funcionando como intermediario permitiendo la comunicación. • GNU: proyecto iniciado por Richard Stallman con el objetivo de crear un sistema operativo completamente libre: el sistema GNU . • GPL: (Licencia Pública General) es una licencia creada por la Free Software Foundation, y está orientada principalmente a proteger la libre distribución, modificación y uso de software. • Hacker: es el neologismo utilizado para referirse a un experto en varias o alguna rama técnica relacionada con la informática: programación, redes de computadoras, sistemas operativos, hardware de red/voz, entre otros. • IAX: AX (Inter-Asterisk eXchange protocol) es uno de los protocolos utilizado por Asterisk. Es utilizado para manejar conexiones VoIP entre servidores Asterisk, y entre servidores y clientes que también utilizan protocolo IAX. • Java: es un lenguaje de programación orientado a objetos desarrollado por Sun Microsystems a principios de los años 1990. El lenguaje en sí mismo toma mucha de su sintaxis de C y C++, pero tiene un modelo de objetos más simple y elimina herramientas de bajo nivel como punteros. • JavaScript: es un lenguaje de programación interpretado, es decir, que no requiere compilación, utilizado principalmente en páginas Web, con una sintaxis semejante a la del lenguaje Java y el lenguaje C. 149 • Lenguajes de Script: es un lenguaje de programación que fue diseñado para ser ejecutado por medio de un intérprete, en contraste con los lenguajes compilados. • Productividad: También conocido como eficiencia es genéricamente entendida como la relación entre la producción obtenida por un sistema de producción o servicios y los recursos utilizados para obtenerla. También puede ser definida como la relación entre los resultados y el tiempo utilizado para obtenerlos: cuanto menor sea el tiempo que lleve obtener el resultado deseado, más productivo es el sistema. • PSTN: La Red Telefónica Conmutada (PSTN en inglés) es una red de comunicación diseñada primordialmente para la transmisión de voz, aunque pueda también transportar datos, por ejemplo en el caso del fax o de la conexión a Internet a través de un módem acústico. • RSDI: Según la UIT-T podemos definir Red Digital de Servicios Integrados (RDSI o ISDN en inglés) como: una red que procede por evolución de la Red Digital Integrada (RDI) y que facilita conexiones digitales extremo a extremo para proporcionar una amplia gama de servicios, tanto de voz como de otros tipos, y a la que los usuarios acceden a través de un conjunto de interfaces normalizados. • SIP: Session Initiation Protocol (SIP o Protocolo de Inicio de Sesiones) es un protocolo desarrollado por el IETF MMUSIC Working Group con la intención de ser el estándar para la iniciación, modificación y finalización de sesiones interactivas de usuario donde intervienen elementos multimedia como el video, voz, mensajería instantánea, juegos online y realidad virtual. 150 • Softphone: es un software que hace una simulación de teléfono convencional por computadora. Es decir, permite usar la computadora para hacer llamadas a otros softphones o a otros teléfonos convencionales. • TCP/IP: La familia de protocolos de Internet es un conjunto de protocolos de red en la que se basa Internet y que permiten la transmisión de datos entre redes de computadoras. En ocasiones se la denomina conjunto de protocolos TCP/IP, en referencia a los dos protocolos más importantes que la componen: Protocolo de Control de Transmisión (TCP) y Protocolo de Internet (IP), que fueron los dos primeros en definirse, y que son los más utilizados de la familia. • URI: es una cadena corta de caracteres que identifica inequívocamente un recurso (servicio, página, documento, dirección de correo electrónico, enciclopedia, etc). Normalmente estos recursos son accesibles en una red o sistema. • URL: significa Uniform Resource Locator, es decir, localizador uniforme de recurso. Es una secuencia de caracteres, de acuerdo a un formato estándar, que se usa para nombrar recursos, como documentos e imágenes en Internet, por su localización. • VoIP: Voz sobre Protocolo de Internet, también llamado Voz sobre IP, VozIP, VoIP (por sus siglas en inglés), o Telefonía IP, es un grupo de recursos que hacen posible que la señal de voz viaje a través de Internet empleando un protocolo IP (Internet Protocol). Esto significa que se envía la señal de voz en forma digital en paquetes en lugar de enviarla (en forma digital o analógica) a través de circuitos utilizables solo para telefonía como una compañía telefónica convencional o PSTN. 151 • XMPP: siglas inglesas de eXtensible Messaging and Presence Protocol (Protocolo ampliable de mensajería y [comunicación de] presencia), es un protocolo abierto y ampliable basado en XML, originalmente ideado para mensajería instantánea. Anexo 1: Valores del Manifiesto Ágil • Valorar más a los individuos y su interacción que a los procesos y las herramientas • Este principio es muy importante y no se puede malinterpretar su planteamiento. No plantea que los procesos no son importantes, es más generalmente comprenden una guía de operación, pero sin personas con el conocimiento técnico e incentivo adecuado, no producen resultados por más que los procesos se encuentren eficientes. • Se plantea que los procesos deberían adaptarse a la organización, a las personas y a los grupos de trabajo; no al revés. • Valorar más el software que funciona que la documentación exhaustiva • Se debería tener en cuenta el valor del trabajo por prototipos o por partes, ya que las entregas de funcionalidades ya elaboradas ofrece una retroalimentación enriquecedora y estimulante, generando nuevas ideas y posibilidades que serían muy complicadas concebir en un documento de requisitos hecho antes de comenzar a elaborar el proyecto. • Los documentos son soporte del análisis y diseño y permiten la transferencia del conocimiento, registrando información histórica. El manifiesto no afirma que no hagan falta, sino plantea que son menos importantes que los productos que funcionan. • Entonces se afirma que los documentos no pueden sustituir, ni pueden 152 ofrecer la riqueza y generación de valor que se logra con la comunicación directa entre las personas y a través de la interacción con los prototipos. • Valorar más la colaboración con el cliente que la negociación contractual • Como se observo en valores expuestos anteriormente, el manifiesto ágil plantea que el valor del resultado no es consecuencia de haber controlado una ejecución conforme a procesos, sino de haber sido implementado directamente sobre el producto. Un contrato tampoco aporta mucho valor al producto, simplemente comprende una formalidad que establece líneas divisorias entre responsabilidades, que fija los referentes para posibles disputas contractuales entre cliente y proveedor. • En el desarrollo ágil se intenta incluir al cliente como un miembro más del equipo, integrándolo y aportando colaboración en el grupo de trabajo, es por eso que los modelos por contrato no encajan es este tipo de métodos. • Valorar más la respuesta al cambio que el seguimiento de un plan • Las prácticas ágiles están especialmente indicadas para productos difíciles de definir con detalle en el principio, en entornos inestables, que tienen como factor inherente al cambio, que presentan una evolución rápida y continua, es por eso que la capacidad de respuesta a los cambios resulta un aporte de mayor valor que la elaboración y cumplimiento una rigurosa planificación. • Uno de los principales valores de la gestión ágil es la adaptación y facilidad de respuesta al cambio; diferentes a los de la antigua gestión de proyectos que comprenden control y planificación para evitar desviaciones sobre el plan. 153 Anexo2: Principios del Manifiesto Ágil Tras los cuatro valores descritos anteriormente, los firmantes redactaron los siguientes lineamientos como principios del Manifiesto Ágil: • Nuestra principal prioridad es satisfacer al cliente a través de la entrega temprana y continua de software de valor. • Los requisitos cambiantes son bienvenidos, aunque lleguen tarde al desarrollo. Los procesos ágiles explotan el cambio como ventaja competitiva para el cliente. • Entregar con frecuencia software que funcione, los periodos pueden variar de un par de semanas hasta un par de meses, prefiriendo los periodos breves. • Los clientes o expertos del negocio y los desarrolladores deben trabajar juntos de forma cotidiana a lo largo del proyecto. • Construir los proyectos en torno a individuos motivados, brindándoles la oportunidad y el respaldo que necesitan y dándoles confianza para que lleven a cabo la tarea. • La forma más eficiente y efectiva de hacer fluir la información de ida y vuelta dentro de un grupo de desarrollo es mediante la conversación personalizada. • Software en funcionamiento es la principal medida del progreso. • Los procesos ágiles promueven el desarrollo sostenible. Los patrocinadores, desarrolladores y usuarios deben mantener un ritmo constante en forma indefinida. • La atención continua a la excelencia técnica y buen diseño enaltece la agilidad. 154 • Simplicidad, arte de maximizar la cantidad de trabajo que no se hace, es esencial. • Las mejores arquitecturas, requisitos y diseños emergen de equipos auto- organizados. • En intervalos regulares, el equipo reflexiona la forma de ser más efectivo para ajustar acordemente su conducta. 155 Anexo3: Proceso de la Programación Extrema El ciclo de XP comprende cinco fases: Exploración, Planeamiento, Iteraciones de Entregas, Producción, Mantenimiento y Muerte, como se muestran en la siguiente figura: Gráfico 16: Anexo 3, Proceso de la programación Extrema. Fuente: Beck, K. (1999-b) 156 Anexo4: Prácticas de la Programación Extrema Las prácticas de la programación extrema se pueden apreciar gráficamente en el siguiente gráfico: Gráfico 17: Anexo 4, Prácticas de la programación Extrema. Fuente: Beck, K. (1999-b)